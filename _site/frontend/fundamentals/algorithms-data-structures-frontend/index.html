<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithms &amp; Data Structures for Frontend | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">â˜°</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/frontend/">Frontend</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/frontend/fundamentals/">Fundamentals</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Algorithms &amp; data structures for frontend</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Algorithms &amp; Data Structures for Frontend</h1>
                
                
            </header>
        
        
        <div class="content-body">
            <h1 id="algorithms--data-structures-for-frontend">Algorithms &amp; Data Structures for Frontend</h1>

<h2 id="overview">Overview</h2>
<p>Frontend engineers need strong algorithmic thinking for optimization, data manipulation, and building efficient user interfaces. This guide covers essential algorithms and data structures with frontend-specific applications.</p>

<hr />

<h2 id="essential-data-structures-for-frontend">Essential Data Structures for Frontend</h2>

<h3 id="advanced-array-manipulation"><strong>Advanced Array Manipulation</strong></h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
</pre></td><td class="rouge-code"><pre><span class="c1">// Frontend-specific array algorithms and optimizations</span>
<span class="kd">class</span> <span class="nx">FrontendArrayAlgorithms</span> <span class="p">{</span>
  
  <span class="c1">// Virtual scrolling algorithm for large lists</span>
  <span class="kd">static</span> <span class="nx">virtualScrolling</span><span class="p">(</span><span class="nx">items</span><span class="p">,</span> <span class="nx">containerHeight</span><span class="p">,</span> <span class="nx">itemHeight</span><span class="p">,</span> <span class="nx">scrollTop</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">totalItems</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">visibleCount</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">ceil</span><span class="p">(</span><span class="nx">containerHeight</span> <span class="o">/</span> <span class="nx">itemHeight</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">bufferSize</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">visibleCount</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
    
    <span class="kd">const</span> <span class="nx">startIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">scrollTop</span> <span class="o">/</span> <span class="nx">itemHeight</span><span class="p">)</span> <span class="o">-</span> <span class="nx">bufferSize</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">endIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">totalItems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">startIndex</span> <span class="o">+</span> <span class="nx">visibleCount</span> <span class="o">+</span> <span class="nx">bufferSize</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    
    <span class="kd">const</span> <span class="nx">visibleItems</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">startIndex</span><span class="p">,</span> <span class="nx">endIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">offsetY</span> <span class="o">=</span> <span class="nx">startIndex</span> <span class="o">*</span> <span class="nx">itemHeight</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">totalHeight</span> <span class="o">=</span> <span class="nx">totalItems</span> <span class="o">*</span> <span class="nx">itemHeight</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="p">{</span>
      <span class="nx">visibleItems</span><span class="p">,</span>
      <span class="nx">startIndex</span><span class="p">,</span>
      <span class="nx">endIndex</span><span class="p">,</span>
      <span class="nx">offsetY</span><span class="p">,</span>
      <span class="nx">totalHeight</span><span class="p">,</span>
      <span class="na">spacerTop</span><span class="p">:</span> <span class="nx">offsetY</span><span class="p">,</span>
      <span class="na">spacerBottom</span><span class="p">:</span> <span class="nx">totalHeight</span> <span class="o">-</span> <span class="p">(</span><span class="nx">endIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">itemHeight</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// Efficient filtering for real-time search</span>
  <span class="kd">static</span> <span class="nx">fuzzySearch</span><span class="p">(</span><span class="nx">items</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">keys</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">query</span><span class="p">.</span><span class="nx">trim</span><span class="p">())</span> <span class="k">return</span> <span class="nx">items</span><span class="p">;</span>
    
    <span class="kd">const</span> <span class="nx">queryTerms</span> <span class="o">=</span> <span class="nx">query</span><span class="p">.</span><span class="nx">toLowerCase</span><span class="p">().</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">term</span> <span class="o">=&gt;</span> <span class="nx">term</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    
    <span class="kd">const</span> <span class="nx">results</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">matches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">key</span> <span class="k">of</span> <span class="nx">keys</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="nx">item</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">||</span> <span class="dl">''</span><span class="p">).</span><span class="nx">toLowerCase</span><span class="p">();</span>
        
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">term</span> <span class="k">of</span> <span class="nx">queryTerms</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Exact match bonus</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">value</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">term</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">score</span> <span class="o">+=</span> <span class="nx">term</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
            <span class="nx">matches</span><span class="o">++</span><span class="p">;</span>
          <span class="p">}</span>
          
          <span class="c1">// Fuzzy match</span>
          <span class="kd">const</span> <span class="nx">fuzzyScore</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">fuzzyMatchScore</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">term</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">fuzzyScore</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">score</span> <span class="o">+=</span> <span class="nx">fuzzyScore</span> <span class="o">*</span> <span class="mi">5</span><span class="p">;</span>
            <span class="nx">matches</span><span class="o">++</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
      
      <span class="k">return</span> <span class="p">{</span>
        <span class="nx">item</span><span class="p">,</span>
        <span class="na">score</span><span class="p">:</span> <span class="nx">matches</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">score</span> <span class="o">/</span> <span class="nx">queryTerms</span><span class="p">.</span><span class="nx">length</span> <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="nx">matches</span>
      <span class="p">};</span>
    <span class="p">});</span>
    
    <span class="k">return</span> <span class="nx">results</span>
      <span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="nx">result</span><span class="p">.</span><span class="nx">score</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">score</span> <span class="o">-</span> <span class="nx">a</span><span class="p">.</span><span class="nx">score</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="nx">result</span><span class="p">.</span><span class="nx">item</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">static</span> <span class="nx">fuzzyMatchScore</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">textLen</span> <span class="o">=</span> <span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">patternLen</span> <span class="o">=</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">patternLen</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">patternLen</span> <span class="o">&gt;</span> <span class="nx">textLen</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="c1">// Dynamic programming approach</span>
    <span class="kd">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">patternLen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">fill</span><span class="p">().</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">textLen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    
    <span class="c1">// Initialize base cases</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">textLen</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">patternLen</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">textLen</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">pattern</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="nx">text</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
          <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">;</span> <span class="c1">// Penalty for skipping characters</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">patternLen</span><span class="p">][</span><span class="nx">textLen</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// Efficient grouping for data visualization</span>
  <span class="kd">static</span> <span class="nx">groupByWithAggregation</span><span class="p">(</span><span class="nx">items</span><span class="p">,</span> <span class="nx">groupKey</span><span class="p">,</span> <span class="nx">aggregations</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">groups</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">groupKey</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="p">?</span> <span class="nx">groupKey</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">:</span> <span class="nx">item</span><span class="p">[</span><span class="nx">groupKey</span><span class="p">];</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">groups</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">groups</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="p">{</span>
          <span class="nx">key</span><span class="p">,</span>
          <span class="na">items</span><span class="p">:</span> <span class="p">[],</span>
          <span class="na">count</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
          <span class="na">aggregates</span><span class="p">:</span> <span class="p">{}</span>
        <span class="p">});</span>
      <span class="p">}</span>
      
      <span class="kd">const</span> <span class="nx">group</span> <span class="o">=</span> <span class="nx">groups</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
      <span class="nx">group</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
      <span class="nx">group</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span><span class="p">;</span>
      
      <span class="c1">// Calculate aggregations</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">aggKey</span><span class="p">,</span> <span class="nx">aggConfig</span><span class="p">]</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">aggregations</span><span class="p">))</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="nx">field</span><span class="p">,</span> <span class="nx">type</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">aggConfig</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">field</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="p">?</span> <span class="nx">field</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">:</span> <span class="nx">item</span><span class="p">[</span><span class="nx">field</span><span class="p">];</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">])</span> <span class="p">{</span>
          <span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">]</span> <span class="o">=</span> <span class="nx">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">avg</span><span class="dl">'</span> <span class="p">?</span> <span class="p">{</span> <span class="na">sum</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">count</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">:</span> 
                                     <span class="nx">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">min</span><span class="dl">'</span> <span class="p">?</span> <span class="kc">Infinity</span> <span class="p">:</span>
                                     <span class="nx">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">max</span><span class="dl">'</span> <span class="p">?</span> <span class="o">-</span><span class="kc">Infinity</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">switch</span> <span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="dl">'</span><span class="s1">sum</span><span class="dl">'</span><span class="p">:</span>
            <span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">value</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="k">case</span> <span class="dl">'</span><span class="s1">avg</span><span class="dl">'</span><span class="p">:</span>
            <span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">].</span><span class="nx">sum</span> <span class="o">+=</span> <span class="nx">value</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
            <span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">].</span><span class="nx">count</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="k">case</span> <span class="dl">'</span><span class="s1">min</span><span class="dl">'</span><span class="p">:</span>
            <span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">],</span> <span class="nx">value</span> <span class="o">||</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="k">case</span> <span class="dl">'</span><span class="s1">max</span><span class="dl">'</span><span class="p">:</span>
            <span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">],</span> <span class="nx">value</span> <span class="o">||</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="k">case</span> <span class="dl">'</span><span class="s1">count</span><span class="dl">'</span><span class="p">:</span>
            <span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// Finalize average calculations</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">group</span> <span class="k">of</span> <span class="nx">groups</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">aggKey</span><span class="p">,</span> <span class="nx">aggConfig</span><span class="p">]</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">aggregations</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">aggConfig</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">avg</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">])</span> <span class="p">{</span>
          <span class="kd">const</span> <span class="p">{</span> <span class="nx">sum</span><span class="p">,</span> <span class="nx">count</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">];</span>
          <span class="nx">group</span><span class="p">.</span><span class="nx">aggregates</span><span class="p">[</span><span class="nx">aggKey</span><span class="p">]</span> <span class="o">=</span> <span class="nx">count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">?</span> <span class="nx">sum</span> <span class="o">/</span> <span class="nx">count</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">groups</span><span class="p">.</span><span class="nx">values</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="c1">// Optimized sorting for UI tables</span>
  <span class="kd">static</span> <span class="nx">multiColumnSort</span><span class="p">(</span><span class="nx">items</span><span class="p">,</span> <span class="nx">sortConfigs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">items</span><span class="p">.</span><span class="nx">slice</span><span class="p">().</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">config</span> <span class="k">of</span> <span class="nx">sortConfigs</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">direction</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">asc</span><span class="dl">'</span><span class="p">,</span> <span class="nx">type</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">config</span><span class="p">;</span>
        
        <span class="kd">let</span> <span class="nx">valueA</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">key</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="p">?</span> <span class="nx">key</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">:</span> <span class="nx">a</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
        <span class="kd">let</span> <span class="nx">valueB</span> <span class="o">=</span> <span class="k">typeof</span> <span class="nx">key</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="p">?</span> <span class="nx">key</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">:</span> <span class="nx">b</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
        
        <span class="c1">// Handle null/undefined values</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">valueA</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="nx">valueB</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">valueA</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="nx">direction</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">asc</span><span class="dl">'</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">valueB</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="nx">direction</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">asc</span><span class="dl">'</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
        
        <span class="c1">// Type-specific comparison</span>
        <span class="kd">let</span> <span class="nx">comparison</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">:</span>
            <span class="nx">comparison</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">valueA</span><span class="p">)</span> <span class="o">-</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">valueB</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="k">case</span> <span class="dl">'</span><span class="s1">date</span><span class="dl">'</span><span class="p">:</span>
            <span class="nx">comparison</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">valueA</span><span class="p">)</span> <span class="o">-</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">valueB</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="k">case</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">:</span>
          <span class="na">default</span><span class="p">:</span>
            <span class="nx">comparison</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="nx">valueA</span><span class="p">).</span><span class="nx">localeCompare</span><span class="p">(</span><span class="nb">String</span><span class="p">(</span><span class="nx">valueB</span><span class="p">));</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nx">comparison</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nx">direction</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">asc</span><span class="dl">'</span> <span class="p">?</span> <span class="nx">comparison</span> <span class="p">:</span> <span class="o">-</span><span class="nx">comparison</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">});</span>
  <span class="p">}</span>

  <span class="c1">// Efficient pagination with cursor-based approach</span>
  <span class="kd">static</span> <span class="nx">paginateWithCursor</span><span class="p">(</span><span class="nx">items</span><span class="p">,</span> <span class="nx">cursor</span> <span class="o">=</span> <span class="kc">null</span><span class="p">,</span> <span class="nx">pageSize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="nx">sortKey</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">id</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">startIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">cursor</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">startIndex</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> 
        <span class="p">(</span><span class="k">typeof</span> <span class="nx">sortKey</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="p">?</span> <span class="nx">sortKey</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">:</span> <span class="nx">item</span><span class="p">[</span><span class="nx">sortKey</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nx">cursor</span>
      <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">startIndex</span> <span class="o">===</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="nx">startIndex</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="kd">const</span> <span class="nx">pageItems</span> <span class="o">=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">startIndex</span><span class="p">,</span> <span class="nx">startIndex</span> <span class="o">+</span> <span class="nx">pageSize</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">hasNext</span> <span class="o">=</span> <span class="nx">startIndex</span> <span class="o">+</span> <span class="nx">pageSize</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">nextCursor</span> <span class="o">=</span> <span class="nx">hasNext</span> <span class="o">&amp;&amp;</span> <span class="nx">pageItems</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">?</span>
      <span class="p">(</span><span class="k">typeof</span> <span class="nx">sortKey</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">function</span><span class="dl">'</span> <span class="p">?</span> <span class="nx">sortKey</span><span class="p">(</span><span class="nx">pageItems</span><span class="p">[</span><span class="nx">pageItems</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">:</span> 
       <span class="nx">pageItems</span><span class="p">[</span><span class="nx">pageItems</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">sortKey</span><span class="p">])</span> <span class="p">:</span> <span class="kc">null</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">items</span><span class="p">:</span> <span class="nx">pageItems</span><span class="p">,</span>
      <span class="nx">hasNext</span><span class="p">,</span>
      <span class="nx">nextCursor</span><span class="p">,</span>
      <span class="na">totalCount</span><span class="p">:</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
      <span class="nx">pageSize</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="tree-structures-for-ui-components"><strong>Tree Structures for UI Components</strong></h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
</pre></td><td class="rouge-code"><pre><span class="c1">// Tree data structures for hierarchical UI components</span>
<span class="kd">class</span> <span class="nx">UITreeStructures</span> <span class="p">{</span>
  
  <span class="c1">// Tree structure for nested menus/navigation</span>
  <span class="kd">static</span> <span class="nx">buildNavigationTree</span><span class="p">(</span><span class="nx">flatItems</span><span class="p">,</span> <span class="nx">parentKey</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">parentId</span><span class="dl">'</span><span class="p">,</span> <span class="nx">idKey</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">id</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">itemMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">rootItems</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="c1">// First pass: create lookup map</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">flatItems</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">itemMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">item</span><span class="p">[</span><span class="nx">idKey</span><span class="p">],</span> <span class="p">{</span> <span class="p">...</span><span class="nx">item</span><span class="p">,</span> <span class="na">children</span><span class="p">:</span> <span class="p">[]</span> <span class="p">});</span>
    <span class="p">}</span>
    
    <span class="c1">// Second pass: build tree structure</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">flatItems</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">treeItem</span> <span class="o">=</span> <span class="nx">itemMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">item</span><span class="p">[</span><span class="nx">idKey</span><span class="p">]);</span>
      <span class="kd">const</span> <span class="nx">parentId</span> <span class="o">=</span> <span class="nx">item</span><span class="p">[</span><span class="nx">parentKey</span><span class="p">];</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nx">parentId</span> <span class="o">&amp;&amp;</span> <span class="nx">itemMap</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">parentId</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">itemMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">parentId</span><span class="p">).</span><span class="nx">children</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">treeItem</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">rootItems</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">treeItem</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">rootItems</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Tree traversal for component hierarchy</span>
  <span class="kd">static</span> <span class="nx">traverseComponentTree</span><span class="p">(</span><span class="nx">rootComponent</span><span class="p">,</span> <span class="nx">callback</span><span class="p">,</span> <span class="nx">traversalType</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">preorder</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="kd">const</span> <span class="nx">preorderTraversal</span> <span class="o">=</span> <span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">[])</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">currentPath</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">component</span><span class="p">.</span><span class="nx">id</span> <span class="o">||</span> <span class="nx">component</span><span class="p">.</span><span class="nx">name</span><span class="p">];</span>
      <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">depth</span><span class="p">,</span> <span class="nx">currentPath</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nx">component</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">component</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">preorderTraversal</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">currentPath</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">};</span>
    
    <span class="kd">const</span> <span class="nx">postorderTraversal</span> <span class="o">=</span> <span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">[])</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">currentPath</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">component</span><span class="p">.</span><span class="nx">id</span> <span class="o">||</span> <span class="nx">component</span><span class="p">.</span><span class="nx">name</span><span class="p">];</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nx">component</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">component</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">postorderTraversal</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">currentPath</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      
      <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">depth</span><span class="p">,</span> <span class="nx">currentPath</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
    <span class="p">};</span>
    
    <span class="kd">const</span> <span class="nx">levelOrderTraversal</span> <span class="o">=</span> <span class="p">(</span><span class="nx">rootComponent</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[{</span> <span class="na">component</span><span class="p">:</span> <span class="nx">rootComponent</span><span class="p">,</span> <span class="na">depth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">path</span><span class="p">:</span> <span class="p">[]</span> <span class="p">}];</span>
      
      <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="nx">component</span><span class="p">,</span> <span class="nx">depth</span><span class="p">,</span> <span class="nx">path</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
        <span class="kd">const</span> <span class="nx">currentPath</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">component</span><span class="p">.</span><span class="nx">id</span> <span class="o">||</span> <span class="nx">component</span><span class="p">.</span><span class="nx">name</span><span class="p">];</span>
        
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">callback</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">depth</span><span class="p">,</span> <span class="nx">currentPath</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">result</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nx">component</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">component</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="na">component</span><span class="p">:</span> <span class="nx">child</span><span class="p">,</span> <span class="na">depth</span><span class="p">:</span> <span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="na">path</span><span class="p">:</span> <span class="nx">currentPath</span> <span class="p">});</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">};</span>
    
    <span class="k">switch</span> <span class="p">(</span><span class="nx">traversalType</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="dl">'</span><span class="s1">preorder</span><span class="dl">'</span><span class="p">:</span>
        <span class="nx">preorderTraversal</span><span class="p">(</span><span class="nx">rootComponent</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="dl">'</span><span class="s1">postorder</span><span class="dl">'</span><span class="p">:</span>
        <span class="nx">postorderTraversal</span><span class="p">(</span><span class="nx">rootComponent</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="dl">'</span><span class="s1">levelorder</span><span class="dl">'</span><span class="p">:</span>
        <span class="nx">levelOrderTraversal</span><span class="p">(</span><span class="nx">rootComponent</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Find node in tree with path tracking</span>
  <span class="kd">static</span> <span class="nx">findNodeWithPath</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">,</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">[])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">predicate</span><span class="p">(</span><span class="nx">tree</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span> <span class="na">node</span><span class="p">:</span> <span class="nx">tree</span><span class="p">,</span> <span class="na">path</span><span class="p">:</span> <span class="p">[...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">tree</span><span class="p">]</span> <span class="p">};</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">tree</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">tree</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">findNodeWithPath</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">,</span> <span class="p">[...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">tree</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Tree diffing algorithm for efficient updates</span>
  <span class="kd">static</span> <span class="nx">diffTrees</span><span class="p">(</span><span class="nx">oldTree</span><span class="p">,</span> <span class="nx">newTree</span><span class="p">,</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{})</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> 
      <span class="nx">keyProperty</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">id</span><span class="dl">'</span><span class="p">,</span>
      <span class="nx">compareProperties</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">value</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">type</span><span class="dl">'</span><span class="p">]</span>
    <span class="p">}</span> <span class="o">=</span> <span class="nx">options</span><span class="p">;</span>
    
    <span class="kd">const</span> <span class="nx">changes</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="kd">const</span> <span class="nx">diff</span> <span class="o">=</span> <span class="p">(</span><span class="nx">oldNode</span><span class="p">,</span> <span class="nx">newNode</span><span class="p">,</span> <span class="nx">path</span> <span class="o">=</span> <span class="p">[])</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">currentPath</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">path</span><span class="p">];</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">oldNode</span> <span class="o">&amp;&amp;</span> <span class="nx">newNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Node added</span>
        <span class="nx">changes</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ADD</span><span class="dl">'</span><span class="p">,</span>
          <span class="na">path</span><span class="p">:</span> <span class="nx">currentPath</span><span class="p">,</span>
          <span class="na">node</span><span class="p">:</span> <span class="nx">newNode</span>
        <span class="p">});</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nx">oldNode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">newNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Node removed</span>
        <span class="nx">changes</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">REMOVE</span><span class="dl">'</span><span class="p">,</span>
          <span class="na">path</span><span class="p">:</span> <span class="nx">currentPath</span><span class="p">,</span>
          <span class="na">node</span><span class="p">:</span> <span class="nx">oldNode</span>
        <span class="p">});</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">oldNode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">newNode</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
      
      <span class="c1">// Check for property changes</span>
      <span class="kd">const</span> <span class="nx">propertyChanges</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">prop</span> <span class="k">of</span> <span class="nx">compareProperties</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">oldNode</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">newNode</span><span class="p">[</span><span class="nx">prop</span><span class="p">])</span> <span class="p">{</span>
          <span class="nx">propertyChanges</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="na">old</span><span class="p">:</span> <span class="nx">oldNode</span><span class="p">[</span><span class="nx">prop</span><span class="p">],</span>
            <span class="na">new</span><span class="p">:</span> <span class="nx">newNode</span><span class="p">[</span><span class="nx">prop</span><span class="p">]</span>
          <span class="p">};</span>
        <span class="p">}</span>
      <span class="p">}</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">propertyChanges</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">changes</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">UPDATE</span><span class="dl">'</span><span class="p">,</span>
          <span class="na">path</span><span class="p">:</span> <span class="nx">currentPath</span><span class="p">,</span>
          <span class="na">changes</span><span class="p">:</span> <span class="nx">propertyChanges</span>
        <span class="p">});</span>
      <span class="p">}</span>
      
      <span class="c1">// Diff children</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">diffChildren</span><span class="p">(</span>
        <span class="nx">oldNode</span><span class="p">.</span><span class="nx">children</span> <span class="o">||</span> <span class="p">[],</span>
        <span class="nx">newNode</span><span class="p">.</span><span class="nx">children</span> <span class="o">||</span> <span class="p">[],</span>
        <span class="p">[...</span><span class="nx">currentPath</span><span class="p">,</span> <span class="nx">newNode</span><span class="p">[</span><span class="nx">keyProperty</span><span class="p">]],</span>
        <span class="nx">keyProperty</span><span class="p">,</span>
        <span class="nx">changes</span>
      <span class="p">);</span>
    <span class="p">};</span>
    
    <span class="nx">diff</span><span class="p">(</span><span class="nx">oldTree</span><span class="p">,</span> <span class="nx">newTree</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">changes</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">static</span> <span class="nx">diffChildren</span><span class="p">(</span><span class="nx">oldChildren</span><span class="p">,</span> <span class="nx">newChildren</span><span class="p">,</span> <span class="nx">path</span><span class="p">,</span> <span class="nx">keyProperty</span><span class="p">,</span> <span class="nx">changes</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">oldMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">newMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    
    <span class="c1">// Create lookup maps</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">oldChildren</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">oldMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">child</span><span class="p">[</span><span class="nx">keyProperty</span><span class="p">],</span> <span class="nx">child</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">newChildren</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">newMap</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">child</span><span class="p">[</span><span class="nx">keyProperty</span><span class="p">],</span> <span class="nx">child</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// Find added, removed, and updated children</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">newChild</span><span class="p">]</span> <span class="k">of</span> <span class="nx">newMap</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">oldChild</span> <span class="o">=</span> <span class="nx">oldMap</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">diffTrees</span><span class="p">(</span><span class="nx">oldChild</span><span class="p">,</span> <span class="nx">newChild</span><span class="p">,</span> <span class="p">[...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">key</span><span class="p">]);</span>
    <span class="p">}</span>
    
    <span class="c1">// Find removed children</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">oldChild</span><span class="p">]</span> <span class="k">of</span> <span class="nx">oldMap</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">newMap</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">changes</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">REMOVE</span><span class="dl">'</span><span class="p">,</span>
          <span class="na">path</span><span class="p">:</span> <span class="p">[...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">key</span><span class="p">],</span>
          <span class="na">node</span><span class="p">:</span> <span class="nx">oldChild</span>
        <span class="p">});</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Virtualized tree rendering for large hierarchies</span>
  <span class="kd">static</span> <span class="nx">virtualizeTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">visibleRange</span><span class="p">,</span> <span class="nx">itemHeight</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">flattenedNodes</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">expandedNodes</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    
    <span class="kd">const</span> <span class="nx">flatten</span> <span class="o">=</span> <span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">parentExpanded</span> <span class="o">=</span> <span class="kc">true</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">parentExpanded</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
      
      <span class="nx">flattenedNodes</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
        <span class="p">...</span><span class="nx">node</span><span class="p">,</span>
        <span class="nx">depth</span><span class="p">,</span>
        <span class="na">index</span><span class="p">:</span> <span class="nx">flattenedNodes</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
        <span class="na">hasChildren</span><span class="p">:</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="na">isExpanded</span><span class="p">:</span> <span class="nx">expandedNodes</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
      <span class="p">});</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">children</span> <span class="o">&amp;&amp;</span> <span class="nx">expandedNodes</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">id</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">node</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">flatten</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">};</span>
    
    <span class="nx">flatten</span><span class="p">(</span><span class="nx">tree</span><span class="p">);</span>
    
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">startIndex</span><span class="p">,</span> <span class="nx">endIndex</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">visibleRange</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">visibleNodes</span> <span class="o">=</span> <span class="nx">flattenedNodes</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">startIndex</span><span class="p">,</span> <span class="nx">endIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">totalHeight</span><span class="p">:</span> <span class="nx">flattenedNodes</span><span class="p">.</span><span class="nx">length</span> <span class="o">*</span> <span class="nx">itemHeight</span><span class="p">,</span>
      <span class="nx">visibleNodes</span><span class="p">,</span>
      <span class="na">totalCount</span><span class="p">:</span> <span class="nx">flattenedNodes</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span>
      <span class="na">toggleExpanded</span><span class="p">:</span> <span class="p">(</span><span class="nx">nodeId</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">expandedNodes</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">nodeId</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">expandedNodes</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">nodeId</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">expandedNodes</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">nodeId</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">virtualizeTree</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">visibleRange</span><span class="p">,</span> <span class="nx">itemHeight</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">};</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<hr />

<h2 id="graph-algorithms-for-frontend">Graph Algorithms for Frontend</h2>

<h3 id="component-dependency-resolution"><strong>Component Dependency Resolution</strong></h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
</pre></td><td class="rouge-code"><pre><span class="c1">// Graph algorithms for managing component dependencies and relationships</span>
<span class="kd">class</span> <span class="nx">FrontendGraphAlgorithms</span> <span class="p">{</span>
  
  <span class="c1">// Topological sort for component loading order</span>
  <span class="kd">static</span> <span class="nx">topologicalSort</span><span class="p">(</span><span class="nx">dependencies</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">graph</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">inDegree</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="c1">// Build graph and calculate in-degrees</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">component</span><span class="p">,</span> <span class="nx">deps</span><span class="p">]</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">dependencies</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">graph</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">component</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">graph</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="p">[]);</span>
        <span class="nx">inDegree</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="p">}</span>
      
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">dep</span> <span class="k">of</span> <span class="nx">deps</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">graph</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">dep</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">graph</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">dep</span><span class="p">,</span> <span class="p">[]);</span>
          <span class="nx">inDegree</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">dep</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        
        <span class="nx">graph</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">dep</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="nx">component</span><span class="p">);</span>
        <span class="nx">inDegree</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">component</span><span class="p">,</span> <span class="nx">inDegree</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">component</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// Kahn's algorithm</span>
    <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">component</span><span class="p">,</span> <span class="nx">degree</span><span class="p">]</span> <span class="k">of</span> <span class="nx">inDegree</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">degree</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">component</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">current</span><span class="p">);</span>
      
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">neighbor</span> <span class="k">of</span> <span class="nx">graph</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">current</span><span class="p">)</span> <span class="o">||</span> <span class="p">[])</span> <span class="p">{</span>
        <span class="nx">inDegree</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">,</span> <span class="nx">inDegree</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">inDegree</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">)</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// Check for circular dependencies</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="nx">inDegree</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">remaining</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">inDegree</span><span class="p">.</span><span class="nx">keys</span><span class="p">()).</span><span class="nx">filter</span><span class="p">(</span><span class="nx">k</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">result</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">k</span><span class="p">));</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">`Circular dependency detected: </span><span class="p">${</span><span class="nx">remaining</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">'</span><span class="s1">, </span><span class="dl">'</span><span class="p">)}</span><span class="s2">`</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Find strongly connected components for circular dependency detection</span>
  <span class="kd">static</span> <span class="nx">findStronglyConnectedComponents</span><span class="p">(</span><span class="nx">graph</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">components</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="c1">// First DFS to fill stack</span>
    <span class="kd">const</span> <span class="nx">dfs1</span> <span class="o">=</span> <span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">neighbor</span> <span class="k">of</span> <span class="nx">graph</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="o">||</span> <span class="p">[])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">dfs1</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="p">};</span>
    
    <span class="c1">// Build reverse graph</span>
    <span class="kd">const</span> <span class="nx">reverseGraph</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">node</span><span class="p">,</span> <span class="nx">neighbors</span><span class="p">]</span> <span class="k">of</span> <span class="nx">graph</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">reverseGraph</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">reverseGraph</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="p">[]);</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">neighbor</span> <span class="k">of</span> <span class="nx">neighbors</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">reverseGraph</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">reverseGraph</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">,</span> <span class="p">[]);</span>
        <span class="p">}</span>
        <span class="nx">reverseGraph</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// Second DFS on reverse graph</span>
    <span class="kd">const</span> <span class="nx">dfs2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">component</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="nx">component</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">neighbor</span> <span class="k">of</span> <span class="nx">reverseGraph</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="o">||</span> <span class="p">[])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">dfs2</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">,</span> <span class="nx">component</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">};</span>
    
    <span class="c1">// Process all nodes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">node</span> <span class="k">of</span> <span class="nx">graph</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">dfs1</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="nx">visited</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">component</span> <span class="o">=</span> <span class="p">[];</span>
        <span class="nx">dfs2</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">component</span><span class="p">);</span>
        <span class="nx">components</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">component</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">components</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Shortest path for component communication</span>
  <span class="kd">static</span> <span class="nx">findShortestPath</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">start</span> <span class="o">===</span> <span class="nx">end</span><span class="p">)</span> <span class="k">return</span> <span class="p">[</span><span class="nx">start</span><span class="p">];</span>
    
    <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="nx">start</span><span class="p">]];</span>
    <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="nx">start</span><span class="p">]);</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
      <span class="kd">const</span> <span class="nx">current</span> <span class="o">=</span> <span class="nx">path</span><span class="p">[</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
      
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">neighbor</span> <span class="k">of</span> <span class="nx">graph</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">current</span><span class="p">)</span> <span class="o">||</span> <span class="p">[])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">neighbor</span> <span class="o">===</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">[...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">neighbor</span><span class="p">];</span>
        <span class="p">}</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">);</span>
          <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">([...</span><span class="nx">path</span><span class="p">,</span> <span class="nx">neighbor</span><span class="p">]);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// No path found</span>
  <span class="p">}</span>

  <span class="c1">// Component hierarchy analysis using graph traversal</span>
  <span class="kd">static</span> <span class="nx">analyzeComponentHierarchy</span><span class="p">(</span><span class="nx">componentTree</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">analysis</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">depth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="na">breadth</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="na">totalComponents</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="na">leafComponents</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="na">componentsByLevel</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">(),</span>
      <span class="na">cyclomaticComplexity</span><span class="p">:</span> <span class="mi">0</span>
    <span class="p">};</span>
    
    <span class="kd">const</span> <span class="nx">queue</span> <span class="o">=</span> <span class="p">[{</span> <span class="na">component</span><span class="p">:</span> <span class="nx">componentTree</span><span class="p">,</span> <span class="na">level</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}];</span>
    <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="p">{</span> <span class="nx">component</span><span class="p">,</span> <span class="nx">level</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">queue</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">component</span><span class="p">.</span><span class="nx">id</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">analysis</span><span class="p">.</span><span class="nx">cyclomaticComplexity</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Potential cycle</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      
      <span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">component</span><span class="p">.</span><span class="nx">id</span><span class="p">);</span>
      <span class="nx">analysis</span><span class="p">.</span><span class="nx">totalComponents</span><span class="o">++</span><span class="p">;</span>
      <span class="nx">analysis</span><span class="p">.</span><span class="nx">depth</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">analysis</span><span class="p">.</span><span class="nx">depth</span><span class="p">,</span> <span class="nx">level</span><span class="p">);</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">analysis</span><span class="p">.</span><span class="nx">componentsByLevel</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">level</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">analysis</span><span class="p">.</span><span class="nx">componentsByLevel</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">level</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">analysis</span><span class="p">.</span><span class="nx">componentsByLevel</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">level</span><span class="p">,</span> <span class="nx">analysis</span><span class="p">.</span><span class="nx">componentsByLevel</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">level</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">component</span><span class="p">.</span><span class="nx">children</span> <span class="o">||</span> <span class="nx">component</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">analysis</span><span class="p">.</span><span class="nx">leafComponents</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">analysis</span><span class="p">.</span><span class="nx">breadth</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">analysis</span><span class="p">.</span><span class="nx">breadth</span><span class="p">,</span> <span class="nx">component</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">child</span> <span class="k">of</span> <span class="nx">component</span><span class="p">.</span><span class="nx">children</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">queue</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="na">component</span><span class="p">:</span> <span class="nx">child</span><span class="p">,</span> <span class="na">level</span><span class="p">:</span> <span class="nx">level</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">});</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">analysis</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Graph coloring for conflict resolution</span>
  <span class="kd">static</span> <span class="nx">graphColoring</span><span class="p">(</span><span class="nx">conflictGraph</span><span class="p">,</span> <span class="nx">colors</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">blue</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">green</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">yellow</span><span class="dl">'</span><span class="p">])</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">coloring</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">nodes</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">conflictGraph</span><span class="p">.</span><span class="nx">keys</span><span class="p">());</span>
    
    <span class="c1">// Sort nodes by degree (most connected first)</span>
    <span class="nx">nodes</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">degreeA</span> <span class="o">=</span> <span class="nx">conflictGraph</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">a</span><span class="p">)?.</span><span class="nx">length</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">degreeB</span> <span class="o">=</span> <span class="nx">conflictGraph</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">b</span><span class="p">)?.</span><span class="nx">length</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">degreeB</span> <span class="o">-</span> <span class="nx">degreeA</span><span class="p">;</span>
    <span class="p">});</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">node</span> <span class="k">of</span> <span class="nx">nodes</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">usedColors</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
      
      <span class="c1">// Check colors used by neighbors</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">neighbor</span> <span class="k">of</span> <span class="nx">conflictGraph</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="o">||</span> <span class="p">[])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">coloring</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">usedColors</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">coloring</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">));</span>
        <span class="p">}</span>
      <span class="p">}</span>
      
      <span class="c1">// Find first available color</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">color</span> <span class="k">of</span> <span class="nx">colors</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">usedColors</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">color</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">coloring</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">color</span><span class="p">);</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      
      <span class="c1">// If no color available, add a new one</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">coloring</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">newColor</span> <span class="o">=</span> <span class="s2">`color_</span><span class="p">${</span><span class="nx">colors</span><span class="p">.</span><span class="nx">length</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
        <span class="nx">colors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">newColor</span><span class="p">);</span>
        <span class="nx">coloring</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">newColor</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">coloring</span><span class="p">:</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">fromEntries</span><span class="p">(</span><span class="nx">coloring</span><span class="p">),</span>
      <span class="na">colorCount</span><span class="p">:</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">(</span><span class="nx">coloring</span><span class="p">.</span><span class="nx">values</span><span class="p">()).</span><span class="nx">size</span><span class="p">,</span>
      <span class="na">isValidColoring</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">validateColoring</span><span class="p">(</span><span class="nx">conflictGraph</span><span class="p">,</span> <span class="nx">coloring</span><span class="p">)</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="kd">static</span> <span class="nx">validateColoring</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">coloring</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">node</span><span class="p">,</span> <span class="nx">neighbors</span><span class="p">]</span> <span class="k">of</span> <span class="nx">graph</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">nodeColor</span> <span class="o">=</span> <span class="nx">coloring</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">neighbor</span> <span class="k">of</span> <span class="nx">neighbors</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">coloring</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">neighbor</span><span class="p">)</span> <span class="o">===</span> <span class="nx">nodeColor</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Minimum spanning tree for optimal component connections</span>
  <span class="kd">static</span> <span class="nx">minimumSpanningTree</span><span class="p">(</span><span class="nx">graph</span><span class="p">,</span> <span class="nx">weights</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">mst</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">edges</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="c1">// Convert graph to edge list</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="k">from</span><span class="p">,</span> <span class="nx">neighbors</span><span class="p">]</span> <span class="k">of</span> <span class="nx">graph</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">to</span> <span class="k">of</span> <span class="nx">neighbors</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">weight</span> <span class="o">=</span> <span class="nx">weights</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">from</span><span class="p">}</span><span class="s2">-</span><span class="p">${</span><span class="nx">to</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span> <span class="o">||</span> <span class="nx">weights</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">to</span><span class="p">}</span><span class="s2">-</span><span class="p">${</span><span class="k">from</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">edges</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">weight</span> <span class="p">});</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// Sort edges by weight</span>
    <span class="nx">edges</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">weight</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">weight</span><span class="p">);</span>
    
    <span class="c1">// Union-Find data structure</span>
    <span class="kd">const</span> <span class="nx">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">rank</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    
    <span class="kd">const</span> <span class="nx">find</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">parent</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">parent</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
        <span class="nx">rank</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">!==</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">parent</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">find</span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">x</span><span class="p">)));</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">parent</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
    <span class="p">};</span>
    
    <span class="kd">const</span> <span class="nx">union</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">rootX</span> <span class="o">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">rootY</span> <span class="o">=</span> <span class="nx">find</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nx">rootX</span> <span class="o">!==</span> <span class="nx">rootY</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">rank</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">rootX</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nx">rank</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">rootY</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">parent</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">rootX</span><span class="p">,</span> <span class="nx">rootY</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">rank</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">rootX</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nx">rank</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">rootY</span><span class="p">))</span> <span class="p">{</span>
          <span class="nx">parent</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">rootY</span><span class="p">,</span> <span class="nx">rootX</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">parent</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">rootY</span><span class="p">,</span> <span class="nx">rootX</span><span class="p">);</span>
          <span class="nx">rank</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">rootX</span><span class="p">,</span> <span class="nx">rank</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">rootX</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">};</span>
    
    <span class="c1">// Kruskal's algorithm</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">edge</span> <span class="k">of</span> <span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">union</span><span class="p">(</span><span class="nx">edge</span><span class="p">.</span><span class="k">from</span><span class="p">,</span> <span class="nx">edge</span><span class="p">.</span><span class="nx">to</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">mst</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">edge</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">mst</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<hr />

<h2 id="optimization-algorithms">Optimization Algorithms</h2>

<h3 id="frontend-specific-optimizations"><strong>Frontend-Specific Optimizations</strong></h3>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
</pre></td><td class="rouge-code"><pre><span class="c1">// Optimization algorithms for frontend performance</span>
<span class="kd">class</span> <span class="nx">FrontendOptimizationAlgorithms</span> <span class="p">{</span>
  
  <span class="c1">// Bundle splitting optimization using dynamic programming</span>
  <span class="kd">static</span> <span class="nx">optimizeBundleSplitting</span><span class="p">(</span><span class="nx">modules</span><span class="p">,</span> <span class="nx">maxBundleSize</span> <span class="o">=</span> <span class="mi">250000</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">dp</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">fill</span><span class="p">().</span><span class="nx">map</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">maxBundleSize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="kd">const</span> <span class="nx">bundles</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="c1">// Sort modules by importance/usage frequency</span>
    <span class="nx">modules</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">importance</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">importance</span> <span class="o">||</span> <span class="mi">0</span><span class="p">));</span>
    
    <span class="c1">// Dynamic programming to find optimal bundles</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
      <span class="kd">const</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">module</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">module</span><span class="p">.</span><span class="nx">importance</span> <span class="o">||</span> <span class="mi">1</span><span class="p">;</span>
      
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">w</span> <span class="o">&lt;=</span> <span class="nx">maxBundleSize</span><span class="p">;</span> <span class="nx">w</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">w</span><span class="p">]</span> <span class="o">=</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">w</span><span class="p">];</span> <span class="c1">// Don't include current module</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="nx">size</span> <span class="o">&lt;=</span> <span class="nx">w</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">w</span><span class="p">]</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">w</span><span class="p">],</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">w</span> <span class="o">-</span> <span class="nx">size</span><span class="p">]</span> <span class="o">+</span> <span class="nx">value</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// Backtrack to find which modules to include</span>
    <span class="kd">let</span> <span class="nx">w</span> <span class="o">=</span> <span class="nx">maxBundleSize</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">currentBundle</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">currentSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">dp</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">w</span><span class="p">]</span> <span class="o">!==</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">w</span><span class="p">])</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="nx">currentBundle</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">module</span><span class="p">);</span>
        <span class="nx">currentSize</span> <span class="o">+=</span> <span class="nx">module</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
        <span class="nx">w</span> <span class="o">-=</span> <span class="nx">module</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="nx">bundles</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
      <span class="na">modules</span><span class="p">:</span> <span class="nx">currentBundle</span><span class="p">,</span>
      <span class="na">size</span><span class="p">:</span> <span class="nx">currentSize</span><span class="p">,</span>
      <span class="na">value</span><span class="p">:</span> <span class="nx">dp</span><span class="p">[</span><span class="nx">n</span><span class="p">][</span><span class="nx">maxBundleSize</span><span class="p">]</span>
    <span class="p">});</span>
    
    <span class="c1">// Recursively create remaining bundles</span>
    <span class="kd">const</span> <span class="nx">remainingModules</span> <span class="o">=</span> <span class="nx">modules</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">m</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">currentBundle</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">m</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">remainingModules</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">remainingBundles</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">optimizeBundleSplitting</span><span class="p">(</span><span class="nx">remainingModules</span><span class="p">,</span> <span class="nx">maxBundleSize</span><span class="p">);</span>
      <span class="nx">bundles</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">remainingBundles</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">bundles</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Resource loading optimization using greedy algorithm</span>
  <span class="kd">static</span> <span class="nx">optimizeResourceLoading</span><span class="p">(</span><span class="nx">resources</span><span class="p">,</span> <span class="nx">bandwidth</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 1MB/s default</span>
    <span class="kd">const</span> <span class="nx">critical</span> <span class="o">=</span> <span class="nx">resources</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">critical</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">nonCritical</span> <span class="o">=</span> <span class="nx">resources</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">r</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">r</span><span class="p">.</span><span class="nx">critical</span><span class="p">);</span>
    
    <span class="c1">// Sort critical resources by priority, non-critical by size/importance ratio</span>
    <span class="nx">critical</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">priority</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">priority</span> <span class="o">||</span> <span class="mi">0</span><span class="p">));</span>
    <span class="nx">nonCritical</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">ratioA</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">importance</span> <span class="o">||</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nx">a</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">ratioB</span> <span class="o">=</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">importance</span> <span class="o">||</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nx">b</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
      <span class="k">return</span> <span class="nx">ratioB</span> <span class="o">-</span> <span class="nx">ratioA</span><span class="p">;</span>
    <span class="p">});</span>
    
    <span class="kd">const</span> <span class="nx">loadingSchedule</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">currentTime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">currentBandwidth</span> <span class="o">=</span> <span class="nx">bandwidth</span><span class="p">;</span>
    
    <span class="c1">// Schedule critical resources first</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">resource</span> <span class="k">of</span> <span class="nx">critical</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">loadTime</span> <span class="o">=</span> <span class="nx">resource</span><span class="p">.</span><span class="nx">size</span> <span class="o">/</span> <span class="nx">currentBandwidth</span><span class="p">;</span>
      <span class="nx">loadingSchedule</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
        <span class="nx">resource</span><span class="p">,</span>
        <span class="na">startTime</span><span class="p">:</span> <span class="nx">currentTime</span><span class="p">,</span>
        <span class="na">endTime</span><span class="p">:</span> <span class="nx">currentTime</span> <span class="o">+</span> <span class="nx">loadTime</span><span class="p">,</span>
        <span class="na">priority</span><span class="p">:</span> <span class="dl">'</span><span class="s1">critical</span><span class="dl">'</span>
      <span class="p">});</span>
      <span class="nx">currentTime</span> <span class="o">+=</span> <span class="nx">loadTime</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Schedule non-critical resources</span>
    <span class="kd">const</span> <span class="nx">nonCriticalBatches</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">createLoadingBatches</span><span class="p">(</span><span class="nx">nonCritical</span><span class="p">,</span> <span class="nx">bandwidth</span><span class="p">);</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">batch</span> <span class="k">of</span> <span class="nx">nonCriticalBatches</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">batchStartTime</span> <span class="o">=</span> <span class="nx">currentTime</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">maxBatchTime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">resource</span> <span class="k">of</span> <span class="nx">batch</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">loadTime</span> <span class="o">=</span> <span class="nx">resource</span><span class="p">.</span><span class="nx">size</span> <span class="o">/</span> <span class="p">(</span><span class="nx">bandwidth</span> <span class="o">/</span> <span class="nx">batch</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// Parallel loading</span>
        <span class="nx">loadingSchedule</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="nx">resource</span><span class="p">,</span>
          <span class="na">startTime</span><span class="p">:</span> <span class="nx">batchStartTime</span><span class="p">,</span>
          <span class="na">endTime</span><span class="p">:</span> <span class="nx">batchStartTime</span> <span class="o">+</span> <span class="nx">loadTime</span><span class="p">,</span>
          <span class="na">priority</span><span class="p">:</span> <span class="dl">'</span><span class="s1">normal</span><span class="dl">'</span>
        <span class="p">});</span>
        <span class="nx">maxBatchTime</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">maxBatchTime</span><span class="p">,</span> <span class="nx">loadTime</span><span class="p">);</span>
      <span class="p">}</span>
      
      <span class="nx">currentTime</span> <span class="o">+=</span> <span class="nx">maxBatchTime</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">schedule</span><span class="p">:</span> <span class="nx">loadingSchedule</span><span class="p">,</span>
      <span class="na">totalTime</span><span class="p">:</span> <span class="nx">currentTime</span><span class="p">,</span>
      <span class="na">criticalTime</span><span class="p">:</span> <span class="nx">critical</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">sum</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">sum</span> <span class="o">+</span> <span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">size</span> <span class="o">/</span> <span class="nx">bandwidth</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="kd">static</span> <span class="nx">createLoadingBatches</span><span class="p">(</span><span class="nx">resources</span><span class="p">,</span> <span class="nx">bandwidth</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">batches</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">currentBatch</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">currentBatchSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">maxBatchSize</span> <span class="o">=</span> <span class="nx">bandwidth</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">;</span> <span class="c1">// Don't exceed 50% bandwidth per batch</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">resource</span> <span class="k">of</span> <span class="nx">resources</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">currentBatchSize</span> <span class="o">+</span> <span class="nx">resource</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;</span> <span class="nx">maxBatchSize</span> <span class="o">&amp;&amp;</span> <span class="nx">currentBatch</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">batches</span><span class="p">.</span><span class="nx">push</span><span class="p">([...</span><span class="nx">currentBatch</span><span class="p">]);</span>
        <span class="nx">currentBatch</span> <span class="o">=</span> <span class="p">[</span><span class="nx">resource</span><span class="p">];</span>
        <span class="nx">currentBatchSize</span> <span class="o">=</span> <span class="nx">resource</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">currentBatch</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">resource</span><span class="p">);</span>
        <span class="nx">currentBatchSize</span> <span class="o">+=</span> <span class="nx">resource</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">currentBatch</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">batches</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">currentBatch</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">batches</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Cache optimization using LRU and frequency-based algorithms</span>
  <span class="kd">static</span> <span class="nx">optimizeCache</span><span class="p">(</span><span class="nx">accessPattern</span><span class="p">,</span> <span class="nx">cacheSize</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">lruCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">frequencyCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">accessCount</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    
    <span class="kd">let</span> <span class="nx">lruHits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">frequencyHits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="c1">// Simulate LRU cache</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">accessPattern</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">lruCache</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">lruHits</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">// Move to end (most recently used)</span>
        <span class="nx">lruCache</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
        <span class="nx">lruCache</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">lruCache</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="nx">cacheSize</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Remove least recently used (first item)</span>
          <span class="kd">const</span> <span class="nx">lru</span> <span class="o">=</span> <span class="nx">lruCache</span><span class="p">.</span><span class="nx">keys</span><span class="p">().</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">;</span>
          <span class="nx">lruCache</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">lru</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">lruCache</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// Reset for frequency-based cache</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">accessPattern</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">accessCount</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="p">(</span><span class="nx">accessCount</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nx">frequencyCache</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">frequencyHits</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">frequencyCache</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="nx">cacheSize</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// Remove least frequently used</span>
          <span class="kd">let</span> <span class="nx">lfu</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
          <span class="kd">let</span> <span class="nx">minCount</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span>
          
          <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">cachedItem</span> <span class="k">of</span> <span class="nx">frequencyCache</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">accessCount</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">cachedItem</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">count</span> <span class="o">&lt;</span> <span class="nx">minCount</span><span class="p">)</span> <span class="p">{</span>
              <span class="nx">minCount</span> <span class="o">=</span> <span class="nx">count</span><span class="p">;</span>
              <span class="nx">lfu</span> <span class="o">=</span> <span class="nx">cachedItem</span><span class="p">;</span>
            <span class="p">}</span>
          <span class="p">}</span>
          
          <span class="k">if</span> <span class="p">(</span><span class="nx">lfu</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">frequencyCache</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">lfu</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">frequencyCache</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">lru</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">hits</span><span class="p">:</span> <span class="nx">lruHits</span><span class="p">,</span>
        <span class="na">hitRate</span><span class="p">:</span> <span class="nx">lruHits</span> <span class="o">/</span> <span class="nx">accessPattern</span><span class="p">.</span><span class="nx">length</span>
      <span class="p">},</span>
      <span class="na">frequency</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">hits</span><span class="p">:</span> <span class="nx">frequencyHits</span><span class="p">,</span>
        <span class="na">hitRate</span><span class="p">:</span> <span class="nx">frequencyHits</span> <span class="o">/</span> <span class="nx">accessPattern</span><span class="p">.</span><span class="nx">length</span>
      <span class="p">},</span>
      <span class="na">recommendation</span><span class="p">:</span> <span class="nx">frequencyHits</span> <span class="o">&gt;</span> <span class="nx">lruHits</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">frequency-based</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">'</span><span class="s1">lru</span><span class="dl">'</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// Image optimization algorithm</span>
  <span class="kd">static</span> <span class="nx">optimizeImageLoading</span><span class="p">(</span><span class="nx">images</span><span class="p">,</span> <span class="nx">viewportSize</span> <span class="o">=</span> <span class="p">{</span> <span class="na">width</span><span class="p">:</span> <span class="mi">1920</span><span class="p">,</span> <span class="na">height</span><span class="p">:</span> <span class="mi">1080</span> <span class="p">})</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">optimizedImages</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">image</span> <span class="k">of</span> <span class="nx">images</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">optimization</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">original</span><span class="p">:</span> <span class="nx">image</span><span class="p">,</span>
        <span class="na">recommendations</span><span class="p">:</span> <span class="p">[]</span>
      <span class="p">};</span>
      
      <span class="c1">// Resize recommendation</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">width</span> <span class="o">&gt;</span> <span class="nx">viewportSize</span><span class="p">.</span><span class="nx">width</span> <span class="o">||</span> <span class="nx">image</span><span class="p">.</span><span class="nx">height</span> <span class="o">&gt;</span> <span class="nx">viewportSize</span><span class="p">.</span><span class="nx">height</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">scale</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span>
          <span class="nx">viewportSize</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="nx">image</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span>
          <span class="nx">viewportSize</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="nx">image</span><span class="p">.</span><span class="nx">height</span>
        <span class="p">);</span>
        
        <span class="nx">optimization</span><span class="p">.</span><span class="nx">recommendations</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">resize</span><span class="dl">'</span><span class="p">,</span>
          <span class="na">newWidth</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="nx">scale</span><span class="p">),</span>
          <span class="na">newHeight</span><span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">height</span> <span class="o">*</span> <span class="nx">scale</span><span class="p">),</span>
          <span class="na">savings</span><span class="p">:</span> <span class="s2">`</span><span class="p">${(</span><span class="mi">100</span> <span class="o">-</span> <span class="nx">scale</span> <span class="o">*</span> <span class="mi">100</span><span class="p">).</span><span class="nx">toFixed</span><span class="p">(</span><span class="mi">1</span><span class="p">)}</span><span class="s2">% size reduction`</span>
        <span class="p">});</span>
      <span class="p">}</span>
      
      <span class="c1">// Format recommendation</span>
      <span class="kd">const</span> <span class="nx">formatRecommendation</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">getOptimalImageFormat</span><span class="p">(</span><span class="nx">image</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">formatRecommendation</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">optimization</span><span class="p">.</span><span class="nx">recommendations</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">formatRecommendation</span><span class="p">);</span>
      <span class="p">}</span>
      
      <span class="c1">// Lazy loading recommendation</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">image</span><span class="p">.</span><span class="nx">critical</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">optimization</span><span class="p">.</span><span class="nx">recommendations</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">lazy-loading</span><span class="dl">'</span><span class="p">,</span>
          <span class="na">description</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Load image when it enters viewport</span><span class="dl">'</span>
        <span class="p">});</span>
      <span class="p">}</span>
      
      <span class="c1">// Progressive loading recommendation</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 100KB</span>
        <span class="nx">optimization</span><span class="p">.</span><span class="nx">recommendations</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">progressive</span><span class="dl">'</span><span class="p">,</span>
          <span class="na">description</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Use progressive JPEG or WebP</span><span class="dl">'</span>
        <span class="p">});</span>
      <span class="p">}</span>
      
      <span class="nx">optimizedImages</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">optimization</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">optimizedImages</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">static</span> <span class="nx">getOptimalImageFormat</span><span class="p">(</span><span class="nx">image</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">hasTransparency</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">format</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">recommendation</span><span class="p">:</span> <span class="dl">'</span><span class="s1">WebP or PNG</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">reason</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Image has transparency</span><span class="dl">'</span>
      <span class="p">};</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">isPhoto</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">format</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">recommendation</span><span class="p">:</span> <span class="dl">'</span><span class="s1">WebP or JPEG</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">reason</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Photographic content compresses well with lossy formats</span><span class="dl">'</span>
      <span class="p">};</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">image</span><span class="p">.</span><span class="nx">hasText</span> <span class="o">||</span> <span class="nx">image</span><span class="p">.</span><span class="nx">isIcon</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">format</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">recommendation</span><span class="p">:</span> <span class="dl">'</span><span class="s1">SVG or WebP</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">reason</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Vector format better for text and icons</span><span class="dl">'</span>
      <span class="p">};</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Code splitting optimization</span>
  <span class="kd">static</span> <span class="nx">optimizeCodeSplitting</span><span class="p">(</span><span class="nx">componentUsage</span><span class="p">,</span> <span class="nx">bundleTargetSize</span> <span class="o">=</span> <span class="mi">250000</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">components</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">componentUsage</span><span class="p">).</span><span class="nx">map</span><span class="p">(([</span><span class="nx">name</span><span class="p">,</span> <span class="nx">data</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="p">({</span>
      <span class="nx">name</span><span class="p">,</span>
      <span class="p">...</span><span class="nx">data</span>
    <span class="p">}));</span>
    
    <span class="c1">// Group components by usage patterns</span>
    <span class="kd">const</span> <span class="nx">highFrequency</span> <span class="o">=</span> <span class="nx">components</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">c</span> <span class="o">=&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">frequency</span> <span class="o">&gt;</span> <span class="mf">0.7</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">mediumFrequency</span> <span class="o">=</span> <span class="nx">components</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">c</span> <span class="o">=&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">frequency</span> <span class="o">&gt;</span> <span class="mf">0.3</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">frequency</span> <span class="o">&lt;=</span> <span class="mf">0.7</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">lowFrequency</span> <span class="o">=</span> <span class="nx">components</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">c</span> <span class="o">=&gt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">frequency</span> <span class="o">&lt;=</span> <span class="mf">0.3</span><span class="p">);</span>
    
    <span class="kd">const</span> <span class="nx">splitStrategy</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">core</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">components</span><span class="p">:</span> <span class="nx">highFrequency</span><span class="p">,</span>
        <span class="na">priority</span><span class="p">:</span> <span class="dl">'</span><span class="s1">critical</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">loadStrategy</span><span class="p">:</span> <span class="dl">'</span><span class="s1">eager</span><span class="dl">'</span>
      <span class="p">},</span>
      <span class="na">features</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">groupComponentsByFeature</span><span class="p">(</span><span class="nx">mediumFrequency</span><span class="p">,</span> <span class="nx">bundleTargetSize</span><span class="p">),</span>
      <span class="na">lazy</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">components</span><span class="p">:</span> <span class="nx">lowFrequency</span><span class="p">,</span>
        <span class="na">priority</span><span class="p">:</span> <span class="dl">'</span><span class="s1">low</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">loadStrategy</span><span class="p">:</span> <span class="dl">'</span><span class="s1">lazy</span><span class="dl">'</span>
      <span class="p">}</span>
    <span class="p">};</span>
    
    <span class="k">return</span> <span class="nx">splitStrategy</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">static</span> <span class="nx">groupComponentsByFeature</span><span class="p">(</span><span class="nx">components</span><span class="p">,</span> <span class="nx">targetSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">features</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    
    <span class="c1">// Group by feature/route</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">component</span> <span class="k">of</span> <span class="nx">components</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">feature</span> <span class="o">=</span> <span class="nx">component</span><span class="p">.</span><span class="nx">feature</span> <span class="o">||</span> <span class="nx">component</span><span class="p">.</span><span class="nx">route</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">common</span><span class="dl">'</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">features</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">feature</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">features</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">feature</span><span class="p">,</span> <span class="p">[]);</span>
      <span class="p">}</span>
      <span class="nx">features</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">feature</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="nx">component</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="c1">// Optimize bundle sizes within features</span>
    <span class="kd">const</span> <span class="nx">optimizedFeatures</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="nx">featureName</span><span class="p">,</span> <span class="nx">featureComponents</span><span class="p">]</span> <span class="k">of</span> <span class="nx">features</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">totalSize</span> <span class="o">=</span> <span class="nx">featureComponents</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">sum</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">c</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      
      <span class="k">if</span> <span class="p">(</span><span class="nx">totalSize</span> <span class="o">&lt;=</span> <span class="nx">targetSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">optimizedFeatures</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="na">name</span><span class="p">:</span> <span class="nx">featureName</span><span class="p">,</span>
          <span class="na">components</span><span class="p">:</span> <span class="nx">featureComponents</span><span class="p">,</span>
          <span class="na">size</span><span class="p">:</span> <span class="nx">totalSize</span><span class="p">,</span>
          <span class="na">loadStrategy</span><span class="p">:</span> <span class="dl">'</span><span class="s1">route-based</span><span class="dl">'</span>
        <span class="p">});</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Split large features into smaller bundles</span>
        <span class="kd">const</span> <span class="nx">subBundles</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">splitLargeFeature</span><span class="p">(</span><span class="nx">featureComponents</span><span class="p">,</span> <span class="nx">targetSize</span><span class="p">);</span>
        <span class="nx">optimizedFeatures</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">subBundles</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">bundle</span> <span class="o">=&gt;</span> <span class="p">({</span>
          <span class="na">name</span><span class="p">:</span> <span class="s2">`</span><span class="p">${</span><span class="nx">featureName</span><span class="p">}</span><span class="s2">-</span><span class="p">${</span><span class="nx">bundle</span><span class="p">.</span><span class="nx">index</span><span class="p">}</span><span class="s2">`</span><span class="p">,</span>
          <span class="na">components</span><span class="p">:</span> <span class="nx">bundle</span><span class="p">.</span><span class="nx">components</span><span class="p">,</span>
          <span class="na">size</span><span class="p">:</span> <span class="nx">bundle</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span>
          <span class="na">loadStrategy</span><span class="p">:</span> <span class="dl">'</span><span class="s1">progressive</span><span class="dl">'</span>
        <span class="p">})));</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">optimizedFeatures</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">static</span> <span class="nx">splitLargeFeature</span><span class="p">(</span><span class="nx">components</span><span class="p">,</span> <span class="nx">targetSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">bundles</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">currentBundle</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">currentSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">bundleIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="c1">// Sort by dependency order and importance</span>
    <span class="nx">components</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">importance</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">importance</span> <span class="o">||</span> <span class="mi">0</span><span class="p">));</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">component</span> <span class="k">of</span> <span class="nx">components</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">currentSize</span> <span class="o">+</span> <span class="nx">component</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;</span> <span class="nx">targetSize</span> <span class="o">&amp;&amp;</span> <span class="nx">currentBundle</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">bundles</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
          <span class="na">index</span><span class="p">:</span> <span class="nx">bundleIndex</span><span class="o">++</span><span class="p">,</span>
          <span class="na">components</span><span class="p">:</span> <span class="p">[...</span><span class="nx">currentBundle</span><span class="p">],</span>
          <span class="na">size</span><span class="p">:</span> <span class="nx">currentSize</span>
        <span class="p">});</span>
        <span class="nx">currentBundle</span> <span class="o">=</span> <span class="p">[</span><span class="nx">component</span><span class="p">];</span>
        <span class="nx">currentSize</span> <span class="o">=</span> <span class="nx">component</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">currentBundle</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">component</span><span class="p">);</span>
        <span class="nx">currentSize</span> <span class="o">+=</span> <span class="nx">component</span><span class="p">.</span><span class="nx">size</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nx">currentBundle</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">bundles</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span>
        <span class="na">index</span><span class="p">:</span> <span class="nx">bundleIndex</span><span class="p">,</span>
        <span class="na">components</span><span class="p">:</span> <span class="nx">currentBundle</span><span class="p">,</span>
        <span class="na">size</span><span class="p">:</span> <span class="nx">currentSize</span>
      <span class="p">});</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">bundles</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This comprehensive guide provides essential algorithms and data structures specifically tailored for frontend development challenges, optimization problems, and user interface requirements commonly encountered in Big Tech interviews.</p>

        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>