<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implement strStr() | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/string/">String</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/string/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Implement strstr()</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Implement strStr()</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">String</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">String</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                                    <span class="tag">Sliding Window</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="implement-strstr">Implement strStr()</h1>

<p><strong>LeetCode Problem # * 28. Implement strStr()</strong></p>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>Implement strStr().  *  * Return the index of the first occurrence of needle in haystack, or -1 if  * needle is not part of haystack.  *</li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Implement strStr()
 *</li>
    </ol>
  </li>
  <li>Problem:</li>
  <li>Implement strStr().
 *</li>
  <li>Return the index of the first occurrence of needle in haystack, or -1 if</li>
  <li>needle is not part of haystack.
 *</li>
  <li>Clarification:</li>
  <li>What should we return when needle is an empty string? This is a great question</li>
  <li>to ask during an interview.
 *</li>
  <li>For the purpose of this problem, we will return 0 when needle is an empty string.</li>
  <li>This is consistent to C’s strstr() and Java’s indexOf().
 *</li>
  <li>Example:</li>
  <li>Input: haystack = “hello”, needle = “ll”</li>
  <li>Output: 2
 *</li>
  <li>Input: haystack = “aaaaa”, needle = “bba”</li>
  <li>Output: -1
 *</li>
  <li>Input: haystack = “”, needle = “”</li>
  <li>Output: 0
 *</li>
  <li>LeetCode: https://leetcode.com/problems/implement-strstr/
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>Solution 1: Built-in indexOf (Simple)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use JavaScript’s built-in indexOf method</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Simple but not educational for interviews
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n * m)</li>
  <li>Space Complexity: O(1)
 */
function strStr(haystack: string, needle: string): number {
  return haystack.indexOf(needle);
}</li>
</ul>

<p>/**</p>
<ul>
  <li>Solution 2: Brute Force (Naive)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Check each possible starting position</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Compare substring with needle
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n * m)</li>
  <li>Space Complexity: O(1)
 */
function strStrBruteForce(haystack: string, needle: string): number {
  if (needle === “”) return 0;</li>
</ul>

<p>const n = haystack.length;
  const m = needle.length;</p>

<p>for (let i = 0; i &lt;= n - m; i++) {
    let j = 0;
    while (j &lt; m &amp;&amp; haystack[i + j] === needle[j]) {
      j++;
    }
    if (j === m) {
      return i;
    }
  }</p>

<p>return -1;
}</p>

<p>/**</p>
<ul>
  <li>Solution 3: KMP Algorithm (Optimal)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use KMP algorithm for efficient string matching</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Precompute failure function
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n + m)</li>
  <li>Space Complexity: O(m)
 */
function strStrKMP(haystack: string, needle: string): number {
  if (needle === “”) return 0;</li>
</ul>

<p>const n = haystack.length;
  const m = needle.length;</p>

<p>// Compute failure function
  const failure = computeFailureFunction(needle);</p>

<p>let i = 0; // index for haystack
  let j = 0; // index for needle</p>

<p>while (i &lt; n) {
    if (needle[j] === haystack[i]) {
      i++;
      j++;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>if (j === m) {
  return i - j;
} else if (i &lt; n &amp;&amp; needle[j] !== haystack[i]) {
  if (j !== 0) {
    j = failure[j - 1];
  } else {
    i++;
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return -1;
}</p>

<p>function computeFailureFunction(pattern: string): number[] {
  const m = pattern.length;
  const failure = new Array(m).fill(0);</p>

<p>let len = 0;
  let i = 1;</p>

<p>while (i &lt; m) {
    if (pattern[i] === pattern[len]) {
      len++;
      failure[i] = len;
      i++;
    } else {
      if (len !== 0) {
        len = failure[len - 1];
      } else {
        failure[i] = 0;
        i++;
      }
    }
  }</p>

<p>return failure;
}</p>

<p>/**</p>
<ul>
  <li>Solution 4: Boyer-Moore Algorithm
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Boyer-Moore algorithm for efficient string matching</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Bad character rule and good suffix rule
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n * m) worst case, O(n/m) best case</li>
  <li>Space Complexity: O(k) where k is alphabet size
 */
function strStrBoyerMoore(haystack: string, needle: string): number {
  if (needle === “”) return 0;</li>
</ul>

<p>const n = haystack.length;
  const m = needle.length;</p>

<p>// Bad character table
  const badChar = new Map&lt;string, number&gt;();
  for (let i = 0; i &lt; m - 1; i++) {
    badChar.set(needle[i], m - 1 - i);
  }</p>

<p>let i = m - 1;
  while (i &lt; n) {
    let j = m - 1;
    let k = i;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>while (j &gt;= 0 &amp;&amp; haystack[k] === needle[j]) {
  k--;
  j--;
}

if (j === -1) {
  return k + 1;
}

const shift = badChar.get(haystack[i]) || m;
i += shift;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return -1;
}</p>

<p>/**</p>
<ul>
  <li>Solution 5: Rabin-Karp Algorithm
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use rolling hash for string matching</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Hash-based comparison
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n + m) average case</li>
  <li>Space Complexity: O(1)
 */
function strStrRabinKarp(haystack: string, needle: string): number {
  if (needle === “”) return 0;</li>
</ul>

<p>const n = haystack.length;
  const m = needle.length;</p>

<p>if (n &lt; m) return -1;</p>

<p>const base = 256;
  const mod = 101; // Prime number</p>

<p>// Compute hash for needle
  let needleHash = 0;
  for (let i = 0; i &lt; m; i++) {
    needleHash = (needleHash * base + needle.charCodeAt(i)) % mod;
  }</p>

<p>// Compute hash for first window of haystack
  let haystackHash = 0;
  for (let i = 0; i &lt; m; i++) {
    haystackHash = (haystackHash * base + haystack.charCodeAt(i)) % mod;
  }</p>

<p>// Power for rolling hash
  let power = 1;
  for (let i = 0; i &lt; m - 1; i++) {
    power = (power * base) % mod;
  }</p>

<p>// Check first window
  if (haystackHash === needleHash &amp;&amp; haystack.substring(0, m) === needle) {
    return 0;
  }</p>

<p>// Check remaining windows
  for (let i = m; i &lt; n; i++) {
    haystackHash =
      (haystackHash - ((haystack.charCodeAt(i - m) * power) % mod) + mod) % mod;
    haystackHash = (haystackHash * base + haystack.charCodeAt(i)) % mod;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>if (
  haystackHash === needleHash &amp;&amp;
  haystack.substring(i - m + 1, i + 1) === needle
) {
  return i - m + 1;
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return -1;
}</p>

<p>/**</p>
<ul>
  <li>Solution 6: Using Sliding Window
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use sliding window technique</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Compare substrings directly
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n * m)</li>
  <li>Space Complexity: O(1)
 */
function strStrSlidingWindow(haystack: string, needle: string): number {
  if (needle === “”) return 0;</li>
</ul>

<p>const n = haystack.length;
  const m = needle.length;</p>

<p>for (let i = 0; i &lt;= n - m; i++) {
    const window = haystack.substring(i, i + m);
    if (window === needle) {
      return i;
    }
  }</p>

<p>return -1;
}</p>

<p>/**</p>
<ul>
  <li>Solution 7: Using Generator (Memory efficient)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use generator to yield possible positions</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory efficient for large strings
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n * m)</li>
  <li>Space Complexity: O(1)
 <em>/
function</em> possiblePositions(
  haystack: string,
  needle: string
): Generator<number> {
  if (needle === "") {
 yield 0;
 return;
  }</number></li>
</ul>

<p>const n = haystack.length;
  const m = needle.length;</p>

<p>for (let i = 0; i &lt;= n - m; i++) {
    let match = true;
    for (let j = 0; j &lt; m; j++) {
      if (haystack[i + j] !== needle[j]) {
        match = false;
        break;
      }
    }
    if (match) {
      yield i;
    }
  }
}</p>

<p>function strStrGenerator(haystack: string, needle: string): number {
  const positions = possiblePositions(haystack, needle);
  const first = positions.next();
  return first.done ? -1 : first.value;
}</p>

<p>/**</p>
<ul>
  <li>Solution 8: Using Class (Object-oriented)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Create a StringMatcher class</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Encapsulate matching logic
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n * m)</li>
  <li>Space Complexity: O(1)
 */
class StringMatcher {
  private haystack: string;
  private needle: string;</li>
</ul>

<p>constructor(haystack: string, needle: string) {
    this.haystack = haystack;
    this.needle = needle;
  }</p>

<p>findFirstOccurrence(): number {
    if (this.needle === “”) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>const n = this.haystack.length;
const m = this.needle.length;

for (let i = 0; i &lt;= n - m; i++) {
  if (this.matchesAt(i)) {
    return i;
  }
}

return -1;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>private matchesAt(startIndex: number): boolean {
    for (let i = 0; i &lt; this.needle.length; i++) {
      if (this.haystack[startIndex + i] !== this.needle[i]) {
        return false;
      }
    }
    return true;
  }
}</p>

<p>function strStrClass(haystack: string, needle: string): number {
  const matcher = new StringMatcher(haystack, needle);
  return matcher.findFirstOccurrence();
}</p>

<p>/**</p>
<ul>
  <li>Solution 9: Using Functional Approach
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use functional programming concepts</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More declarative style
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n * m)</li>
  <li>Space Complexity: O(n)
 */
function strStrFunctional(haystack: string, needle: string): number {
  if (needle === “”) return 0;</li>
</ul>

<p>const n = haystack.length;
  const m = needle.length;</p>

<p>const positions = Array.from({ length: n - m + 1 }, (_, i) =&gt; i).filter(
    (i) =&gt; haystack.substring(i, i + m) === needle
  );</p>

<p>return positions.length &gt; 0 ? positions[0] : -1;
}</p>

<p>// Test cases
function testStrStr() {
  console.log(“=== Testing Implement strStr() ===\n”);</p>

<p>const testCases = [
    {
      haystack: “hello”,
      needle: “ll”,
      expected: 2,
      description: “Standard case”,
    },
    {
      haystack: “aaaaa”,
      needle: “bba”,
      expected: -1,
      description: “No match”,
    },
    {
      haystack: “”,
      needle: “”,
      expected: 0,
      description: “Empty strings”,
    },
    {
      haystack: “hello”,
      needle: “”,
      expected: 0,
      description: “Empty needle”,
    },
    {
      haystack: “”,
      needle: “hello”,
      expected: -1,
      description: “Empty haystack”,
    },
    {
      haystack: “mississippi”,
      needle: “issip”,
      expected: 4,
      description: “Complex case”,
    },
    {
      haystack: “a”,
      needle: “a”,
      expected: 0,
      description: “Single character match”,
    },
    {
      haystack: “abc”,
      needle: “abcd”,
      expected: -1,
      description: “Needle longer than haystack”,
    },
  ];</p>

<p>testCases.forEach((testCase, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Test Case ${index + 1}: ${testCase.description}</code>);
    console.log(
      <code class="language-plaintext highlighter-rouge">Input: haystack = "${testCase.haystack}", needle = "${testCase.needle}"</code>
    );
    console.log(<code class="language-plaintext highlighter-rouge">Expected: ${testCase.expected}\n</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
</pre></td><td class="rouge-code"><pre>// Test Solution 1 (Built-in)
const result1 = strStr(testCase.haystack, testCase.needle);
console.log(
  `Solution 1 (Built-in): ${result1} ${
    result1 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 2 (Brute Force)
const result2 = strStrBruteForce(testCase.haystack, testCase.needle);
console.log(
  `Solution 2 (Brute Force): ${result2} ${
    result2 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 3 (KMP)
const result3 = strStrKMP(testCase.haystack, testCase.needle);
console.log(
  `Solution 3 (KMP): ${result3} ${
    result3 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 4 (Boyer-Moore)
const result4 = strStrBoyerMoore(testCase.haystack, testCase.needle);
console.log(
  `Solution 4 (Boyer-Moore): ${result4} ${
    result4 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 5 (Rabin-Karp)
const result5 = strStrRabinKarp(testCase.haystack, testCase.needle);
console.log(
  `Solution 5 (Rabin-Karp): ${result5} ${
    result5 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 6 (Sliding Window)
const result6 = strStrSlidingWindow(testCase.haystack, testCase.needle);
console.log(
  `Solution 6 (Sliding Window): ${result6} ${
    result6 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 7 (Generator)
const result7 = strStrGenerator(testCase.haystack, testCase.needle);
console.log(
  `Solution 7 (Generator): ${result7} ${
    result7 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 8 (Class)
const result8 = strStrClass(testCase.haystack, testCase.needle);
console.log(
  `Solution 8 (Class): ${result8} ${
    result8 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 9 (Functional)
const result9 = strStrFunctional(testCase.haystack, testCase.needle);
console.log(
  `Solution 9 (Functional): ${result9} ${
    result9 === testCase.expected ? "✅" : "❌"
  }`
);

console.log("\n---\n");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Performance comparison
function performanceComparison() {
  console.log(“=== Performance Comparison ===\n”);</p>

<p>const testCases = [
    { name: “Built-in”, func: strStr },
    { name: “Brute Force”, func: strStrBruteForce },
    { name: “KMP”, func: strStrKMP },
    { name: “Boyer-Moore”, func: strStrBoyerMoore },
    { name: “Rabin-Karp”, func: strStrRabinKarp },
    { name: “Sliding Window”, func: strStrSlidingWindow },
    { name: “Generator”, func: strStrGenerator },
    { name: “Class”, func: strStrClass },
    { name: “Functional”, func: strStrFunctional },
  ];</p>

<p>// Create test cases
  const shortCase = { haystack: “hello world”, needle: “world” };
  const mediumCase = { haystack: “a”.repeat(1000) + “b”, needle: “ab” };
  const longCase = { haystack: “a”.repeat(10000) + “b”, needle: “ab” };</p>

<p>const cases = [
    { name: “Short”, case: shortCase },
    { name: “Medium”, case: mediumCase },
    { name: “Long”, case: longCase },
  ];</p>

<p>cases.forEach(({ name, case: testCase }) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">${name} Case:</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>testCases.forEach(({ name: funcName, func }) =&gt; {
  const start = performance.now();
  const result = func(testCase.haystack, testCase.needle);
  const end = performance.now();

  console.log(`  ${funcName}: ${(end - start).toFixed(2)}ms (${result})`);
});

console.log("");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Uncomment the following lines to run tests
// testStrStr();
// performanceComparison();</p>

<p>export {
  strStr,
  strStrBruteForce,
  strStrKMP,
  strStrBoyerMoore,
  strStrRabinKarp,
  strStrSlidingWindow,
  strStrGenerator,
  strStrClass,
  strStrFunctional,
  StringMatcher,
  possiblePositions,
  computeFailureFunction,
  testStrStr,
  performanceComparison,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>