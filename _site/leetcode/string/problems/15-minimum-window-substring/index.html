<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimum Window Substring | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/string/">String</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/string/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Minimum window substring</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Minimum Window Substring</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">String</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">String</span>
                                
                                    <span class="tag">Two Pointers</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                                    <span class="tag">Sliding Window</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="minimum-window-substring">Minimum Window Substring</h1>

<p><strong>LeetCode Problem # * 76. Minimum Window Substring</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Minimum Window Substring</li>
    </ol>
  </li>
  <li></li>
  <li>Given two strings s and t of lengths m and n respectively, return the minimum window</li>
  <li>substring of s such that every character in t (including duplicates) is included in the window.</li>
  <li>If there is no such window, return the empty string “”.</li>
  <li></li>
  <li>The testcases will be generated such that the answer is unique.</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: s = “ADOBECODEBANC”, t = “ABC”</li>
  <li>Output: “BANC”</li>
  <li>Explanation: The minimum window substring “BANC” includes ‘A’, ‘B’, and ‘C’ from string t.</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: s = “a”, t = “a”</li>
  <li>Output: “a”</li>
  <li></li>
  <li>Example 3:</li>
  <li>Input: s = “a”, t = “aa”</li>
  <li>Output: “”</li>
  <li>Explanation: Both ‘a’s from t must be included in the window.</li>
  <li>Since the largest window of s only has one ‘a’, return empty string.</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>m == s.length</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>n == t.length</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>1 &lt;= m, n &lt;= 10^5</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>s and t consist of uppercase and lowercase English letters.</li>
    </ul>
  </li>
  <li></li>
  <li>Follow up: Could you find an algorithm that runs in O(m + n) time?
 */</li>
</ul>

<p>// Solution 1: Sliding Window with HashMap
// Time: O(m + n), Space: O(m + n)
export function minWindow1(s: string, t: string): string {
    if (s.length &lt; t.length) return “”;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre>// Count characters in t
const tCount = new Map&lt;string, number&gt;();
for (const char of t) {
    tCount.set(char, (tCount.get(char) || 0) + 1);
}

const required = tCount.size;
let formed = 0;

// Sliding window
const windowCounts = new Map&lt;string, number&gt;();
let left = 0;
let minLength = Infinity;
let minStart = 0;

for (let right = 0; right &lt; s.length; right++) {
    const char = s[right];
    windowCounts.set(char, (windowCounts.get(char) || 0) + 1);
    
    // Check if current character's frequency matches required frequency
    if (tCount.has(char) &amp;&amp; windowCounts.get(char) === tCount.get(char)) {
        formed++;
    }
    
    // Try to shrink window from left
    while (formed === required &amp;&amp; left &lt;= right) {
        const windowLength = right - left + 1;
        if (windowLength &lt; minLength) {
            minLength = windowLength;
            minStart = left;
        }
        
        const leftChar = s[left];
        windowCounts.set(leftChar, windowCounts.get(leftChar)! - 1);
        
        if (tCount.has(leftChar) &amp;&amp; windowCounts.get(leftChar)! &lt; tCount.get(leftChar)!) {
            formed--;
        }
        
        left++;
    }
}

return minLength === Infinity ? "" : s.substring(minStart, minStart + minLength); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Optimized Sliding Window (Filter approach)
// Time: O(m + n), Space: O(m + n)
export function minWindow2(s: string, t: string): string {
    if (s.length &lt; t.length) return “”;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre>// Count characters in t
const tCount = new Map&lt;string, number&gt;();
for (const char of t) {
    tCount.set(char, (tCount.get(char) || 0) + 1);
}

// Filter s to only include characters that are in t
const filteredS: [string, number][] = [];
for (let i = 0; i &lt; s.length; i++) {
    if (tCount.has(s[i])) {
        filteredS.push([s[i], i]);
    }
}

const required = tCount.size;
let formed = 0;
const windowCounts = new Map&lt;string, number&gt;();

let left = 0;
let minLength = Infinity;
let minStart = 0;

for (let right = 0; right &lt; filteredS.length; right++) {
    const [char, originalIndex] = filteredS[right];
    windowCounts.set(char, (windowCounts.get(char) || 0) + 1);
    
    if (windowCounts.get(char) === tCount.get(char)) {
        formed++;
    }
    
    while (formed === required &amp;&amp; left &lt;= right) {
        const windowLength = filteredS[right][1] - filteredS[left][1] + 1;
        if (windowLength &lt; minLength) {
            minLength = windowLength;
            minStart = filteredS[left][1];
        }
        
        const leftChar = filteredS[left][0];
        windowCounts.set(leftChar, windowCounts.get(leftChar)! - 1);
        
        if (windowCounts.get(leftChar)! &lt; tCount.get(leftChar)!) {
            formed--;
        }
        
        left++;
    }
}

return minLength === Infinity ? "" : s.substring(minStart, minStart + minLength); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Sliding Window with Array (ASCII optimization)
// Time: O(m + n), Space: O(1) - fixed size array
export function minWindow3(s: string, t: string): string {
    if (s.length &lt; t.length) return “”;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre>// Use arrays for ASCII characters (assuming extended ASCII)
const tCount = new Array(128).fill(0);
const windowCount = new Array(128).fill(0);

let required = 0;
for (const char of t) {
    if (tCount[char.charCodeAt(0)] === 0) {
        required++;
    }
    tCount[char.charCodeAt(0)]++;
}

let formed = 0;
let left = 0;
let minLength = Infinity;
let minStart = 0;

for (let right = 0; right &lt; s.length; right++) {
    const charCode = s.charCodeAt(right);
    windowCount[charCode]++;
    
    if (tCount[charCode] &gt; 0 &amp;&amp; windowCount[charCode] === tCount[charCode]) {
        formed++;
    }
    
    while (formed === required) {
        const windowLength = right - left + 1;
        if (windowLength &lt; minLength) {
            minLength = windowLength;
            minStart = left;
        }
        
        const leftCharCode = s.charCodeAt(left);
        windowCount[leftCharCode]--;
        
        if (tCount[leftCharCode] &gt; 0 &amp;&amp; windowCount[leftCharCode] &lt; tCount[leftCharCode]) {
            formed--;
        }
        
        left++;
    }
}

return minLength === Infinity ? "" : s.substring(minStart, minStart + minLength); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Two Pointers with Character Matching
// Time: O(m + n), Space: O(n)
export function minWindow4(s: string, t: string): string {
    if (s.length &lt; t.length) return “”;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre>const need = new Map&lt;string, number&gt;();
const window = new Map&lt;string, number&gt;();

// Initialize need map
for (const char of t) {
    need.set(char, (need.get(char) || 0) + 1);
}

let left = 0;
let right = 0;
let valid = 0;
let start = 0;
let len = Infinity;

while (right &lt; s.length) {
    const char = s[right];
    right++;
    
    // Update window
    if (need.has(char)) {
        window.set(char, (window.get(char) || 0) + 1);
        if (window.get(char) === need.get(char)) {
            valid++;
        }
    }
    
    // Try to shrink window
    while (valid === need.size) {
        // Update result
        if (right - left &lt; len) {
            start = left;
            len = right - left;
        }
        
        const leftChar = s[left];
        left++;
        
        // Update window
        if (need.has(leftChar)) {
            if (window.get(leftChar) === need.get(leftChar)) {
                valid--;
            }
            window.set(leftChar, window.get(leftChar)! - 1);
        }
    }
}

return len === Infinity ? "" : s.substring(start, start + len); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testMinWindow() {
    console.log(“Testing Minimum Window Substring:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre>const testCases = [
    {
        s: "ADOBECODEBANC",
        t: "ABC",
        expected: "BANC"
    },
    {
        s: "a",
        t: "a",
        expected: "a"
    },
    {
        s: "a",
        t: "aa",
        expected: ""
    },
    {
        s: "ab",
        t: "b",
        expected: "b"
    },
    {
        s: "bba",
        t: "ab",
        expected: "ba"
    },
    {
        s: "abc",
        t: "cba",
        expected: "abc"
    }
];

const solutions = [
    { name: "Sliding Window HashMap", fn: minWindow1 },
    { name: "Optimized Filter", fn: minWindow2 },
    { name: "Array Optimization", fn: minWindow3 },
    { name: "Two Pointers", fn: minWindow4 }
];

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        const result = solution.fn(test.s, test.t);
        const passed = result === test.expected;
        console.log(`  Test ${i + 1}: ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Input: s="${test.s}", t="${test.t}"`);
            console.log(`    Expected: "${test.expected}"`);
            console.log(`    Got: "${result}"`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Sliding Window Pattern</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Expand window by moving right pointer</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Contract window by moving left pointer when valid</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Keep track of valid characters count</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Window Validity</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Window is valid when it contains all characters from t</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use counter to track required vs available characters</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>formed === required means window is valid</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimization Techniques</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Filter approach: only process relevant characters</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Array vs HashMap: ASCII optimization for character counting</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Early termination when impossible</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(m + n) where m = s.length, n = t.length</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Each character in s is visited at most twice</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Each character in t is processed once for counting</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>: O(n) for character counting</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>HashMap: O(unique characters in t)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Array: O(1) for ASCII (128 characters)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with brute force (check all substrings)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Identify sliding window pattern</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Implement basic sliding window</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimize with filtering or array indexing</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>s shorter than t</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>t has duplicate characters</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>No valid window exists</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Single character strings</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Not handling duplicate characters in t</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect window validity check</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Off-by-one errors in substring extraction</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not updating counters correctly when shrinking</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Find all minimum windows</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Return indices instead of substring</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle Unicode characters</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Minimize/maximize other criteria
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>