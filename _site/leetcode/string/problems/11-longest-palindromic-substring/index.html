<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Longest Palindromic Substring | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/string/">String</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/string/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Longest palindromic substring</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Longest Palindromic Substring</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">String</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">String</span>
                                
                                    <span class="tag">Two Pointers</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                                    <span class="tag">Sliding Window</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="longest-palindromic-substring">Longest Palindromic Substring</h1>

<p><strong>LeetCode Problem # * 5. Longest Palindromic Substring</strong></p>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>Given a string s, return the longest palindromic substring in s.  *  * Input: s = “babad”  * Output: “bab”  * Explanation: “aba” is also a valid answer.</li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Longest Palindromic Substring
 *</li>
    </ol>
  </li>
  <li>Problem:</li>
  <li>Given a string s, return the longest palindromic substring in s.
 *</li>
  <li>Example:</li>
  <li>Input: s = “babad”</li>
  <li>Output: “bab”</li>
  <li>Explanation: “aba” is also a valid answer.
 *</li>
  <li>Input: s = “cbbd”</li>
  <li>Output: “bb”
 *</li>
  <li>Input: s = “a”</li>
  <li>Output: “a”
 *</li>
  <li>LeetCode: https://leetcode.com/problems/longest-palindromic-substring/
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>Solution 1: Expand Around Center (Optimal)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>For each character, expand around it to find palindromes</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle both odd and even length palindromes</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Keep track of the longest palindrome found
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n²)</li>
  <li>Space Complexity: O(1)
 */
function longestPalindrome(s: string): string {
  if (s.length &lt; 2) return s;</li>
</ul>

<p>let start = 0;
  let maxLength = 1;</p>

<p>function expandAroundCenter(left: number, right: number): number {
    while (left &gt;= 0 &amp;&amp; right &lt; s.length &amp;&amp; s[left] === s[right]) {
      left–;
      right++;
    }
    return right - left - 1;
  }</p>

<p>for (let i = 0; i &lt; s.length; i++) {
    // Check odd length palindromes
    const len1 = expandAroundCenter(i, i);
    // Check even length palindromes
    const len2 = expandAroundCenter(i, i + 1);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>const maxLen = Math.max(len1, len2);

if (maxLen &gt; maxLength) {
  start = i - Math.floor((maxLen - 1) / 2);
  maxLength = maxLen;
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return s.substring(start, start + maxLength);
}</p>

<p>/**</p>
<ul>
  <li>Solution 2: Dynamic Programming
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use DP table to track palindrome substrings</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>dp[i][j] = true if s[i…j] is palindrome</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Fill table diagonally
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n²)</li>
  <li>Space Complexity: O(n²)
 */
function longestPalindromeDP(s: string): string {
  if (s.length &lt; 2) return s;</li>
</ul>

<p>const n = s.length;
  const dp = Array(n)
    .fill(null)
    .map(() =&gt; Array(n).fill(false));</p>

<p>let start = 0;
  let maxLength = 1;</p>

<p>// All single characters are palindromes
  for (let i = 0; i &lt; n; i++) {
    dp[i][i] = true;
  }</p>

<p>// Check for 2-character palindromes
  for (let i = 0; i &lt; n - 1; i++) {
    if (s[i] === s[i + 1]) {
      dp[i][i + 1] = true;
      start = i;
      maxLength = 2;
    }
  }</p>

<p>// Check for palindromes of length &gt; 2
  for (let len = 3; len &lt;= n; len++) {
    for (let i = 0; i &lt;= n - len; i++) {
      const j = i + len - 1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>  if (s[i] === s[j] &amp;&amp; dp[i + 1][j - 1]) {
    dp[i][j] = true;

    if (len &gt; maxLength) {
      start = i;
      maxLength = len;
    }
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return s.substring(start, start + maxLength);
}</p>

<p>/**</p>
<ul>
  <li>Solution 3: Manacher’s Algorithm
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Manacher’s algorithm for linear time complexity</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Transform string to handle even length palindromes</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use palindrome radius array
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(n)
 */
function longestPalindromeManacher(s: string): string {
  if (s.length &lt; 2) return s;</li>
</ul>

<p>// Transform string to handle even length palindromes
  const transformed = “#” + s.split(“”).join(“#”) + “#”;
  const n = transformed.length;
  const p = new Array(n).fill(0);</p>

<p>let center = 0;
  let right = 0;</p>

<p>for (let i = 0; i &lt; n; i++) {
    if (i &lt; right) {
      const mirror = 2 * center - i;
      p[i] = Math.min(right - i, p[mirror]);
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>// Expand around current center
let left = i - (p[i] + 1);
let r = i + (p[i] + 1);

while (left &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; transformed[left] === transformed[r]) {
  p[i]++;
  left--;
  r++;
}

// Update center and right boundary
if (i + p[i] &gt; right) {
  center = i;
  right = i + p[i];
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Find the longest palindrome
  let maxLen = 0;
  let centerIndex = 0;</p>

<p>for (let i = 0; i &lt; n; i++) {
    if (p[i] &gt; maxLen) {
      maxLen = p[i];
      centerIndex = i;
    }
  }</p>

<p>const start = Math.floor((centerIndex - maxLen) / 2);
  return s.substring(start, start + maxLen);
}</p>

<p>/**</p>
<ul>
  <li>Solution 4: Brute Force
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Check all possible substrings</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Verify if each substring is palindrome
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n³)</li>
  <li>Space Complexity: O(1)
 */
function longestPalindromeBruteForce(s: string): string {
  if (s.length &lt; 2) return s;</li>
</ul>

<p>let maxLength = 1;
  let start = 0;</p>

<p>function isPalindrome(str: string): boolean {
    let left = 0;
    let right = str.length - 1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>while (left &lt; right) {
  if (str[left] !== str[right]) {
    return false;
  }
  left++;
  right--;
}
return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>for (let i = 0; i &lt; s.length; i++) {
    for (let j = i + 1; j &lt; s.length; j++) {
      const substring = s.substring(i, j + 1);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>  if (isPalindrome(substring) &amp;&amp; substring.length &gt; maxLength) {
    maxLength = substring.length;
    start = i;
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return s.substring(start, start + maxLength);
}</p>

<p>/**</p>
<ul>
  <li>Solution 5: Using Class (Object-oriented)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Create a PalindromeFinder class</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Encapsulate the finding logic
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n²)</li>
  <li>Space Complexity: O(1)
 */
class PalindromeFinder {
  private s: string;</li>
</ul>

<p>constructor(s: string) {
    this.s = s;
  }</p>

<p>findLongest(): string {
    if (this.s.length &lt; 2) return this.s;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>let start = 0;
let maxLength = 1;

for (let i = 0; i &lt; this.s.length; i++) {
  const len1 = this.expandAroundCenter(i, i);
  const len2 = this.expandAroundCenter(i, i + 1);

  const maxLen = Math.max(len1, len2);

  if (maxLen &gt; maxLength) {
    start = i - Math.floor((maxLen - 1) / 2);
    maxLength = maxLen;
  }
}

return this.s.substring(start, start + maxLength);   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>private expandAroundCenter(left: number, right: number): number {
    while (
      left &gt;= 0 &amp;&amp;
      right &lt; this.s.length &amp;&amp;
      this.s[left] === this.s[right]
    ) {
      left–;
      right++;
    }
    return right - left - 1;
  }</p>

<p>getString(): string {
    return this.s;
  }
}</p>

<p>function longestPalindromeClass(s: string): string {
  const finder = new PalindromeFinder(s);
  return finder.findLongest();
}</p>

<p>/**</p>
<ul>
  <li>Solution 6: Using Generator (Memory efficient)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use generator to yield palindrome lengths</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory efficient for large strings
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n²)</li>
  <li>Space Complexity: O(1)
 <em>/
function</em> longestPalindromeGenerator(
  s: string
): Generator&lt;{ start: number; length: number }&gt; {
  if (s.length &lt; 2) {
 yield { start: 0, length: s.length };
 return;
  }</li>
</ul>

<p>function expandAroundCenter(left: number, right: number): number {
    while (left &gt;= 0 &amp;&amp; right &lt; s.length &amp;&amp; s[left] === s[right]) {
      left–;
      right++;
    }
    return right - left - 1;
  }</p>

<p>for (let i = 0; i &lt; s.length; i++) {
    const len1 = expandAroundCenter(i, i);
    const len2 = expandAroundCenter(i, i + 1);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>const maxLen = Math.max(len1, len2);
const start = i - Math.floor((maxLen - 1) / 2);

yield { start, length: maxLen };   } }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>function longestPalindromeWithGenerator(s: string): string {
  let maxLength = 0;
  let start = 0;</p>

<p>for (const { start: currentStart, length } of longestPalindromeGenerator(s)) {
    if (length &gt; maxLength) {
      maxLength = length;
      start = currentStart;
    }
  }</p>

<p>return s.substring(start, start + maxLength);
}</p>

<p>/**</p>
<ul>
  <li>Solution 7: Using Functional Approach
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use functional programming concepts</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More declarative style
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n²)</li>
  <li>Space Complexity: O(1)
 */
function longestPalindromeFunctional(s: string): string {
  if (s.length &lt; 2) return s;</li>
</ul>

<p>const expandAroundCenter = (left: number, right: number): number =&gt; {
    while (left &gt;= 0 &amp;&amp; right &lt; s.length &amp;&amp; s[left] === s[right]) {
      left–;
      right++;
    }
    return right - left - 1;
  };</p>

<p>const results = s.split(“”).map((_, i) =&gt; {
    const len1 = expandAroundCenter(i, i);
    const len2 = expandAroundCenter(i, i + 1);
    const maxLen = Math.max(len1, len2);
    const start = i - Math.floor((maxLen - 1) / 2);
    return { start, length: maxLen };
  });</p>

<p>const maxResult = results.reduce((max, current) =&gt;
    current.length &gt; max.length ? current : max
  );</p>

<p>return s.substring(maxResult.start, maxResult.start + maxResult.length);
}</p>

<p>/**</p>
<ul>
  <li>Solution 8: Using Two Pointers with Optimization
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use two pointers with early termination</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimize by checking palindrome property
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n²)</li>
  <li>Space Complexity: O(1)
 */
function longestPalindromeTwoPointers(s: string): string {
  if (s.length &lt; 2) return s;</li>
</ul>

<p>let start = 0;
  let maxLength = 1;</p>

<p>for (let i = 0; i &lt; s.length; i++) {
    // Skip duplicates to optimize
    let left = i;
    let right = i;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>while (right + 1 &lt; s.length &amp;&amp; s[right] === s[right + 1]) {
  right++;
}

i = right; // Skip the duplicates in next iteration

// Expand around center
while (left &gt; 0 &amp;&amp; right + 1 &lt; s.length &amp;&amp; s[left - 1] === s[right + 1]) {
  left--;
  right++;
}

const length = right - left + 1;
if (length &gt; maxLength) {
  start = left;
  maxLength = length;
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return s.substring(start, start + maxLength);
}</p>

<p>/**</p>
<ul>
  <li>Solution 9: Using Recursion
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use recursive approach to find palindromes</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memoize results to avoid recomputation
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n²)</li>
  <li>Space Complexity: O(n²)
 */
function longestPalindromeRecursive(s: string): string {
  if (s.length &lt; 2) return s;</li>
</ul>

<p>const memo = new Map&lt;string, boolean&gt;();</p>

<p>function isPalindrome(left: number, right: number): boolean {
    const key = <code class="language-plaintext highlighter-rouge">${left},${right}</code>;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>if (memo.has(key)) {
  return memo.get(key)!;
}

if (left &gt;= right) {
  memo.set(key, true);
  return true;
}

const result = s[left] === s[right] &amp;&amp; isPalindrome(left + 1, right - 1);
memo.set(key, result);
return result;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>let start = 0;
  let maxLength = 1;</p>

<p>for (let i = 0; i &lt; s.length; i++) {
    for (let j = i + 1; j &lt; s.length; j++) {
      if (isPalindrome(i, j) &amp;&amp; j - i + 1 &gt; maxLength) {
        start = i;
        maxLength = j - i + 1;
      }
    }
  }</p>

<p>return s.substring(start, start + maxLength);
}</p>

<p>/**</p>
<ul>
  <li>Solution 10: Using Sliding Window
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use sliding window technique</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Check palindrome property for each window
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n²)</li>
  <li>Space Complexity: O(1)
 */
function longestPalindromeSlidingWindow(s: string): string {
  if (s.length &lt; 2) return s;</li>
</ul>

<p>let start = 0;
  let maxLength = 1;</p>

<p>function isPalindrome(left: number, right: number): boolean {
    while (left &lt; right) {
      if (s[left] !== s[right]) {
        return false;
      }
      left++;
      right–;
    }
    return true;
  }</p>

<p>// Try different window sizes
  for (let windowSize = s.length; windowSize &gt;= 2; windowSize–) {
    for (let i = 0; i &lt;= s.length - windowSize; i++) {
      const j = i + windowSize - 1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>  if (isPalindrome(i, j)) {
    return s.substring(i, j + 1);
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return s[0];
}</p>

<p>// Test cases
function testLongestPalindrome() {
  console.log(“=== Testing Longest Palindromic Substring ===\n”);</p>

<p>const testCases = [
    {
      input: “babad”,
      expected: “bab”,
      description: “Multiple palindromes”,
    },
    {
      input: “cbbd”,
      expected: “bb”,
      description: “Even length palindrome”,
    },
    {
      input: “a”,
      expected: “a”,
      description: “Single character”,
    },
    {
      input: “”,
      expected: “”,
      description: “Empty string”,
    },
    {
      input: “racecar”,
      expected: “racecar”,
      description: “Full string palindrome”,
    },
    {
      input: “abcde”,
      expected: “a”,
      description: “No palindromes longer than 1”,
    },
    {
      input: “aaa”,
      expected: “aaa”,
      description: “All same characters”,
    },
  ];</p>

<p>testCases.forEach((testCase, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Test Case ${index + 1}: ${testCase.description}</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Input: "${testCase.input}"</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Expected: "${testCase.expected}"\n</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre></td><td class="rouge-code"><pre>// Test Solution 1 (Expand Around Center)
const result1 = longestPalindrome(testCase.input);
console.log(
  `Solution 1 (Expand Around Center): "${result1}" ${
    result1 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 2 (Dynamic Programming)
const result2 = longestPalindromeDP(testCase.input);
console.log(
  `Solution 2 (Dynamic Programming): "${result2}" ${
    result2 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 3 (Manacher's Algorithm)
const result3 = longestPalindromeManacher(testCase.input);
console.log(
  `Solution 3 (Manacher's Algorithm): "${result3}" ${
    result3 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 4 (Brute Force)
const result4 = longestPalindromeBruteForce(testCase.input);
console.log(
  `Solution 4 (Brute Force): "${result4}" ${
    result4 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 5 (Class)
const result5 = longestPalindromeClass(testCase.input);
console.log(
  `Solution 5 (Class): "${result5}" ${
    result5 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 6 (Generator)
const result6 = longestPalindromeWithGenerator(testCase.input);
console.log(
  `Solution 6 (Generator): "${result6}" ${
    result6 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 7 (Functional)
const result7 = longestPalindromeFunctional(testCase.input);
console.log(
  `Solution 7 (Functional): "${result7}" ${
    result7 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 8 (Two Pointers)
const result8 = longestPalindromeTwoPointers(testCase.input);
console.log(
  `Solution 8 (Two Pointers): "${result8}" ${
    result8 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 9 (Recursive)
const result9 = longestPalindromeRecursive(testCase.input);
console.log(
  `Solution 9 (Recursive): "${result9}" ${
    result9 === testCase.expected ? "✅" : "❌"
  }`
);

// Test Solution 10 (Sliding Window)
const result10 = longestPalindromeSlidingWindow(testCase.input);
console.log(
  `Solution 10 (Sliding Window): "${result10}" ${
    result10 === testCase.expected ? "✅" : "❌"
  }`
);

console.log("\n---\n");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Performance comparison
function performanceComparison() {
  console.log(“=== Performance Comparison ===\n”);</p>

<p>const testCases = [
    { name: “Expand Around Center”, func: longestPalindrome },
    { name: “Dynamic Programming”, func: longestPalindromeDP },
    { name: “Manacher’s Algorithm”, func: longestPalindromeManacher },
    { name: “Brute Force”, func: longestPalindromeBruteForce },
    { name: “Class”, func: longestPalindromeClass },
    { name: “Generator”, func: longestPalindromeWithGenerator },
    { name: “Functional”, func: longestPalindromeFunctional },
    { name: “Two Pointers”, func: longestPalindromeTwoPointers },
    { name: “Recursive”, func: longestPalindromeRecursive },
    { name: “Sliding Window”, func: longestPalindromeSlidingWindow },
  ];</p>

<p>// Create test cases
  const smallCase = “babad”;
  const mediumCase = “racecar”;
  const largeCase = “a”.repeat(100) + “b” + “a”.repeat(100);</p>

<p>const cases = [
    { name: “Small”, case: smallCase },
    { name: “Medium”, case: mediumCase },
    { name: “Large”, case: largeCase },
  ];</p>

<p>cases.forEach(({ name, case: testCase }) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">${name} Case:</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>testCases.forEach(({ name: funcName, func }) =&gt; {
  const start = performance.now();
  const result = func(testCase);
  const end = performance.now();

  console.log(
    `  ${funcName}: ${(end - start).toFixed(2)}ms (length: ${
      result.length
    })`
  );
});

console.log("");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Palindrome analysis
function palindromeAnalysis() {
  console.log(“=== Palindrome Analysis ===\n”);</p>

<p>const testCases = [“babad”, “cbbd”, “racecar”, “aaa”, “abcde”, “abba”];</p>

<p>testCases.forEach((testCase, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Test Case ${index + 1}:</code>);
    console.log(<code class="language-plaintext highlighter-rouge">String: "${testCase}"</code>);
    const result = longestPalindrome(testCase);
    console.log(<code class="language-plaintext highlighter-rouge">Longest palindrome: "${result}" (length: ${result.length})</code>);
    console.log(“”);
  });
}</p>

<p>// Uncomment the following lines to run tests
// testLongestPalindrome();
// performanceComparison();
// palindromeAnalysis();</p>

<p>export {
  longestPalindrome,
  longestPalindromeDP,
  longestPalindromeManacher,
  longestPalindromeBruteForce,
  longestPalindromeClass,
  longestPalindromeWithGenerator,
  longestPalindromeFunctional,
  longestPalindromeTwoPointers,
  longestPalindromeRecursive,
  longestPalindromeSlidingWindow,
  PalindromeFinder,
  longestPalindromeGenerator,
  testLongestPalindrome,
  performanceComparison,
  palindromeAnalysis,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>