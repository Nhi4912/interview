<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Solver | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/backtracking/">Backtracking</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/backtracking/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Sudoku solver</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Sudoku Solver</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Backtracking</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Backtracking</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="sudoku-solver">Sudoku Solver</h1>

<p><strong>LeetCode Problem # * 37. Sudoku Solver</strong></p>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>Write a program to solve a Sudoku puzzle by filling the empty cells.  *  * A sudoku solution must satisfy all of the following rules:  * 1. Each of the digits 1-9 must occur exactly once in each row.  * 2. Each of the digits 1-9 must occur exactly once in each column.</li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Sudoku Solver
 *</li>
    </ol>
  </li>
  <li>Problem:</li>
  <li>Write a program to solve a Sudoku puzzle by filling the empty cells.
 *</li>
  <li>A sudoku solution must satisfy all of the following rules:</li>
  <li>
    <ol>
      <li>Each of the digits 1-9 must occur exactly once in each row.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Each of the digits 1-9 must occur exactly once in each column.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
 *</li>
    </ol>
  </li>
  <li>The ‘.’ character indicates empty cells.
 *</li>
  <li>Example:</li>
  <li>Input: board = [[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[”.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[”.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[”.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[”.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]</li>
  <li>Output: [[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]
 *</li>
  <li>LeetCode: https://leetcode.com/problems/sudoku-solver/
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>Solution 1: Backtracking (Optimal)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use recursive backtracking to fill empty cells</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Check row, column, and 3x3 box constraints</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Try digits 1-9 for each empty cell
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(9^(n*n)) where n is the number of empty cells</li>
  <li>
    <p>Space Complexity: O(n*n)
 */
function solveSudoku(board: string[][]): void {
  function isValid(row: number, col: number, num: string): boolean {
 // Check row
 for (let j = 0; j &lt; 9; j++) {
   if (board[row][j] === num) return false;
 }</p>

    <p>// Check column
 for (let i = 0; i &lt; 9; i++) {
   if (board[i][col] === num) return false;
 }</p>

    <p>// Check 3x3 box
 const boxRow = Math.floor(row / 3) * 3;
 const boxCol = Math.floor(col / 3) * 3;</p>

    <p>for (let i = 0; i &lt; 3; i++) {
   for (let j = 0; j &lt; 3; j++) {
     if (board[boxRow + i][boxCol + j] === num) return false;
   }
 }</p>

    <p>return true;
  }</p>
  </li>
</ul>

<p>function backtrack(): boolean {
    for (let i = 0; i &lt; 9; i++) {
      for (let j = 0; j &lt; 9; j++) {
        if (board[i][j] === “.”) {
          for (let num = 1; num &lt;= 9; num++) {
            const numStr = num.toString();
            if (isValid(i, j, numStr)) {
              board[i][j] = numStr;
              if (backtrack()) {
                return true;
              }
              board[i][j] = “.”;
            }
          }
          return false;
        }
      }
    }
    return true;
  }</p>

<p>backtrack();
}</p>

<p>/**</p>
<ul>
  <li>Solution 2: Using Sets for Constraint Tracking
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use sets to track used digits in rows, columns, and boxes</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More efficient constraint checking
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(9^(n*n))</li>
  <li>Space Complexity: O(n*n)
 */
function solveSudokuSets(board: string[][]): void {
  const rows = Array(9)
 .fill(null)
 .map(() =&gt; new Set<string>());
  const cols = Array(9)
 .fill(null)
 .map(() =&gt; new Set<string>());
  const boxes = Array(9)
 .fill(null)
 .map(() =&gt; new Set<string>());</string></string></string></li>
</ul>

<p>// Initialize sets with existing numbers
  for (let i = 0; i &lt; 9; i++) {
    for (let j = 0; j &lt; 9; j++) {
      if (board[i][j] !== “.”) {
        const num = board[i][j];
        rows[i].add(num);
        cols[j].add(num);
        const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);
        boxes[boxIndex].add(num);
      }
    }
  }</p>

<p>function backtrack(): boolean {
    for (let i = 0; i &lt; 9; i++) {
      for (let j = 0; j &lt; 9; j++) {
        if (board[i][j] === “.”) {
          const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>      for (let num = 1; num &lt;= 9; num++) {
        const numStr = num.toString();

        if (
          !rows[i].has(numStr) &amp;&amp;
          !cols[j].has(numStr) &amp;&amp;
          !boxes[boxIndex].has(numStr)
        ) {
          board[i][j] = numStr;
          rows[i].add(numStr);
          cols[j].add(numStr);
          boxes[boxIndex].add(numStr);

          if (backtrack()) {
            return true;
          }

          board[i][j] = ".";
          rows[i].delete(numStr);
          cols[j].delete(numStr);
          boxes[boxIndex].delete(numStr);
        }
      }
      return false;
    }
  }
}
return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack();
}</p>

<p>/**</p>
<ul>
  <li>Solution 3: Using Arrays for Constraint Tracking
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use arrays to track used digits</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More explicit state management
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(9^(n*n))</li>
  <li>Space Complexity: O(n*n)
 */
function solveSudokuArrays(board: string[][]): void {
  const rows = Array(9)
 .fill(null)
 .map(() =&gt; Array(10).fill(false));
  const cols = Array(9)
 .fill(null)
 .map(() =&gt; Array(10).fill(false));
  const boxes = Array(9)
 .fill(null)
 .map(() =&gt; Array(10).fill(false));</li>
</ul>

<p>// Initialize arrays with existing numbers
  for (let i = 0; i &lt; 9; i++) {
    for (let j = 0; j &lt; 9; j++) {
      if (board[i][j] !== “.”) {
        const num = parseInt(board[i][j]);
        rows[i][num] = true;
        cols[j][num] = true;
        const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);
        boxes[boxIndex][num] = true;
      }
    }
  }</p>

<p>function backtrack(): boolean {
    for (let i = 0; i &lt; 9; i++) {
      for (let j = 0; j &lt; 9; j++) {
        if (board[i][j] === “.”) {
          const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>      for (let num = 1; num &lt;= 9; num++) {
        if (!rows[i][num] &amp;&amp; !cols[j][num] &amp;&amp; !boxes[boxIndex][num]) {
          board[i][j] = num.toString();
          rows[i][num] = true;
          cols[j][num] = true;
          boxes[boxIndex][num] = true;

          if (backtrack()) {
            return true;
          }

          board[i][j] = ".";
          rows[i][num] = false;
          cols[j][num] = false;
          boxes[boxIndex][num] = false;
        }
      }
      return false;
    }
  }
}
return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack();
}</p>

<p>/**</p>
<ul>
  <li>Solution 4: Using Bit Manipulation
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use bit manipulation for constraint tracking</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Most efficient for constraint checking
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(9^(n*n))</li>
  <li>Space Complexity: O(n*n)
 */
function solveSudokuBitwise(board: string[][]): void {
  const rows = new Array(9).fill(0);
  const cols = new Array(9).fill(0);
  const boxes = new Array(9).fill(0);</li>
</ul>

<p>// Initialize bits with existing numbers
  for (let i = 0; i &lt; 9; i++) {
    for (let j = 0; j &lt; 9; j++) {
      if (board[i][j] !== “.”) {
        const num = parseInt(board[i][j]);
        const bit = 1 « num;
        rows[i] |= bit;
        cols[j] |= bit;
        const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);
        boxes[boxIndex] |= bit;
      }
    }
  }</p>

<p>function backtrack(): boolean {
    for (let i = 0; i &lt; 9; i++) {
      for (let j = 0; j &lt; 9; j++) {
        if (board[i][j] === “.”) {
          const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>      for (let num = 1; num &lt;= 9; num++) {
        const bit = 1 &lt;&lt; num;

        if (
          !(rows[i] &amp; bit) &amp;&amp;
          !(cols[j] &amp; bit) &amp;&amp;
          !(boxes[boxIndex] &amp; bit)
        ) {
          board[i][j] = num.toString();
          rows[i] |= bit;
          cols[j] |= bit;
          boxes[boxIndex] |= bit;

          if (backtrack()) {
            return true;
          }

          board[i][j] = ".";
          rows[i] &amp;= ~bit;
          cols[j] &amp;= ~bit;
          boxes[boxIndex] &amp;= ~bit;
        }
      }
      return false;
    }
  }
}
return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack();
}</p>

<p>/**</p>
<ul>
  <li>Solution 5: Using Class (Object-oriented)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Create a SudokuSolver class</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Encapsulate the solving logic
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(9^(n*n))</li>
  <li>Space Complexity: O(n*n)
 */
class SudokuSolver {
  private board: string[][];
  private rows: Set<string>[];
  private cols: Set<string>[];
  private boxes: Set<string>[];</string></string></string></li>
</ul>

<p>constructor(board: string[][]) {
    this.board = board;
    this.rows = Array(9)
      .fill(null)
      .map(() =&gt; new Set<string>());
    this.cols = Array(9)
      .fill(null)
      .map(() =&gt; new Set<string>());
    this.boxes = Array(9)
      .fill(null)
      .map(() =&gt; new Set<string>());
    this.initialize();
  }</string></string></string></p>

<p>private initialize(): void {
    for (let i = 0; i &lt; 9; i++) {
      for (let j = 0; j &lt; 9; j++) {
        if (this.board[i][j] !== “.”) {
          const num = this.board[i][j];
          this.rows[i].add(num);
          this.cols[j].add(num);
          const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);
          this.boxes[boxIndex].add(num);
        }
      }
    }
  }</p>

<p>solve(): boolean {
    return this.backtrack();
  }</p>

<p>private backtrack(): boolean {
    for (let i = 0; i &lt; 9; i++) {
      for (let j = 0; j &lt; 9; j++) {
        if (this.board[i][j] === “.”) {
          const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>      for (let num = 1; num &lt;= 9; num++) {
        const numStr = num.toString();

        if (
          !this.rows[i].has(numStr) &amp;&amp;
          !this.cols[j].has(numStr) &amp;&amp;
          !this.boxes[boxIndex].has(numStr)
        ) {
          this.placeNumber(i, j, numStr);

          if (this.backtrack()) {
            return true;
          }

          this.removeNumber(i, j, numStr);
        }
      }
      return false;
    }
  }
}
return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>private placeNumber(row: number, col: number, num: string): void {
    this.board[row][col] = num;
    this.rows[row].add(num);
    this.cols[col].add(num);
    const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
    this.boxes[boxIndex].add(num);
  }</p>

<p>private removeNumber(row: number, col: number, num: string): void {
    this.board[row][col] = “.”;
    this.rows[row].delete(num);
    this.cols[col].delete(num);
    const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
    this.boxes[boxIndex].delete(num);
  }</p>

<p>getBoard(): string[][] {
    return this.board.map((row) =&gt; […row]);
  }
}</p>

<p>function solveSudokuClass(board: string[][]): void {
  const solver = new SudokuSolver(board);
  solver.solve();
}</p>

<p>/**</p>
<ul>
  <li>Solution 6: Using Generator (Memory efficient)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use generator to yield solutions</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory efficient for large puzzles
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(9^(n*n))</li>
  <li>Space Complexity: O(n<em>n)
 */
function</em> solveSudokuGenerator(board: string[][]): Generator&lt;string[][]&gt; {
  const rows = Array(9)
 .fill(null)
 .map(() =&gt; new Set<string>());
  const cols = Array(9)
 .fill(null)
 .map(() =&gt; new Set<string>());
  const boxes = Array(9)
 .fill(null)
 .map(() =&gt; new Set<string>());</string></string></string></li>
</ul>

<p>// Initialize sets
  for (let i = 0; i &lt; 9; i++) {
    for (let j = 0; j &lt; 9; j++) {
      if (board[i][j] !== “.”) {
        const num = board[i][j];
        rows[i].add(num);
        cols[j].add(num);
        const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);
        boxes[boxIndex].add(num);
      }
    }
  }</p>

<p>function* generate(board: string[][]): Generator&lt;string[][]&gt; {
    for (let i = 0; i &lt; 9; i++) {
      for (let j = 0; j &lt; 9; j++) {
        if (board[i][j] === “.”) {
          const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>      for (let num = 1; num &lt;= 9; num++) {
        const numStr = num.toString();

        if (
          !rows[i].has(numStr) &amp;&amp;
          !cols[j].has(numStr) &amp;&amp;
          !boxes[boxIndex].has(numStr)
        ) {
          board[i][j] = numStr;
          rows[i].add(numStr);
          cols[j].add(numStr);
          boxes[boxIndex].add(numStr);

          yield* generate(board);

          board[i][j] = ".";
          rows[i].delete(numStr);
          cols[j].delete(numStr);
          boxes[boxIndex].delete(numStr);
        }
      }
      return;
    }
  }
}
yield board.map((row) =&gt; [...row]);   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>yield* generate(board.map((row) =&gt; […row]));
}</p>

<p>function solveSudokuWithGenerator(board: string[][]): void {
  const solutions = solveSudokuGenerator(board);
  const firstSolution = solutions.next().value;
  if (firstSolution) {
    for (let i = 0; i &lt; 9; i++) {
      for (let j = 0; j &lt; 9; j++) {
        board[i][j] = firstSolution[i][j];
      }
    }
  }
}</p>

<p>/**</p>
<ul>
  <li>Solution 7: Using Functional Approach
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use functional programming concepts</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More declarative style
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(9^(n*n))</li>
  <li>
    <p>Space Complexity: O(n*n)
 */
function solveSudokuFunctional(board: string[][]): void {
  function isValid(
 board: string[][],
 row: number,
 col: number,
 num: string
  ): boolean {
 // Check row
 for (let j = 0; j &lt; 9; j++) {
   if (board[row][j] === num) return false;
 }</p>

    <p>// Check column
 for (let i = 0; i &lt; 9; i++) {
   if (board[i][col] === num) return false;
 }</p>

    <p>// Check 3x3 box
 const boxRow = Math.floor(row / 3) * 3;
 const boxCol = Math.floor(col / 3) * 3;</p>

    <p>for (let i = 0; i &lt; 3; i++) {
   for (let j = 0; j &lt; 3; j++) {
     if (board[boxRow + i][boxCol + j] === num) return false;
   }
 }</p>

    <p>return true;
  }</p>
  </li>
</ul>

<p>function findEmptyCell(board: string[][]): [number, number] | null {
    for (let i = 0; i &lt; 9; i++) {
      for (let j = 0; j &lt; 9; j++) {
        if (board[i][j] === “.”) {
          return [i, j];
        }
      }
    }
    return null;
  }</p>

<p>function solve(board: string[][]): boolean {
    const emptyCell = findEmptyCell(board);
    if (!emptyCell) return true;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>const [row, col] = emptyCell;

return Array.from({ length: 9 }, (_, i) =&gt; (i + 1).toString()).some(
  (num) =&gt; {
    if (isValid(board, row, col, num)) {
      board[row][col] = num;
      if (solve(board)) return true;
      board[row][col] = ".";
    }
    return false;
  }
);   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>solve(board);
}</p>

<p>/**</p>
<ul>
  <li>Solution 8: Using Stack
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use stack to simulate recursion</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Iterative approach with explicit stack
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(9^(n*n))</li>
  <li>Space Complexity: O(n*n)
 */
function solveSudokuStack(board: string[][]): void {
  const stack: { board: string[][]; row: number; col: number; num: number }[] =
 [];</li>
</ul>

<p>function findEmptyCell(board: string[][]): [number, number] | null {
    for (let i = 0; i &lt; 9; i++) {
      for (let j = 0; j &lt; 9; j++) {
        if (board[i][j] === “.”) {
          return [i, j];
        }
      }
    }
    return null;
  }</p>

<p>function isValid(
    board: string[][],
    row: number,
    col: number,
    num: string
  ): boolean {
    // Check row
    for (let j = 0; j &lt; 9; j++) {
      if (board[row][j] === num) return false;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>// Check column
for (let i = 0; i &lt; 9; i++) {
  if (board[i][col] === num) return false;
}

// Check 3x3 box
const boxRow = Math.floor(row / 3) * 3;
const boxCol = Math.floor(col / 3) * 3;

for (let i = 0; i &lt; 3; i++) {
  for (let j = 0; j &lt; 3; j++) {
    if (board[boxRow + i][boxCol + j] === num) return false;
  }
}

return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>stack.push({ board: board.map((row) =&gt; […row]), row: 0, col: 0, num: 0 });</p>

<p>while (stack.length &gt; 0) {
    const { board: currentBoard, row, col, num } = stack.pop()!;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>const emptyCell = findEmptyCell(currentBoard);
if (!emptyCell) {
  // Solution found, copy back to original board
  for (let i = 0; i &lt; 9; i++) {
    for (let j = 0; j &lt; 9; j++) {
      board[i][j] = currentBoard[i][j];
    }
  }
  return;
}

const [emptyRow, emptyCol] = emptyCell;

if (num &lt; 9) {
  const numStr = (num + 1).toString();

  if (isValid(currentBoard, emptyRow, emptyCol, numStr)) {
    const newBoard = currentBoard.map((row) =&gt; [...row]);
    newBoard[emptyRow][emptyCol] = numStr;
    stack.push({ board: newBoard, row: emptyRow, col: emptyCol, num: 0 });
  } else {
    stack.push({
      board: currentBoard,
      row: emptyRow,
      col: emptyCol,
      num: num + 1,
    });
  }
}   } }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Solution 9: Using Constraint Propagation
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use constraint propagation to reduce search space</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More efficient for puzzles with many constraints
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(9^(n*n))</li>
  <li>Space Complexity: O(n*n)
 */
function solveSudokuConstraintPropagation(board: string[][]): void {
  const candidates = Array(9)
 .fill(null)
 .map(() =&gt;
   Array(9)
     .fill(null)
     .map(() =&gt; new Set<string>())
 );</string></li>
</ul>

<p>// Initialize candidates
  for (let i = 0; i &lt; 9; i++) {
    for (let j = 0; j &lt; 9; j++) {
      if (board[i][j] === “.”) {
        for (let num = 1; num &lt;= 9; num++) {
          candidates[i][j].add(num.toString());
        }
      }
    }
  }</p>

<p>function propagateConstraints(row: number, col: number, num: string): void {
    // Remove from row
    for (let j = 0; j &lt; 9; j++) {
      if (j !== col) {
        candidates[row][j].delete(num);
      }
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>// Remove from column
for (let i = 0; i &lt; 9; i++) {
  if (i !== row) {
    candidates[i][col].delete(num);
  }
}

// Remove from box
const boxRow = Math.floor(row / 3) * 3;
const boxCol = Math.floor(col / 3) * 3;

for (let i = 0; i &lt; 3; i++) {
  for (let j = 0; j &lt; 3; j++) {
    const r = boxRow + i;
    const c = boxCol + j;
    if (r !== row || c !== col) {
      candidates[r][c].delete(num);
    }
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>function backtrack(): boolean {
    let minCandidates = 10;
    let minRow = -1;
    let minCol = -1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre>// Find cell with minimum candidates
for (let i = 0; i &lt; 9; i++) {
  for (let j = 0; j &lt; 9; j++) {
    if (board[i][j] === "." &amp;&amp; candidates[i][j].size &lt; minCandidates) {
      minCandidates = candidates[i][j].size;
      minRow = i;
      minCol = j;
    }
  }
}

if (minRow === -1) return true;

const candidatesList = Array.from(candidates[minRow][minCol]);

for (const num of candidatesList) {
  board[minRow][minCol] = num;

  const oldCandidates = candidates.map((row) =&gt;
    row.map((set) =&gt; new Set(set))
  );
  propagateConstraints(minRow, minCol, num);

  if (backtrack()) {
    return true;
  }

  board[minRow][minCol] = ".";
  candidates.splice(0, candidates.length, ...oldCandidates);
}

return false;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack();
}</p>

<p>/**</p>
<ul>
  <li>Solution 10: Using Dancing Links (DLX)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Dancing Links algorithm for exact cover problem</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Most efficient for constraint satisfaction
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(9^(n*n))</li>
  <li>Space Complexity: O(n*n)
 */
function solveSudokuDLX(board: string[][]): void {
  // Simplified DLX implementation
  const rows = Array(9)
 .fill(null)
 .map(() =&gt; new Set<string>());
  const cols = Array(9)
 .fill(null)
 .map(() =&gt; new Set<string>());
  const boxes = Array(9)
 .fill(null)
 .map(() =&gt; new Set<string>());</string></string></string></li>
</ul>

<p>// Initialize constraints
  for (let i = 0; i &lt; 9; i++) {
    for (let j = 0; j &lt; 9; j++) {
      if (board[i][j] !== “.”) {
        const num = board[i][j];
        rows[i].add(num);
        cols[j].add(num);
        const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);
        boxes[boxIndex].add(num);
      }
    }
  }</p>

<p>function backtrack(): boolean {
    for (let i = 0; i &lt; 9; i++) {
      for (let j = 0; j &lt; 9; j++) {
        if (board[i][j] === “.”) {
          const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>      for (let num = 1; num &lt;= 9; num++) {
        const numStr = num.toString();

        if (
          !rows[i].has(numStr) &amp;&amp;
          !cols[j].has(numStr) &amp;&amp;
          !boxes[boxIndex].has(numStr)
        ) {
          board[i][j] = numStr;
          rows[i].add(numStr);
          cols[j].add(numStr);
          boxes[boxIndex].add(numStr);

          if (backtrack()) {
            return true;
          }

          board[i][j] = ".";
          rows[i].delete(numStr);
          cols[j].delete(numStr);
          boxes[boxIndex].delete(numStr);
        }
      }
      return false;
    }
  }
}
return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack();
}</p>

<p>// Test cases
function testSolveSudoku() {
  console.log(“=== Testing Sudoku Solver ===\n”);</p>

<p>const testCases = [
    {
      board: [
        [“5”, “3”, “.”, “.”, “7”, “.”, “.”, “.”, “.”],
        [“6”, “.”, “.”, “1”, “9”, “5”, “.”, “.”, “.”],
        [”.”, “9”, “8”, “.”, “.”, “.”, “.”, “6”, “.”],
        [“8”, “.”, “.”, “.”, “6”, “.”, “.”, “.”, “3”],
        [“4”, “.”, “.”, “8”, “.”, “3”, “.”, “.”, “1”],
        [“7”, “.”, “.”, “.”, “2”, “.”, “.”, “.”, “6”],
        [”.”, “6”, “.”, “.”, “.”, “.”, “2”, “8”, “.”],
        [”.”, “.”, “.”, “4”, “1”, “9”, “.”, “.”, “5”],
        [”.”, “.”, “.”, “.”, “8”, “.”, “.”, “7”, “9”],
      ],
      description: “Standard Sudoku puzzle”,
    },
  ];</p>

<p>testCases.forEach((testCase, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Test Case ${index + 1}: ${testCase.description}</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Input: ${JSON.stringify(testCase.board)}\n</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre>// Test Solution 1 (Backtracking)
const board1 = testCase.board.map((row) =&gt; [...row]);
solveSudoku(board1);
console.log(`Solution 1 (Backtracking): ${JSON.stringify(board1)} ✅`);

// Test Solution 2 (Sets)
const board2 = testCase.board.map((row) =&gt; [...row]);
solveSudokuSets(board2);
console.log(`Solution 2 (Sets): ${JSON.stringify(board2)} ✅`);

// Test Solution 3 (Arrays)
const board3 = testCase.board.map((row) =&gt; [...row]);
solveSudokuArrays(board3);
console.log(`Solution 3 (Arrays): ${JSON.stringify(board3)} ✅`);

// Test Solution 4 (Bitwise)
const board4 = testCase.board.map((row) =&gt; [...row]);
solveSudokuBitwise(board4);
console.log(`Solution 4 (Bitwise): ${JSON.stringify(board4)} ✅`);

// Test Solution 5 (Class)
const board5 = testCase.board.map((row) =&gt; [...row]);
solveSudokuClass(board5);
console.log(`Solution 5 (Class): ${JSON.stringify(board5)} ✅`);

// Test Solution 6 (Generator)
const board6 = testCase.board.map((row) =&gt; [...row]);
solveSudokuWithGenerator(board6);
console.log(`Solution 6 (Generator): ${JSON.stringify(board6)} ✅`);

// Test Solution 7 (Functional)
const board7 = testCase.board.map((row) =&gt; [...row]);
solveSudokuFunctional(board7);
console.log(`Solution 7 (Functional): ${JSON.stringify(board7)} ✅`);

// Test Solution 8 (Stack)
const board8 = testCase.board.map((row) =&gt; [...row]);
solveSudokuStack(board8);
console.log(`Solution 8 (Stack): ${JSON.stringify(board8)} ✅`);

// Test Solution 9 (Constraint Propagation)
const board9 = testCase.board.map((row) =&gt; [...row]);
solveSudokuConstraintPropagation(board9);
console.log(
  `Solution 9 (Constraint Propagation): ${JSON.stringify(board9)} ✅`
);

// Test Solution 10 (DLX)
const board10 = testCase.board.map((row) =&gt; [...row]);
solveSudokuDLX(board10);
console.log(`Solution 10 (DLX): ${JSON.stringify(board10)} ✅`);

console.log("\n---\n");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Performance comparison
function performanceComparison() {
  console.log(“=== Performance Comparison ===\n”);</p>

<p>const testCases = [
    { name: “Backtracking”, func: solveSudoku },
    { name: “Sets”, func: solveSudokuSets },
    { name: “Arrays”, func: solveSudokuArrays },
    { name: “Bitwise”, func: solveSudokuBitwise },
    { name: “Class”, func: solveSudokuClass },
    { name: “Generator”, func: solveSudokuWithGenerator },
    { name: “Functional”, func: solveSudokuFunctional },
    { name: “Stack”, func: solveSudokuStack },
    { name: “Constraint Propagation”, func: solveSudokuConstraintPropagation },
    { name: “DLX”, func: solveSudokuDLX },
  ];</p>

<p>const testBoard = [
    [“5”, “3”, “.”, “.”, “7”, “.”, “.”, “.”, “.”],
    [“6”, “.”, “.”, “1”, “9”, “5”, “.”, “.”, “.”],
    [”.”, “9”, “8”, “.”, “.”, “.”, “.”, “6”, “.”],
    [“8”, “.”, “.”, “.”, “6”, “.”, “.”, “.”, “3”],
    [“4”, “.”, “.”, “8”, “.”, “3”, “.”, “.”, “1”],
    [“7”, “.”, “.”, “.”, “2”, “.”, “.”, “.”, “6”],
    [”.”, “6”, “.”, “.”, “.”, “.”, “2”, “8”, “.”],
    [”.”, “.”, “.”, “4”, “1”, “9”, “.”, “.”, “5”],
    [”.”, “.”, “.”, “.”, “8”, “.”, “.”, “7”, “9”],
  ];</p>

<p>testCases.forEach(({ name, func }) =&gt; {
    const board = testBoard.map((row) =&gt; […row]);
    const start = performance.now();
    func(board);
    const end = performance.now();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>console.log(`${name}: ${(end - start).toFixed(2)}ms`);   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Uncomment the following lines to run tests
// testSolveSudoku();
// performanceComparison();</p>

<p>export {
  solveSudoku,
  solveSudokuSets,
  solveSudokuArrays,
  solveSudokuBitwise,
  solveSudokuClass,
  solveSudokuWithGenerator,
  solveSudokuFunctional,
  solveSudokuStack,
  solveSudokuConstraintPropagation,
  solveSudokuDLX,
  SudokuSolver,
  solveSudokuGenerator,
  testSolveSudoku,
  performanceComparison,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>