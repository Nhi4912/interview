<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Permutation | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/backtracking/">Backtracking</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/backtracking/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Permutation</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Permutation</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Backtracking</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Backtracking</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="permutation">Permutation</h1>

<p><strong>LeetCode Problem # * 46. Permutations</strong></p>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>Given an array nums of distinct integers, return all the possible permutations.  * You can return the answer in any order.  *  * Input: nums = [1,2,3]  * Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Permutations
 *</li>
    </ol>
  </li>
  <li>Problem:</li>
  <li>Given an array nums of distinct integers, return all the possible permutations.</li>
  <li>You can return the answer in any order.
 *</li>
  <li>Example:</li>
  <li>Input: nums = [1,2,3]</li>
  <li>Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 *</li>
  <li>Input: nums = [0,1]</li>
  <li>Output: [[0,1],[1,0]]
 *</li>
  <li>Input: nums = [1]</li>
  <li>Output: [[1]]
 *</li>
  <li>LeetCode: https://leetcode.com/problems/permutations/
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>Solution 1: Backtracking (Optimal)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use recursive backtracking to generate all permutations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use a visited array to track used elements
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n) - recursion stack
 */
function permute(nums: number[]): number[][] {
  const result: number[][] = [];
  const visited = new Array(nums.length).fill(false);</li>
</ul>

<p>function backtrack(current: number[]) {
    if (current.length === nums.length) {
      result.push([…current]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>for (let i = 0; i &lt; nums.length; i++) {
  if (!visited[i]) {
    visited[i] = true;
    current.push(nums[i]);
    backtrack(current);
    current.pop();
    visited[i] = false;
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack([]);
  return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 2: Swap-based Backtracking
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use swapping to generate permutations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Swap elements in place to avoid extra space
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(1) - excluding result space
 */
function permuteSwap(nums: number[]): number[][] {
  const result: number[][] = [];</li>
</ul>

<p>function backtrack(start: number) {
    if (start === nums.length) {
      result.push([…nums]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>for (let i = start; i &lt; nums.length; i++) {
  [nums[start], nums[i]] = [nums[i], nums[start]];
  backtrack(start + 1);
  [nums[start], nums[i]] = [nums[i], nums[start]];
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack(0);
  return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 3: Iterative Approach
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Build permutations incrementally</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Insert each element at all possible positions
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n!)
 */
function permuteIterative(nums: number[]): number[][] {
  if (nums.length === 0) return [];
  if (nums.length === 1) return [nums];</li>
</ul>

<p>let result: number[][] = [[nums[0]]];</p>

<p>for (let i = 1; i &lt; nums.length; i++) {
    const newResult: number[][] = [];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>for (const perm of result) {
  for (let j = 0; j &lt;= perm.length; j++) {
    const newPerm = [...perm.slice(0, j), nums[i], ...perm.slice(j)];
    newResult.push(newPerm);
  }
}

result = newResult;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 4: Using Array Methods
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use array methods to generate permutations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More functional programming style
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n!)
 */
function permuteArray(nums: number[]): number[][] {
  if (nums.length === 0) return [];
  if (nums.length === 1) return [nums];</li>
</ul>

<p>const result: number[][] = [];</p>

<p>for (let i = 0; i &lt; nums.length; i++) {
    const current = nums[i];
    const remaining = […nums.slice(0, i), …nums.slice(i + 1)];
    const perms = permuteArray(remaining);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>for (const perm of perms) {
  result.push([current, ...perm]);
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 5: Using Set
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Set to track used elements</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More explicit tracking of used elements
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n)
 */
function permuteSet(nums: number[]): number[][] {
  const result: number[][] = [];</li>
</ul>

<p>function backtrack(current: number[], used: Set<number>) {
    if (current.length === nums.length) {
      result.push([...current]);
      return;
    }</number></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>for (const num of nums) {
  if (!used.has(num)) {
    used.add(num);
    current.push(num);
    backtrack(current, used);
    current.pop();
    used.delete(num);
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack([], new Set());
  return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 6: Using Map
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Map to track element frequencies</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle duplicates if needed
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n)
 */
function permuteMap(nums: number[]): number[][] {
  const result: number[][] = [];
  const freqMap = new Map&lt;number, number&gt;();</li>
</ul>

<p>// Count frequencies
  for (const num of nums) {
    freqMap.set(num, (freqMap.get(num) || 0) + 1);
  }</p>

<p>function backtrack(current: number[]) {
    if (current.length === nums.length) {
      result.push([…current]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>for (const [num, count] of freqMap) {
  if (count &gt; 0) {
    freqMap.set(num, count - 1);
    current.push(num);
    backtrack(current);
    current.pop();
    freqMap.set(num, count);
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack([]);
  return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 7: Using Generator (Memory efficient)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use generator to yield permutations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory efficient for large arrays
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>
    <p>Space Complexity: O(n)
 <em>/
function</em> permuteGenerator(nums: number[]): Generator&lt;number[]&gt; {
  function* generatePermutations(
 current: number[],
 used: Set<number>
  ): Generator&lt;number[]&gt; {
 if (current.length === nums.length) {
   yield [...current];
   return;
 }</number></p>

    <p>for (const num of nums) {
   if (!used.has(num)) {
     used.add(num);
     current.push(num);
     yield* generatePermutations(current, used);
     current.pop();
     used.delete(num);
   }
 }
  }</p>
  </li>
</ul>

<p>yield* generatePermutations([], new Set());
}</p>

<p>function permuteWithGenerator(nums: number[]): number[][] {
  return Array.from(permuteGenerator(nums));
}</p>

<p>/**</p>
<ul>
  <li>Solution 8: Using Class (Object-oriented)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Create a PermutationGenerator class</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Encapsulate the generation logic
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n!)
 */
class PermutationGenerator {
  private nums: number[];
  private result: number[][];
  private visited: boolean[];</li>
</ul>

<p>constructor(nums: number[]) {
    this.nums = nums;
    this.result = [];
    this.visited = new Array(nums.length).fill(false);
  }</p>

<p>generatePermutations(): number[][] {
    this.result = [];
    this.backtrack([]);
    return this.result;
  }</p>

<p>private backtrack(current: number[]): void {
    if (current.length === this.nums.length) {
      this.result.push([…current]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>for (let i = 0; i &lt; this.nums.length; i++) {
  if (!this.visited[i]) {
    this.visited[i] = true;
    current.push(this.nums[i]);
    this.backtrack(current);
    current.pop();
    this.visited[i] = false;
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>getPermutations(): number[][] {
    return […this.result];
  }
}</p>

<p>function permuteClass(nums: number[]): number[][] {
  const generator = new PermutationGenerator(nums);
  return generator.generatePermutations();
}</p>

<p>/**</p>
<ul>
  <li>Solution 9: Using Functional Approach
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use functional programming concepts</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More declarative style
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n!)
 */
function permuteFunctional(nums: number[]): number[][] {
  if (nums.length === 0) return [];
  if (nums.length === 1) return [nums];</li>
</ul>

<p>return nums.flatMap((num, index) =&gt; {
    const remaining = […nums.slice(0, index), …nums.slice(index + 1)];
    return permuteFunctional(remaining).map((perm) =&gt; [num, …perm]);
  });
}</p>

<p>/**</p>
<ul>
  <li>Solution 10: Using Stack
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use stack to simulate recursion</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Iterative approach with explicit stack
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n!)
 */
function permuteStack(nums: number[]): number[][] {
  const result: number[][] = [];
  const stack: { current: number[]; used: Set<number> }[] = [
 { current: [], used: new Set() },
  ];</number></li>
</ul>

<p>while (stack.length &gt; 0) {
    const { current, used } = stack.pop()!;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>if (current.length === nums.length) {
  result.push([...current]);
  continue;
}

for (let i = nums.length - 1; i &gt;= 0; i--) {
  const num = nums[i];
  if (!used.has(num)) {
    const newUsed = new Set(used);
    newUsed.add(num);
    stack.push({ current: [...current, num], used: newUsed });
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 11: Using Heap’s Algorithm
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Heap’s algorithm for generating permutations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Non-recursive algorithm
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(1) - excluding result space
 */
function permuteHeap(nums: number[]): number[][] {
  const result: number[][] = [];
  const arr = […nums];
  const n = arr.length;</li>
</ul>

<p>// Generate all permutations using Heap’s algorithm
  function generate(k: number) {
    if (k === 1) {
      result.push([…arr]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>generate(k - 1);

for (let i = 0; i &lt; k - 1; i++) {
  if (k % 2 === 0) {
    [arr[i], arr[k - 1]] = [arr[k - 1], arr[i]];
  } else {
    [arr[0], arr[k - 1]] = [arr[k - 1], arr[0]];
  }
  generate(k - 1);
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>generate(n);
  return result;
}</p>

<p>// Test cases
function testPermute() {
  console.log(“=== Testing Permutations ===\n”);</p>

<p>const testCases = [
    {
      input: [1, 2, 3],
      expected: [
        [1, 2, 3],
        [1, 3, 2],
        [2, 1, 3],
        [2, 3, 1],
        [3, 1, 2],
        [3, 2, 1],
      ],
      description: “Three elements”,
    },
    {
      input: [0, 1],
      expected: [
        [0, 1],
        [1, 0],
      ],
      description: “Two elements”,
    },
    {
      input: [1],
      expected: [[1]],
      description: “Single element”,
    },
    {
      input: [],
      expected: [],
      description: “Empty array”,
    },
    {
      input: [1, 2, 3, 4],
      expected: [], // Will be calculated
      description: “Four elements”,
    },
  ];</p>

<p>testCases.forEach((testCase, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Test Case ${index + 1}: ${testCase.description}</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Input: [${testCase.input.join(", ")}]</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
</pre></td><td class="rouge-code"><pre>if (testCase.expected.length === 0) {
  // Calculate expected for 4 elements
  testCase.expected = permute([...testCase.input]);
}

console.log(`Expected: ${JSON.stringify(testCase.expected)}\n`);

// Test Solution 1 (Backtracking)
const result1 = permute([...testCase.input]);
console.log(
  `Solution 1 (Backtracking): ${JSON.stringify(result1)} ${
    JSON.stringify(result1.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 2 (Swap-based)
const result2 = permuteSwap([...testCase.input]);
console.log(
  `Solution 2 (Swap-based): ${JSON.stringify(result2)} ${
    JSON.stringify(result2.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 3 (Iterative)
const result3 = permuteIterative([...testCase.input]);
console.log(
  `Solution 3 (Iterative): ${JSON.stringify(result3)} ${
    JSON.stringify(result3.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 4 (Array Methods)
const result4 = permuteArray([...testCase.input]);
console.log(
  `Solution 4 (Array Methods): ${JSON.stringify(result4)} ${
    JSON.stringify(result4.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 5 (Set)
const result5 = permuteSet([...testCase.input]);
console.log(
  `Solution 5 (Set): ${JSON.stringify(result5)} ${
    JSON.stringify(result5.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 6 (Map)
const result6 = permuteMap([...testCase.input]);
console.log(
  `Solution 6 (Map): ${JSON.stringify(result6)} ${
    JSON.stringify(result6.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 7 (Generator)
const result7 = permuteWithGenerator([...testCase.input]);
console.log(
  `Solution 7 (Generator): ${JSON.stringify(result7)} ${
    JSON.stringify(result7.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 8 (Class)
const result8 = permuteClass([...testCase.input]);
console.log(
  `Solution 8 (Class): ${JSON.stringify(result8)} ${
    JSON.stringify(result8.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 9 (Functional)
const result9 = permuteFunctional([...testCase.input]);
console.log(
  `Solution 9 (Functional): ${JSON.stringify(result9)} ${
    JSON.stringify(result9.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 10 (Stack)
const result10 = permuteStack([...testCase.input]);
console.log(
  `Solution 10 (Stack): ${JSON.stringify(result10)} ${
    JSON.stringify(result10.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 11 (Heap's Algorithm)
const result11 = permuteHeap([...testCase.input]);
console.log(
  `Solution 11 (Heap's Algorithm): ${JSON.stringify(result11)} ${
    JSON.stringify(result11.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

console.log("\n---\n");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Performance comparison
function performanceComparison() {
  console.log(“=== Performance Comparison ===\n”);</p>

<p>const testCases = [
    { name: “Backtracking”, func: permute },
    { name: “Swap-based”, func: permuteSwap },
    { name: “Iterative”, func: permuteIterative },
    { name: “Array Methods”, func: permuteArray },
    { name: “Set”, func: permuteSet },
    { name: “Map”, func: permuteMap },
    { name: “Generator”, func: permuteWithGenerator },
    { name: “Class”, func: permuteClass },
    { name: “Functional”, func: permuteFunctional },
    { name: “Stack”, func: permuteStack },
    { name: “Heap’s Algorithm”, func: permuteHeap },
  ];</p>

<p>// Create test cases
  const smallCase = [1, 2, 3];
  const mediumCase = [1, 2, 3, 4];
  const largeCase = [1, 2, 3, 4, 5];</p>

<p>const cases = [
    { name: “Small”, case: smallCase },
    { name: “Medium”, case: mediumCase },
    { name: “Large”, case: largeCase },
  ];</p>

<p>cases.forEach(({ name, case: testCase }) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">${name} Case:</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>testCases.forEach(({ name: funcName, func }) =&gt; {
  const start = performance.now();
  const result = func([...testCase]);
  const end = performance.now();

  console.log(
    `  ${funcName}: ${(end - start).toFixed(2)}ms (${
      result.length
    } permutations)`
  );
});

console.log("");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Permutation analysis
function permutationAnalysis() {
  console.log(“=== Permutation Analysis ===\n”);</p>

<p>const testArrays = [[], [1], [1, 2], [1, 2, 3], [1, 2, 3, 4]];</p>

<p>testArrays.forEach((arr, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Array ${index + 1}: [${arr.join(", ")}]</code>);
    const result = permute(arr);
    console.log(
      <code class="language-plaintext highlighter-rouge">Permutations: ${result.length} (${arr.length}! = ${factorial(
        arr.length
      )})</code>
    );
    console.log(<code class="language-plaintext highlighter-rouge">Result: ${JSON.stringify(result)}</code>);
    console.log(“”);
  });
}</p>

<p>function factorial(n: number): number {
  if (n &lt;= 1) return 1;
  return n * factorial(n - 1);
}</p>

<p>// Uncomment the following lines to run tests
// testPermute();
// performanceComparison();
// permutationAnalysis();</p>

<p>export {
  permute,
  permuteSwap,
  permuteIterative,
  permuteArray,
  permuteSet,
  permuteMap,
  permuteWithGenerator,
  permuteClass,
  permuteFunctional,
  permuteStack,
  permuteHeap,
  PermutationGenerator,
  permuteGenerator,
  testPermute,
  performanceComparison,
  permutationAnalysis,
  factorial,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>