<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combination Sum | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/backtracking/">Backtracking</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/backtracking/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Combination sum</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Combination Sum</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Backtracking</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Backtracking</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                                    <span class="tag">Binary Search</span>
                                
                                    <span class="tag">Sorting</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="combination-sum">Combination Sum</h1>

<p><strong>LeetCode Problem # * 39. Combination Sum</strong></p>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>Given an array of distinct integers candidates and a target integer target,  * return a list of all unique combinations of candidates where the chosen numbers  * sum to target. You may return the combinations in any order.  *  * The same number may be chosen from candidates an unlimited number of times.</li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Combination Sum
 *</li>
    </ol>
  </li>
  <li>Problem:</li>
  <li>Given an array of distinct integers candidates and a target integer target,</li>
  <li>return a list of all unique combinations of candidates where the chosen numbers</li>
  <li>sum to target. You may return the combinations in any order.
 *</li>
  <li>The same number may be chosen from candidates an unlimited number of times.</li>
  <li>Two combinations are unique if the frequency of at least one of the chosen</li>
  <li>numbers is different.
 *</li>
  <li>Example:</li>
  <li>Input: candidates = [2,3,6,7], target = 7</li>
  <li>Output: [[2,2,3],[7]]
 *</li>
  <li>Input: candidates = [2,3,5], target = 8</li>
  <li>Output: [[2,2,2,2],[2,3,3],[3,5]]
 *</li>
  <li>Input: candidates = [2], target = 1</li>
  <li>Output: []
 *</li>
  <li>LeetCode: https://leetcode.com/problems/combination-sum/
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>Solution 1: Backtracking (Optimal)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use recursive backtracking to find all combinations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Sort candidates first to avoid duplicates</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use start index to avoid generating duplicate combinations
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(2^target) - exponential</li>
  <li>Space Complexity: O(target) - recursion stack
 */
function combinationSum(candidates: number[], target: number): number[][] {
  const result: number[][] = [];</li>
</ul>

<p>// Sort candidates to avoid duplicates
  candidates.sort((a, b) =&gt; a - b);</p>

<p>function backtrack(start: number, current: number[], sum: number) {
    if (sum === target) {
      result.push([…current]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>if (sum &gt; target) {
  return;
}

for (let i = start; i &lt; candidates.length; i++) {
  current.push(candidates[i]);
  backtrack(i, current, sum + candidates[i]);
  current.pop();
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack(0, [], 0);
  return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 2: Recursive with Early Pruning
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Add early pruning when sum exceeds target</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More efficient pruning strategy
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(2^target)</li>
  <li>Space Complexity: O(target)
 */
function combinationSumPruning(
  candidates: number[],
  target: number
): number[][] {
  const result: number[][] = [];
  candidates.sort((a, b) =&gt; a - b);</li>
</ul>

<p>function backtrack(start: number, current: number[], sum: number) {
    if (sum === target) {
      result.push([…current]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>for (let i = start; i &lt; candidates.length; i++) {
  // Early pruning
  if (sum + candidates[i] &gt; target) {
    break;
  }

  current.push(candidates[i]);
  backtrack(i, current, sum + candidates[i]);
  current.pop();
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack(0, [], 0);
  return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 3: Using Set for Uniqueness
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Set to ensure uniqueness</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Convert combinations to strings for comparison
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(2^target)</li>
  <li>Space Complexity: O(2^target)
 */
function combinationSumSet(candidates: number[], target: number): number[][] {
  const result = new Set<string>();
  candidates.sort((a, b) =&gt; a - b);</string></li>
</ul>

<p>function backtrack(start: number, current: number[], sum: number) {
    if (sum === target) {
      result.add(current.join(“,”));
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>if (sum &gt; target) {
  return;
}

for (let i = start; i &lt; candidates.length; i++) {
  current.push(candidates[i]);
  backtrack(i, current, sum + candidates[i]);
  current.pop();
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack(0, [], 0);
  return Array.from(result).map((s) =&gt; s.split(“,”).map(Number));
}</p>

<p>/**</p>
<ul>
  <li>Solution 4: Using Map for Frequency Tracking
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Map to track element frequencies</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More explicit frequency management
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(2^target)</li>
  <li>Space Complexity: O(2^target)
 */
function combinationSumMap(candidates: number[], target: number): number[][] {
  const result: number[][] = [];
  const freqMap = new Map&lt;number, number&gt;();
  candidates.sort((a, b) =&gt; a - b);</li>
</ul>

<p>function backtrack(start: number, current: number[], sum: number) {
    if (sum === target) {
      result.push([…current]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>if (sum &gt; target) {
  return;
}

for (let i = start; i &lt; candidates.length; i++) {
  const num = candidates[i];
  freqMap.set(num, (freqMap.get(num) || 0) + 1);
  current.push(num);
  backtrack(i, current, sum + num);
  current.pop();
  freqMap.set(num, freqMap.get(num)! - 1);
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack(0, [], 0);
  return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 5: Using Generator (Memory efficient)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use generator to yield combinations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory efficient for large targets
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(2^target)</li>
  <li>Space Complexity: O(target)
 <em>/
function</em> combinationSumGenerator(
  candidates: number[],
  target: number
): Generator&lt;number[]&gt; {
  candidates.sort((a, b) =&gt; a - b);</li>
</ul>

<p>function* generate(
    start: number,
    current: number[],
    sum: number
  ): Generator&lt;number[]&gt; {
    if (sum === target) {
      yield […current];
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>if (sum &gt; target) {
  return;
}

for (let i = start; i &lt; candidates.length; i++) {
  current.push(candidates[i]);
  yield* generate(i, current, sum + candidates[i]);
  current.pop();
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>yield* generate(0, [], 0);
}</p>

<p>function combinationSumWithGenerator(
  candidates: number[],
  target: number
): number[][] {
  return Array.from(combinationSumGenerator(candidates, target));
}</p>

<p>/**</p>
<ul>
  <li>Solution 6: Using Class (Object-oriented)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Create a CombinationSumGenerator class</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Encapsulate the generation logic
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(2^target)</li>
  <li>Space Complexity: O(2^target)
 */
class CombinationSumGenerator {
  private candidates: number[];
  private target: number;
  private result: number[][];</li>
</ul>

<p>constructor(candidates: number[], target: number) {
    this.candidates = […candidates].sort((a, b) =&gt; a - b);
    this.target = target;
    this.result = [];
  }</p>

<p>generate(): number[][] {
    this.result = [];
    this.backtrack(0, [], 0);
    return this.result;
  }</p>

<p>private backtrack(start: number, current: number[], sum: number): void {
    if (sum === this.target) {
      this.result.push([…current]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>if (sum &gt; this.target) {
  return;
}

for (let i = start; i &lt; this.candidates.length; i++) {
  current.push(this.candidates[i]);
  this.backtrack(i, current, sum + this.candidates[i]);
  current.pop();
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>getResult(): number[][] {
    return […this.result];
  }
}</p>

<p>function combinationSumClass(candidates: number[], target: number): number[][] {
  const generator = new CombinationSumGenerator(candidates, target);
  return generator.generate();
}</p>

<p>/**</p>
<ul>
  <li>Solution 7: Using Functional Approach
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use functional programming concepts</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More declarative style
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(2^target)</li>
  <li>Space Complexity: O(2^target)
 */
function combinationSumFunctional(
  candidates: number[],
  target: number
): number[][] {
  candidates.sort((a, b) =&gt; a - b);</li>
</ul>

<p>function generate(start: number, current: number[], sum: number): number[][] {
    if (sum === target) {
      return [current];
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>if (sum &gt; target) {
  return [];
}

return candidates.slice(start).flatMap((candidate, index) =&gt; {
  return generate(start + index, [...current, candidate], sum + candidate);
});   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return generate(0, [], 0);
}</p>

<p>/**</p>
<ul>
  <li>Solution 8: Using Stack
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use stack to simulate recursion</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Iterative approach with explicit stack
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(2^target)</li>
  <li>Space Complexity: O(2^target)
 */
function combinationSumStack(candidates: number[], target: number): number[][] {
  const result: number[][] = [];
  const stack: { start: number; current: number[]; sum: number }[] = [
 { start: 0, current: [], sum: 0 },
  ];</li>
</ul>

<p>candidates.sort((a, b) =&gt; a - b);</p>

<p>while (stack.length &gt; 0) {
    const { start, current, sum } = stack.pop()!;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>if (sum === target) {
  result.push([...current]);
  continue;
}

if (sum &gt; target) {
  continue;
}

for (let i = candidates.length - 1; i &gt;= start; i--) {
  stack.push({
    start: i,
    current: [...current, candidates[i]],
    sum: sum + candidates[i],
  });
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 9: Using Dynamic Programming
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use DP to build solutions incrementally</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Cache intermediate results
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(target * candidates.length)</li>
  <li>Space Complexity: O(target * candidates.length)
 */
function combinationSumDP(candidates: number[], target: number): number[][] {
  const dp: number[][][] = Array(target + 1)
 .fill(null)
 .map(() =&gt; []);
  dp[0] = [[]];</li>
</ul>

<p>candidates.sort((a, b) =&gt; a - b);</p>

<p>for (let i = 1; i &lt;= target; i++) {
    for (const candidate of candidates) {
      if (candidate &lt;= i) {
        for (const combination of dp[i - candidate]) {
          dp[i].push([…combination, candidate]);
        }
      }
    }
  }</p>

<p>return dp[target];
}</p>

<p>/**</p>
<ul>
  <li>Solution 10: Using Memoization
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use memoization to cache results</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Avoid recalculating same subproblems
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(target * candidates.length)</li>
  <li>Space Complexity: O(target * candidates.length)
 */
function combinationSumMemo(candidates: number[], target: number): number[][] {
  const memo = new Map&lt;string, number[][]&gt;();
  candidates.sort((a, b) =&gt; a - b);</li>
</ul>

<p>function backtrack(
    start: number,
    current: number[],
    sum: number
  ): number[][] {
    const key = <code class="language-plaintext highlighter-rouge">${start},${sum}</code>;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>if (memo.has(key)) {
  return memo.get(key)!.map((comb) =&gt; [...current, ...comb]);
}

if (sum === target) {
  return [current];
}

if (sum &gt; target) {
  return [];
}

const result: number[][] = [];

for (let i = start; i &lt; candidates.length; i++) {
  const combinations = backtrack(
    i,
    [...current, candidates[i]],
    sum + candidates[i]
  );
  result.push(...combinations);
}

memo.set(
  key,
  result.map((comb) =&gt; comb.slice(current.length))
);
return result;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return backtrack(0, [], 0);
}</p>

<p>/**</p>
<ul>
  <li>Solution 11: Using Binary Search Optimization
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use binary search to find valid candidates</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimize candidate selection
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(2^target * log(candidates.length))</li>
  <li>Space Complexity: O(target)
 */
function combinationSumBinarySearch(
  candidates: number[],
  target: number
): number[][] {
  const result: number[][] = [];
  candidates.sort((a, b) =&gt; a - b);</li>
</ul>

<p>function binarySearch(arr: number[], target: number): number {
    let left = 0;
    let right = arr.length - 1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>while (left &lt;= right) {
  const mid = Math.floor((left + right) / 2);
  if (arr[mid] === target) return mid;
  if (arr[mid] &lt; target) left = mid + 1;
  else right = mid - 1;
}

return -1;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>function backtrack(start: number, current: number[], sum: number) {
    if (sum === target) {
      result.push([…current]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>if (sum &gt; target) {
  return;
}

for (let i = start; i &lt; candidates.length; i++) {
  if (sum + candidates[i] &gt; target) {
    break;
  }

  current.push(candidates[i]);
  backtrack(i, current, sum + candidates[i]);
  current.pop();
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack(0, [], 0);
  return result;
}</p>

<p>// Test cases
function testCombinationSum() {
  console.log(“=== Testing Combination Sum ===\n”);</p>

<p>const testCases = [
    {
      candidates: [2, 3, 6, 7],
      target: 7,
      expected: [[2, 2, 3], [7]],
      description: “Basic case”,
    },
    {
      candidates: [2, 3, 5],
      target: 8,
      expected: [
        [2, 2, 2, 2],
        [2, 3, 3],
        [3, 5],
      ],
      description: “Multiple combinations”,
    },
    {
      candidates: [2],
      target: 1,
      expected: [],
      description: “No solution”,
    },
    {
      candidates: [1],
      target: 1,
      expected: [[1]],
      description: “Single element”,
    },
    {
      candidates: [1],
      target: 2,
      expected: [[1, 1]],
      description: “Repeated element”,
    },
  ];</p>

<p>testCases.forEach((testCase, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Test Case ${index + 1}: ${testCase.description}</code>);
    console.log(
      <code class="language-plaintext highlighter-rouge">Input: candidates = [${testCase.candidates.join(", ")}], target = ${
        testCase.target
      }</code>
    );
    console.log(<code class="language-plaintext highlighter-rouge">Expected: ${JSON.stringify(testCase.expected)}\n</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
</pre></td><td class="rouge-code"><pre>// Test Solution 1 (Backtracking)
const result1 = combinationSum([...testCase.candidates], testCase.target);
console.log(
  `Solution 1 (Backtracking): ${JSON.stringify(result1)} ${
    JSON.stringify(result1.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 2 (Pruning)
const result2 = combinationSumPruning(
  [...testCase.candidates],
  testCase.target
);
console.log(
  `Solution 2 (Pruning): ${JSON.stringify(result2)} ${
    JSON.stringify(result2.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 3 (Set)
const result3 = combinationSumSet(
  [...testCase.candidates],
  testCase.target
);
console.log(
  `Solution 3 (Set): ${JSON.stringify(result3)} ${
    JSON.stringify(result3.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 4 (Map)
const result4 = combinationSumMap(
  [...testCase.candidates],
  testCase.target
);
console.log(
  `Solution 4 (Map): ${JSON.stringify(result4)} ${
    JSON.stringify(result4.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 5 (Generator)
const result5 = combinationSumWithGenerator(
  [...testCase.candidates],
  testCase.target
);
console.log(
  `Solution 5 (Generator): ${JSON.stringify(result5)} ${
    JSON.stringify(result5.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 6 (Class)
const result6 = combinationSumClass(
  [...testCase.candidates],
  testCase.target
);
console.log(
  `Solution 6 (Class): ${JSON.stringify(result6)} ${
    JSON.stringify(result6.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 7 (Functional)
const result7 = combinationSumFunctional(
  [...testCase.candidates],
  testCase.target
);
console.log(
  `Solution 7 (Functional): ${JSON.stringify(result7)} ${
    JSON.stringify(result7.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 8 (Stack)
const result8 = combinationSumStack(
  [...testCase.candidates],
  testCase.target
);
console.log(
  `Solution 8 (Stack): ${JSON.stringify(result8)} ${
    JSON.stringify(result8.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 9 (Dynamic Programming)
const result9 = combinationSumDP([...testCase.candidates], testCase.target);
console.log(
  `Solution 9 (Dynamic Programming): ${JSON.stringify(result9)} ${
    JSON.stringify(result9.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 10 (Memoization)
const result10 = combinationSumMemo(
  [...testCase.candidates],
  testCase.target
);
console.log(
  `Solution 10 (Memoization): ${JSON.stringify(result10)} ${
    JSON.stringify(result10.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 11 (Binary Search)
const result11 = combinationSumBinarySearch(
  [...testCase.candidates],
  testCase.target
);
console.log(
  `Solution 11 (Binary Search): ${JSON.stringify(result11)} ${
    JSON.stringify(result11.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

console.log("\n---\n");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Performance comparison
function performanceComparison() {
  console.log(“=== Performance Comparison ===\n”);</p>

<p>const testCases = [
    { name: “Backtracking”, func: combinationSum },
    { name: “Pruning”, func: combinationSumPruning },
    { name: “Set”, func: combinationSumSet },
    { name: “Map”, func: combinationSumMap },
    { name: “Generator”, func: combinationSumWithGenerator },
    { name: “Class”, func: combinationSumClass },
    { name: “Functional”, func: combinationSumFunctional },
    { name: “Stack”, func: combinationSumStack },
    { name: “Dynamic Programming”, func: combinationSumDP },
    { name: “Memoization”, func: combinationSumMemo },
    { name: “Binary Search”, func: combinationSumBinarySearch },
  ];</p>

<p>// Create test cases
  const smallCase = { candidates: [2, 3, 6, 7], target: 7 };
  const mediumCase = { candidates: [2, 3, 5], target: 8 };
  const largeCase = { candidates: [2, 3, 5, 7], target: 10 };</p>

<p>const cases = [
    { name: “Small”, case: smallCase },
    { name: “Medium”, case: mediumCase },
    { name: “Large”, case: largeCase },
  ];</p>

<p>cases.forEach(({ name, case: testCase }) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">${name} Case:</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>testCases.forEach(({ name: funcName, func }) =&gt; {
  const start = performance.now();
  const result = func([...testCase.candidates], testCase.target);
  const end = performance.now();

  console.log(
    `  ${funcName}: ${(end - start).toFixed(2)}ms (${
      result.length
    } combinations)`
  );
});

console.log("");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Combination analysis
function combinationAnalysis() {
  console.log(“=== Combination Analysis ===\n”);</p>

<p>const testCases = [
    { candidates: [2, 3, 6, 7], target: 7 },
    { candidates: [2, 3, 5], target: 8 },
    { candidates: [1, 2, 3], target: 4 },
    { candidates: [2, 4, 6], target: 6 },
  ];</p>

<p>testCases.forEach((testCase, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Test Case ${index + 1}:</code>);
    console.log(
      <code class="language-plaintext highlighter-rouge">Candidates: [${testCase.candidates.join(", ")}], Target: ${
        testCase.target
      }</code>
    );
    const result = combinationSum([…testCase.candidates], testCase.target);
    console.log(<code class="language-plaintext highlighter-rouge">Combinations: ${result.length}</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Result: ${JSON.stringify(result)}</code>);
    console.log(“”);
  });
}</p>

<p>// Uncomment the following lines to run tests
// testCombinationSum();
// performanceComparison();
// combinationAnalysis();</p>

<p>export {
  combinationSum,
  combinationSumPruning,
  combinationSumSet,
  combinationSumMap,
  combinationSumWithGenerator,
  combinationSumClass,
  combinationSumFunctional,
  combinationSumStack,
  combinationSumDP,
  combinationSumMemo,
  combinationSumBinarySearch,
  CombinationSumGenerator,
  combinationSumGenerator,
  testCombinationSum,
  performanceComparison,
  combinationAnalysis,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>