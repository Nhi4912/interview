<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N-Queen | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/backtracking/">Backtracking</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/backtracking/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">N queen</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">N-Queen</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Backtracking</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Backtracking</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="n-queen">N-Queen</h1>

<p><strong>LeetCode Problem # * 51. N-Queens</strong></p>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>The n-queens puzzle is the problem of placing n queens on an n x n chessboard  * such that no two queens attack each other.  *  * Given an integer n, return all distinct solutions to the n-queens puzzle.  * You may return the answer in any order.</li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>N-Queens
 *</li>
    </ol>
  </li>
  <li>Problem:</li>
  <li>The n-queens puzzle is the problem of placing n queens on an n x n chessboard</li>
  <li>such that no two queens attack each other.
 *</li>
  <li>Given an integer n, return all distinct solutions to the n-queens puzzle.</li>
  <li>You may return the answer in any order.
 *</li>
  <li>Each solution contains a distinct board configuration of the n-queens’ placement,</li>
  <li>where ‘Q’ and ‘.’ both indicate a queen and an empty space, respectively.
 *</li>
  <li>Example:</li>
  <li>Input: n = 4</li>
  <li>Output: [[“.Q..”,”…Q”,”Q…”,”..Q.”],[”..Q.”,”Q…”,”…Q”,”.Q..”]]
 *</li>
  <li>Input: n = 1</li>
  <li>Output: [[“Q”]]
 *</li>
  <li>LeetCode: https://leetcode.com/problems/n-queens/
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>Solution 1: Backtracking (Optimal)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use recursive backtracking to place queens</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Check row, column, and diagonal constraints</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Build solution incrementally
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n^2)
 */
function solveNQueens(n: number): string[][] {
  const result: string[][] = [];
  const board = Array(n)
 .fill(null)
 .map(() =&gt; Array(n).fill(“.”));</li>
</ul>

<p>function isValid(row: number, col: number): boolean {
    // Check column
    for (let i = 0; i &lt; row; i++) {
      if (board[i][col] === “Q”) return false;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>// Check diagonal (top-left to bottom-right)
for (let i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) {
  if (board[i][j] === "Q") return false;
}

// Check diagonal (top-right to bottom-left)
for (let i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) {
  if (board[i][j] === "Q") return false;
}

return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>function backtrack(row: number) {
    if (row === n) {
      result.push(board.map((row) =&gt; row.join(“”)));
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>for (let col = 0; col &lt; n; col++) {
  if (isValid(row, col)) {
    board[row][col] = "Q";
    backtrack(row + 1);
    board[row][col] = ".";
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack(0);
  return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 2: Using Sets for Constraint Tracking
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use sets to track occupied columns and diagonals</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More efficient constraint checking
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n)
 */
function solveNQueensSets(n: number): string[][] {
  const result: string[][] = [];
  const cols = new Set<number>();
  const diag1 = new Set<number>(); // row + col
  const diag2 = new Set<number>(); // row - col</number></number></number></li>
</ul>

<p>function backtrack(row: number, board: string[]) {
    if (row === n) {
      result.push([…board]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>for (let col = 0; col &lt; n; col++) {
  if (cols.has(col) || diag1.has(row + col) || diag2.has(row - col)) {
    continue;
  }

  cols.add(col);
  diag1.add(row + col);
  diag2.add(row - col);

  const newRow = ".".repeat(col) + "Q" + ".".repeat(n - col - 1);
  board.push(newRow);

  backtrack(row + 1, board);

  board.pop();
  cols.delete(col);
  diag1.delete(row + col);
  diag2.delete(row - col);
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack(0, []);
  return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 3: Using Arrays for Constraint Tracking
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use arrays to track occupied positions</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More explicit state management
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n)
 */
function solveNQueensArrays(n: number): string[][] {
  const result: string[][] = [];
  const cols = new Array(n).fill(false);
  const diag1 = new Array(2 * n - 1).fill(false);
  const diag2 = new Array(2 * n - 1).fill(false);</li>
</ul>

<p>function backtrack(row: number, board: string[]) {
    if (row === n) {
      result.push([…board]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>for (let col = 0; col &lt; n; col++) {
  const d1 = row + col;
  const d2 = row - col + n - 1;

  if (cols[col] || diag1[d1] || diag2[d2]) {
    continue;
  }

  cols[col] = true;
  diag1[d1] = true;
  diag2[d2] = true;

  const newRow = ".".repeat(col) + "Q" + ".".repeat(n - col - 1);
  board.push(newRow);

  backtrack(row + 1, board);

  board.pop();
  cols[col] = false;
  diag1[d1] = false;
  diag2[d2] = false;
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack(0, []);
  return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 4: Using Bit Manipulation
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use bit manipulation for constraint tracking</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Most efficient for small n
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n)
 */
function solveNQueensBitwise(n: number): string[][] {
  const result: string[][] = [];</li>
</ul>

<p>function backtrack(
    row: number,
    cols: number,
    diag1: number,
    diag2: number,
    board: string[]
  ) {
    if (row === n) {
      result.push([…board]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>for (let col = 0; col &lt; n; col++) {
  const colBit = 1 &lt;&lt; col;
  const diag1Bit = 1 &lt;&lt; (row + col);
  const diag2Bit = 1 &lt;&lt; (row - col + n - 1);

  if (cols &amp; colBit || diag1 &amp; diag1Bit || diag2 &amp; diag2Bit) {
    continue;
  }

  const newRow = ".".repeat(col) + "Q" + ".".repeat(n - col - 1);
  board.push(newRow);

  backtrack(
    row + 1,
    cols | colBit,
    diag1 | diag1Bit,
    diag2 | diag2Bit,
    board
  );

  board.pop();
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack(0, 0, 0, 0, []);
  return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 5: Using Class (Object-oriented)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Create an NQueensSolver class</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Encapsulate the solving logic
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n^2)
 */
class NQueensSolver {
  private n: number;
  private result: string[][];
  private board: string[][];
  private cols: Set<number>;
  private diag1: Set<number>;
  private diag2: Set<number>;</number></number></number></li>
</ul>

<p>constructor(n: number) {
    this.n = n;
    this.result = [];
    this.board = Array(n)
      .fill(null)
      .map(() =&gt; Array(n).fill(“.”));
    this.cols = new Set();
    this.diag1 = new Set();
    this.diag2 = new Set();
  }</p>

<p>solve(): string[][] {
    this.result = [];
    this.backtrack(0);
    return this.result;
  }</p>

<p>private backtrack(row: number): void {
    if (row === this.n) {
      this.result.push(this.board.map((row) =&gt; row.join(“”)));
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>for (let col = 0; col &lt; this.n; col++) {
  if (this.isValid(row, col)) {
    this.placeQueen(row, col);
    this.backtrack(row + 1);
    this.removeQueen(row, col);
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>private isValid(row: number, col: number): boolean {
    return (
      !this.cols.has(col) &amp;&amp;
      !this.diag1.has(row + col) &amp;&amp;
      !this.diag2.has(row - col)
    );
  }</p>

<p>private placeQueen(row: number, col: number): void {
    this.board[row][col] = “Q”;
    this.cols.add(col);
    this.diag1.add(row + col);
    this.diag2.add(row - col);
  }</p>

<p>private removeQueen(row: number, col: number): void {
    this.board[row][col] = “.”;
    this.cols.delete(col);
    this.diag1.delete(row + col);
    this.diag2.delete(row - col);
  }
}</p>

<p>function solveNQueensClass(n: number): string[][] {
  const solver = new NQueensSolver(n);
  return solver.solve();
}</p>

<p>/**</p>
<ul>
  <li>Solution 6: Using Generator (Memory efficient)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use generator to yield solutions</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory efficient for large n
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n)
 <em>/
function</em> solveNQueensGenerator(n: number): Generator&lt;string[]&gt; {
  const cols = new Set<number>();
  const diag1 = new Set<number>();
  const diag2 = new Set<number>();</number></number></number></li>
</ul>

<p>function* generate(row: number, board: string[]): Generator&lt;string[]&gt; {
    if (row === n) {
      yield […board];
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>for (let col = 0; col &lt; n; col++) {
  if (cols.has(col) || diag1.has(row + col) || diag2.has(row - col)) {
    continue;
  }

  cols.add(col);
  diag1.add(row + col);
  diag2.add(row - col);

  const newRow = ".".repeat(col) + "Q" + ".".repeat(n - col - 1);
  board.push(newRow);

  yield* generate(row + 1, board);

  board.pop();
  cols.delete(col);
  diag1.delete(row + col);
  diag2.delete(row - col);
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>yield* generate(0, []);
}</p>

<p>function solveNQueensWithGenerator(n: number): string[][] {
  return Array.from(solveNQueensGenerator(n));
}</p>

<p>/**</p>
<ul>
  <li>Solution 7: Using Functional Approach
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use functional programming concepts</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More declarative style
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>
    <p>Space Complexity: O(n^2)
 */
function solveNQueensFunctional(n: number): string[][] {
  function isValid(board: string[][], row: number, col: number): boolean {
 // Check column
 for (let i = 0; i &lt; row; i++) {
   if (board[i][col] === “Q”) return false;
 }</p>

    <p>// Check diagonals
 for (let i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i–, j–) {
   if (board[i][j] === “Q”) return false;
 }</p>

    <p>for (let i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i–, j++) {
   if (board[i][j] === “Q”) return false;
 }</p>

    <p>return true;
  }</p>
  </li>
</ul>

<p>function backtrack(row: number, board: string[][]): string[][] {
    if (row === n) {
      return [board.map((row) =&gt; row.join(“”))];
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>const results: string[][] = [];

for (let col = 0; col &lt; n; col++) {
  if (isValid(board, row, col)) {
    const newBoard = board.map((row) =&gt; [...row]);
    newBoard[row][col] = "Q";
    results.push(...backtrack(row + 1, newBoard));
  }
}

return results;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>const initialBoard = Array(n)
    .fill(null)
    .map(() =&gt; Array(n).fill(“.”));
  return backtrack(0, initialBoard);
}</p>

<p>/**</p>
<ul>
  <li>Solution 8: Using Stack
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use stack to simulate recursion</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Iterative approach with explicit stack
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n^2)
 */
function solveNQueensStack(n: number): string[][] {
  const result: string[][] = [];
  const stack: {
 row: number;
 board: string[][];
 cols: Set<number>;
 diag1: Set<number>;
 diag2: Set<number>;
  }[] = [];</number></number></number></li>
</ul>

<p>stack.push({
    row: 0,
    board: Array(n)
      .fill(null)
      .map(() =&gt; Array(n).fill(“.”)),
    cols: new Set(),
    diag1: new Set(),
    diag2: new Set(),
  });</p>

<p>while (stack.length &gt; 0) {
    const { row, board, cols, diag1, diag2 } = stack.pop()!;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>if (row === n) {
  result.push(board.map((row) =&gt; row.join("")));
  continue;
}

for (let col = n - 1; col &gt;= 0; col--) {
  if (cols.has(col) || diag1.has(row + col) || diag2.has(row - col)) {
    continue;
  }

  const newBoard = board.map((row) =&gt; [...row]);
  newBoard[row][col] = "Q";

  const newCols = new Set(cols);
  const newDiag1 = new Set(diag1);
  const newDiag2 = new Set(diag2);

  newCols.add(col);
  newDiag1.add(row + col);
  newDiag2.add(row - col);

  stack.push({
    row: row + 1,
    board: newBoard,
    cols: newCols,
    diag1: newDiag1,
    diag2: newDiag2,
  });
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 9: Using Memoization
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use memoization to cache partial solutions</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Avoid recalculating same subproblems
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n^2)
 */
function solveNQueensMemo(n: number): string[][] {
  const memo = new Map&lt;string, string[][]&gt;();</li>
</ul>

<p>function backtrack(
    row: number,
    cols: number,
    diag1: number,
    diag2: number
  ): string[][] {
    const key = <code class="language-plaintext highlighter-rouge">${row},${cols},${diag1},${diag2}</code>;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre>if (memo.has(key)) {
  return memo.get(key)!.map((solution) =&gt; [...solution]);
}

if (row === n) {
  return [[""]];
}

const results: string[][] = [];

for (let col = 0; col &lt; n; col++) {
  const colBit = 1 &lt;&lt; col;
  const diag1Bit = 1 &lt;&lt; (row + col);
  const diag2Bit = 1 &lt;&lt; (row - col + n - 1);

  if (cols &amp; colBit || diag1 &amp; diag1Bit || diag2 &amp; diag2Bit) {
    continue;
  }

  const subResults = backtrack(
    row + 1,
    cols | colBit,
    diag1 | diag1Bit,
    diag2 | diag2Bit
  );
  const newRow = ".".repeat(col) + "Q" + ".".repeat(n - col - 1);

  for (const subResult of subResults) {
    results.push([newRow, ...subResult]);
  }
}

memo.set(
  key,
  results.map((solution) =&gt; [...solution])
);
return results;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return backtrack(0, 0, 0, 0);
}</p>

<p>/**</p>
<ul>
  <li>Solution 10: Using Symmetry Optimization
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use symmetry to reduce search space</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Only search first half of first row
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n!)</li>
  <li>Space Complexity: O(n^2)
 */
function solveNQueensSymmetry(n: number): string[][] {
  const result: string[][] = [];
  const cols = new Set<number>();
  const diag1 = new Set<number>();
  const diag2 = new Set<number>();</number></number></number></li>
</ul>

<p>function backtrack(row: number, board: string[]) {
    if (row === n) {
      result.push([…board]);
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>const startCol = row === 0 ? 0 : 0;
const endCol = row === 0 ? Math.ceil(n / 2) : n;

for (let col = startCol; col &lt; endCol; col++) {
  if (cols.has(col) || diag1.has(row + col) || diag2.has(row - col)) {
    continue;
  }

  cols.add(col);
  diag1.add(row + col);
  diag2.add(row - col);

  const newRow = ".".repeat(col) + "Q" + ".".repeat(n - col - 1);
  board.push(newRow);

  backtrack(row + 1, board);

  board.pop();
  cols.delete(col);
  diag1.delete(row + col);
  diag2.delete(row - col);
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>backtrack(0, []);
  return result;
}</p>

<p>// Test cases
function testSolveNQueens() {
  console.log(“=== Testing N-Queens ===\n”);</p>

<p>const testCases = [
    {
      input: 1,
      expected: [[“Q”]],
      description: “Single queen”,
    },
    {
      input: 2,
      expected: [],
      description: “No solution for 2x2”,
    },
    {
      input: 3,
      expected: [],
      description: “No solution for 3x3”,
    },
    {
      input: 4,
      expected: [
        [“.Q..”, “…Q”, “Q…”, “..Q.”],
        [”..Q.”, “Q…”, “…Q”, “.Q..”],
      ],
      description: “Two solutions for 4x4”,
    },
  ];</p>

<p>testCases.forEach((testCase, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Test Case ${index + 1}: ${testCase.description}</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Input: n = ${testCase.input}</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Expected: ${JSON.stringify(testCase.expected)}\n</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
</pre></td><td class="rouge-code"><pre>// Test Solution 1 (Backtracking)
const result1 = solveNQueens(testCase.input);
console.log(
  `Solution 1 (Backtracking): ${JSON.stringify(result1)} ${
    JSON.stringify(result1.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 2 (Sets)
const result2 = solveNQueensSets(testCase.input);
console.log(
  `Solution 2 (Sets): ${JSON.stringify(result2)} ${
    JSON.stringify(result2.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 3 (Arrays)
const result3 = solveNQueensArrays(testCase.input);
console.log(
  `Solution 3 (Arrays): ${JSON.stringify(result3)} ${
    JSON.stringify(result3.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 4 (Bitwise)
const result4 = solveNQueensBitwise(testCase.input);
console.log(
  `Solution 4 (Bitwise): ${JSON.stringify(result4)} ${
    JSON.stringify(result4.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 5 (Class)
const result5 = solveNQueensClass(testCase.input);
console.log(
  `Solution 5 (Class): ${JSON.stringify(result5)} ${
    JSON.stringify(result5.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 6 (Generator)
const result6 = solveNQueensWithGenerator(testCase.input);
console.log(
  `Solution 6 (Generator): ${JSON.stringify(result6)} ${
    JSON.stringify(result6.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 7 (Functional)
const result7 = solveNQueensFunctional(testCase.input);
console.log(
  `Solution 7 (Functional): ${JSON.stringify(result7)} ${
    JSON.stringify(result7.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 8 (Stack)
const result8 = solveNQueensStack(testCase.input);
console.log(
  `Solution 8 (Stack): ${JSON.stringify(result8)} ${
    JSON.stringify(result8.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 9 (Memoization)
const result9 = solveNQueensMemo(testCase.input);
console.log(
  `Solution 9 (Memoization): ${JSON.stringify(result9)} ${
    JSON.stringify(result9.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

// Test Solution 10 (Symmetry)
const result10 = solveNQueensSymmetry(testCase.input);
console.log(
  `Solution 10 (Symmetry): ${JSON.stringify(result10)} ${
    JSON.stringify(result10.sort()) ===
    JSON.stringify(testCase.expected.sort())
      ? "✅"
      : "❌"
  }`
);

console.log("\n---\n");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Performance comparison
function performanceComparison() {
  console.log(“=== Performance Comparison ===\n”);</p>

<p>const testCases = [
    { name: “Backtracking”, func: solveNQueens },
    { name: “Sets”, func: solveNQueensSets },
    { name: “Arrays”, func: solveNQueensArrays },
    { name: “Bitwise”, func: solveNQueensBitwise },
    { name: “Class”, func: solveNQueensClass },
    { name: “Generator”, func: solveNQueensWithGenerator },
    { name: “Functional”, func: solveNQueensFunctional },
    { name: “Stack”, func: solveNQueensStack },
    { name: “Memoization”, func: solveNQueensMemo },
    { name: “Symmetry”, func: solveNQueensSymmetry },
  ];</p>

<p>// Create test cases
  const smallCase = 4;
  const mediumCase = 5;
  const largeCase = 6;</p>

<p>const cases = [
    { name: “Small”, case: smallCase },
    { name: “Medium”, case: mediumCase },
    { name: “Large”, case: largeCase },
  ];</p>

<p>cases.forEach(({ name, case: testCase }) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">${name} Case (n = ${testCase}):</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>testCases.forEach(({ name: funcName, func }) =&gt; {
  const start = performance.now();
  const result = func(testCase);
  const end = performance.now();

  console.log(
    `  ${funcName}: ${(end - start).toFixed(2)}ms (${
      result.length
    } solutions)`
  );
});

console.log("");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// N-Queens analysis
function nQueensAnalysis() {
  console.log(“=== N-Queens Analysis ===\n”);</p>

<p>const testValues = [1, 2, 3, 4, 5, 6, 7, 8];</p>

<p>testValues.forEach((n) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">n = ${n}:</code>);
    const result = solveNQueens(n);
    console.log(<code class="language-plaintext highlighter-rouge">Solutions: ${result.length}</code>);
    if (result.length &gt; 0) {
      console.log(<code class="language-plaintext highlighter-rouge">First solution: ${JSON.stringify(result[0])}</code>);
    }
    console.log(“”);
  });
}</p>

<p>// Uncomment the following lines to run tests
// testSolveNQueens();
// performanceComparison();
// nQueensAnalysis();</p>

<p>export {
  solveNQueens,
  solveNQueensSets,
  solveNQueensArrays,
  solveNQueensBitwise,
  solveNQueensClass,
  solveNQueensWithGenerator,
  solveNQueensFunctional,
  solveNQueensStack,
  solveNQueensMemo,
  solveNQueensSymmetry,
  NQueensSolver,
  solveNQueensGenerator,
  testSolveNQueens,
  performanceComparison,
  nQueensAnalysis,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>