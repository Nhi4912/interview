<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Number of Island | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/">Tree graph</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Number of island</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Number of Island</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Tree/Graph</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Tree/Graph</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="number-of-island">Number of Island</h1>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>
    <ul>
      <li>Given an m x n 2D binary grid grid which represents a map of ‘1’s (land) and ‘0’s (water),  * return the number of islands.  *  * An island is surrounded by water and is formed by connecting adjacent lands horizontally</li>
    </ul>
  </li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>Number of Islands
 *</li>
  <li>Problem: https://leetcode.com/problems/number-of-islands/
 *</li>
  <li>Given an m x n 2D binary grid grid which represents a map of ‘1’s (land) and ‘0’s (water),</li>
  <li>return the number of islands.
 *</li>
  <li>An island is surrounded by water and is formed by connecting adjacent lands horizontally</li>
  <li>or vertically. You may assume all four edges of the grid are all surrounded by water.
 *</li>
  <li>Example 1:</li>
  <li>Input: grid = [</li>
  <li>[“1”,”1”,”1”,”1”,”0”],</li>
  <li>[“1”,”1”,”0”,”1”,”0”],</li>
  <li>[“1”,”1”,”0”,”0”,”0”],</li>
  <li>[“0”,”0”,”0”,”0”,”0”]</li>
  <li>]</li>
  <li>Output: 1
 *</li>
  <li>Example 2:</li>
  <li>Input: grid = [</li>
  <li>[“1”,”1”,”0”,”0”,”0”],</li>
  <li>[“1”,”1”,”0”,”0”,”0”],</li>
  <li>[“0”,”0”,”1”,”0”,”0”],</li>
  <li>[“0”,”0”,”0”,”1”,”1”]</li>
  <li>]</li>
  <li>Output: 3
 *</li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>m == grid.length</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>n == grid[i].length</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>1 &lt;= m, n &lt;= 300</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>grid[i][j] is ‘0’ or ‘1’.
 *</li>
    </ul>
  </li>
  <li>Solution Approach:</li>
  <li>
    <ol>
      <li>DFS (Depth-First Search) with flood fill</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>BFS (Breadth-First Search) with flood fill</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Union-Find (Disjoint Set) approach</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Mark visited cells to avoid revisiting
 *</li>
    </ol>
  </li>
  <li>Time Complexity: O(m * n) where m and n are grid dimensions</li>
  <li>Space Complexity: O(m * n) for recursion stack or queue
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>Number of Islands - DFS Solution
 *</li>
  <li>Giải pháp DFS cho bài toán Số lượng đảo
 *</li>
  <li>@param grid - 2D binary grid representing land and water</li>
  <li>@returns Number of islands
 */
function numIslands(grid: string[][]): number {
  if (!grid || grid.length === 0) return 0;</li>
</ul>

<p>const m = grid.length;
  const n = grid[0].length;
  let count = 0;</p>

<p>// DFS function to mark connected land cells
  function dfs(row: number, col: number): void {
    // Check boundaries and if cell is land
    if (row &lt; 0 || row &gt;= m || col &lt; 0 || col &gt;= n || grid[row][col] === “0”) {
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>// Mark current cell as visited (water)
grid[row][col] = "0";

// Explore all four directions
dfs(row - 1, col); // up
dfs(row + 1, col); // down
dfs(row, col - 1); // left
dfs(row, col + 1); // right   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Iterate through all cells
  for (let i = 0; i &lt; m; i++) {
    for (let j = 0; j &lt; n; j++) {
      if (grid[i][j] === “1”) {
        count++;
        dfs(i, j);
      }
    }
  }</p>

<p>return count;
}</p>

<p>/**</p>
<ul>
  <li>Alternative Solution: BFS Approach
 *</li>
  <li>Giải pháp thay thế: Phương pháp BFS
 *</li>
  <li>@param grid - 2D binary grid representing land and water</li>
  <li>@returns Number of islands
 */
function numIslandsBFS(grid: string[][]): number {
  if (!grid || grid.length === 0) return 0;</li>
</ul>

<p>const m = grid.length;
  const n = grid[0].length;
  let count = 0;</p>

<p>// BFS function to mark connected land cells
  function bfs(row: number, col: number): void {
    const queue: [number, number][] = [[row, col]];
    const directions = [
      [-1, 0],
      [1, 0],
      [0, -1],
      [0, 1],
    ]; // up, down, left, right</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>while (queue.length &gt; 0) {
  const [currentRow, currentCol] = queue.shift()!;

  // Mark current cell as visited
  grid[currentRow][currentCol] = "0";

  // Check all four directions
  for (const [dr, dc] of directions) {
    const newRow = currentRow + dr;
    const newCol = currentCol + dc;

    if (
      newRow &gt;= 0 &amp;&amp;
      newRow &lt; m &amp;&amp;
      newCol &gt;= 0 &amp;&amp;
      newCol &lt; n &amp;&amp;
      grid[newRow][newCol] === "1"
    ) {
      queue.push([newRow, newCol]);
    }
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Iterate through all cells
  for (let i = 0; i &lt; m; i++) {
    for (let j = 0; j &lt; n; j++) {
      if (grid[i][j] === “1”) {
        count++;
        bfs(i, j);
      }
    }
  }</p>

<p>return count;
}</p>

<p>/**</p>
<ul>
  <li>Union-Find Solution
 *</li>
  <li>Giải pháp Union-Find
 *</li>
  <li>@param grid - 2D binary grid representing land and water</li>
  <li>@returns Number of islands
 */
function numIslandsUnionFind(grid: string[][]): number {
  if (!grid || grid.length === 0) return 0;</li>
</ul>

<p>const m = grid.length;
  const n = grid[0].length;</p>

<p>// Union-Find class
  class UnionFind {
    private parent: number[];
    private rank: number[];
    private count: number;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre>constructor(size: number) {
  this.parent = Array.from({ length: size }, (_, i) =&gt; i);
  this.rank = new Array(size).fill(0);
  this.count = size;
}

find(x: number): number {
  if (this.parent[x] !== x) {
    this.parent[x] = this.find(this.parent[x]);
  }
  return this.parent[x];
}

union(x: number, y: number): void {
  const rootX = this.find(x);
  const rootY = this.find(y);

  if (rootX !== rootY) {
    if (this.rank[rootX] &lt; this.rank[rootY]) {
      this.parent[rootX] = rootY;
    } else if (this.rank[rootX] &gt; this.rank[rootY]) {
      this.parent[rootY] = rootX;
    } else {
      this.parent[rootY] = rootX;
      this.rank[rootX]++;
    }
    this.count--;
  }
}

getCount(): number {
  return this.count;
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Count land cells and create Union-Find
  let landCount = 0;
  for (let i = 0; i &lt; m; i++) {
    for (let j = 0; j &lt; n; j++) {
      if (grid[i][j] === “1”) {
        landCount++;
      }
    }
  }</p>

<p>const uf = new UnionFind(landCount);
  const directions = [
    [-1, 0],
    [1, 0],
    [0, -1],
    [0, 1],
  ];</p>

<p>// Convert 2D coordinates to 1D indices
  const getIndex = (row: number, col: number): number =&gt; {
    return row * n + col;
  };</p>

<p>// Union adjacent land cells
  for (let i = 0; i &lt; m; i++) {
    for (let j = 0; j &lt; n; j++) {
      if (grid[i][j] === “1”) {
        const currentIndex = getIndex(i, j);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>    for (const [dr, dc] of directions) {
      const newRow = i + dr;
      const newCol = j + dc;

      if (
        newRow &gt;= 0 &amp;&amp;
        newRow &lt; m &amp;&amp;
        newCol &gt;= 0 &amp;&amp;
        newCol &lt; n &amp;&amp;
        grid[newRow][newCol] === "1"
      ) {
        const neighborIndex = getIndex(newRow, newCol);
        uf.union(currentIndex, neighborIndex);
      }
    }
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return uf.getCount();
}</p>

<p>/**</p>
<ul>
  <li>Solution with Island Tracking
 *</li>
  <li>Giải pháp với theo dõi đảo
 *</li>
  <li>@param grid - 2D binary grid representing land and water</li>
  <li>@returns Object containing island count and island information
 */
function numIslandsWithTracking(grid: string[][]): {
  count: number;
  islands: Array&lt;{ id: number; cells: [number, number][]; size: number }&gt;;
} {
  if (!grid || grid.length === 0) return { count: 0, islands: [] };</li>
</ul>

<p>const m = grid.length;
  const n = grid[0].length;
  let islandId = 0;
  const islands: Array&lt;{
    id: number;
    cells: [number, number][];
    size: number;
  }&gt; = [];</p>

<p>function dfs(
    row: number,
    col: number,
    currentIsland: [number, number][]
  ): void {
    if (row &lt; 0 || row &gt;= m || col &lt; 0 || col &gt;= n || grid[row][col] === “0”) {
      return;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>grid[row][col] = "0";
currentIsland.push([row, col]);

dfs(row - 1, col, currentIsland);
dfs(row + 1, col, currentIsland);
dfs(row, col - 1, currentIsland);
dfs(row, col + 1, currentIsland);   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>for (let i = 0; i &lt; m; i++) {
    for (let j = 0; j &lt; n; j++) {
      if (grid[i][j] === “1”) {
        const currentIsland: [number, number][] = [];
        dfs(i, j, currentIsland);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>    islands.push({
      id: islandId++,
      cells: currentIsland,
      size: currentIsland.length,
    });
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return { count: islands.length, islands };
}</p>

<p>/**</p>
<ul>
  <li>Solution with Grid Visualization
 *</li>
  <li>Giải pháp với hiển thị lưới
 *</li>
  <li>@param grid - 2D binary grid representing land and water</li>
  <li>@returns Object containing count and visualization
 */
function numIslandsWithVisualization(grid: string[][]): {
  count: number;
  visualization: string;
} {
  const { count, islands } = numIslandsWithTracking(grid);</li>
</ul>

<p>let visualization = “Grid Visualization:\n”;
  visualization += “Hiển thị lưới:\n\n”;</p>

<p>// Create a copy of the grid for visualization
  const visGrid = grid.map((row) =&gt; […row]);</p>

<p>// Mark islands with different characters
  for (let i = 0; i &lt; islands.length; i++) {
    const islandChar = String.fromCharCode(65 + i); // A, B, C, …
    for (const [row, col] of islands[i].cells) {
      visGrid[row][col] = islandChar;
    }
  }</p>

<p>// Display the grid
  for (let i = 0; i &lt; visGrid.length; i++) {
    visualization += <code class="language-plaintext highlighter-rouge">Row ${i}: [${visGrid[i].join(", ")}]\n</code>;
  }</p>

<p>visualization += <code class="language-plaintext highlighter-rouge">\nTotal Islands: ${count}\n</code>;
  visualization += <code class="language-plaintext highlighter-rouge">Tổng số đảo: ${count}\n\n</code>;</p>

<p>for (const island of islands) {
    visualization += <code class="language-plaintext highlighter-rouge">Island ${island.id} (${String.fromCharCode(
      65 + island.id
    )}): ${island.size} cells\n</code>;
    visualization += <code class="language-plaintext highlighter-rouge">Đảo ${island.id} (${String.fromCharCode(
      65 + island.id
    )}): ${island.size} ô\n</code>;
  }</p>

<p>return { count, visualization };
}</p>

<p>// Test cases / Các trường hợp kiểm thử
function runTests() {
  console.log(“=== Number of Islands Tests ===”);
  console.log(“=== Kiểm thử bài toán Số lượng đảo ===\n”);</p>

<p>const testCases = [
    {
      name: “Example 1: Single island”,
      input: [
        [“1”, “1”, “1”, “1”, “0”],
        [“1”, “1”, “0”, “1”, “0”],
        [“1”, “1”, “0”, “0”, “0”],
        [“0”, “0”, “0”, “0”, “0”],
      ],
      expected: 1,
      description: “One large island”,
    },
    {
      name: “Example 2: Three islands”,
      input: [
        [“1”, “1”, “0”, “0”, “0”],
        [“1”, “1”, “0”, “0”, “0”],
        [“0”, “0”, “1”, “0”, “0”],
        [“0”, “0”, “0”, “1”, “1”],
      ],
      expected: 3,
      description: “Three separate islands”,
    },
    {
      name: “Empty grid”,
      input: [],
      expected: 0,
      description: “Empty grid”,
    },
    {
      name: “All water”,
      input: [
        [“0”, “0”, “0”],
        [“0”, “0”, “0”],
        [“0”, “0”, “0”],
      ],
      expected: 0,
      description: “Grid with only water”,
    },
    {
      name: “All land”,
      input: [
        [“1”, “1”, “1”],
        [“1”, “1”, “1”],
        [“1”, “1”, “1”],
      ],
      expected: 1,
      description: “Grid with only land”,
    },
    {
      name: “Diagonal islands”,
      input: [
        [“1”, “0”, “1”],
        [“0”, “1”, “0”],
        [“1”, “0”, “1”],
      ],
      expected: 5,
      description: “Five separate single-cell islands”,
    },
    {
      name: “Large single island”,
      input: [
        [“1”, “1”, “1”, “1”, “1”],
        [“1”, “0”, “0”, “0”, “1”],
        [“1”, “0”, “1”, “0”, “1”],
        [“1”, “0”, “0”, “0”, “1”],
        [“1”, “1”, “1”, “1”, “1”],
      ],
      expected: 2,
      description: “One large island with one small island inside”,
    },
  ];</p>

<p>for (const testCase of testCases) {
    console.log(<code class="language-plaintext highlighter-rouge">Test: ${testCase.name}</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Description: ${testCase.description}</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre>// Create a copy of the input grid for each test
const grid1 = testCase.input.map((row) =&gt; [...row]);
const grid2 = testCase.input.map((row) =&gt; [...row]);
const grid3 = testCase.input.map((row) =&gt; [...row]);

// Test DFS solution
const result1 = numIslands(grid1);
const passed1 = result1 === testCase.expected;

console.log(`DFS Result: ${result1}`);
console.log(`DFS Status: ${passed1 ? "✅ PASSED" : "❌ FAILED"}`);

// Test BFS solution
const result2 = numIslandsBFS(grid2);
const passed2 = result2 === testCase.expected;

console.log(`BFS Result: ${result2}`);
console.log(`BFS Status: ${passed2 ? "✅ PASSED" : "❌ FAILED"}`);

// Test Union-Find solution
const result3 = numIslandsUnionFind(grid3);
const passed3 = result3 === testCase.expected;

console.log(`Union-Find Result: ${result3}`);
console.log(`Union-Find Status: ${passed3 ? "✅ PASSED" : "❌ FAILED"}`);

const allPassed = passed1 &amp;&amp; passed2 &amp;&amp; passed3;
console.log(`All implementations match: ${allPassed ? "✅ Yes" : "❌ No"}`);

console.log("---");   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test with visualization
  console.log(“\n=== Testing with Visualization ===”);
  console.log(“=== Kiểm thử với hiển thị ===\n”);</p>

<p>const testGrid = [
    [“1”, “1”, “0”, “0”, “0”],
    [“1”, “1”, “0”, “0”, “0”],
    [“0”, “0”, “1”, “0”, “0”],
    [“0”, “0”, “0”, “1”, “1”],
  ];</p>

<p>const { count, visualization } = numIslandsWithVisualization(testGrid);
  console.log(visualization);</p>

<p>// Test with island tracking
  console.log(“\n=== Testing with Island Tracking ===”);
  console.log(“=== Kiểm thử với theo dõi đảo ===\n”);</p>

<p>const testGrid2 = [
    [“1”, “1”, “0”, “0”, “0”],
    [“1”, “1”, “0”, “0”, “0”],
    [“0”, “0”, “1”, “0”, “0”],
    [“0”, “0”, “0”, “1”, “1”],
  ];</p>

<p>const { count: count2, islands } = numIslandsWithTracking(testGrid2);</p>

<p>console.log(<code class="language-plaintext highlighter-rouge">Total islands: ${count2}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Tổng số đảo: ${count2}</code>);</p>

<p>for (const island of islands) {
    console.log(
      <code class="language-plaintext highlighter-rouge">Island ${island.id}: ${island.size} cells at positions: ${JSON.stringify(
        island.cells
      )}</code>
    );
  }</p>

<p>// Performance comparison
  console.log(“\n=== Performance Comparison ===”);
  console.log(“=== So sánh hiệu suất ===\n”);</p>

<p>// Create a large grid
  const largeGrid: string[][] = [];
  for (let i = 0; i &lt; 100; i++) {
    const row: string[] = [];
    for (let j = 0; j &lt; 100; j++) {
      row.push(Math.random() &gt; 0.7 ? “1” : “0”);
    }
    largeGrid.push(row);
  }</p>

<p>console.log(“Testing with large grid (100x100)…”);
  console.log(“Kiểm thử với lưới lớn (100x100)…”);</p>

<p>const start1 = performance.now();
  const result1 = numIslands(largeGrid.map((row) =&gt; […row]));
  const time1 = performance.now() - start1;</p>

<p>const start2 = performance.now();
  const result2 = numIslandsBFS(largeGrid.map((row) =&gt; […row]));
  const time2 = performance.now() - start2;</p>

<p>const start3 = performance.now();
  const result3 = numIslandsUnionFind(largeGrid.map((row) =&gt; […row]));
  const time3 = performance.now() - start3;</p>

<p>console.log(<code class="language-plaintext highlighter-rouge">DFS: ${time1.toFixed(4)}ms, Islands: ${result1}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">BFS: ${time2.toFixed(4)}ms, Islands: ${result2}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Union-Find: ${time3.toFixed(4)}ms, Islands: ${result3}</code>);</p>

<p>const resultsMatch = result1 === result2 &amp;&amp; result2 === result3;
  console.log(<code class="language-plaintext highlighter-rouge">Results match: ${resultsMatch ? "✅ Yes" : "❌ No"}</code>);
}</p>

<p>// Run tests if this file is executed directly
if (require.main === module) {
  runTests();
}</p>

<p>export {
  numIslands,
  numIslandsBFS,
  numIslandsUnionFind,
  numIslandsWithTracking,
  numIslandsWithVisualization,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>