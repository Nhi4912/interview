<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alien Dictionary | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/">Tree graph</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Alien dictionary</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Alien Dictionary</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Tree/Graph</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Tree/Graph</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                                    <span class="tag">Sorting</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="alien-dictionary">Alien Dictionary</h1>

<p><strong>LeetCode Problem # * 269. Alien Dictionary</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Alien Dictionary</li>
    </ol>
  </li>
  <li></li>
  <li>There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.</li>
  <li>You are given a list of strings words from the alien language’s dictionary, where the strings in words are sorted lexicographically by the rules of this new language.</li>
  <li></li>
  <li>Return a string of the unique letters in the new alien language sorted in lexicographically increasing order by the new language’s rules.</li>
  <li>If there is no solution, return “”. If there are multiple solutions, return any of them.</li>
  <li></li>
  <li>A string s is lexicographically smaller than a string t if at the first position where s and t differ, the character in s comes before the character in t in the alien language.</li>
  <li>If the first min(s.length, t.length) characters are the same, then s is lexicographically smaller if and only if s.length &lt; t.length.</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: words = [“wrt”,”wrf”,”er”,”ett”,”rftt”]</li>
  <li>Output: “wertf”</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: words = [“z”,”x”]</li>
  <li>Output: “zx”</li>
  <li></li>
  <li>Example 3:</li>
  <li>Input: words = [“z”,”x”,”z”]</li>
  <li>Output: “”</li>
  <li>Explanation: The order is invalid, so return “”.</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>1 &lt;= words.length &lt;= 100</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>1 &lt;= words[i].length &lt;= 100</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>words[i] consists of only lowercase English letters.
 */</li>
    </ul>
  </li>
</ul>

<p>// Solution 1: Topological Sort with DFS
// Time: O(V + E) where V = unique chars, E = relationships, Space: O(V + E)
export function alienOrder1(words: string[]): string {
    if (words.length === 0) return “”;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
</pre></td><td class="rouge-code"><pre>// Build adjacency list and in-degree count
const graph = new Map&lt;string, Set&lt;string&gt;&gt;();
const inDegree = new Map&lt;string, number&gt;();

// Initialize all characters
for (const word of words) {
    for (const char of word) {
        if (!graph.has(char)) {
            graph.set(char, new Set());
            inDegree.set(char, 0);
        }
    }
}

// Build graph by comparing adjacent words
for (let i = 0; i &lt; words.length - 1; i++) {
    const word1 = words[i];
    const word2 = words[i + 1];
    
    // Check for invalid case: word1 is prefix of word2 but longer
    if (word1.length &gt; word2.length &amp;&amp; word1.startsWith(word2)) {
        return "";
    }
    
    // Find first different character
    for (let j = 0; j &lt; Math.min(word1.length, word2.length); j++) {
        const char1 = word1[j];
        const char2 = word2[j];
        
        if (char1 !== char2) {
            // Add edge from char1 to char2
            if (!graph.get(char1)!.has(char2)) {
                graph.get(char1)!.add(char2);
                inDegree.set(char2, inDegree.get(char2)! + 1);
            }
            break; // Only first difference matters
        }
    }
}

// Topological sort using DFS
const WHITE = 0, GRAY = 1, BLACK = 2;
const colors = new Map&lt;string, number&gt;();
const result: string[] = [];

for (const char of graph.keys()) {
    colors.set(char, WHITE);
}

function dfs(char: string): boolean {
    if (colors.get(char) === GRAY) return false; // Cycle detected
    if (colors.get(char) === BLACK) return true; // Already processed
    
    colors.set(char, GRAY);
    
    // Visit all neighbors
    for (const neighbor of graph.get(char)!) {
        if (!dfs(neighbor)) return false;
    }
    
    colors.set(char, BLACK);
    result.push(char);
    return true;
}

// Process all characters
for (const char of graph.keys()) {
    if (colors.get(char) === WHITE) {
        if (!dfs(char)) return ""; // Cycle detected
    }
}

return result.reverse().join(""); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Kahn’s Algorithm (BFS Topological Sort)
// Time: O(V + E), Space: O(V + E)
export function alienOrder2(words: string[]): string {
    if (words.length === 0) return “”;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="rouge-code"><pre>const graph = new Map&lt;string, Set&lt;string&gt;&gt;();
const inDegree = new Map&lt;string, number&gt;();

// Initialize characters
for (const word of words) {
    for (const char of word) {
        if (!graph.has(char)) {
            graph.set(char, new Set());
            inDegree.set(char, 0);
        }
    }
}

// Build graph
for (let i = 0; i &lt; words.length - 1; i++) {
    const word1 = words[i];
    const word2 = words[i + 1];
    
    // Check invalid case
    if (word1.length &gt; word2.length &amp;&amp; word1.startsWith(word2)) {
        return "";
    }
    
    for (let j = 0; j &lt; Math.min(word1.length, word2.length); j++) {
        const char1 = word1[j];
        const char2 = word2[j];
        
        if (char1 !== char2) {
            if (!graph.get(char1)!.has(char2)) {
                graph.get(char1)!.add(char2);
                inDegree.set(char2, inDegree.get(char2)! + 1);
            }
            break;
        }
    }
}

// Kahn's algorithm
const queue: string[] = [];
for (const [char, degree] of inDegree) {
    if (degree === 0) {
        queue.push(char);
    }
}

const result: string[] = [];

while (queue.length &gt; 0) {
    const char = queue.shift()!;
    result.push(char);
    
    for (const neighbor of graph.get(char)!) {
        inDegree.set(neighbor, inDegree.get(neighbor)! - 1);
        if (inDegree.get(neighbor) === 0) {
            queue.push(neighbor);
        }
    }
}

// Check if all characters are processed (no cycle)
return result.length === graph.size ? result.join("") : ""; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Union-Find with Constraint Checking
// Time: O(V + E), Space: O(V)
export function alienOrder3(words: string[]): string {
    if (words.length === 0) return “”;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="rouge-code"><pre>class UnionFind {
    parent: Map&lt;string, string&gt; = new Map();
    rank: Map&lt;string, number&gt; = new Map();
    
    makeSet(x: string): void {
        if (!this.parent.has(x)) {
            this.parent.set(x, x);
            this.rank.set(x, 0);
        }
    }
    
    find(x: string): string {
        if (this.parent.get(x) !== x) {
            this.parent.set(x, this.find(this.parent.get(x)!));
        }
        return this.parent.get(x)!;
    }
    
    union(x: string, y: string): boolean {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) return false; // Would create cycle
        
        if (this.rank.get(rootX)! &lt; this.rank.get(rootY)!) {
            this.parent.set(rootX, rootY);
        } else if (this.rank.get(rootX)! &gt; this.rank.get(rootY)!) {
            this.parent.set(rootY, rootX);
        } else {
            this.parent.set(rootY, rootX);
            this.rank.set(rootX, this.rank.get(rootX)! + 1);
        }
        
        return true;
    }
}

const uf = new UnionFind();
const edges: [string, string][] = [];
const chars = new Set&lt;string&gt;();

// Collect all characters
for (const word of words) {
    for (const char of word) {
        chars.add(char);
        uf.makeSet(char);
    }
}

// Collect ordering constraints
for (let i = 0; i &lt; words.length - 1; i++) {
    const word1 = words[i];
    const word2 = words[i + 1];
    
    if (word1.length &gt; word2.length &amp;&amp; word1.startsWith(word2)) {
        return "";
    }
    
    for (let j = 0; j &lt; Math.min(word1.length, word2.length); j++) {
        if (word1[j] !== word2[j]) {
            edges.push([word1[j], word2[j]]);
            break;
        }
    }
}

// This approach is complex for this problem, switching to DFS
return alienOrder1(words); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Modified DFS with Path Reconstruction
// Time: O(V + E), Space: O(V + E)
export function alienOrder4(words: string[]): string {
    const graph = new Map&lt;string, string[]&gt;();
    const inDegree = new Map&lt;string, number&gt;();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="rouge-code"><pre>// Initialize
for (const word of words) {
    for (const char of word) {
        if (!graph.has(char)) {
            graph.set(char, []);
            inDegree.set(char, 0);
        }
    }
}

// Build graph
for (let i = 0; i &lt; words.length - 1; i++) {
    const word1 = words[i];
    const word2 = words[i + 1];
    
    if (word1.length &gt; word2.length &amp;&amp; word1.startsWith(word2)) {
        return "";
    }
    
    for (let j = 0; j &lt; Math.min(word1.length, word2.length); j++) {
        if (word1[j] !== word2[j]) {
            graph.get(word1[j])!.push(word2[j]);
            inDegree.set(word2[j], inDegree.get(word2[j])! + 1);
            break;
        }
    }
}

// Topological sort
const result: string[] = [];
const queue: string[] = [];

for (const [char, degree] of inDegree) {
    if (degree === 0) {
        queue.push(char);
    }
}

while (queue.length &gt; 0) {
    const char = queue.shift()!;
    result.push(char);
    
    for (const neighbor of graph.get(char)!) {
        inDegree.set(neighbor, inDegree.get(neighbor)! - 1);
        if (inDegree.get(neighbor) === 0) {
            queue.push(neighbor);
        }
    }
}

return result.length === graph.size ? result.join("") : ""; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Priority Queue Based Topological Sort
// Time: O(V log V + E), Space: O(V + E)
export function alienOrder5(words: string[]): string {
    class MinHeap {
        heap: string[] = [];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
</pre></td><td class="rouge-code"><pre>    push(val: string): void {
        this.heap.push(val);
        this.heapifyUp(this.heap.length - 1);
    }
    
    pop(): string | undefined {
        if (this.heap.length === 0) return undefined;
        
        const min = this.heap[0];
        const last = this.heap.pop()!;
        
        if (this.heap.length &gt; 0) {
            this.heap[0] = last;
            this.heapifyDown(0);
        }
        
        return min;
    }
    
    isEmpty(): boolean {
        return this.heap.length === 0;
    }
    
    private heapifyUp(idx: number): void {
        while (idx &gt; 0) {
            const parentIdx = Math.floor((idx - 1) / 2);
            if (this.heap[parentIdx] &lt;= this.heap[idx]) break;
            
            [this.heap[parentIdx], this.heap[idx]] = [this.heap[idx], this.heap[parentIdx]];
            idx = parentIdx;
        }
    }
    
    private heapifyDown(idx: number): void {
        while (true) {
            let minIdx = idx;
            const leftChild = 2 * idx + 1;
            const rightChild = 2 * idx + 2;
            
            if (leftChild &lt; this.heap.length &amp;&amp; this.heap[leftChild] &lt; this.heap[minIdx]) {
                minIdx = leftChild;
            }
            
            if (rightChild &lt; this.heap.length &amp;&amp; this.heap[rightChild] &lt; this.heap[minIdx]) {
                minIdx = rightChild;
            }
            
            if (minIdx === idx) break;
            
            [this.heap[idx], this.heap[minIdx]] = [this.heap[minIdx], this.heap[idx]];
            idx = minIdx;
        }
    }
}

const graph = new Map&lt;string, string[]&gt;();
const inDegree = new Map&lt;string, number&gt;();

// Initialize
for (const word of words) {
    for (const char of word) {
        if (!graph.has(char)) {
            graph.set(char, []);
            inDegree.set(char, 0);
        }
    }
}

// Build graph
for (let i = 0; i &lt; words.length - 1; i++) {
    const word1 = words[i];
    const word2 = words[i + 1];
    
    if (word1.length &gt; word2.length &amp;&amp; word1.startsWith(word2)) {
        return "";
    }
    
    for (let j = 0; j &lt; Math.min(word1.length, word2.length); j++) {
        if (word1[j] !== word2[j]) {
            graph.get(word1[j])!.push(word2[j]);
            inDegree.set(word2[j], inDegree.get(word2[j])! + 1);
            break;
        }
    }
}

// Use priority queue for lexicographic order
const pq = new MinHeap();
for (const [char, degree] of inDegree) {
    if (degree === 0) {
        pq.push(char);
    }
}

const result: string[] = [];

while (!pq.isEmpty()) {
    const char = pq.pop()!;
    result.push(char);
    
    for (const neighbor of graph.get(char)!) {
        inDegree.set(neighbor, inDegree.get(neighbor)! - 1);
        if (inDegree.get(neighbor) === 0) {
            pq.push(neighbor);
        }
    }
}

return result.length === graph.size ? result.join("") : ""; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testAlienOrder() {
    console.log(“Testing Alien Dictionary:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
</pre></td><td class="rouge-code"><pre>const testCases = [
    {
        input: ["wrt", "wrf", "er", "ett", "rftt"],
        expected: "wertf"
    },
    {
        input: ["z", "x"],
        expected: "zx"
    },
    {
        input: ["z", "x", "z"],
        expected: ""
    },
    {
        input: ["abc", "ab"],
        expected: ""
    },
    {
        input: ["a", "b", "ca", "cc"],
        expected: "abc"
    },
    {
        input: ["ac", "ab", "zc", "zb"],
        expected: "acbz"
    }
];

const solutions = [
    { name: "DFS Topological Sort", fn: alienOrder1 },
    { name: "Kahn's Algorithm", fn: alienOrder2 },
    { name: "Union Find (fallback)", fn: alienOrder3 },
    { name: "Modified DFS", fn: alienOrder4 },
    { name: "Priority Queue", fn: alienOrder5 }
];

function isValidOrder(result: string, words: string[]): boolean {
    if (result === "") return false;
    
    const charToIndex = new Map&lt;string, number&gt;();
    for (let i = 0; i &lt; result.length; i++) {
        charToIndex.set(result[i], i);
    }
    
    for (let i = 0; i &lt; words.length - 1; i++) {
        const word1 = words[i];
        const word2 = words[i + 1];
        
        for (let j = 0; j &lt; Math.min(word1.length, word2.length); j++) {
            const char1 = word1[j];
            const char2 = word2[j];
            
            if (char1 !== char2) {
                if (charToIndex.get(char1)! &gt; charToIndex.get(char2)!) {
                    return false;
                }
                break;
            }
        }
    }
    
    return true;
}

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        const result = solution.fn([...test.input]);
        let passed = false;
        
        if (test.expected === "") {
            passed = result === "";
        } else {
            passed = result !== "" &amp;&amp; isValidOrder(result, test.input);
        }
        
        console.log(`  Test ${i + 1}: ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Input: ${JSON.stringify(test.input)}`);
            console.log(`    Expected: "${test.expected}" (or valid order)`);
            console.log(`    Got: "${result}"`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Problem Recognition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Topological sorting problem</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Build DAG from lexicographic ordering constraints</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Detect cycles (invalid alien language)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Graph Construction</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Compare adjacent words to find character relationships</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Only first differing position creates ordering constraint</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle invalid case: longer word is prefix of shorter</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Topological Sort Approaches</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>DFS with cycle detection (using colors)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Kahn’s algorithm (BFS with in-degree tracking)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Both have O(V + E) time complexity</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Case Handling</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Invalid ordering: [“abc”, “ab”] → impossible</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Cycle detection: [“z”, “x”, “z”] → contradiction</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Single characters: valid trivial cases</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Algorithm Choice</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>DFS: More intuitive cycle detection</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Kahn’s: Easier to understand and implement</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Priority Queue: Ensures lexicographic result order</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(V + E)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>V = number of unique characters</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>E = number of ordering relationships</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Linear in total input size</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>: O(V + E)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Adjacency list storage</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Additional data structures for sorting</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Recognize as graph problem</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Build graph from word comparisons</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Apply topological sorting</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle edge cases carefully</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Not checking prefix invalidation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Comparing entire words instead of first difference</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect cycle detection</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not handling disconnected components</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Cycle Detection Importance</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Contradictory ordering relationships</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Must detect and return empty string</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>DFS colors or Kahn’s count verification</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Multiple Valid Solutions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Problem allows any valid topological order</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Priority queue can ensure specific ordering</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>All solutions are equally correct</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: Multiple alien languages</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Weighted character relationships</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Streaming word updates</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Partial ordering verification</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Verify if given order is valid</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Find all possible alien orderings</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle streaming dictionary updates</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimize for very large dictionaries</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Compiler dependency resolution</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Task scheduling with prerequisites</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Package installation ordering</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Course prerequisite planning</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Build system dependency graphs</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Pattern Recognition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Constraint satisfaction problem</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>DAG construction from implicit relationships</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Topological ordering application</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Cycle detection in directed graphs
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>