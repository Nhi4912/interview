<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Ladder | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/">Tree graph</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Word ladder</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Word Ladder</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Tree/Graph</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Tree/Graph</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="word-ladder">Word Ladder</h1>

<p><strong>LeetCode Problem # * 127. Word Ladder</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Word Ladder</li>
    </ol>
  </li>
  <li></li>
  <li>A transformation sequence from word beginWord to word endWord using a dictionary wordList</li>
  <li>is a sequence of words beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk such that:</li>
  <li></li>
  <li>
    <ul>
      <li>Every adjacent pair of words differs by exactly one letter.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Every si for 1 &lt;= i &lt;= k is in wordList. Note that beginWord does not need to be in wordList.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>sk == endWord</li>
    </ul>
  </li>
  <li></li>
  <li>Given two words, beginWord and endWord, and a dictionary wordList, return the length of the</li>
  <li>shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: beginWord = “hit”, endWord = “cog”, wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]</li>
  <li>Output: 5</li>
  <li>Explanation: One shortest transformation sequence is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”, which is 5 words long.</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: beginWord = “hit”, endWord = “cog”, wordList = [“hot”,”dot”,”dog”,”lot”,”log”]</li>
  <li>Output: 0</li>
  <li>Explanation: The endWord “cog” is not in wordList, therefore there is no valid transformation sequence.</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>1 &lt;= beginWord.length &lt;= 10</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>endWord.length == beginWord.length</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>1 &lt;= wordList.length &lt;= 5000</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>wordList[i].length == beginWord.length</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>beginWord, endWord, and wordList[i] consist of lowercase English letters.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>beginWord != endWord</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>All the words in wordList are unique.
 */</li>
    </ul>
  </li>
</ul>

<p>// Solution 1: BFS (Breadth-First Search)
// Time: O(M²×N), Space: O(M²×N)
// M = length of each word, N = total number of words
export function ladderLength1(beginWord: string, endWord: string, wordList: string[]): number {
    const wordSet = new Set(wordList);
    if (!wordSet.has(endWord)) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>const queue: [string, number][] = [[beginWord, 1]];
const visited = new Set&lt;string&gt;();
visited.add(beginWord);

while (queue.length &gt; 0) {
    const [currentWord, level] = queue.shift()!;
    
    if (currentWord === endWord) {
        return level;
    }
    
    // Try changing each character
    for (let i = 0; i &lt; currentWord.length; i++) {
        for (let charCode = 97; charCode &lt;= 122; charCode++) { // 'a' to 'z'
            const newChar = String.fromCharCode(charCode);
            if (newChar === currentWord[i]) continue;
            
            const newWord = currentWord.slice(0, i) + newChar + currentWord.slice(i + 1);
            
            if (wordSet.has(newWord) &amp;&amp; !visited.has(newWord)) {
                visited.add(newWord);
                queue.push([newWord, level + 1]);
            }
        }
    }
}

return 0; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Bidirectional BFS
// Time: O(M²×N), Space: O(M²×N)
export function ladderLength2(beginWord: string, endWord: string, wordList: string[]): number {
    const wordSet = new Set(wordList);
    if (!wordSet.has(endWord)) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre>let beginSet = new Set([beginWord]);
let endSet = new Set([endWord]);
const visited = new Set&lt;string&gt;();
let level = 1;

while (beginSet.size &gt; 0 &amp;&amp; endSet.size &gt; 0) {
    // Always expand the smaller set for optimization
    if (beginSet.size &gt; endSet.size) {
        [beginSet, endSet] = [endSet, beginSet];
    }
    
    const nextSet = new Set&lt;string&gt;();
    
    for (const word of beginSet) {
        for (let i = 0; i &lt; word.length; i++) {
            for (let charCode = 97; charCode &lt;= 122; charCode++) {
                const newChar = String.fromCharCode(charCode);
                if (newChar === word[i]) continue;
                
                const newWord = word.slice(0, i) + newChar + word.slice(i + 1);
                
                if (endSet.has(newWord)) {
                    return level + 1;
                }
                
                if (wordSet.has(newWord) &amp;&amp; !visited.has(newWord)) {
                    visited.add(newWord);
                    nextSet.add(newWord);
                }
            }
        }
    }
    
    beginSet = nextSet;
    level++;
}

return 0; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: BFS with Pattern Matching
// Time: O(M²×N), Space: O(M²×N)
export function ladderLength3(beginWord: string, endWord: string, wordList: string[]): number {
    const wordSet = new Set(wordList);
    if (!wordSet.has(endWord)) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="rouge-code"><pre>// Build adjacency list using pattern matching
const patternMap = new Map&lt;string, string[]&gt;();
const allWords = [beginWord, ...wordList];

for (const word of allWords) {
    for (let i = 0; i &lt; word.length; i++) {
        const pattern = word.slice(0, i) + '*' + word.slice(i + 1);
        if (!patternMap.has(pattern)) {
            patternMap.set(pattern, []);
        }
        patternMap.get(pattern)!.push(word);
    }
}

const queue: [string, number][] = [[beginWord, 1]];
const visited = new Set&lt;string&gt;();
visited.add(beginWord);

while (queue.length &gt; 0) {
    const [currentWord, level] = queue.shift()!;
    
    if (currentWord === endWord) {
        return level;
    }
    
    // Check all patterns for current word
    for (let i = 0; i &lt; currentWord.length; i++) {
        const pattern = currentWord.slice(0, i) + '*' + currentWord.slice(i + 1);
        const neighbors = patternMap.get(pattern) || [];
        
        for (const neighbor of neighbors) {
            if (!visited.has(neighbor)) {
                visited.add(neighbor);
                queue.push([neighbor, level + 1]);
            }
        }
    }
}

return 0; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: DFS with Memoization
// Time: O(M²×N), Space: O(M²×N)
export function ladderLength4(beginWord: string, endWord: string, wordList: string[]): number {
    const wordSet = new Set(wordList);
    if (!wordSet.has(endWord)) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre>const memo = new Map&lt;string, number&gt;();

function canTransform(word1: string, word2: string): boolean {
    let diff = 0;
    for (let i = 0; i &lt; word1.length; i++) {
        if (word1[i] !== word2[i]) {
            diff++;
            if (diff &gt; 1) return false;
        }
    }
    return diff === 1;
}

function dfs(currentWord: string, visited: Set&lt;string&gt;): number {
    if (currentWord === endWord) return 1;
    
    const key = currentWord + '|' + Array.from(visited).sort().join(',');
    if (memo.has(key)) return memo.get(key)!;
    
    let minLength = Infinity;
    
    for (const word of wordSet) {
        if (!visited.has(word) &amp;&amp; canTransform(currentWord, word)) {
            visited.add(word);
            const length = dfs(word, visited);
            if (length !== Infinity) {
                minLength = Math.min(minLength, length + 1);
            }
            visited.delete(word);
        }
    }
    
    memo.set(key, minLength);
    return minLength;
}

const result = dfs(beginWord, new Set([beginWord]));
return result === Infinity ? 0 : result; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: A* Search Algorithm
// Time: O(M²×N log N), Space: O(M²×N)
export function ladderLength5(beginWord: string, endWord: string, wordList: string[]): number {
    const wordSet = new Set(wordList);
    if (!wordSet.has(endWord)) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="rouge-code"><pre>function heuristic(word1: string, word2: string): number {
    let diff = 0;
    for (let i = 0; i &lt; word1.length; i++) {
        if (word1[i] !== word2[i]) diff++;
    }
    return diff;
}

function getNeighbors(word: string): string[] {
    const neighbors: string[] = [];
    for (let i = 0; i &lt; word.length; i++) {
        for (let charCode = 97; charCode &lt;= 122; charCode++) {
            const newChar = String.fromCharCode(charCode);
            if (newChar === word[i]) continue;
            
            const newWord = word.slice(0, i) + newChar + word.slice(i + 1);
            if (wordSet.has(newWord)) {
                neighbors.push(newWord);
            }
        }
    }
    return neighbors;
}

// Priority queue: [fScore, gScore, word]
const openSet: [number, number, string][] = [[heuristic(beginWord, endWord), 0, beginWord]];
const gScore = new Map&lt;string, number&gt;();
gScore.set(beginWord, 0);

while (openSet.length &gt; 0) {
    // Find node with lowest fScore
    openSet.sort((a, b) =&gt; a[0] - b[0]);
    const [, g, current] = openSet.shift()!;
    
    if (current === endWord) {
        return g + 1;
    }
    
    const neighbors = getNeighbors(current);
    for (const neighbor of neighbors) {
        const tentativeG = g + 1;
        
        if (!gScore.has(neighbor) || tentativeG &lt; gScore.get(neighbor)!) {
            gScore.set(neighbor, tentativeG);
            const fScore = tentativeG + heuristic(neighbor, endWord);
            openSet.push([fScore, tentativeG, neighbor]);
        }
    }
}

return 0; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testLadderLength() {
    console.log(“Testing Word Ladder:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre>const testCases = [
    {
        beginWord: "hit",
        endWord: "cog",
        wordList: ["hot", "dot", "dog", "lot", "log", "cog"],
        expected: 5
    },
    {
        beginWord: "hit",
        endWord: "cog",
        wordList: ["hot", "dot", "dog", "lot", "log"],
        expected: 0
    },
    {
        beginWord: "a",
        endWord: "c",
        wordList: ["a", "b", "c"],
        expected: 2
    },
    {
        beginWord: "hot",
        endWord: "dog",
        wordList: ["hot", "dog"],
        expected: 0
    },
    {
        beginWord: "hot",
        endWord: "dog",
        wordList: ["hot", "hog", "dog"],
        expected: 3
    }
];

const solutions = [
    { name: "BFS", fn: ladderLength1 },
    { name: "Bidirectional BFS", fn: ladderLength2 },
    { name: "BFS with Patterns", fn: ladderLength3 },
    { name: "DFS with Memoization", fn: ladderLength4 },
    { name: "A* Search", fn: ladderLength5 }
];

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        const result = solution.fn(test.beginWord, test.endWord, test.wordList);
        const passed = result === test.expected;
        console.log(`  Test ${i + 1}: ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Expected: ${test.expected}`);
            console.log(`    Got: ${result}`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Graph Problem Recognition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Each word is a node</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Edge exists between words differing by exactly one character</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Find shortest path from beginWord to endWord</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>BFS vs DFS</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>BFS finds shortest path naturally (level-order traversal)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>DFS needs memoization to avoid exponential time</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>BFS preferred for shortest path problems</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimization Techniques</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Bidirectional BFS: Search from both ends</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Pattern matching: Pre-compute adjacency relationships</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>A* search: Use heuristic to guide search</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(M²×N)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>M = length of each word</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>N = number of words in wordList</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>For each word, try M×26 transformations</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>: O(M²×N)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Storing visited words and queue</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Pattern map in solution 3</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Recognize as shortest path problem</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Start with BFS approach</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimize with bidirectional search</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Discuss pattern matching optimization</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>endWord not in wordList</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>beginWord equals endWord</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>No transformation possible</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Single character words</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Focus</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: Often asks about optimization techniques</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Facebook: Focuses on bidirectional BFS</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Tests edge case handling</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Emphasizes clean code structure</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Return the actual transformation sequence</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Find all shortest transformation sequences</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle case-insensitive transformations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimize for multiple queries</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Using DFS without memoization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not checking if endWord exists in wordList</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect neighbor generation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Off-by-one errors in path length
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>