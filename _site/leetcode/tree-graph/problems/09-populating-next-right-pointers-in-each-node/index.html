<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Populating Next Right Pointers in Each Node | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/">Tree graph</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Populating next right pointers in each node</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Populating Next Right Pointers in Each Node</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Tree/Graph</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Tree/Graph</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="populating-next-right-pointers-in-each-node">Populating Next Right Pointers in Each Node</h1>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>and every parent has two children. Populate each next pointer to point to its next right node.  * If there is no next right node, the next pointer should be set to NULL.  *  *  * Companies: Amazon, Google, Microsoft, Facebook</li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>Populating Next Right Pointers in Each Node
 *</li>
  <li>Problem: You are given a perfect binary tree where all leaves are on the same level,</li>
  <li>and every parent has two children. Populate each next pointer to point to its next right node.</li>
  <li>If there is no next right node, the next pointer should be set to NULL.
 *</li>
  <li>LeetCode: https://leetcode.com/problems/populating-next-right-pointers-in-each-node/
 *</li>
  <li>Companies: Amazon, Google, Microsoft, Facebook
 *</li>
  <li>Difficulty: Medium
 *</li>
  <li>Key Concepts: Level-order traversal, pointer manipulation, BFS
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>Definition for a Node.
 */
class Node {
  val: number;
  left: Node | null;
  right: Node | null;
  next: Node | null;</li>
</ul>

<p>constructor(
    val: number = 0,
    left: Node | null = null,
    right: Node | null = null,
    next: Node | null = null
  ) {
    this.val = val;
    this.left = left;
    this.right = right;
    this.next = next;
  }
}</p>

<p>/**</p>
<ul>
  <li>Solution 1: Level-order Traversal with Queue (BFS)
 *</li>
  <li>Time Complexity: O(n) - Each node is visited once</li>
  <li>Space Complexity: O(w) - Where w is the maximum width of the tree
 *</li>
  <li>Approach:</li>
  <li>
    <ol>
      <li>Use BFS to traverse level by level</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>For each level, connect nodes from left to right</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>The last node in each level points to null
 *</li>
    </ol>
  </li>
  <li>Thuật toán:</li>
  <li>
    <ol>
      <li>Sử dụng BFS để duyệt từng cấp</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Với mỗi cấp, kết nối các nút từ trái sang phải</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Nút cuối cùng trong mỗi cấp trỏ đến null
 */
function connect(root: Node | null): Node | null {
  if (!root) return null;</li>
    </ol>
  </li>
</ul>

<p>const queue: Node[] = [root];</p>

<p>while (queue.length &gt; 0) {
    const levelSize = queue.length;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>for (let i = 0; i &lt; levelSize; i++) {
  const current = queue.shift()!;

  // Connect to next node in the same level
  if (i &lt; levelSize - 1) {
    current.next = queue[0];
  }

  // Add children to queue
  if (current.left) {
    queue.push(current.left);
  }
  if (current.right) {
    queue.push(current.right);
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return root;
}</p>

<p>/**</p>
<ul>
  <li>Solution 2: O(1) Space Approach (Optimal)
 *</li>
  <li>Time Complexity: O(n) - Each node is visited once</li>
  <li>Space Complexity: O(1) - Only using a few pointers
 *</li>
  <li>Approach:</li>
  <li>
    <ol>
      <li>Use the next pointers we’re creating to traverse the tree</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>For each node, connect its children</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Use the next pointer to move to the next node in the same level
 *</li>
    </ol>
  </li>
  <li>Thuật toán:</li>
  <li>
    <ol>
      <li>Sử dụng các con trỏ next đang tạo để duyệt cây</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Với mỗi nút, kết nối các con của nó</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Sử dụng con trỏ next để di chuyển đến nút tiếp theo trong cùng cấp
 */
function connectOptimal(root: Node | null): Node | null {
  if (!root) return null;</li>
    </ol>
  </li>
</ul>

<p>let leftmost = root;</p>

<p>// While we have a leftmost node (not a leaf)
  while (leftmost.left) {
    let current = leftmost;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>// Traverse the current level
while (current) {
  // Connect left child to right child
  current.left!.next = current.right;

  // Connect right child to next node's left child (if exists)
  if (current.next) {
    current.right!.next = current.next.left;
  }

  current = current.next;
}

// Move to the next level
leftmost = leftmost.left;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return root;
}</p>

<p>/**</p>
<ul>
  <li>Solution 3: Recursive Approach
 *</li>
  <li>Time Complexity: O(n) - Each node is visited once</li>
  <li>Space Complexity: O(h) - Height of the tree (recursion stack)
 *</li>
  <li>Approach:</li>
  <li>
    <ol>
      <li>Recursively connect nodes at each level</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Use the next pointers to traverse horizontally</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Connect children and their cousins
 *</li>
    </ol>
  </li>
  <li>Thuật toán:</li>
  <li>
    <ol>
      <li>Đệ quy kết nối các nút ở mỗi cấp</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Sử dụng con trỏ next để duyệt theo chiều ngang</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Kết nối các con và anh em họ của chúng
 */
function connectRecursive(root: Node | null): Node | null {
  if (!root) return null;</li>
    </ol>
  </li>
</ul>

<table>
  <tbody>
    <tr>
      <td>function connectLevel(node: Node</td>
      <td>null): void {</td>
      <td> </td>
    </tr>
    <tr>
      <td>if (!node</td>
      <td> </td>
      <td>!node.left) return;</td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>// Connect left child to right child
node.left.next = node.right;

// Connect right child to next node's left child (if exists)
if (node.next) {
  node.right!.next = node.next.left;
}

// Recursively connect next level
connectLevel(node.left);
connectLevel(node.right);   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>connectLevel(root);
  return root;
}</p>

<p>/**</p>
<ul>
  <li>Solution 4: DFS with Level Tracking
 *</li>
  <li>Time Complexity: O(n) - Each node is visited once</li>
  <li>Space Complexity: O(h) - Height of the tree (recursion stack)
 *</li>
  <li>Approach:</li>
  <li>
    <ol>
      <li>Use DFS to visit nodes in preorder</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Keep track of the rightmost node at each level</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Connect current node to the rightmost node at the same level
 *</li>
    </ol>
  </li>
  <li>Thuật toán:</li>
  <li>
    <ol>
      <li>Sử dụng DFS để thăm các nút theo thứ tự preorder</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Theo dõi nút ngoài cùng bên phải ở mỗi cấp</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Kết nối nút hiện tại với nút ngoài cùng bên phải ở cùng cấp
 */
function connectDFS(root: Node | null): Node | null {
  if (!root) return null;</li>
    </ol>
  </li>
</ul>

<p>const rightmost: Node[] = [];</p>

<p>function dfs(node: Node | null, level: number): void {
    if (!node) return;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>// If this is the rightmost node at this level
if (level &gt;= rightmost.length) {
  rightmost.push(node);
} else {
  // Connect to the rightmost node at this level
  rightmost[level].next = node;
  rightmost[level] = node;
}

dfs(node.left, level + 1);
dfs(node.right, level + 1);   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>dfs(root, 0);
  return root;
}</p>

<p>/**</p>
<ul>
  <li>Utility function to create a perfect binary tree from array
 */
function createPerfectBinaryTree(values: number[]): Node | null {
  if (values.length === 0) return null;</li>
</ul>

<p>const root = new Node(values[0]);
  const queue: Node[] = [root];
  let i = 1;</p>

<p>while (queue.length &gt; 0 &amp;&amp; i &lt; values.length) {
    const current = queue.shift()!;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>if (i &lt; values.length &amp;&amp; values[i] !== null) {
  current.left = new Node(values[i]);
  queue.push(current.left);
}
i++;

if (i &lt; values.length &amp;&amp; values[i] !== null) {
  current.right = new Node(values[i]);
  queue.push(current.right);
}
i++;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return root;
}</p>

<p>/**</p>
<ul>
  <li>Utility function to print tree with next pointers
 */
function printTreeWithNext(root: Node | null): void {
  if (!root) {
 console.log(“Empty tree”);
 return;
  }</li>
</ul>

<p>let current = root;
  let level = 0;</p>

<p>while (current) {
    console.log(<code class="language-plaintext highlighter-rouge">Level ${level}:</code>);
    let node = current;
    const levelNodes: (number | string)[] = [];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>while (node) {
  levelNodes.push(node.val);
  node = node.next;
}

console.log(levelNodes.join(" -&gt; "));
current = current.left;
level++;   } }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Utility function to verify next pointers
 */
function verifyNextPointers(root: Node | null): boolean {
  if (!root) return true;</li>
</ul>

<p>let current = root;</p>

<p>while (current) {
    let node = current;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>// Check if all nodes in this level are properly connected
while (node &amp;&amp; node.next) {
  if (node.next.val &lt;= node.val) {
    return false; // Next pointer should point to a node with greater value
  }
  node = node.next;
}

current = current.left;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return true;
}</p>

<p>// Test cases
function runTests(): void {
  console.log(“=== Testing Populating Next Right Pointers in Each Node ===\n”);</p>

<p>// Test Case 1: Simple perfect binary tree
  console.log(“Test Case 1: Simple perfect binary tree”);
  const values1 = [1, 2, 3, 4, 5, 6, 7];
  const tree1 = createPerfectBinaryTree(values1);</p>

<p>console.log(“Original tree:”);
  printTreeWithNext(tree1);</p>

<p>const result1 = connect(tree1);
  console.log(“\nAfter connecting:”);
  printTreeWithNext(result1);
  console.log(“Next pointers valid:”, verifyNextPointers(result1));
  console.log();</p>

<p>// Test Case 2: Single node
  console.log(“Test Case 2: Single node”);
  const values2 = [1];
  const tree2 = createPerfectBinaryTree(values2);</p>

<p>console.log(“Original tree:”);
  printTreeWithNext(tree2);</p>

<p>const result2 = connect(tree2);
  console.log(“\nAfter connecting:”);
  printTreeWithNext(result2);
  console.log(“Next pointers valid:”, verifyNextPointers(result2));
  console.log();</p>

<p>// Test Case 3: Larger perfect binary tree
  console.log(“Test Case 3: Larger perfect binary tree”);
  const values3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
  const tree3 = createPerfectBinaryTree(values3);</p>

<p>console.log(“Original tree:”);
  printTreeWithNext(tree3);</p>

<p>const result3 = connect(tree3);
  console.log(“\nAfter connecting:”);
  printTreeWithNext(result3);
  console.log(“Next pointers valid:”, verifyNextPointers(result3));
  console.log();</p>

<p>// Test Case 4: Empty tree
  console.log(“Test Case 4: Empty tree”);
  const tree4 = null;
  const result4 = connect(tree4);
  console.log(“Result:”, result4);
  console.log();</p>

<p>// Performance comparison
  console.log(“=== Performance Comparison ===”);</p>

<p>// Create a large perfect binary tree (15 levels = 2^15 - 1 nodes)
  const largeValues = Array.from({ length: 32767 }, (_, i) =&gt; i + 1);
  const largeTree = createPerfectBinaryTree(largeValues);</p>

<p>console.time(“BFS Approach”);
  connect(largeTree);
  console.timeEnd(“BFS Approach”);</p>

<p>const largeTree2 = createPerfectBinaryTree(largeValues);
  console.time(“Optimal O(1) Space Approach”);
  connectOptimal(largeTree2);
  console.timeEnd(“Optimal O(1) Space Approach”);</p>

<p>const largeTree3 = createPerfectBinaryTree(largeValues);
  console.time(“Recursive Approach”);
  connectRecursive(largeTree3);
  console.timeEnd(“Recursive Approach”);</p>

<p>const largeTree4 = createPerfectBinaryTree(largeValues);
  console.time(“DFS Approach”);
  connectDFS(largeTree4);
  console.timeEnd(“DFS Approach”);
}</p>

<p>// Run tests
runTests();</p>

<p>export { connect, connectOptimal, connectRecursive, connectDFS, Node };</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>