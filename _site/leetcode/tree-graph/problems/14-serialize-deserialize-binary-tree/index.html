<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serialize and Deserialize Binary Tree | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/">Tree graph</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Serialize and deserialize binary tree</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Serialize and Deserialize Binary Tree</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Tree/Graph</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Tree/Graph</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="serialize-and-deserialize-binary-tree">Serialize and Deserialize Binary Tree</h1>

<p><strong>LeetCode Problem # * 297. Serialize and Deserialize Binary Tree</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Serialize and Deserialize Binary Tree</li>
    </ol>
  </li>
  <li></li>
  <li>Serialization is the process of converting a data structure or object into a sequence of bits</li>
  <li>so that it can be stored in a file or memory buffer, or transmitted across a network connection</li>
  <li>link to be reconstructed later in the same or another computer environment.</li>
  <li></li>
  <li>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how</li>
  <li>your serialization/deserialization algorithm should work. You just need to ensure that a binary</li>
  <li>tree can be serialized to a string and this string can be deserialized to the original tree structure.</li>
  <li></li>
  <li>Clarification: The input/output format is the same as how LeetCode serializes a binary tree.</li>
  <li>You do not necessarily need to follow this format, so please be creative and come up with</li>
  <li>different approaches yourself.</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: root = [1,2,3,null,null,4,5]</li>
  <li>Output: [1,2,3,null,null,4,5]</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: root = []</li>
  <li>Output: []</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>The number of nodes in the tree is in the range [0, 10^4].</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>-1000 &lt;= Node.val &lt;= 1000
 */</li>
    </ul>
  </li>
</ul>

<p>// Definition for a binary tree node
class TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
    this.val = (val === undefined ? 0 : val);
    this.left = (left === undefined ? null : left);
    this.right = (right === undefined ? null : right);
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 1: Preorder Traversal (DFS)
// Time: O(n), Space: O(n)
export class Codec1 {
    serialize(root: TreeNode | null): string {
        const result: string[] = [];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre>    function preorder(node: TreeNode | null): void {
        if (!node) {
            result.push("null");
            return;
        }
        
        result.push(node.val.toString());
        preorder(node.left);
        preorder(node.right);
    }
    
    preorder(root);
    return result.join(",");
}

deserialize(data: string): TreeNode | null {
    const values = data.split(",");
    let index = 0;
    
    function buildTree(): TreeNode | null {
        if (index &gt;= values.length || values[index] === "null") {
            index++;
            return null;
        }
        
        const node = new TreeNode(parseInt(values[index]));
        index++;
        
        node.left = buildTree();
        node.right = buildTree();
        
        return node;
    }
    
    return buildTree();
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Level Order Traversal (BFS)
// Time: O(n), Space: O(n)
export class Codec2 {
    serialize(root: TreeNode | null): string {
        if (!root) return “”;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="rouge-code"><pre>    const result: string[] = [];
    const queue: (TreeNode | null)[] = [root];
    
    while (queue.length &gt; 0) {
        const node = queue.shift()!;
        
        if (node) {
            result.push(node.val.toString());
            queue.push(node.left);
            queue.push(node.right);
        } else {
            result.push("null");
        }
    }
    
    // Remove trailing nulls
    while (result.length &gt; 0 &amp;&amp; result[result.length - 1] === "null") {
        result.pop();
    }
    
    return result.join(",");
}

deserialize(data: string): TreeNode | null {
    if (!data) return null;
    
    const values = data.split(",");
    const root = new TreeNode(parseInt(values[0]));
    const queue: TreeNode[] = [root];
    let i = 1;
    
    while (queue.length &gt; 0 &amp;&amp; i &lt; values.length) {
        const node = queue.shift()!;
        
        // Process left child
        if (i &lt; values.length &amp;&amp; values[i] !== "null") {
            node.left = new TreeNode(parseInt(values[i]));
            queue.push(node.left);
        }
        i++;
        
        // Process right child
        if (i &lt; values.length &amp;&amp; values[i] !== "null") {
            node.right = new TreeNode(parseInt(values[i]));
            queue.push(node.right);
        }
        i++;
    }
    
    return root;
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Postorder Traversal
// Time: O(n), Space: O(n)
export class Codec3 {
    serialize(root: TreeNode | null): string {
        const result: string[] = [];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre>    function postorder(node: TreeNode | null): void {
        if (!node) {
            result.push("null");
            return;
        }
        
        postorder(node.left);
        postorder(node.right);
        result.push(node.val.toString());
    }
    
    postorder(root);
    return result.join(",");
}

deserialize(data: string): TreeNode | null {
    const values = data.split(",");
    let index = values.length - 1;
    
    function buildTree(): TreeNode | null {
        if (index &lt; 0 || values[index] === "null") {
            index--;
            return null;
        }
        
        const node = new TreeNode(parseInt(values[index]));
        index--;
        
        // Note: in postorder, we build right first, then left
        node.right = buildTree();
        node.left = buildTree();
        
        return node;
    }
    
    return buildTree();
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Parentheses Representation
// Time: O(n), Space: O(n)
export class Codec4 {
    serialize(root: TreeNode | null): string {
        if (!root) return “”;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre>    function helper(node: TreeNode | null): string {
        if (!node) return "()";
        
        const left = helper(node.left);
        const right = helper(node.right);
        
        return `(${node.val}${left}${right})`;
    }
    
    return helper(root);
}

deserialize(data: string): TreeNode | null {
    if (!data) return null;
    
    let index = 0;
    
    function helper(): TreeNode | null {
        if (index &gt;= data.length || data[index] !== '(') {
            return null;
        }
        
        index++; // Skip '('
        
        if (data[index] === ')') {
            index++; // Skip ')'
            return null;
        }
        
        // Parse value
        let val = "";
        while (index &lt; data.length &amp;&amp; data[index] !== '(' &amp;&amp; data[index] !== ')') {
            val += data[index];
            index++;
        }
        
        const node = new TreeNode(parseInt(val));
        node.left = helper();
        node.right = helper();
        
        index++; // Skip ')'
        return node;
    }
    
    return helper();
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Compact Binary Representation
// Time: O(n), Space: O(n)
export class Codec5 {
    serialize(root: TreeNode | null): string {
        const result: number[] = [];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre>    function encode(node: TreeNode | null): void {
        if (!node) {
            result.push(0); // Use 0 to represent null
            return;
        }
        
        // Encode non-null with value + offset to handle negative numbers
        result.push(node.val + 1001); // Offset by 1001 (since -1000 &lt;= val &lt;= 1000)
        encode(node.left);
        encode(node.right);
    }
    
    encode(root);
    return result.join(",");
}

deserialize(data: string): TreeNode | null {
    if (!data) return null;
    
    const values = data.split(",").map(Number);
    let index = 0;
    
    function decode(): TreeNode | null {
        if (index &gt;= values.length || values[index] === 0) {
            index++;
            return null;
        }
        
        const node = new TreeNode(values[index] - 1001); // Restore original value
        index++;
        
        node.left = decode();
        node.right = decode();
        
        return node;
    }
    
    return decode();
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 6: Morris-like Encoding (Advanced)
// Time: O(n), Space: O(1) for serialization, O(n) for deserialization
export class Codec6 {
    serialize(root: TreeNode | null): string {
        if (!root) return “”;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre>    const result: string[] = [];
    const stack: [TreeNode | null, number][] = [[root, 0]]; // [node, state]
    
    while (stack.length &gt; 0) {
        const [node, state] = stack.pop()!;
        
        if (!node) {
            result.push("null");
            continue;
        }
        
        if (state === 0) {
            // First visit: process value and push children
            result.push(node.val.toString());
            stack.push([node, 1]); // Mark as processed
            stack.push([node.right, 0]);
            stack.push([node.left, 0]);
        }
    }
    
    return result.join(",");
}

deserialize(data: string): TreeNode | null {
    if (!data) return null;
    
    const values = data.split(",");
    let index = 0;
    
    function buildTree(): TreeNode | null {
        if (index &gt;= values.length || values[index] === "null") {
            index++;
            return null;
        }
        
        const node = new TreeNode(parseInt(values[index]));
        index++;
        
        node.left = buildTree();
        node.right = buildTree();
        
        return node;
    }
    
    return buildTree();
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testSerializeDeserialize() {
    console.log(“Testing Serialize and Deserialize Binary Tree:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="rouge-code"><pre>// Helper function to create test tree
function createTree(): TreeNode {
    const root = new TreeNode(1);
    root.left = new TreeNode(2);
    root.right = new TreeNode(3);
    root.right.left = new TreeNode(4);
    root.right.right = new TreeNode(5);
    return root;
}

// Helper function to compare trees
function treesEqual(t1: TreeNode | null, t2: TreeNode | null): boolean {
    if (!t1 &amp;&amp; !t2) return true;
    if (!t1 || !t2) return false;
    return t1.val === t2.val &amp;&amp; 
           treesEqual(t1.left, t2.left) &amp;&amp; 
           treesEqual(t1.right, t2.right);
}

const codecs = [
    { name: "Preorder DFS", codec: new Codec1() },
    { name: "Level Order BFS", codec: new Codec2() },
    { name: "Postorder", codec: new Codec3() },
    { name: "Parentheses", codec: new Codec4() },
    { name: "Compact Binary", codec: new Codec5() },
    { name: "Morris-like", codec: new Codec6() }
];

const testCases = [
    { name: "Normal Tree", tree: createTree() },
    { name: "Empty Tree", tree: null },
    { name: "Single Node", tree: new TreeNode(1) },
    { 
        name: "Left Skewed", 
        tree: (() =&gt; {
            const root = new TreeNode(1);
            root.left = new TreeNode(2);
            root.left.left = new TreeNode(3);
            return root;
        })()
    }
];

codecs.forEach(codecInfo =&gt; {
    console.log(`\n${codecInfo.name}:`);
    
    testCases.forEach(test =&gt; {
        try {
            const serialized = codecInfo.codec.serialize(test.tree);
            const deserialized = codecInfo.codec.deserialize(serialized);
            const passed = treesEqual(test.tree, deserialized);
            
            console.log(`  ${test.name}: ${passed ? 'PASS' : 'FAIL'}`);
            if (passed) {
                console.log(`    Serialized: ${serialized.length &gt; 50 ? serialized.substring(0, 50) + '...' : serialized}`);
            }
        } catch (error) {
            console.log(`  ${test.name}: FAIL (Error: ${error})`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Serialization Strategies</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Preorder: Root -&gt; Left -&gt; Right (most common)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Level order: BFS traversal (LeetCode format)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Postorder: Left -&gt; Right -&gt; Root</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Custom formats: Parentheses, binary encoding</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Preorder Advantage</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Natural recursive structure</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Easy to implement both directions</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Matches tree construction pattern</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Level Order Advantage</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Matches standard tree representations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Good for visualization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Can optimize trailing nulls</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Null Handling</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Must represent null nodes for structure preservation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Different approaches: “null”, “0”, special markers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Trade-off between size and simplicity</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(n)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Must visit each node exactly once</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Both serialization and deserialization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Cannot be optimized further</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>: O(n)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Serialized string size: O(n)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Recursion stack: O(h) where h is height</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Additional data structures: O(n)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with preorder approach</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Explain null handling clearly</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Code both serialize and deserialize</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Test with edge cases</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Empty tree (null root)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Single node tree</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Skewed trees (all left or all right)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Negative values</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimization Considerations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>String vs binary format</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Compression techniques</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory usage minimization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Parse efficiency</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Forgetting to handle null nodes</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect parsing of negative numbers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Wrong order in postorder reconstruction</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not maintaining global index properly</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: N-ary tree serialization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Serialize with metadata</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Space-optimized formats</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Streaming serialization</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Serialize N-ary trees</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle very large trees (streaming)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Compress the serialized format</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Serialize with additional node properties</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Database index serialization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Network data transmission</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>File format design</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Caching and persistence</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Distributed systems communication</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Format Trade-offs</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Human readable vs compact</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Parse speed vs size</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Error detection capabilities</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Version compatibility</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Advanced Techniques</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Huffman coding for compression</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Delta encoding for similar values</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Schema evolution support</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Checksums for integrity
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>