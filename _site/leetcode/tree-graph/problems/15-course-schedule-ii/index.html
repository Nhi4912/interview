<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Schedule II | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/">Tree graph</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/tree-graph/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Course schedule ii</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Course Schedule II</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Tree/Graph</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Tree/Graph</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                                    <span class="tag">Sorting</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="course-schedule-ii">Course Schedule II</h1>

<p><strong>LeetCode Problem # * 210. Course Schedule II</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Course Schedule II</li>
    </ol>
  </li>
  <li></li>
  <li>There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1.</li>
  <li>You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you</li>
  <li>must take course bi first if you want to take course ai.</li>
  <li></li>
  <li>For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.</li>
  <li>Return the ordering of courses you should take to finish all courses. If there are many valid</li>
  <li>answers, return any of them. If it is impossible to finish all courses, return an empty array.</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: numCourses = 2, prerequisites = [[1,0]]</li>
  <li>Output: [0,1]</li>
  <li>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</li>
  <li>Output: [0,2,1,3]</li>
  <li>Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.</li>
  <li>So one correct course order is [0,2,1,3]. Another correct ordering is [0,1,2,3].</li>
  <li></li>
  <li>Example 3:</li>
  <li>Input: numCourses = 1, prerequisites = []</li>
  <li>Output: [0]</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>1 &lt;= numCourses &lt;= 2000</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>prerequisites[i].length == 2</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>0 &lt;= ai, bi &lt; numCourses</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>ai != bi</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>All the pairs [ai, bi] are distinct.
 */</li>
    </ul>
  </li>
</ul>

<p>// Solution 1: Kahn’s Algorithm (BFS-based Topological Sort)
// Time: O(V + E), Space: O(V + E)
export function findOrder1(numCourses: number, prerequisites: number[][]): number[] {
    // Build adjacency list and in-degree array
    const graph: number[][] = Array(numCourses).fill(null).map(() =&gt; []);
    const inDegree = new Array(numCourses).fill(0);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre>for (const [course, prereq] of prerequisites) {
    graph[prereq].push(course);
    inDegree[course]++;
}

// Initialize queue with courses having no prerequisites
const queue: number[] = [];
for (let i = 0; i &lt; numCourses; i++) {
    if (inDegree[i] === 0) {
        queue.push(i);
    }
}

const result: number[] = [];

while (queue.length &gt; 0) {
    const course = queue.shift()!;
    result.push(course);
    
    // Process all courses that depend on current course
    for (const nextCourse of graph[course]) {
        inDegree[nextCourse]--;
        
        if (inDegree[nextCourse] === 0) {
            queue.push(nextCourse);
        }
    }
}

// Check if all courses can be completed
return result.length === numCourses ? result : []; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: DFS-based Topological Sort
// Time: O(V + E), Space: O(V + E)
export function findOrder2(numCourses: number, prerequisites: number[][]): number[] {
    // Build adjacency list
    const graph: number[][] = Array(numCourses).fill(null).map(() =&gt; []);
    for (const [course, prereq] of prerequisites) {
        graph[prereq].push(course);
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre>const WHITE = 0; // Unvisited
const GRAY = 1;  // Visiting (in current path)
const BLACK = 2; // Visited (completed)

const colors = new Array(numCourses).fill(WHITE);
const result: number[] = [];

function dfs(course: number): boolean {
    if (colors[course] === GRAY) {
        // Cycle detected
        return false;
    }
    
    if (colors[course] === BLACK) {
        // Already processed
        return true;
    }
    
    // Mark as visiting
    colors[course] = GRAY;
    
    // Visit all dependencies
    for (const nextCourse of graph[course]) {
        if (!dfs(nextCourse)) {
            return false;
        }
    }
    
    // Mark as completed and add to result
    colors[course] = BLACK;
    result.push(course);
    
    return true;
}

// Process all courses
for (let i = 0; i &lt; numCourses; i++) {
    if (colors[i] === WHITE &amp;&amp; !dfs(i)) {
        return []; // Cycle detected
    }
}

// Reverse to get correct topological order
return result.reverse(); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: DFS with Explicit Stack
// Time: O(V + E), Space: O(V + E)
export function findOrder3(numCourses: number, prerequisites: number[][]): number[] {
    // Build adjacency list
    const graph: number[][] = Array(numCourses).fill(null).map(() =&gt; []);
    for (const [course, prereq] of prerequisites) {
        graph[prereq].push(course);
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre>const visited = new Set&lt;number&gt;();
const visiting = new Set&lt;number&gt;();
const result: number[] = [];

function hasNoCycle(course: number): boolean {
    if (visiting.has(course)) {
        return false; // Cycle detected
    }
    
    if (visited.has(course)) {
        return true; // Already processed
    }
    
    visiting.add(course);
    
    for (const nextCourse of graph[course]) {
        if (!hasNoCycle(nextCourse)) {
            return false;
        }
    }
    
    visiting.delete(course);
    visited.add(course);
    result.push(course);
    
    return true;
}

// Check all courses
for (let i = 0; i &lt; numCourses; i++) {
    if (!visited.has(i) &amp;&amp; !hasNoCycle(i)) {
        return [];
    }
}

return result.reverse(); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Modified Kahn’s with Priority Queue (Lexicographic Order)
// Time: O(V log V + E), Space: O(V + E)
export function findOrder4(numCourses: number, prerequisites: number[][]): number[] {
    // Build adjacency list and in-degree array
    const graph: number[][] = Array(numCourses).fill(null).map(() =&gt; []);
    const inDegree = new Array(numCourses).fill(0);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
</pre></td><td class="rouge-code"><pre>for (const [course, prereq] of prerequisites) {
    graph[prereq].push(course);
    inDegree[course]++;
}

// Use a min heap to ensure lexicographic order
class MinHeap {
    heap: number[] = [];
    
    push(val: number): void {
        this.heap.push(val);
        this.heapifyUp(this.heap.length - 1);
    }
    
    pop(): number | undefined {
        if (this.heap.length === 0) return undefined;
        
        const min = this.heap[0];
        const last = this.heap.pop()!;
        
        if (this.heap.length &gt; 0) {
            this.heap[0] = last;
            this.heapifyDown(0);
        }
        
        return min;
    }
    
    isEmpty(): boolean {
        return this.heap.length === 0;
    }
    
    private heapifyUp(idx: number): void {
        while (idx &gt; 0) {
            const parentIdx = Math.floor((idx - 1) / 2);
            if (this.heap[parentIdx] &lt;= this.heap[idx]) break;
            
            [this.heap[parentIdx], this.heap[idx]] = [this.heap[idx], this.heap[parentIdx]];
            idx = parentIdx;
        }
    }
    
    private heapifyDown(idx: number): void {
        while (true) {
            let minIdx = idx;
            const leftChild = 2 * idx + 1;
            const rightChild = 2 * idx + 2;
            
            if (leftChild &lt; this.heap.length &amp;&amp; this.heap[leftChild] &lt; this.heap[minIdx]) {
                minIdx = leftChild;
            }
            
            if (rightChild &lt; this.heap.length &amp;&amp; this.heap[rightChild] &lt; this.heap[minIdx]) {
                minIdx = rightChild;
            }
            
            if (minIdx === idx) break;
            
            [this.heap[idx], this.heap[minIdx]] = [this.heap[minIdx], this.heap[idx]];
            idx = minIdx;
        }
    }
}

const pq = new MinHeap();

// Add all courses with no prerequisites
for (let i = 0; i &lt; numCourses; i++) {
    if (inDegree[i] === 0) {
        pq.push(i);
    }
}

const result: number[] = [];

while (!pq.isEmpty()) {
    const course = pq.pop()!;
    result.push(course);
    
    // Process all dependent courses
    for (const nextCourse of graph[course]) {
        inDegree[nextCourse]--;
        
        if (inDegree[nextCourse] === 0) {
            pq.push(nextCourse);
        }
    }
}

return result.length === numCourses ? result : []; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Union-Find with Topological Sort
// Time: O(V + E), Space: O(V + E)
export function findOrder5(numCourses: number, prerequisites: number[][]): number[] {
    // First check for cycles using Union-Find
    class UnionFind {
        parent: number[];
        rank: number[];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre></td><td class="rouge-code"><pre>    constructor(n: number) {
        this.parent = Array.from({ length: n }, (_, i) =&gt; i);
        this.rank = new Array(n).fill(0);
    }
    
    find(x: number): number {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }
    
    union(x: number, y: number): boolean {
        const rootX = this.find(x);
        const rootY = this.find(y);
        
        if (rootX === rootY) return false; // Would create cycle
        
        if (this.rank[rootX] &lt; this.rank[rootY]) {
            this.parent[rootX] = rootY;
        } else if (this.rank[rootX] &gt; this.rank[rootY]) {
            this.parent[rootY] = rootX;
        } else {
            this.parent[rootY] = rootX;
            this.rank[rootX]++;
        }
        
        return true;
    }
}

// Build adjacency list
const graph: number[][] = Array(numCourses).fill(null).map(() =&gt; []);
const inDegree = new Array(numCourses).fill(0);

for (const [course, prereq] of prerequisites) {
    graph[prereq].push(course);
    inDegree[course]++;
}

// Use Kahn's algorithm for topological sort
const queue: number[] = [];
for (let i = 0; i &lt; numCourses; i++) {
    if (inDegree[i] === 0) {
        queue.push(i);
    }
}

const result: number[] = [];

while (queue.length &gt; 0) {
    const course = queue.shift()!;
    result.push(course);
    
    for (const nextCourse of graph[course]) {
        inDegree[nextCourse]--;
        
        if (inDegree[nextCourse] === 0) {
            queue.push(nextCourse);
        }
    }
}

return result.length === numCourses ? result : []; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testFindOrder() {
    console.log(“Testing Course Schedule II:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="rouge-code"><pre>const testCases = [
    {
        numCourses: 2,
        prerequisites: [[1, 0]],
        expectedLength: 2,
        description: "Simple dependency"
    },
    {
        numCourses: 4,
        prerequisites: [[1, 0], [2, 0], [3, 1], [3, 2]],
        expectedLength: 4,
        description: "Multiple dependencies"
    },
    {
        numCourses: 1,
        prerequisites: [],
        expectedLength: 1,
        description: "Single course"
    },
    {
        numCourses: 2,
        prerequisites: [[1, 0], [0, 1]],
        expectedLength: 0,
        description: "Circular dependency"
    },
    {
        numCourses: 3,
        prerequisites: [[0, 1], [0, 2], [1, 2]],
        expectedLength: 3,
        description: "Diamond dependency"
    }
];

const solutions = [
    { name: "Kahn's Algorithm", fn: findOrder1 },
    { name: "DFS Topological", fn: findOrder2 },
    { name: "DFS with Stack", fn: findOrder3 },
    { name: "Priority Queue", fn: findOrder4 },
    { name: "Union-Find + Kahn", fn: findOrder5 }
];

function isValidOrder(order: number[], numCourses: number, prerequisites: number[][]): boolean {
    if (order.length !== numCourses) return false;
    
    const position = new Map&lt;number, number&gt;();
    for (let i = 0; i &lt; order.length; i++) {
        position.set(order[i], i);
    }
    
    for (const [course, prereq] of prerequisites) {
        if (!position.has(course) || !position.has(prereq)) return false;
        if (position.get(prereq)! &gt;= position.get(course)!) return false;
    }
    
    return true;
}

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        const result = solution.fn(test.numCourses, test.prerequisites);
        
        let passed = false;
        if (test.expectedLength === 0) {
            passed = result.length === 0;
        } else {
            passed = isValidOrder(result, test.numCourses, test.prerequisites);
        }
        
        console.log(`  Test ${i + 1} (${test.description}): ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Result: ${JSON.stringify(result)}`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Problem Recognition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Topological sorting of directed acyclic graph (DAG)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Must detect cycles (impossible to complete courses)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Multiple valid orderings possible</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Kahn’s Algorithm</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>BFS-based approach</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Start with nodes having in-degree 0</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Remove edges as nodes are processed</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Cycle detection: not all nodes processed</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>DFS Approach</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Post-order traversal gives reverse topological order</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Three colors: White (unvisited), Gray (visiting), Black (visited)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Gray nodes in path indicate cycle</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(V + E)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>V = numCourses, E = prerequisites</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Each vertex and edge processed once</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimal for this problem</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>: O(V + E)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Adjacency list: O(E)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Additional arrays/sets: O(V)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Recursion stack: O(V) in worst case</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Cycle Detection</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Kahn’s: Count processed nodes</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>DFS: Detect back edges (gray → gray)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Both approaches handle cycles effectively</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Recognize as topological sort problem</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Choose approach (Kahn’s or DFS)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Implement cycle detection</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle edge cases</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>No prerequisites (all courses independent)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Circular dependencies (no valid order)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Single course</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Self-dependencies (should not occur per constraints)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Algorithm Comparison</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Kahn’s: More intuitive, iterative</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>DFS: Recursive, elegant for some</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Both have same complexity</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Wrong direction of edges in graph</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Forgetting to reverse DFS result</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect cycle detection logic</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not handling disconnected components</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimizations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Priority queue for lexicographic order</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Early termination on cycle detection</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory-efficient representations</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: Build order with priorities</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Dependency resolution in systems</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Package installation order</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Build pipeline optimization</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Find minimum number of semesters</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Multiple valid orders, return specific one</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Weighted dependencies (time/cost)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Dynamic dependency updates</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Course scheduling systems</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Build dependency resolution</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Task scheduling with dependencies</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Package manager installations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Makefile dependency tracking</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Graph Theory Context</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>DAG property essential</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Topological sort uniqueness</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Strongly connected components</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Critical path analysis
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>