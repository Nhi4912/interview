<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serialize and Deserialize Binary Tree | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/design/">Design</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/design/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Serialize and deserialize binary tree</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Serialize and Deserialize Binary Tree</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Design</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Design</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="serialize-and-deserialize-binary-tree">Serialize and Deserialize Binary Tree</h1>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>
    <ul>
      <li>Serialization is the process of converting a data structure or object into a sequence  * of bits so that it can be stored in a file or memory buffer, or transmitted across a  * network connection link to be reconstructed later in the same or another computer environment.  *</li>
    </ul>
  </li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>Serialize and Deserialize Binary Tree
 *</li>
  <li>Problem: https://leetcode.com/problems/serialize-and-deserialize-binary-tree/
 *</li>
  <li>Serialization is the process of converting a data structure or object into a sequence</li>
  <li>of bits so that it can be stored in a file or memory buffer, or transmitted across a</li>
  <li>network connection link to be reconstructed later in the same or another computer environment.
 *</li>
  <li>Design an algorithm to serialize and deserialize a binary tree. There is no restriction</li>
  <li>on how your serialization/deserialization algorithm should work. You just need to ensure</li>
  <li>that a binary tree can be serialized to a string and this string can be deserialized to</li>
  <li>the original tree structure.
 *</li>
  <li>Example 1:</li>
  <li>Input: root = [1,2,3,null,null,4,5]</li>
  <li>Output: [1,2,3,null,null,4,5]
 *</li>
  <li>Example 2:</li>
  <li>Input: root = []</li>
  <li>Output: []
 *</li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>The number of nodes in the tree is in the range [0, 10^4].</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>-1000 &lt;= Node.val &lt;= 1000
 *</li>
    </ul>
  </li>
  <li>Solution Approach:</li>
  <li>
    <ol>
      <li>Preorder traversal with null markers</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Level-order traversal (BFS) with null markers</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Use special characters to represent null nodes</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Parse the string back to reconstruct the tree
 *</li>
    </ol>
  </li>
  <li>Time Complexity: O(n) for both serialization and deserialization</li>
  <li>Space Complexity: O(n) for storing the serialized string
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>TreeNode class definition
 *</li>
  <li>Định nghĩa lớp TreeNode
 */
class TreeNode {
  val: number;
  left: TreeNode | null;
  right: TreeNode | null;</li>
</ul>

<p>constructor(
    val: number = 0,
    left: TreeNode | null = null,
    right: TreeNode | null = null
  ) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}</p>

<p>/**</p>
<ul>
  <li>Serialize and Deserialize Binary Tree - Preorder Solution
 *</li>
  <li>Giải pháp duyệt tiền thứ tự cho bài toán Tuần tự hóa và giải tuần tự hóa cây nhị phân
 */
class Codec {
  /**
    <ul>
      <li>Serialize a binary tree to a string using preorder traversal
*</li>
      <li>Tuần tự hóa cây nhị phân thành chuỗi sử dụng duyệt tiền thứ tự
*</li>
      <li>@param root - Root of the binary tree</li>
      <li>@returns Serialized string representation
*/
serialize(root: TreeNode | null): string {
 if (!root) return “null”;</li>
    </ul>

    <p>const left = this.serialize(root.left);
 const right = this.serialize(root.right);</p>

    <p>return <code class="language-plaintext highlighter-rouge">${root.val},${left},${right}</code>;
  }</p>
  </li>
</ul>

<p>/**</p>
<ul>
  <li>Deserialize a string back to a binary tree
   *</li>
  <li>Giải tuần tự hóa chuỗi về cây nhị phân
   *</li>
  <li>@param data - Serialized string</li>
  <li>@returns Root of the reconstructed binary tree
   */
  deserialize(data: string): TreeNode | null {
    const values = data.split(“,”);
    let index = 0;</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>function deserializeHelper(): TreeNode | null {
  if (index &gt;= values.length || values[index] === "null") {
    index++;
    return null;
  }

  const val = parseInt(values[index]);
  index++;

  const node = new TreeNode(val);
  node.left = deserializeHelper();
  node.right = deserializeHelper();

  return node;
}

return deserializeHelper();   } }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Alternative Solution: Level-order (BFS) Serialization
 *</li>
  <li>
    <p>Giải pháp thay thế: Tuần tự hóa theo thứ tự mức (BFS)
 */
class CodecBFS {
  serialize(root: TreeNode | null): string {
 if (!root) return “[]”;</p>

    <table>
      <tbody>
        <tr>
          <td>const queue: (TreeNode</td>
          <td>null)[] = [root];</td>
        </tr>
        <tr>
          <td>const result: (number</td>
          <td>null)[] = [];</td>
        </tr>
      </tbody>
    </table>

    <p>while (queue.length &gt; 0) {
   const node = queue.shift()!;</p>

    <p>if (node === null) {
     result.push(null);
   } else {
     result.push(node.val);
     queue.push(node.left);
     queue.push(node.right);
   }
 }</p>

    <p>// Remove trailing nulls
 while (result.length &gt; 0 &amp;&amp; result[result.length - 1] === null) {
   result.pop();
 }</p>

    <p>return JSON.stringify(result);
  }</p>
  </li>
</ul>

<p>deserialize(data: string): TreeNode | null {
    if (data === “[]”) return null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>const values: (number | null)[] = JSON.parse(data);
if (values.length === 0) return null;

const root = new TreeNode(values[0]!);
const queue: TreeNode[] = [root];
let i = 1;

while (queue.length &gt; 0 &amp;&amp; i &lt; values.length) {
  const node = queue.shift()!;

  // Left child
  if (i &lt; values.length &amp;&amp; values[i] !== null) {
    node.left = new TreeNode(values[i]!);
    queue.push(node.left);
  }
  i++;

  // Right child
  if (i &lt; values.length &amp;&amp; values[i] !== null) {
    node.right = new TreeNode(values[i]!);
    queue.push(node.right);
  }
  i++;
}

return root;   } }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Solution with Compact Representation
 *</li>
  <li>
    <p>Giải pháp với biểu diễn gọn
 */
class CodecCompact {
  serialize(root: TreeNode | null): string {
 if (!root) return “#”;</p>

    <p>const left = this.serialize(root.left);
 const right = this.serialize(root.right);</p>

    <p>return <code class="language-plaintext highlighter-rouge">${root.val}(${left})(${right})</code>;
  }</p>
  </li>
</ul>

<p>deserialize(data: string): TreeNode | null {
    if (data === “#”) return null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre>let index = 0;

function parseValue(): number {
  let value = "";
  while (index &lt; data.length &amp;&amp; data[index] !== "(") {
    value += data[index];
    index++;
  }
  return parseInt(value);
}

function parseSubtree(): TreeNode | null {
  if (data[index] === "#") {
    index++;
    return null;
  }

  const val = parseValue();
  const node = new TreeNode(val);

  if (data[index] === "(") {
    index++; // skip '('
    node.left = parseSubtree();
    index++; // skip ')'

    index++; // skip '('
    node.right = parseSubtree();
    index++; // skip ')'
  }

  return node;
}

return parseSubtree();   } }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Solution with Tree Visualization
 *</li>
  <li>Giải pháp với hiển thị cây
 */
class CodecWithVisualization {
  serialize(root: TreeNode | null): string {
 return new Codec().serialize(root);
  }</li>
</ul>

<p>deserialize(data: string): TreeNode | null {
    return new Codec().deserialize(data);
  }</p>

<p>/**</p>
<ul>
  <li>Visualize the tree structure
   *</li>
  <li>Hiển thị cấu trúc cây
   *</li>
  <li>@param root - Root of the tree</li>
  <li>@returns String representation of the tree
   */
  visualizeTree(root: TreeNode | null): string {
    if (!root) return “Empty tree”;</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>const result: string[] = [];

function visualizeHelper(
  node: TreeNode | null,
  prefix: string,
  isLeft: boolean
): void {
  if (!node) return;

  result.push(`${prefix}${isLeft ? "├── " : "└── "}${node.val}`);

  const newPrefix = prefix + (isLeft ? "│   " : "    ");

  if (node.left || node.right) {
    if (node.left) {
      visualizeHelper(node.left, newPrefix, true);
    }
    if (node.right) {
      visualizeHelper(node.right, newPrefix, false);
    }
  }
}

result.push(`${root.val}`);
if (root.left) visualizeHelper(root.left, "", true);
if (root.right) visualizeHelper(root.right, "", false);

return result.join("\n");   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Compare two trees for equality
   *</li>
  <li>So sánh hai cây có bằng nhau không
   *</li>
  <li>@param tree1 - First tree</li>
  <li>@param tree2 - Second tree</li>
  <li>@returns true if trees are equal
   */
  areTreesEqual(tree1: TreeNode | null, tree2: TreeNode | null): boolean {
    if (!tree1 &amp;&amp; !tree2) return true;
    if (!tree1 || !tree2) return false;</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>return (
  tree1.val === tree2.val &amp;&amp;
  this.areTreesEqual(tree1.left, tree2.left) &amp;&amp;
  this.areTreesEqual(tree1.right, tree2.right)
);   } }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Utility function to create a binary tree from array
 *</li>
  <li>Hàm tiện ích để tạo cây nhị phân từ mảng
 *</li>
  <li>@param arr - Array representation of the tree</li>
  <li>@returns Root of the created tree
 */
function createTreeFromArray(arr: (number | null)[]): TreeNode | null {
  if (arr.length === 0 || arr[0] === null) return null;</li>
</ul>

<p>const root = new TreeNode(arr[0]!);
  const queue: TreeNode[] = [root];
  let i = 1;</p>

<p>while (queue.length &gt; 0 &amp;&amp; i &lt; arr.length) {
    const node = queue.shift()!;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>// Left child
if (i &lt; arr.length &amp;&amp; arr[i] !== null) {
  node.left = new TreeNode(arr[i]!);
  queue.push(node.left);
}
i++;

// Right child
if (i &lt; arr.length &amp;&amp; arr[i] !== null) {
  node.right = new TreeNode(arr[i]!);
  queue.push(node.right);
}
i++;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return root;
}</p>

<p>/**</p>
<ul>
  <li>Utility function to convert tree to array
 *</li>
  <li>Hàm tiện ích để chuyển cây thành mảng
 *</li>
  <li>@param root - Root of the tree</li>
  <li>@returns Array representation of the tree
 */
function treeToArray(root: TreeNode | null): (number | null)[] {
  if (!root) return [];</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>const result: (number</td>
      <td>null)[] = [];</td>
    </tr>
    <tr>
      <td>const queue: (TreeNode</td>
      <td>null)[] = [root];</td>
    </tr>
  </tbody>
</table>

<p>while (queue.length &gt; 0) {
    const node = queue.shift()!;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>if (node === null) {
  result.push(null);
} else {
  result.push(node.val);
  queue.push(node.left);
  queue.push(node.right);
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Remove trailing nulls
  while (result.length &gt; 0 &amp;&amp; result[result.length - 1] === null) {
    result.pop();
  }</p>

<p>return result;
}</p>

<p>// Test cases / Các trường hợp kiểm thử
function runTests() {
  console.log(“=== Serialize and Deserialize Binary Tree Tests ===”);
  console.log(
    “=== Kiểm thử bài toán Tuần tự hóa và giải tuần tự hóa cây nhị phân ===\n”
  );</p>

<p>const testCases = [
    {
      name: “Example 1: Standard tree”,
      input: [1, 2, 3, null, null, 4, 5],
      description: “Tree with 5 nodes”,
    },
    {
      name: “Example 2: Empty tree”,
      input: [],
      description: “Empty tree”,
    },
    {
      name: “Single node”,
      input: [1],
      description: “Tree with single node”,
    },
    {
      name: “Left-skewed tree”,
      input: [1, 2, null, 3, null, 4],
      description: “Tree skewed to the left”,
    },
    {
      name: “Right-skewed tree”,
      input: [1, null, 2, null, 3, null, 4],
      description: “Tree skewed to the right”,
    },
    {
      name: “Complete binary tree”,
      input: [1, 2, 3, 4, 5, 6, 7],
      description: “Complete binary tree”,
    },
    {
      name: “Tree with negative values”,
      input: [-1, -2, -3, null, null, -4, -5],
      description: “Tree with negative values”,
    },
  ];</p>

<p>const codec = new Codec();
  const codecBFS = new CodecBFS();
  const codecCompact = new CodecCompact();
  const codecViz = new CodecWithVisualization();</p>

<p>for (const testCase of testCases) {
    console.log(<code class="language-plaintext highlighter-rouge">Test: ${testCase.name}</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Input: [${testCase.input.join(", ")}]</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Description: ${testCase.description}</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre>// Create original tree
const originalTree = createTreeFromArray(testCase.input);

// Test preorder serialization
const serialized = codec.serialize(originalTree);
const deserialized = codec.deserialize(serialized);

console.log(`Serialized (preorder): ${serialized}`);
console.log(
  `Deserialized array: [${treeToArray(deserialized).join(", ")}]`
);

// Test BFS serialization
const serializedBFS = codecBFS.serialize(originalTree);
const deserializedBFS = codecBFS.deserialize(serializedBFS);

console.log(`Serialized (BFS): ${serializedBFS}`);

// Test compact serialization
const serializedCompact = codecCompact.serialize(originalTree);
const deserializedCompact = codecCompact.deserialize(serializedCompact);

console.log(`Serialized (compact): ${serializedCompact}`);

// Verify all methods produce same result
const originalArray = treeToArray(originalTree);
const deserializedArray = treeToArray(deserialized);
const deserializedBFSArray = treeToArray(deserializedBFS);
const deserializedCompactArray = treeToArray(deserializedCompact);

const allMatch =
  JSON.stringify(originalArray) === JSON.stringify(deserializedArray) &amp;&amp;
  JSON.stringify(deserializedArray) ===
    JSON.stringify(deserializedBFSArray) &amp;&amp;
  JSON.stringify(deserializedBFSArray) ===
    JSON.stringify(deserializedCompactArray);

console.log(`All methods match: ${allMatch ? "✅ Yes" : "❌ No"}`);

// Show tree visualization
if (originalTree) {
  console.log("Tree visualization:");
  console.log(codecViz.visualizeTree(originalTree));
}

console.log("---");   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Performance comparison
  console.log(“\n=== Performance Comparison ===”);
  console.log(“=== So sánh hiệu suất ===\n”);</p>

<p>// Create a large tree
  const largeTreeArray: (number | null)[] = [];
  for (let i = 0; i &lt; 1000; i++) {
    largeTreeArray.push(i);
  }</p>

<p>const largeTree = createTreeFromArray(largeTreeArray);</p>

<p>console.log(“Testing with large tree (1000 nodes)…”);
  console.log(“Kiểm thử với cây lớn (1000 nút)…”);</p>

<p>const start1 = performance.now();
  const serialized1 = codec.serialize(largeTree);
  const deserialized1 = codec.deserialize(serialized1);
  const time1 = performance.now() - start1;</p>

<p>const start2 = performance.now();
  const serialized2 = codecBFS.serialize(largeTree);
  const deserialized2 = codecBFS.deserialize(serialized2);
  const time2 = performance.now() - start2;</p>

<p>const start3 = performance.now();
  const serialized3 = codecCompact.serialize(largeTree);
  const deserialized3 = codecCompact.deserialize(serialized3);
  const time3 = performance.now() - start3;</p>

<p>console.log(
    <code class="language-plaintext highlighter-rouge">Preorder: ${time1.toFixed(4)}ms, Size: ${serialized1.length} chars</code>
  );
  console.log(<code class="language-plaintext highlighter-rouge">BFS: ${time2.toFixed(4)}ms, Size: ${serialized2.length} chars</code>);
  console.log(
    <code class="language-plaintext highlighter-rouge">Compact: ${time3.toFixed(4)}ms, Size: ${serialized3.length} chars</code>
  );</p>

<p>const resultsMatch =
    codecViz.areTreesEqual(deserialized1, deserialized2) &amp;&amp;
    codecViz.areTreesEqual(deserialized2, deserialized3);
  console.log(<code class="language-plaintext highlighter-rouge">Results match: ${resultsMatch ? "✅ Yes" : "❌ No"}</code>);
}</p>

<p>// Run tests if this file is executed directly
if (require.main === module) {
  runTests();
}</p>

<p>export {
  TreeNode,
  Codec,
  CodecBFS,
  CodecCompact,
  CodecWithVisualization,
  createTreeFromArray,
  treeToArray,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>