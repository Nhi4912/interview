<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LRU Cache | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/design/">Design</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/design/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Lru cache</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">LRU Cache</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Design</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Design</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="lru-cache">LRU Cache</h1>

<p><strong>LeetCode Problem # * 146. LRU Cache</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>LRU Cache</li>
    </ol>
  </li>
  <li></li>
  <li>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</li>
  <li></li>
  <li>Implement the LRUCache class:</li>
  <li>
    <ul>
      <li>LRUCache(int capacity) Initialize the LRU cache with positive size capacity.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>int get(int key) Return the value of the key if the key exists, otherwise return -1.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>void put(int key, int value) Update the value of the key if the key exists.</li>
    </ul>
  </li>
  <li>Otherwise, add the key-value pair to the cache. If the number of keys exceeds</li>
  <li>the capacity from this operation, evict the least recently used key.</li>
  <li></li>
  <li>The functions get and put must each run in O(1) average time complexity.</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input</li>
  <li>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]</li>
  <li>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</li>
  <li>Output</li>
  <li>[null, null, null, 1, null, -1, null, -1, 3, 4]</li>
  <li></li>
  <li>Explanation</li>
  <li>LRUCache lRUCache = new LRUCache(2);</li>
  <li>lRUCache.put(1, 1); // cache is {1=1}</li>
  <li>lRUCache.put(2, 2); // cache is {1=1, 2=2}</li>
  <li>lRUCache.get(1);    // return 1</li>
  <li>lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}</li>
  <li>lRUCache.get(2);    // returns -1 (not found)</li>
  <li>lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {3=3, 4=4}</li>
  <li>lRUCache.get(1);    // return -1 (not found)</li>
  <li>lRUCache.get(3);    // return 3</li>
  <li>lRUCache.get(4);    // return 4</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>1 &lt;= capacity &lt;= 3000</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>0 &lt;= key &lt;= 10^4</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>0 &lt;= value &lt;= 10^5</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>At most 2 * 10^5 calls will be made to get and put.
 */</li>
    </ul>
  </li>
</ul>

<p>// Solution 1: HashMap + Doubly Linked List
// Time: O(1) for both get and put, Space: O(capacity)
class ListNode {
    key: number;
    value: number;
    prev: ListNode | null;
    next: ListNode | null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>constructor(key: number = 0, value: number = 0) {
    this.key = key;
    this.value = value;
    this.prev = null;
    this.next = null;
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>export class LRUCache1 {
    private capacity: number;
    private cache: Map&lt;number, ListNode&gt;;
    private head: ListNode;
    private tail: ListNode;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre></td><td class="rouge-code"><pre>constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();
    
    // Create dummy head and tail nodes
    this.head = new ListNode();
    this.tail = new ListNode();
    this.head.next = this.tail;
    this.tail.prev = this.head;
}

private addToHead(node: ListNode): void {
    node.prev = this.head;
    node.next = this.head.next;
    this.head.next!.prev = node;
    this.head.next = node;
}

private removeNode(node: ListNode): void {
    node.prev!.next = node.next;
    node.next!.prev = node.prev;
}

private moveToHead(node: ListNode): void {
    this.removeNode(node);
    this.addToHead(node);
}

private removeTail(): ListNode {
    const last = this.tail.prev!;
    this.removeNode(last);
    return last;
}

get(key: number): number {
    const node = this.cache.get(key);
    if (!node) return -1;
    
    // Move accessed node to head (most recently used)
    this.moveToHead(node);
    return node.value;
}

put(key: number, value: number): void {
    const node = this.cache.get(key);
    
    if (node) {
        // Update existing node
        node.value = value;
        this.moveToHead(node);
    } else {
        // Add new node
        const newNode = new ListNode(key, value);
        
        if (this.cache.size &gt;= this.capacity) {
            // Remove least recently used node
            const tail = this.removeTail();
            this.cache.delete(tail.key);
        }
        
        this.cache.set(key, newNode);
        this.addToHead(newNode);
    }
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Using JavaScript Map (maintains insertion order)
// Time: O(1) for both get and put, Space: O(capacity)
export class LRUCache2 {
    private capacity: number;
    private cache: Map&lt;number, number&gt;;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();
}

get(key: number): number {
    if (!this.cache.has(key)) return -1;
    
    // Move to end (most recently used)
    const value = this.cache.get(key)!;
    this.cache.delete(key);
    this.cache.set(key, value);
    return value;
}

put(key: number, value: number): void {
    if (this.cache.has(key)) {
        // Update existing key
        this.cache.delete(key);
    } else if (this.cache.size &gt;= this.capacity) {
        // Remove least recently used (first key)
        const firstKey = this.cache.keys().next().value;
        this.cache.delete(firstKey);
    }
    
    this.cache.set(key, value);
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Array-based implementation
// Time: O(n) for both get and put, Space: O(capacity)
export class LRUCache3 {
    private capacity: number;
    private cache: Array&lt;[number, number]&gt;;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre>constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = [];
}

private findIndex(key: number): number {
    for (let i = 0; i &lt; this.cache.length; i++) {
        if (this.cache[i][0] === key) return i;
    }
    return -1;
}

get(key: number): number {
    const index = this.findIndex(key);
    if (index === -1) return -1;
    
    // Move to end (most recently used)
    const [k, v] = this.cache.splice(index, 1)[0];
    this.cache.push([k, v]);
    return v;
}

put(key: number, value: number): void {
    const index = this.findIndex(key);
    
    if (index !== -1) {
        // Update existing key
        this.cache.splice(index, 1);
    } else if (this.cache.length &gt;= this.capacity) {
        // Remove least recently used (first element)
        this.cache.shift();
    }
    
    this.cache.push([key, value]);
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Two-way mapping approach
// Time: O(1) for both get and put, Space: O(capacity)
export class LRUCache4 {
    private capacity: number;
    private keyToValue: Map&lt;number, number&gt;;
    private keyToTime: Map&lt;number, number&gt;;
    private timeToKey: Map&lt;number, number&gt;;
    private currentTime: number;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="rouge-code"><pre>constructor(capacity: number) {
    this.capacity = capacity;
    this.keyToValue = new Map();
    this.keyToTime = new Map();
    this.timeToKey = new Map();
    this.currentTime = 0;
}

private updateTime(key: number): void {
    // Remove old time mapping
    const oldTime = this.keyToTime.get(key);
    if (oldTime !== undefined) {
        this.timeToKey.delete(oldTime);
    }
    
    // Add new time mapping
    this.keyToTime.set(key, this.currentTime);
    this.timeToKey.set(this.currentTime, key);
    this.currentTime++;
}

get(key: number): number {
    if (!this.keyToValue.has(key)) return -1;
    
    this.updateTime(key);
    return this.keyToValue.get(key)!;
}

put(key: number, value: number): void {
    if (this.keyToValue.has(key)) {
        // Update existing key
        this.keyToValue.set(key, value);
        this.updateTime(key);
    } else {
        // Add new key
        if (this.keyToValue.size &gt;= this.capacity) {
            // Find and remove LRU key
            let minTime = Infinity;
            let lruKey = -1;
            
            for (const [k, time] of this.keyToTime) {
                if (time &lt; minTime) {
                    minTime = time;
                    lruKey = k;
                }
            }
            
            // Remove LRU key
            this.keyToValue.delete(lruKey);
            this.keyToTime.delete(lruKey);
            this.timeToKey.delete(minTime);
        }
        
        this.keyToValue.set(key, value);
        this.updateTime(key);
    }
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Using Set for order tracking
// Time: O(1) for both get and put, Space: O(capacity)
export class LRUCache5 {
    private capacity: number;
    private values: Map&lt;number, number&gt;;
    private usage: Set<number>;</number></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre>constructor(capacity: number) {
    this.capacity = capacity;
    this.values = new Map();
    this.usage = new Set();
}

get(key: number): number {
    if (!this.values.has(key)) return -1;
    
    // Update usage order
    this.usage.delete(key);
    this.usage.add(key);
    
    return this.values.get(key)!;
}

put(key: number, value: number): void {
    if (this.values.has(key)) {
        // Update existing key
        this.values.set(key, value);
        this.usage.delete(key);
        this.usage.add(key);
    } else {
        // Add new key
        if (this.values.size &gt;= this.capacity) {
            // Remove least recently used
            const lruKey = this.usage.values().next().value;
            this.values.delete(lruKey);
            this.usage.delete(lruKey);
        }
        
        this.values.set(key, value);
        this.usage.add(key);
    }
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testLRUCache() {
    console.log(“Testing LRU Cache:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>const implementations = [
    { name: "HashMap + Doubly Linked List", LRUCache: LRUCache1 },
    { name: "JavaScript Map", LRUCache: LRUCache2 },
    { name: "Array-based", LRUCache: LRUCache3 },
    { name: "Two-way Mapping", LRUCache: LRUCache4 },
    { name: "Set for Usage", LRUCache: LRUCache5 }
];

implementations.forEach(impl =&gt; {
    console.log(`\n${impl.name}:`);
    
    const cache = new impl.LRUCache(2);
    
    // Test case 1
    cache.put(1, 1);
    cache.put(2, 2);
    console.log(`  get(1): ${cache.get(1)} (expected: 1)`);
    cache.put(3, 3);
    console.log(`  get(2): ${cache.get(2)} (expected: -1)`);
    cache.put(4, 4);
    console.log(`  get(1): ${cache.get(1)} (expected: -1)`);
    console.log(`  get(3): ${cache.get(3)} (expected: 3)`);
    console.log(`  get(4): ${cache.get(4)} (expected: 4)`);
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Core Requirements</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>O(1) time complexity for both get and put</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Fixed capacity with LRU eviction</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Most recently used items should be easily accessible</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Data Structure Choice</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>HashMap: O(1) key lookup</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Doubly Linked List: O(1) insertion/deletion at any position</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Combination provides O(1) for all operations</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Doubly Linked List Advantages</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>O(1) insertion at head (most recent)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>O(1) deletion at tail (least recent)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>O(1) node removal from middle (when accessing)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Implementation Details</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Dummy head/tail nodes simplify edge cases</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>HashMap stores key → node mapping</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Move accessed nodes to head</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Remove from tail when capacity exceeded</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Alternative Approaches</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>JavaScript Map: Maintains insertion order</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Array-based: O(n) but simple implementation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Two-way mapping: Complex but demonstrates concept</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with requirements analysis</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Discuss time complexity constraints</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Explain data structure choice</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Implement step by step</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle edge cases</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Capacity of 1</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Accessing non-existent keys</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Updating existing keys</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Multiple accesses to same key</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Forgetting to update access order on get</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect linked list pointer manipulation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not handling capacity overflow</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Using wrong data structure (losing O(1) property)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>LFU (Least Frequently Used) Cache</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>TTL (Time To Live) Cache</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Multi-level caches</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Thread-safe implementations</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Implement LFU cache</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Add TTL functionality</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Make it thread-safe</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimize for specific access patterns</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle cache statistics</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Performance Considerations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Memory usage vs access speed</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Cache hit/miss ratios</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Eviction policy efficiency</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Concurrent access handling</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>CPU caches</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Database buffer pools</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Web browser caches</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Operating system page replacement</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>CDN caching strategies
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>