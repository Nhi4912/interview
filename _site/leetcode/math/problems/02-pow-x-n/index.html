<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pow(x, n) | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/math/">Math</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/math/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Pow(x, n)</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Pow(x, n)</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Math</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Math</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="powx-n">Pow(x, n)</h1>

<p><strong>LeetCode Problem # * 50. Pow(x, n)</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Pow(x, n)</li>
    </ol>
  </li>
  <li></li>
  <li>Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: x = 2.00000, n = 10</li>
  <li>Output: 1024.00000</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: x = 2.10000, n = 3</li>
  <li>Output: 9.26100</li>
  <li></li>
  <li>Example 3:</li>
  <li>Input: x = 2.00000, n = -2</li>
  <li>Output: 0.25000</li>
  <li>Explanation: 2^-2 = 1/2^2 = 1/4 = 0.25</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>-100.0 &lt; x &lt; 100.0</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>-2^31 &lt;= n &lt;= 2^31-1</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>n is an integer.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Either x is not zero or n &gt; 0.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>-10^4 &lt;= x^n &lt;= 10^4
 */</li>
    </ul>
  </li>
</ul>

<p>// Solution 1: Fast Exponentiation (Iterative)
// Time: O(log n), Space: O(1)
export function myPow1(x: number, n: number): number {
    if (n === 0) return 1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>let absN = Math.abs(n);
let result = 1;
let base = x;

while (absN &gt; 0) {
    // If current bit is 1, multiply result by current base
    if (absN &amp; 1) {
        result *= base;
    }
    
    // Square the base for next bit
    base *= base;
    
    // Right shift to check next bit
    absN &gt;&gt;= 1;
}

return n &lt; 0 ? 1 / result : result; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Fast Exponentiation (Recursive)
// Time: O(log n), Space: O(log n)
export function myPow2(x: number, n: number): number {
    if (n === 0) return 1;
    if (n === 1) return x;
    if (n === -1) return 1 / x;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>if (n % 2 === 0) {
    const half = myPow2(x, n / 2);
    return half * half;
} else {
    if (n &gt; 0) {
        return x * myPow2(x, n - 1);
    } else {
        return (1 / x) * myPow2(x, n + 1);
    }
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Binary Exponentiation with Bit Manipulation
// Time: O(log n), Space: O(1)
export function myPow3(x: number, n: number): number {
    if (n === 0) return 1;
    if (x === 0) return 0;
    if (x === 1) return 1;
    if (x === -1) return n % 2 === 0 ? 1 : -1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>const isNegative = n &lt; 0;
let exp = Math.abs(n);
let result = 1;
let base = x;

// Process each bit of the exponent
while (exp &gt; 0) {
    // Check if least significant bit is 1
    if (exp &amp; 1) {
        result *= base;
    }
    
    // Square the base
    base *= base;
    
    // Right shift exponent
    exp &gt;&gt;&gt;= 1;
}

return isNegative ? 1 / result : result; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Optimized Recursive with Memoization
// Time: O(log n), Space: O(log n)
export function myPow4(x: number, n: number): number {
    const memo = new Map&lt;string, number&gt;();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>function powerHelper(x: number, n: number): number {
    if (n === 0) return 1;
    if (n === 1) return x;
    
    const key = `${x},${n}`;
    if (memo.has(key)) {
        return memo.get(key)!;
    }
    
    let result: number;
    if (n % 2 === 0) {
        const half = powerHelper(x, n / 2);
        result = half * half;
    } else {
        result = x * powerHelper(x, n - 1);
    }
    
    memo.set(key, result);
    return result;
}

if (n &gt;= 0) {
    return powerHelper(x, n);
} else {
    return 1 / powerHelper(x, -n);
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Iterative with Divide and Conquer
// Time: O(log n), Space: O(1)
export function myPow5(x: number, n: number): number {
    if (n === 0) return 1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>let result = 1;
let base = Math.abs(n) % 2 === 1 ? x : 1;
let exp = Math.floor(Math.abs(n) / 2);
x = x * x;

while (exp &gt; 0) {
    if (exp % 2 === 1) {
        base *= x;
    }
    x *= x;
    exp = Math.floor(exp / 2);
}

result = base;
return n &lt; 0 ? 1 / result : result; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 6: Mathematical Logarithm Approach
// Time: O(1), Space: O(1)
export function myPow6(x: number, n: number): number {
    if (n === 0) return 1;
    if (x === 0) return 0;
    if (x === 1) return 1;
    if (x === -1) return n % 2 === 0 ? 1 : -1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>// Handle edge cases for precision
if (Math.abs(x) &lt; 1e-10) return 0;

// Use logarithm: x^n = exp(n * ln(x))
// But this only works for positive x
if (x &gt; 0) {
    return Math.exp(n * Math.log(x));
} else {
    // For negative x, use x^n = (-1)^n * |x|^n
    const absResult = Math.exp(n * Math.log(Math.abs(x)));
    return n % 2 === 0 ? absResult : -absResult;
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 7: Tail Recursive Approach
// Time: O(log n), Space: O(log n)
export function myPow7(x: number, n: number): number {
    function tailPow(base: number, exp: number, acc: number): number {
        if (exp === 0) return acc;
        if (exp === 1) return acc * base;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>    if (exp % 2 === 0) {
        return tailPow(base * base, exp / 2, acc);
    } else {
        return tailPow(base * base, Math.floor(exp / 2), acc * base);
    }
}

if (n === 0) return 1;
if (n &gt; 0) {
    return tailPow(x, n, 1);
} else {
    return 1 / tailPow(x, -n, 1);
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testMyPow() {
    console.log(“Testing Pow(x, n):”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre></td><td class="rouge-code"><pre>const testCases = [
    {
        x: 2.0,
        n: 10,
        expected: 1024.0
    },
    {
        x: 2.1,
        n: 3,
        expected: 9.261
    },
    {
        x: 2.0,
        n: -2,
        expected: 0.25
    },
    {
        x: 1.0,
        n: 2147483647,
        expected: 1.0
    },
    {
        x: -1.0,
        n: 2147483647,
        expected: -1.0
    },
    {
        x: 0.44528,
        n: 0,
        expected: 1.0
    },
    {
        x: 34.00515,
        n: -3,
        expected: 0.00003
    },
    {
        x: -2.0,
        n: 3,
        expected: -8.0
    },
    {
        x: -2.0,
        n: 4,
        expected: 16.0
    }
];

const solutions = [
    { name: "Fast Exponentiation (Iterative)", fn: myPow1 },
    { name: "Fast Exponentiation (Recursive)", fn: myPow2 },
    { name: "Binary Exponentiation", fn: myPow3 },
    { name: "Recursive with Memoization", fn: myPow4 },
    { name: "Iterative Divide and Conquer", fn: myPow5 },
    { name: "Mathematical Logarithm", fn: myPow6 },
    { name: "Tail Recursive", fn: myPow7 }
];

function isClose(a: number, b: number, tolerance = 1e-5): boolean {
    return Math.abs(a - b) &lt; tolerance;
}

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        const result = solution.fn(test.x, test.n);
        const passed = isClose(result, test.expected);
        console.log(`  Test ${i + 1}: ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Input: x=${test.x}, n=${test.n}`);
            console.log(`    Expected: ${test.expected}`);
            console.log(`    Got: ${result}`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Naive vs Optimal</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Naive: O(n) multiplication loop</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimal: O(log n) using fast exponentiation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Massive improvement for large exponents</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Fast Exponentiation Principle</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>x^n = (x^(n/2))^2 if n is even</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>x^n = x * x^(n-1) if n is odd</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Reduces problem size by half each step</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Binary Representation</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>View exponent in binary: n = b_k<em>2^k + … + b_1</em>2^1 + b_0*2^0</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>x^n = x^(b_k<em>2^k) * … * x^(b_1</em>2^1) * x^(b_0*2^0)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Process each bit to build result</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Negative Exponent Handling</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>x^(-n) = 1 / x^n</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Compute positive exponent then invert</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Avoid precision issues with direct computation</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(log n)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Each iteration reduces exponent by half</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Number of iterations = log₂(n)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimal for exponentiation</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Iterative: O(1) constant space</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Recursive: O(log n) call stack</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memoization: O(log n) cache space</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>x = 0, n = 0 (undefined mathematically, return 1)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>x = 1, any n (always 1)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>x = -1, even/odd n (1 or -1)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Large negative exponents</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with naive O(n) approach</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Explain fast exponentiation concept</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Implement iterative binary method</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle negative exponents properly</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Bit Manipulation Insights</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Check least significant bit: n &amp; 1</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Right shift: n »= 1 or n »&gt;= 1</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Process exponent bit by bit</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Precision Considerations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Floating point arithmetic limitations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Large exponents may cause overflow</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Small results may underflow to zero</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Mathematical Properties</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Associativity: (x^a)^b = x^(a*b)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Multiplication: x^a * x^b = x^(a+b)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Division: x^a / x^b = x^(a-b)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Not handling negative exponents</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Integer overflow with large exponents</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect base case handling</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Precision errors with floating point</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimization Techniques</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Early termination for special values</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Bit manipulation for efficiency</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Avoiding unnecessary recursive calls</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memoization for repeated subproblems</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: Matrix exponentiation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Modular exponentiation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Fast Fibonacci using matrix power</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Large number exponentiation</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Implement modular exponentiation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Matrix exponentiation for Fibonacci</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle arbitrary precision numbers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimize for specific exponent patterns</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Cryptography (RSA, modular exponentiation)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Computer graphics (transformations)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Signal processing (Fourier transforms)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Financial calculations (compound interest)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Scientific computing (numerical methods)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Pattern Recognition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Divide and conquer strategy</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Binary representation utilization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Recursive problem decomposition</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimization through mathematical properties</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Alternative Approaches</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Logarithm method: exp(n * log(x))</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Addition chains for specific exponents</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Sliding window methods</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Precomputed power tables</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Implementation Tips</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Handle integer overflow carefully</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use unsigned right shift (»&gt;) for safety</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Consider floating point precision</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Test edge cases thoroughly</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Complexity Analysis</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Best case: O(1) for special values</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Average case: O(log n) for general case</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Worst case: O(log n) always</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Space varies by implementation approach
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>