<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sqrt(x) | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/math/">Math</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/math/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Sqrt(x)</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Sqrt(x)</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Math</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Math</span>
                                
                                    <span class="tag">Binary Search</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="sqrtx">Sqrt(x)</h1>

<p><strong>LeetCode Problem # * 69. Sqrt(x)</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Sqrt(x)</li>
    </ol>
  </li>
  <li></li>
  <li>Given a non-negative integer x, return the square root of x rounded down to the nearest integer.</li>
  <li>The returned integer should be non-negative as well.</li>
  <li></li>
  <li>You must not use any built-in exponent function or operator.</li>
  <li>For example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: x = 4</li>
  <li>Output: 2</li>
  <li>Explanation: The square root of 4 is 2, so we return 2.</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: x = 8</li>
  <li>Output: 2</li>
  <li>Explanation: The square root of 8 is 2.82842…, and since we round it down to the nearest integer, 2 is returned.</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>0 &lt;= x &lt;= 2^31 - 1
 */</li>
    </ul>
  </li>
</ul>

<p>// Solution 1: Binary Search (Optimal)
// Time: O(log x), Space: O(1)
export function mySqrt1(x: number): number {
    if (x &lt; 2) return x;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>let left = 1;
let right = Math.floor(x / 2) + 1; // sqrt(x) &lt;= x/2 for x &gt;= 4

while (left &lt;= right) {
    const mid = Math.floor((left + right) / 2);
    const square = mid * mid;
    
    if (square === x) {
        return mid;
    } else if (square &lt; x) {
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}

return right; // right is the largest integer whose square &lt;= x }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Newton’s Method (Babylonian Method)
// Time: O(log x), Space: O(1)
export function mySqrt2(x: number): number {
    if (x &lt; 2) return x;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>let guess = x;

while (guess * guess &gt; x) {
    guess = Math.floor((guess + Math.floor(x / guess)) / 2);
}

return guess; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Bit Manipulation
// Time: O(log x), Space: O(1)
export function mySqrt3(x: number): number {
    if (x &lt; 2) return x;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>// Find the highest bit position where result can have 1
let bit = 1;
while (bit * bit &lt;= x) {
    bit &lt;&lt;= 1;
}
bit &gt;&gt;= 1; // Step back to valid position

let result = 0;

// Try setting each bit from highest to lowest
while (bit &gt; 0) {
    const candidate = result | bit;
    if (candidate * candidate &lt;= x) {
        result = candidate;
    }
    bit &gt;&gt;= 1;
}

return result; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Linear Search (Brute Force)
// Time: O(sqrt(x)), Space: O(1)
export function mySqrt4(x: number): number {
    if (x &lt; 2) return x;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>let i = 1;
while (i * i &lt;= x) {
    i++;
}

return i - 1; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Exponential Search + Binary Search
// Time: O(log x), Space: O(1)
export function mySqrt5(x: number): number {
    if (x &lt; 2) return x;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>// Exponential search to find the range
let bound = 1;
while (bound * bound &lt;= x) {
    bound &lt;&lt;= 1;
}

// Binary search in the range [bound/2, bound]
let left = bound &gt;&gt; 1;
let right = bound;

while (left &lt;= right) {
    const mid = Math.floor((left + right) / 2);
    const square = mid * mid;
    
    if (square === x) {
        return mid;
    } else if (square &lt; x) {
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}

return right; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 6: Mathematical Optimization
// Time: O(log x), Space: O(1)
export function mySqrt6(x: number): number {
    if (x &lt; 2) return x;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>// Use the fact that sqrt(x) is approximately x/2 for small x
// and use this as a better starting point
let guess = x &gt; 10000 ? Math.floor(x / 100) : Math.floor(x / 2);

while (true) {
    const square = guess * guess;
    const nextGuess = guess + 1;
    const nextSquare = nextGuess * nextGuess;
    
    if (square &lt;= x &amp;&amp; nextSquare &gt; x) {
        return guess;
    } else if (square &gt; x) {
        guess = Math.floor((guess + Math.floor(x / guess)) / 2);
    } else {
        guess++;
    }
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 7: Digit by Digit Calculation
// Time: O(log x), Space: O(1)
export function mySqrt7(x: number): number {
    if (x &lt; 2) return x;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre>let result = 0;
let remainder = 0;

// Process digits from left to right
let shift = 0;
let temp = x;
while (temp &gt; 0) {
    temp = Math.floor(temp / 100);
    shift++;
}

for (let i = shift - 1; i &gt;= 0; i--) {
    remainder = remainder * 100 + Math.floor(x / Math.pow(100, i)) % 100;
    result *= 10;
    
    let digit = 0;
    while ((2 * result + digit + 1) * (digit + 1) &lt;= remainder) {
        digit++;
    }
    
    remainder -= (2 * result + digit) * digit;
    result += digit;
}

return result; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testMySqrt() {
    console.log(“Testing Sqrt(x):”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre>const testCases = [
    { x: 0, expected: 0 },
    { x: 1, expected: 1 },
    { x: 4, expected: 2 },
    { x: 8, expected: 2 },
    { x: 9, expected: 3 },
    { x: 15, expected: 3 },
    { x: 16, expected: 4 },
    { x: 25, expected: 5 },
    { x: 100, expected: 10 },
    { x: 121, expected: 11 },
    { x: 144, expected: 12 },
    { x: 2147395600, expected: 46340 }, // Large test case
    { x: 2147483647, expected: 46340 }  // Maximum int32
];

const solutions = [
    { name: "Binary Search", fn: mySqrt1 },
    { name: "Newton's Method", fn: mySqrt2 },
    { name: "Bit Manipulation", fn: mySqrt3 },
    { name: "Linear Search", fn: mySqrt4 },
    { name: "Exponential + Binary Search", fn: mySqrt5 },
    { name: "Mathematical Optimization", fn: mySqrt6 },
    { name: "Digit by Digit", fn: mySqrt7 }
];

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        const result = solution.fn(test.x);
        const passed = result === test.expected;
        console.log(`  Test ${i + 1}: ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Input: x=${test.x}`);
            console.log(`    Expected: ${test.expected}`);
            console.log(`    Got: ${result}`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Problem Understanding</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Find floor(sqrt(x)) without using built-in functions</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Return largest integer n such that n² ≤ x</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle edge cases: 0, 1, perfect squares</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Binary Search Approach</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Search space: [1, x/2] for x ≥ 4</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimization: sqrt(x) ≤ x/2 for x ≥ 4</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Find largest mid where mid² ≤ x</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Newton’s Method (Babylonian)</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Iterative formula: x_{n+1} = (x_n + a/x_n) / 2</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Converges quadratically to sqrt(a)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Very efficient in practice</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Bit Manipulation Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Build result bit by bit from most significant</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Check if setting each bit keeps square ≤ x</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Leverages binary representation properties</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity Analysis</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Binary Search: O(log x)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Newton’s Method: O(log x)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Bit Manipulation: O(log x)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Linear Search: O(sqrt(x))</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>: O(1)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>All approaches use constant extra space</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>No recursion or additional data structures</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimal space usage</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Newton’s Method Derivation</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Want to solve f(y) = y² - x = 0</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Newton’s formula: y_{n+1} = y_n - f(y_n)/f’(y_n)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>f’(y) = 2y, so y_{n+1} = y_n - (y_n² - x)/(2y_n)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Simplifies to y_{n+1} = (y_n + x/y_n) / 2</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Binary Search Optimization</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Use x/2 as upper bound instead of x</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>For x ≥ 4: if sqrt(x) &gt; x/2, then x &gt; (x/2)² = x²/4, so x &gt; x²/4</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>This implies 4 &gt; x, contradiction for x ≥ 4</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>x = 0: return 0</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>x = 1: return 1</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Perfect squares: exact result</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Large numbers: avoid overflow</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with binary search approach</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Explain the search space optimization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Mention Newton’s method as advanced technique</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle edge cases properly</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Precision Considerations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Integer arithmetic only (no floating point)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Avoid overflow when computing mid²</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use mid = left + (right - left) / 2 for large values</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Not handling overflow in mid * mid</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Wrong search space boundaries</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect termination condition</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not considering edge cases</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimization Techniques</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Better initial guess for Newton’s method</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Early termination for perfect squares</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Exponential search for very large numbers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Bit manipulation for constant factor improvement</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: Nth root calculation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Square root with specific precision</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Floating point square root</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Fast inverse square root</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Implement floating point square root</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Calculate nth root of a number</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Find square root with specific precision</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Implement fast inverse square root</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Computer graphics (distance calculations)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Scientific computing (numerical methods)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Game development (physics engines)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Signal processing (magnitude calculations)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Machine learning (norm calculations)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Mathematical Properties</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>sqrt(a * b) = sqrt(a) * sqrt(b)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>sqrt(a²) =</td>
              <td>a</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Monotonic function: a &lt; b ⟹ sqrt(a) &lt; sqrt(b)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Pattern Recognition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Binary search on answer space</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Newton’s method for root finding</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Bit manipulation for number construction</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Iterative approximation methods</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Performance Comparison</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Newton’s method: fastest convergence</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Binary search: predictable performance</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Bit manipulation: good for small numbers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Linear search: simplest but slowest</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Implementation Tips</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Use integer arithmetic only</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Check for overflow carefully</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle boundary conditions properly</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Test with edge cases and large values
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>