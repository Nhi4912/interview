<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LRU Cache | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/others/">Others</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/others/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Lru cache</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">LRU Cache</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Others</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Others</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="lru-cache">LRU Cache</h1>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>
    <ul>
      <li>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  *  * Implement the LRUCache class:  * - LRUCache(int capacity) Initialize the LRU cache with positive size capacity.</li>
    </ul>
  </li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>LRU Cache
 *</li>
  <li>Problem: https://leetcode.com/problems/lru-cache/
 *</li>
  <li>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
 *</li>
  <li>Implement the LRUCache class:</li>
  <li>
    <ul>
      <li>LRUCache(int capacity) Initialize the LRU cache with positive size capacity.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>int get(int key) Return the value of the key if the key exists, otherwise return -1.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>void put(int key, int value) Update the value of the key if the key exists. Otherwise,</li>
    </ul>
  </li>
  <li>add the key-value pair to the cache. If the number of keys exceeds the capacity from</li>
  <li>this operation, evict the least recently used key.
 *</li>
  <li>The functions get and put must each run in O(1) average time complexity.
 *</li>
  <li>Example 1:</li>
  <li>Input:</li>
  <li>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]</li>
  <li>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</li>
  <li>Output: [null, null, null, 1, null, -1, null, -1, 3, 4]
 *</li>
  <li>Explanation:</li>
  <li>LRUCache lRUCache = new LRUCache(2);</li>
  <li>lRUCache.put(1, 1); // cache is {1=1}</li>
  <li>lRUCache.put(2, 2); // cache is {1=1, 2=2}</li>
  <li>lRUCache.get(1);    // return 1</li>
  <li>lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}</li>
  <li>lRUCache.get(2);    // returns -1 (not found)</li>
  <li>lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}</li>
  <li>lRUCache.get(1);    // return -1 (not found)</li>
  <li>lRUCache.get(3);    // return 3</li>
  <li>lRUCache.get(4);    // return 4
 *</li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>1 &lt;= capacity &lt;= 3000</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>0 &lt;= key &lt;= 10^4</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>0 &lt;= value &lt;= 10^5</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>At most 2 * 10^5 calls will be made to get and put.
 *</li>
    </ul>
  </li>
  <li>Solution Approaches:</li>
  <li>
    <ol>
      <li>HashMap + Doubly Linked List</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Using Map (built-in LRU behavior in some languages)</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Array-based implementation (for small capacity)</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>With eviction statistics
 *</li>
    </ol>
  </li>
  <li>Time Complexity: O(1) for get and put operations</li>
  <li>Space Complexity: O(capacity)
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>Doubly Linked List Node
 */
class ListNode {
  key: number;
  value: number;
  prev: ListNode | null;
  next: ListNode | null;</li>
</ul>

<p>constructor(key: number, value: number) {
    this.key = key;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
}</p>

<p>/**</p>
<ul>
  <li>LRU Cache - HashMap + Doubly Linked List Implementation
 *</li>
  <li>LRU Cache - Triển khai HashMap + Doubly Linked List
 *</li>
  <li>This approach uses a HashMap for O(1) lookups and a doubly linked list</li>
  <li>to maintain the order of recently used items
 */
class LRUCache {
  private capacity: number;
  private cache: Map&lt;number, ListNode&gt;;
  private head: ListNode;
  private tail: ListNode;</li>
</ul>

<p>constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>// Initialize dummy head and tail nodes
this.head = new ListNode(0, 0);
this.tail = new ListNode(0, 0);
this.head.next = this.tail;
this.tail.prev = this.head;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Get value by key</li>
  <li>Lấy giá trị theo khóa
   */
  get(key: number): number {
    const node = this.cache.get(key);</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>if (!node) {
  return -1;
}

// Move to front (most recently used)
this.moveToFront(node);

return node.value;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Put key-value pair</li>
  <li>Đặt cặp khóa-giá trị
   */
  put(key: number, value: number): void {
    const existingNode = this.cache.get(key);</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>if (existingNode) {
  // Update existing node
  existingNode.value = value;
  this.moveToFront(existingNode);
} else {
  // Create new node
  const newNode = new ListNode(key, value);
  this.cache.set(key, newNode);
  this.addToFront(newNode);

  // Check capacity and evict if necessary
  if (this.cache.size &gt; this.capacity) {
    this.evictLRU();
  }
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Move node to front of list (most recently used)</li>
  <li>Di chuyển node lên đầu danh sách (sử dụng gần đây nhất)
   */
  private moveToFront(node: ListNode): void {
    // Remove from current position
    this.removeNode(node);
    // Add to front
    this.addToFront(node);
  }</li>
</ul>

<p>/**</p>
<ul>
  <li>Add node to front of list</li>
  <li>Thêm node vào đầu danh sách
   */
  private addToFront(node: ListNode): void {
    node.prev = this.head;
    node.next = this.head.next;
    this.head.next!.prev = node;
    this.head.next = node;
  }</li>
</ul>

<p>/**</p>
<ul>
  <li>Remove node from list</li>
  <li>Xóa node khỏi danh sách
   */
  private removeNode(node: ListNode): void {
    node.prev!.next = node.next;
    node.next!.prev = node.prev;
  }</li>
</ul>

<p>/**</p>
<ul>
  <li>Evict least recently used item</li>
  <li>Loại bỏ phần tử ít được sử dụng nhất
   */
  private evictLRU(): void {
    const lruNode = this.tail.prev!;
    this.removeNode(lruNode);
    this.cache.delete(lruNode.key);
  }</li>
</ul>

<p>/**</p>
<ul>
  <li>Get current size of cache</li>
  <li>Lấy kích thước hiện tại của cache
   */
  size(): number {
    return this.cache.size;
  }</li>
</ul>

<p>/**</p>
<ul>
  <li>Check if cache is full</li>
  <li>Kiểm tra xem cache có đầy không
   */
  isFull(): boolean {
    return this.cache.size &gt;= this.capacity;
  }</li>
</ul>

<p>/**</p>
<ul>
  <li>Get all keys in order of usage (most recent first)</li>
  <li>Lấy tất cả khóa theo thứ tự sử dụng (gần đây nhất trước)
   */
  getKeysInOrder(): number[] {
    const keys: number[] = [];
    let current = this.head.next;</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>while (current &amp;&amp; current !== this.tail) {
  keys.push(current.key);
  current = current.next;
}

return keys;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Get cache statistics</li>
  <li>Lấy thống kê cache
   */
  getStats(): { size: number; capacity: number; usage: number } {
    return {
 size: this.cache.size,
 capacity: this.capacity,
 usage: (this.cache.size / this.capacity) * 100,
    };
  }
}</li>
</ul>

<p>/**</p>
<ul>
  <li>Alternative Implementation: Using Map (built-in LRU behavior)
 *</li>
  <li>Triển khai thay thế: Sử dụng Map (hành vi LRU có sẵn)
 */
class LRUCacheMap {
  private capacity: number;
  private cache: Map&lt;number, number&gt;;</li>
</ul>

<p>constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();
  }</p>

<p>get(key: number): number {
    if (!this.cache.has(key)) {
      return -1;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>// Move to end (most recently used)
const value = this.cache.get(key)!;
this.cache.delete(key);
this.cache.set(key, value);

return value;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>put(key: number, value: number): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size &gt;= this.capacity) {
      // Remove least recently used (first key)
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>this.cache.set(key, value);   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>size(): number {
    return this.cache.size;
  }</p>

<p>isFull(): boolean {
    return this.cache.size &gt;= this.capacity;
  }
}</p>

<p>/**</p>
<ul>
  <li>Implementation with Eviction Statistics
 *</li>
  <li>Triển khai với thống kê loại bỏ
 */
class LRUCacheWithStats extends LRUCache {
  private evictionCount: number;
  private hitCount: number;
  private missCount: number;
  private evictionHistory: Array&lt;{ key: number; timestamp: number }&gt;;</li>
</ul>

<p>constructor(capacity: number) {
    super(capacity);
    this.evictionCount = 0;
    this.hitCount = 0;
    this.missCount = 0;
    this.evictionHistory = [];
  }</p>

<p>get(key: number): number {
    const result = super.get(key);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>if (result === -1) {
  this.missCount++;
} else {
  this.hitCount++;
}

return result;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>put(key: number, value: number): void {
    const wasFull = this.isFull();
    const hadKey = this.get(key) !== -1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>super.put(key, value);

// Track eviction if cache was full and we added a new key
if (wasFull &amp;&amp; !hadKey) {
  this.evictionCount++;
  this.evictionHistory.push({ key, timestamp: Date.now() });
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Get cache performance statistics</li>
  <li>Lấy thống kê hiệu suất cache
   */
  getPerformanceStats(): {
    hitCount: number;
    missCount: number;
    hitRate: number;
    evictionCount: number;
    evictionHistory: Array&lt;{ key: number; timestamp: number }&gt;;
  } {
    const totalRequests = this.hitCount + this.missCount;
    const hitRate =
 totalRequests &gt; 0 ? (this.hitCount / totalRequests) * 100 : 0;</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>return {
  hitCount: this.hitCount,
  missCount: this.missCount,
  hitRate,
  evictionCount: this.evictionCount,
  evictionHistory: [...this.evictionHistory],
};   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Clear performance statistics</li>
  <li>Xóa thống kê hiệu suất
   */
  clearStats(): void {
    this.evictionCount = 0;
    this.hitCount = 0;
    this.missCount = 0;
    this.evictionHistory = [];
  }
}</li>
</ul>

<p>/**</p>
<ul>
  <li>Implementation with TTL (Time To Live)
 *</li>
  <li>Triển khai với TTL (Thời gian sống)
 */
class LRUCacheWithTTL extends LRUCache {
  private ttl: number; // Time to live in milliseconds
  private timestamps: Map&lt;number, number&gt;;</li>
</ul>

<p>constructor(capacity: number, ttl: number = 60000) {
    // Default 1 minute
    super(capacity);
    this.ttl = ttl;
    this.timestamps = new Map();
  }</p>

<p>get(key: number): number {
    const timestamp = this.timestamps.get(key);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>if (timestamp &amp;&amp; Date.now() - timestamp &gt; this.ttl) {
  // Key has expired, remove it
  this.timestamps.delete(key);
  return -1;
}

const result = super.get(key);

if (result !== -1) {
  // Update timestamp
  this.timestamps.set(key, Date.now());
}

return result;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>put(key: number, value: number): void {
    super.put(key, value);
    this.timestamps.set(key, Date.now());
  }</p>

<p>/**</p>
<ul>
  <li>Clean up expired entries</li>
  <li>Dọn dẹp các mục đã hết hạn
   */
  cleanup(): number {
    const now = Date.now();
    let cleanedCount = 0;</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>for (const [key, timestamp] of this.timestamps.entries()) {
  if (now - timestamp &gt; this.ttl) {
    this.timestamps.delete(key);
    cleanedCount++;
  }
}

return cleanedCount;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Get TTL statistics</li>
  <li>Lấy thống kê TTL
   */
  getTTLStats(): {
    ttl: number;
    activeEntries: number;
    expiredEntries: number;
  } {
    const now = Date.now();
    let expiredCount = 0;</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>for (const timestamp of this.timestamps.values()) {
  if (now - timestamp &gt; this.ttl) {
    expiredCount++;
  }
}

return {
  ttl: this.ttl,
  activeEntries: this.timestamps.size - expiredCount,
  expiredEntries: expiredCount,
};   } }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Performance Comparison Function
 *</li>
  <li>Hàm so sánh hiệu suất các phương pháp
 */
function compareLRUImplementations(
  operations: Array&lt;{ type: “get” | “put”; key: number; value?: number }&gt;
): void {
  console.log(
 “LRU Cache Implementation Performance Comparison / So sánh hiệu suất triển khai LRU Cache”
  );
  console.log(“=”.repeat(80));</li>
</ul>

<p>const implementations = [
    { name: “Doubly Linked List”, cache: new LRUCache(100) },
    { name: “Map-based”, cache: new LRUCacheMap(100) },
  ];</p>

<p>for (const impl of implementations) {
    console.log(<code class="language-plaintext highlighter-rouge">\nTesting ${impl.name}:</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>const start = performance.now();

for (const op of operations) {
  switch (op.type) {
    case "get":
      impl.cache.get(op.key);
      break;
    case "put":
      impl.cache.put(op.key, op.value!);
      break;
  }
}

const end = performance.now();
console.log(`  Time: ${(end - start).toFixed(4)}ms`);
console.log(`  Final size: ${impl.cache.size()}`);   } }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Test Cases
 *</li>
  <li>Các trường hợp kiểm thử
 */
function runTests(): void {
  console.log(“LRU Cache Tests / Kiểm thử LRU Cache”);
  console.log(“=”.repeat(50));</li>
</ul>

<p>// Test 1: Basic operations
  console.log(“\nTest 1: Basic operations / Các thao tác cơ bản”);
  const cache1 = new LRUCache(2);
  cache1.put(1, 1);
  cache1.put(2, 2);
  console.log(<code class="language-plaintext highlighter-rouge">get(1): ${cache1.get(1)}</code>); // Expected: 1
  cache1.put(3, 3);
  console.log(<code class="language-plaintext highlighter-rouge">get(2): ${cache1.get(2)}</code>); // Expected: -1
  cache1.put(4, 4);
  console.log(<code class="language-plaintext highlighter-rouge">get(1): ${cache1.get(1)}</code>); // Expected: -1
  console.log(<code class="language-plaintext highlighter-rouge">get(3): ${cache1.get(3)}</code>); // Expected: 3
  console.log(<code class="language-plaintext highlighter-rouge">get(4): ${cache1.get(4)}</code>); // Expected: 4</p>

<p>// Test 2: Performance tracking
  console.log(“\nTest 2: Performance tracking / Theo dõi hiệu suất”);
  const perfCache = new LRUCacheWithStats(3);</p>

<p>perfCache.put(1, 1);
  perfCache.put(2, 2);
  perfCache.put(3, 3);
  perfCache.get(1); // Hit
  perfCache.get(4); // Miss
  perfCache.put(4, 4); // Evicts 2
  perfCache.get(2); // Miss (evicted)</p>

<p>const stats = perfCache.getPerformanceStats();
  console.log(<code class="language-plaintext highlighter-rouge">Hit count: ${stats.hitCount}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Miss count: ${stats.missCount}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Hit rate: ${stats.hitRate.toFixed(2)}%</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Eviction count: ${stats.evictionCount}</code>);</p>

<p>// Test 3: TTL cache
  console.log(“\nTest 3: TTL cache / Cache với TTL”);
  const ttlCache = new LRUCacheWithTTL(3, 1000); // 1 second TTL</p>

<p>ttlCache.put(1, 1);
  ttlCache.put(2, 2);
  console.log(<code class="language-plaintext highlighter-rouge">get(1): ${ttlCache.get(1)}</code>); // Expected: 1</p>

<p>// Wait for TTL to expire (simulate)
  setTimeout(() =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">get(1) after TTL: ${ttlCache.get(1)}</code>); // Expected: -1
    console.log(<code class="language-plaintext highlighter-rouge">TTL stats: ${JSON.stringify(ttlCache.getTTLStats())}</code>);
  }, 1100);</p>

<p>// Test 4: Cache statistics
  console.log(“\nTest 4: Cache statistics / Thống kê cache”);
  const statCache = new LRUCache(5);</p>

<p>for (let i = 1; i &lt;= 7; i++) {
    statCache.put(i, i * 10);
  }</p>

<p>console.log(<code class="language-plaintext highlighter-rouge">Size: ${statCache.size()}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Is full: ${statCache.isFull()}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Keys in order: [${statCache.getKeysInOrder().join(", ")}]</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Stats: ${JSON.stringify(statCache.getStats())}</code>);</p>

<p>// Test 5: Performance comparison
  console.log(“\nTest 5: Performance comparison / So sánh hiệu suất”);
  const testOperations = [
    { type: “put” as const, key: 1, value: 1 },
    { type: “put” as const, key: 2, value: 2 },
    { type: “get” as const, key: 1 },
    { type: “put” as const, key: 3, value: 3 },
    { type: “get” as const, key: 2 },
    { type: “put” as const, key: 4, value: 4 },
    { type: “get” as const, key: 1 },
    { type: “get” as const, key: 3 },
    { type: “get” as const, key: 4 },
  ];</p>

<p>compareLRUImplementations(testOperations);
}</p>

<p>// Uncomment to run tests
// runTests();</p>

<p>export {
  LRUCache,
  LRUCacheMap,
  LRUCacheWithStats,
  LRUCacheWithTTL,
  ListNode,
  compareLRUImplementations,
  runTests,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>