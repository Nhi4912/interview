<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design Circular Queue | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/others/">Others</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/others/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Design circular queue</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Design Circular Queue</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Others</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Others</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="design-circular-queue">Design Circular Queue</h1>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>
    <ul>
      <li>Design your implementation of the circular queue. The circular queue is a linear  * data structure in which the operations are performed based on FIFO (First In First Out)  * principle and the last position is connected back to the first position to make a circle.  * It is also called “Ring Buffer”.</li>
    </ul>
  </li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>Design Circular Queue
 *</li>
  <li>Problem: https://leetcode.com/problems/design-circular-queue/
 *</li>
  <li>Design your implementation of the circular queue. The circular queue is a linear</li>
  <li>data structure in which the operations are performed based on FIFO (First In First Out)</li>
  <li>principle and the last position is connected back to the first position to make a circle.</li>
  <li>It is also called “Ring Buffer”.
 *</li>
  <li>One of the benefits of the circular queue is that we can make use of the spaces in</li>
  <li>front of the queue. In a normal queue, once the queue becomes full, we cannot insert</li>
  <li>the next element even if there is a space in front of the queue. But using a circular</li>
  <li>queue, we can use the space to store new values.
 *</li>
  <li>Implementation the MyCircularQueue class:</li>
  <li>
    <ul>
      <li>MyCircularQueue(k) Initializes the object with the size of the queue to be k.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>boolean enQueue(int value) Inserts an element into the circular queue. Return true</li>
    </ul>
  </li>
  <li>if the operation is successful.</li>
  <li>
    <ul>
      <li>boolean deQueue() Deletes an element from the circular queue. Return true if the</li>
    </ul>
  </li>
  <li>operation is successful.</li>
  <li>
    <ul>
      <li>int Front() Gets the front item from the queue. If the queue is empty, return -1.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>int Rear() Gets the last item from the queue. If the queue is empty, return -1.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>boolean isEmpty() Checks whether the circular queue is empty or not.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>boolean isFull() Checks whether the circular queue is full or not.
 *</li>
    </ul>
  </li>
  <li>You must solve the problem without using the built-in queue data structure in your</li>
  <li>programming language.
 *</li>
  <li>Example 1:</li>
  <li>Input:</li>
  <li>[“MyCircularQueue”, “enQueue”, “enQueue”, “enQueue”, “enQueue”, “Rear”, “isFull”, “deQueue”, “enQueue”, “Rear”]</li>
  <li>[[3], [1], [2], [3], [4], [], [], [], [4], []]</li>
  <li>Output: [null, true, true, true, false, 3, true, true, true, 4]
 *</li>
  <li>Explanation:</li>
  <li>MyCircularQueue myCircularQueue = new MyCircularQueue(3);</li>
  <li>myCircularQueue.enQueue(1); // return True</li>
  <li>myCircularQueue.enQueue(2); // return True</li>
  <li>myCircularQueue.enQueue(3); // return True</li>
  <li>myCircularQueue.enQueue(4); // return False</li>
  <li>myCircularQueue.Rear();     // return 3</li>
  <li>myCircularQueue.isFull();   // return True</li>
  <li>myCircularQueue.deQueue();  // return True</li>
  <li>myCircularQueue.enQueue(4); // return True</li>
  <li>myCircularQueue.Rear();     // return 4
 *</li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>1 &lt;= k &lt;= 1000</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>0 &lt;= value &lt;= 1000</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>At most 3000 calls will be made to enQueue, deQueue, Front, Rear, isEmpty, and isFull.
 *</li>
    </ul>
  </li>
  <li>Solution Approaches:</li>
  <li>
    <ol>
      <li>Array-based implementation with front and rear pointers</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Array-based implementation with size tracking</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Linked list implementation</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>With additional features and statistics
 *</li>
    </ol>
  </li>
  <li>Time Complexity: O(1) for all operations</li>
  <li>Space Complexity: O(k) where k is the capacity
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>MyCircularQueue - Array-based Implementation with Front and Rear Pointers
 *</li>
  <li>MyCircularQueue - Triển khai dựa trên Array với con trỏ Front và Rear
 *</li>
  <li>This approach uses an array with front and rear pointers to track the queue state
 */
class MyCircularQueue {
  private queue: number[];
  private front: number;
  private rear: number;
  private capacity: number;
  private size: number;</li>
</ul>

<p>constructor(k: number) {
    this.queue = new Array(k);
    this.front = 0;
    this.rear = -1;
    this.capacity = k;
    this.size = 0;
  }</p>

<p>/**</p>
<ul>
  <li>Insert an element into the circular queue</li>
  <li>Chèn một phần tử vào circular queue
   */
  enQueue(value: number): boolean {
    if (this.isFull()) {
 return false;
    }</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>this.rear = (this.rear + 1) % this.capacity;
this.queue[this.rear] = value;
this.size++;

return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Delete an element from the circular queue</li>
  <li>Xóa một phần tử khỏi circular queue
   */
  deQueue(): boolean {
    if (this.isEmpty()) {
 return false;
    }</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>this.front = (this.front + 1) % this.capacity;
this.size--;

return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Get the front item from the queue</li>
  <li>Lấy phần tử đầu tiên từ queue
   */
  Front(): number {
    if (this.isEmpty()) {
 return -1;
    }</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>return this.queue[this.front];   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Get the last item from the queue</li>
  <li>Lấy phần tử cuối cùng từ queue
   */
  Rear(): number {
    if (this.isEmpty()) {
 return -1;
    }</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>return this.queue[this.rear];   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Check if the queue is empty</li>
  <li>Kiểm tra xem queue có rỗng không
   */
  isEmpty(): boolean {
    return this.size === 0;
  }</li>
</ul>

<p>/**</p>
<ul>
  <li>Check if the queue is full</li>
  <li>Kiểm tra xem queue có đầy không
   */
  isFull(): boolean {
    return this.size === this.capacity;
  }</li>
</ul>

<p>/**</p>
<ul>
  <li>Get current size of the queue</li>
  <li>Lấy kích thước hiện tại của queue
   */
  getSize(): number {
    return this.size;
  }</li>
</ul>

<p>/**</p>
<ul>
  <li>Get the capacity of the queue</li>
  <li>Lấy dung lượng của queue
   */
  getCapacity(): number {
    return this.capacity;
  }</li>
</ul>

<p>/**</p>
<ul>
  <li>Get the internal state for debugging</li>
  <li>Lấy trạng thái nội bộ để debug
   */
  getState(): { queue: number[]; front: number; rear: number; size: number } {
    return {
 queue: […this.queue],
 front: this.front,
 rear: this.rear,
 size: this.size,
    };
  }
}</li>
</ul>

<p>/**</p>
<ul>
  <li>Alternative Implementation: Array-based with Size Tracking Only
 *</li>
  <li>Triển khai thay thế: Dựa trên Array chỉ với theo dõi kích thước
 */
class MyCircularQueueSizeOnly {
  private queue: number[];
  private front: number;
  private size: number;
  private capacity: number;</li>
</ul>

<p>constructor(k: number) {
    this.queue = new Array(k);
    this.front = 0;
    this.size = 0;
    this.capacity = k;
  }</p>

<p>enQueue(value: number): boolean {
    if (this.isFull()) {
      return false;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>const rear = (this.front + this.size) % this.capacity;
this.queue[rear] = value;
this.size++;

return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>deQueue(): boolean {
    if (this.isEmpty()) {
      return false;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>this.front = (this.front + 1) % this.capacity;
this.size--;

return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Front(): number {
    if (this.isEmpty()) {
      return -1;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>return this.queue[this.front];   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Rear(): number {
    if (this.isEmpty()) {
      return -1;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>const rear = (this.front + this.size - 1) % this.capacity;
return this.queue[rear];   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>isEmpty(): boolean {
    return this.size === 0;
  }</p>

<p>isFull(): boolean {
    return this.size === this.capacity;
  }</p>

<p>getSize(): number {
    return this.size;
  }
}</p>

<p>/**</p>
<ul>
  <li>Linked List Implementation
 *</li>
  <li>Triển khai Linked List
 */
class CircularQueueNode {
  value: number;
  next: CircularQueueNode | null;</li>
</ul>

<p>constructor(value: number) {
    this.value = value;
    this.next = null;
  }
}</p>

<p>class MyCircularQueueLinkedList {
  private head: CircularQueueNode | null;
  private tail: CircularQueueNode | null;
  private size: number;
  private capacity: number;</p>

<p>constructor(k: number) {
    this.head = null;
    this.tail = null;
    this.size = 0;
    this.capacity = k;
  }</p>

<p>enQueue(value: number): boolean {
    if (this.isFull()) {
      return false;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>const newNode = new CircularQueueNode(value);

if (this.isEmpty()) {
  this.head = newNode;
  this.tail = newNode;
  newNode.next = newNode; // Circular reference
} else {
  this.tail!.next = newNode;
  newNode.next = this.head;
  this.tail = newNode;
}

this.size++;
return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>deQueue(): boolean {
    if (this.isEmpty()) {
      return false;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>if (this.size === 1) {
  this.head = null;
  this.tail = null;
} else {
  this.head = this.head!.next;
  this.tail!.next = this.head;
}

this.size--;
return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Front(): number {
    if (this.isEmpty()) {
      return -1;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>return this.head!.value;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Rear(): number {
    if (this.isEmpty()) {
      return -1;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>return this.tail!.value;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>isEmpty(): boolean {
    return this.size === 0;
  }</p>

<p>isFull(): boolean {
    return this.size === this.capacity;
  }</p>

<p>getSize(): number {
    return this.size;
  }
}</p>

<p>/**</p>
<ul>
  <li>Implementation with Statistics and Monitoring
 *</li>
  <li>Triển khai với thống kê và giám sát
 */
class MyCircularQueueWithStats extends MyCircularQueue {
  private enqueueCount: number;
  private dequeueCount: number;
  private overflowCount: number;
  private underflowCount: number;
  private operationHistory: Array&lt;{
 operation: string;
 value?: number;
 timestamp: number;
 success: boolean;
  }&gt;;</li>
</ul>

<p>constructor(k: number) {
    super(k);
    this.enqueueCount = 0;
    this.dequeueCount = 0;
    this.overflowCount = 0;
    this.underflowCount = 0;
    this.operationHistory = [];
  }</p>

<p>enQueue(value: number): boolean {
    const success = super.enQueue(value);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>this.enqueueCount++;
if (!success) {
  this.overflowCount++;
}

this.operationHistory.push({
  operation: "enQueue",
  value,
  timestamp: Date.now(),
  success,
});

return success;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>deQueue(): boolean {
    const success = super.deQueue();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>this.dequeueCount++;
if (!success) {
  this.underflowCount++;
}

this.operationHistory.push({
  operation: "deQueue",
  timestamp: Date.now(),
  success,
});

return success;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Get queue statistics</li>
  <li>Lấy thống kê queue
   */
  getStats(): {
    enqueueCount: number;
    dequeueCount: number;
    overflowCount: number;
    underflowCount: number;
    successRate: number;
    currentUtilization: number;
  } {
    const totalOperations = this.enqueueCount + this.dequeueCount;
    const successfulOperations =
 this.enqueueCount -
 this.overflowCount +
 this.dequeueCount -
 this.underflowCount;
    const successRate =
 totalOperations &gt; 0 ? (successfulOperations / totalOperations) * 100 : 0;
    const utilization = (this.getSize() / this.getCapacity()) * 100;</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>return {
  enqueueCount: this.enqueueCount,
  dequeueCount: this.dequeueCount,
  overflowCount: this.overflowCount,
  underflowCount: this.underflowCount,
  successRate,
  currentUtilization: utilization,
};   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Get recent operation history</li>
  <li>Lấy lịch sử thao tác gần đây
   */
  getRecentHistory(
    count: number = 10
  ): Array&lt;{
    operation: string;
    value?: number;
    timestamp: number;
    success: boolean;
  }&gt; {
    return this.operationHistory.slice(-count);
  }</li>
</ul>

<p>/**</p>
<ul>
  <li>Clear operation history</li>
  <li>Xóa lịch sử thao tác
   */
  clearHistory(): void {
    this.operationHistory = [];
  }
}</li>
</ul>

<p>/**</p>
<ul>
  <li>Implementation with Priority Queue Features
 *</li>
  <li>Triển khai với tính năng Priority Queue
 */
class MyCircularQueueWithPriority extends MyCircularQueue {
  private priorities: number[];</li>
</ul>

<p>constructor(k: number) {
    super(k);
    this.priorities = new Array(k);
  }</p>

<p>/**</p>
<ul>
  <li>Enqueue with priority</li>
  <li>Enqueue với độ ưu tiên
   */
  enQueueWithPriority(value: number, priority: number): boolean {
    if (this.isFull()) {
 return false;
    }</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>// Find position to insert based on priority
let insertIndex = this.front;
for (let i = 0; i &lt; this.getSize(); i++) {
  const currentIndex = (this.front + i) % this.getCapacity();
  if (priority &gt; this.priorities[currentIndex]) {
    insertIndex = currentIndex;
    break;
  }
}

// Shift elements to make space
for (let i = this.getSize(); i &gt; 0; i--) {
  const currentIndex = (this.front + i - 1) % this.getCapacity();
  const nextIndex = (this.front + i) % this.getCapacity();
  this.queue[nextIndex] = this.queue[currentIndex];
  this.priorities[nextIndex] = this.priorities[currentIndex];
}

// Insert at the correct position
this.queue[insertIndex] = value;
this.priorities[insertIndex] = priority;

return true;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Get element with highest priority</li>
  <li>Lấy phần tử có độ ưu tiên cao nhất
   */
  getHighestPriority(): number {
    if (this.isEmpty()) {
 return -1;
    }</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>let maxPriority = -1;
let maxPriorityIndex = this.front;

for (let i = 0; i &lt; this.getSize(); i++) {
  const currentIndex = (this.front + i) % this.getCapacity();
  if (this.priorities[currentIndex] &gt; maxPriority) {
    maxPriority = this.priorities[currentIndex];
    maxPriorityIndex = currentIndex;
  }
}

return this.queue[maxPriorityIndex];   } }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Performance Comparison Function
 *</li>
  <li>Hàm so sánh hiệu suất các phương pháp
 */
function compareCircularQueueImplementations(
  operations: Array&lt;{
 type: “enQueue” | “deQueue” | “Front” | “Rear”;
 value?: number;
  }&gt;
): void {
  console.log(
 “Circular Queue Implementation Performance Comparison / So sánh hiệu suất triển khai Circular Queue”
  );
  console.log(“=”.repeat(90));</li>
</ul>

<p>const implementations = [
    { name: “Array with Pointers”, queue: new MyCircularQueue(100) },
    { name: “Array Size Only”, queue: new MyCircularQueueSizeOnly(100) },
    { name: “Linked List”, queue: new MyCircularQueueLinkedList(100) },
  ];</p>

<p>for (const impl of implementations) {
    console.log(<code class="language-plaintext highlighter-rouge">\nTesting ${impl.name}:</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>const start = performance.now();

for (const op of operations) {
  switch (op.type) {
    case "enQueue":
      impl.queue.enQueue(op.value!);
      break;
    case "deQueue":
      impl.queue.deQueue();
      break;
    case "Front":
      impl.queue.Front();
      break;
    case "Rear":
      impl.queue.Rear();
      break;
  }
}

const end = performance.now();
console.log(`  Time: ${(end - start).toFixed(4)}ms`);
console.log(`  Final size: ${impl.queue.getSize()}`);   } }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Test Cases
 *</li>
  <li>Các trường hợp kiểm thử
 */
function runTests(): void {
  console.log(“Circular Queue Tests / Kiểm thử Circular Queue”);
  console.log(“=”.repeat(50));</li>
</ul>

<p>// Test 1: Basic operations
  console.log(“\nTest 1: Basic operations / Các thao tác cơ bản”);
  const queue1 = new MyCircularQueue(3);
  console.log(<code class="language-plaintext highlighter-rouge">enQueue(1): ${queue1.enQueue(1)}</code>); // Expected: true
  console.log(<code class="language-plaintext highlighter-rouge">enQueue(2): ${queue1.enQueue(2)}</code>); // Expected: true
  console.log(<code class="language-plaintext highlighter-rouge">enQueue(3): ${queue1.enQueue(3)}</code>); // Expected: true
  console.log(<code class="language-plaintext highlighter-rouge">enQueue(4): ${queue1.enQueue(4)}</code>); // Expected: false
  console.log(<code class="language-plaintext highlighter-rouge">Rear(): ${queue1.Rear()}</code>); // Expected: 3
  console.log(<code class="language-plaintext highlighter-rouge">isFull(): ${queue1.isFull()}</code>); // Expected: true
  console.log(<code class="language-plaintext highlighter-rouge">deQueue(): ${queue1.deQueue()}</code>); // Expected: true
  console.log(<code class="language-plaintext highlighter-rouge">enQueue(4): ${queue1.enQueue(4)}</code>); // Expected: true
  console.log(<code class="language-plaintext highlighter-rouge">Rear(): ${queue1.Rear()}</code>); // Expected: 4</p>

<p>// Test 2: Statistics tracking
  console.log(“\nTest 2: Statistics tracking / Theo dõi thống kê”);
  const statQueue = new MyCircularQueueWithStats(5);</p>

<p>for (let i = 1; i &lt;= 7; i++) {
    statQueue.enQueue(i);
  }</p>

<p>for (let i = 0; i &lt; 3; i++) {
    statQueue.deQueue();
  }</p>

<p>const stats = statQueue.getStats();
  console.log(<code class="language-plaintext highlighter-rouge">Enqueue count: ${stats.enqueueCount}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Dequeue count: ${stats.dequeueCount}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Overflow count: ${stats.overflowCount}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Success rate: ${stats.successRate.toFixed(2)}%</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Utilization: ${stats.currentUtilization.toFixed(2)}%</code>);</p>

<p>// Test 3: State inspection
  console.log(“\nTest 3: State inspection / Kiểm tra trạng thái”);
  const stateQueue = new MyCircularQueue(4);
  stateQueue.enQueue(1);
  stateQueue.enQueue(2);</p>

<p>console.log(“Current state:”);
  console.log(stateQueue.getState());</p>

<p>stateQueue.deQueue();</p>

<p>console.log(“After dequeue:”);
  console.log(stateQueue.getState());</p>

<p>// Test 4: Performance comparison
  console.log(“\nTest 4: Performance comparison / So sánh hiệu suất”);
  const testOperations = [
    { type: “enQueue” as const, value: 1 },
    { type: “enQueue” as const, value: 2 },
    { type: “enQueue” as const, value: 3 },
    { type: “Front” as const },
    { type: “Rear” as const },
    { type: “deQueue” as const },
    { type: “enQueue” as const, value: 4 },
    { type: “Front” as const },
    { type: “Rear” as const },
  ];</p>

<p>compareCircularQueueImplementations(testOperations);
}</p>

<p>// Uncomment to run tests
// runTests();</p>

<p>export {
  MyCircularQueue,
  MyCircularQueueSizeOnly,
  MyCircularQueueLinkedList,
  MyCircularQueueWithStats,
  MyCircularQueueWithPriority,
  CircularQueueNode,
  compareCircularQueueImplementations,
  runTests,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>