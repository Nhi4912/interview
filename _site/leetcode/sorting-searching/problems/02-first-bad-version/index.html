<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>First Bad Version | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/sorting-searching/">Sorting searching</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/sorting-searching/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">First bad version</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">First Bad Version</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Sorting/Searching</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Sorting/Searching</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                                    <span class="tag">Binary Search</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="first-bad-version">First Bad Version</h1>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>
    <ul>
      <li>You are a product manager and currently leading a team to develop a new product.  * Unfortunately, the latest version of your product fails the quality check. Since  * each version is developed based on the previous version, all the versions after  * a bad version are also bad.</li>
    </ul>
  </li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>First Bad Version
 *</li>
  <li>Problem: https://leetcode.com/problems/first-bad-version/
 *</li>
  <li>You are a product manager and currently leading a team to develop a new product.</li>
  <li>Unfortunately, the latest version of your product fails the quality check. Since</li>
  <li>each version is developed based on the previous version, all the versions after</li>
  <li>a bad version are also bad.
 *</li>
  <li>Suppose you have n versions [1, 2, …, n] and you want to find out the first</li>
  <li>bad one, which causes all the following ones to be bad.
 *</li>
  <li>You are given an API bool isBadVersion(version) which returns whether version</li>
  <li>is bad. Implement a function to find the first bad version. You should minimize</li>
  <li>the number of calls to the API.
 *</li>
  <li>Example 1:</li>
  <li>Input: n = 5, bad = 4</li>
  <li>Output: 4</li>
  <li>Explanation:</li>
  <li>call isBadVersion(3) -&gt; false</li>
  <li>call isBadVersion(5) -&gt; true</li>
  <li>call isBadVersion(4) -&gt; true</li>
  <li>Then 4 is the first bad version.
 *</li>
  <li>Example 2:</li>
  <li>Input: n = 1, bad = 1</li>
  <li>Output: 1
 *</li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>1 &lt;= bad &lt;= n &lt;= 2^31 - 1
 *</li>
    </ul>
  </li>
  <li>Solution Approach:</li>
  <li>
    <ol>
      <li>Binary search to minimize API calls</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>If mid version is bad, search in left half</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>If mid version is good, search in right half</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>Return the first bad version found
 *</li>
    </ol>
  </li>
  <li>Time Complexity: O(log n) where n is the number of versions</li>
  <li>Space Complexity: O(1) as we only use a constant amount of extra space
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>Mock API function for testing
 *</li>
  <li>Hàm API giả lập để kiểm thử
 */
let badVersion: number = 0;</li>
</ul>

<p>function isBadVersion(version: number): boolean {
  return version &gt;= badVersion;
}</p>

<p>/**</p>
<ul>
  <li>First Bad Version - Binary Search Solution
 *</li>
  <li>Giải pháp tìm kiếm nhị phân cho bài toán Phiên bản xấu đầu tiên
 *</li>
  <li>@param n - Tổng số phiên bản</li>
  <li>@returns Phiên bản xấu đầu tiên
 */
function firstBadVersion(n: number): number {
  let left = 1;
  let right = n;</li>
</ul>

<p>while (left &lt; right) {
    const mid = Math.floor(left + (right - left) / 2);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>if (isBadVersion(mid)) {
  // Phiên bản mid xấu, tìm kiếm ở nửa trái
  right = mid;
} else {
  // Phiên bản mid tốt, tìm kiếm ở nửa phải
  left = mid + 1;
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return left;
}</p>

<p>/**</p>
<ul>
  <li>Alternative Solution: Using Math.floor
 *</li>
  <li>Giải pháp thay thế: Sử dụng Math.floor
 *</li>
  <li>@param n - Tổng số phiên bản</li>
  <li>@returns Phiên bản xấu đầu tiên
 */
function firstBadVersionAlternative(n: number): number {
  let left = 1;
  let right = n;</li>
</ul>

<p>while (left &lt; right) {
    const mid = Math.floor((left + right) / 2);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>if (isBadVersion(mid)) {
  right = mid;
} else {
  left = mid + 1;
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return left;
}</p>

<p>/**</p>
<ul>
  <li>Solution with API Call Counting
 *</li>
  <li>Giải pháp với đếm số lần gọi API
 *</li>
  <li>@param n - Tổng số phiên bản</li>
  <li>@returns Object chứa phiên bản xấu đầu tiên và số lần gọi API
 */
function firstBadVersionWithCount(n: number): {
  firstBad: number;
  apiCalls: number;
} {
  let left = 1;
  let right = n;
  let apiCalls = 0;</li>
</ul>

<p>while (left &lt; right) {
    const mid = Math.floor(left + (right - left) / 2);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>apiCalls++;
if (isBadVersion(mid)) {
  right = mid;
} else {
  left = mid + 1;
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return { firstBad: left, apiCalls };
}</p>

<p>/**</p>
<ul>
  <li>Linear Search Solution (for comparison)
 *</li>
  <li>Giải pháp tìm kiếm tuyến tính (để so sánh)
 *</li>
  <li>@param n - Tổng số phiên bản</li>
  <li>@returns Phiên bản xấu đầu tiên
 */
function firstBadVersionLinear(n: number): number {
  for (let i = 1; i &lt;= n; i++) {
 if (isBadVersion(i)) {
   return i;
 }
  }</li>
</ul>

<p>return n; // Tất cả phiên bản đều xấu
}</p>

<p>/**</p>
<ul>
  <li>Solution with Version History
 *</li>
  <li>Giải pháp với lịch sử phiên bản
 *</li>
  <li>@param n - Tổng số phiên bản</li>
  <li>@returns Object chứa kết quả và lịch sử kiểm tra
 */
function firstBadVersionWithHistory(n: number): {
  firstBad: number;
  history: Array&lt;{ version: number; isBad: boolean }&gt;;
} {
  let left = 1;
  let right = n;
  const history: Array&lt;{ version: number; isBad: boolean }&gt; = [];</li>
</ul>

<p>while (left &lt; right) {
    const mid = Math.floor(left + (right - left) / 2);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>const isBad = isBadVersion(mid);
history.push({ version: mid, isBad });

if (isBad) {
  right = mid;
} else {
  left = mid + 1;
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return { firstBad: left, history };
}</p>

<p>/**</p>
<ul>
  <li>Recursive Binary Search Solution
 *</li>
  <li>Giải pháp tìm kiếm nhị phân đệ quy
 *</li>
  <li>@param n - Tổng số phiên bản</li>
  <li>
    <p>@returns Phiên bản xấu đầu tiên
 */
function firstBadVersionRecursive(n: number): number {
  function binarySearch(left: number, right: number): number {
 if (left &gt;= right) {
   return left;
 }</p>

    <p>const mid = Math.floor(left + (right - left) / 2);</p>

    <p>if (isBadVersion(mid)) {
   return binarySearch(left, mid);
 } else {
   return binarySearch(mid + 1, right);
 }
  }</p>
  </li>
</ul>

<p>return binarySearch(1, n);
}</p>

<p>// Test cases / Các trường hợp kiểm thử
function runTests() {
  console.log(“=== First Bad Version Tests ===”);
  console.log(“=== Kiểm thử bài toán Phiên bản xấu đầu tiên ===\n”);</p>

<p>const testCases = [
    {
      name: “Example 1: n=5, bad=4”,
      n: 5,
      bad: 4,
      expected: 4,
      description: “First bad version is 4”,
    },
    {
      name: “Example 2: n=1, bad=1”,
      n: 1,
      bad: 1,
      expected: 1,
      description: “Only one version and it’s bad”,
    },
    {
      name: “n=10, bad=1”,
      n: 10,
      bad: 1,
      expected: 1,
      description: “First version is bad”,
    },
    {
      name: “n=10, bad=10”,
      n: 10,
      bad: 10,
      expected: 10,
      description: “Last version is bad”,
    },
    {
      name: “n=100, bad=50”,
      n: 100,
      bad: 50,
      expected: 50,
      description: “Middle version is bad”,
    },
    {
      name: “n=1000, bad=1”,
      n: 1000,
      bad: 1,
      expected: 1,
      description: “Large n, first version bad”,
    },
    {
      name: “n=1000, bad=1000”,
      n: 1000,
      bad: 1000,
      expected: 1000,
      description: “Large n, last version bad”,
    },
  ];</p>

<p>let passedTests = 0;
  const totalTests = testCases.length;</p>

<p>for (const testCase of testCases) {
    console.log(<code class="language-plaintext highlighter-rouge">Test: ${testCase.name}</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Input: n=${testCase.n}, bad=${testCase.bad}</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Expected: ${testCase.expected}</code>);
    console.log(<code class="language-plaintext highlighter-rouge">Description: ${testCase.description}</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>// Set the bad version for this test
badVersion = testCase.bad;

const result = firstBadVersion(testCase.n);
const passed = result === testCase.expected;

console.log(`Result: ${result}`);
console.log(`Status: ${passed ? "✅ PASSED" : "❌ FAILED"}`);

if (passed) {
  passedTests++;
} else {
  console.log(`Expected: ${testCase.expected}, Got: ${result}`);
}

console.log("---");   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>console.log(<code class="language-plaintext highlighter-rouge">\nTest Summary: ${passedTests}/${totalTests} tests passed</code>);
  console.log(
    <code class="language-plaintext highlighter-rouge">Tóm tắt kiểm thử: ${passedTests}/${totalTests} bài kiểm thử đã qua</code>
  );</p>

<p>// Test with API call counting
  console.log(“\n=== Testing with API Call Counting ===”);
  console.log(“=== Kiểm thử với đếm số lần gọi API ===\n”);</p>

<p>const testN = 100;
  const testBad = 50;
  badVersion = testBad;</p>

<p>const resultWithCount = firstBadVersionWithCount(testN);
  console.log(<code class="language-plaintext highlighter-rouge">n=${testN}, bad=${testBad}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">First bad version: ${resultWithCount.firstBad}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">API calls: ${resultWithCount.apiCalls}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Expected API calls: ~${Math.ceil(Math.log2(testN))}</code>);</p>

<p>// Test with history
  console.log(“\n=== Testing with History ===”);
  console.log(“=== Kiểm thử với lịch sử ===\n”);</p>

<p>const resultWithHistory = firstBadVersionWithHistory(20);
  console.log(<code class="language-plaintext highlighter-rouge">n=20, bad=${badVersion}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">First bad version: ${resultWithHistory.firstBad}</code>);
  console.log(“API call history:”);
  console.log(“Lịch sử gọi API:”);
  resultWithHistory.history.forEach((call, index) =&gt; {
    console.log(
      `  ${index + 1}. isBadVersion(${call.version}) -&gt; ${call.isBad}`
    );
  });</p>

<p>// Performance comparison
  console.log(“\n=== Performance Comparison ===”);
  console.log(“=== So sánh hiệu suất ===\n”);</p>

<p>const largeN = 1000000;
  const largeBad = 500000;
  badVersion = largeBad;</p>

<p>console.log(<code class="language-plaintext highlighter-rouge">Testing with large input: n=${largeN}, bad=${largeBad}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Kiểm thử với đầu vào lớn: n=${largeN}, bad=${largeBad}</code>);</p>

<p>const start1 = performance.now();
  const result1 = firstBadVersion(largeN);
  const time1 = performance.now() - start1;</p>

<p>const start2 = performance.now();
  const result2 = firstBadVersionAlternative(largeN);
  const time2 = performance.now() - start2;</p>

<p>const start3 = performance.now();
  const result3 = firstBadVersionRecursive(largeN);
  const time3 = performance.now() - start3;</p>

<p>console.log(<code class="language-plaintext highlighter-rouge">Binary Search: ${time1.toFixed(4)}ms, Result: ${result1}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Alternative: ${time2.toFixed(4)}ms, Result: ${result2}</code>);
  console.log(<code class="language-plaintext highlighter-rouge">Recursive: ${time3.toFixed(4)}ms, Result: ${result3}</code>);
  console.log(
    <code class="language-plaintext highlighter-rouge">Results match: ${
      result1 === result2 &amp;&amp; result2 === result3 ? "✅ Yes" : "❌ No"
    }</code>
  );</p>

<p>// Compare with linear search for small input
  console.log(“\n=== Linear vs Binary Search (small input) ===”);
  console.log(“=== Tìm kiếm tuyến tính vs nhị phân (đầu vào nhỏ) ===\n”);</p>

<p>const smallN = 1000;
  const smallBad = 500;
  badVersion = smallBad;</p>

<p>const startLinear = performance.now();
  const resultLinear = firstBadVersionLinear(smallN);
  const timeLinear = performance.now() - startLinear;</p>

<p>const startBinary = performance.now();
  const resultBinary = firstBadVersion(smallN);
  const timeBinary = performance.now() - startBinary;</p>

<p>console.log(
    <code class="language-plaintext highlighter-rouge">Linear Search: ${timeLinear.toFixed(4)}ms, Result: ${resultLinear}</code>
  );
  console.log(
    <code class="language-plaintext highlighter-rouge">Binary Search: ${timeBinary.toFixed(4)}ms, Result: ${resultBinary}</code>
  );
  console.log(<code class="language-plaintext highlighter-rouge">Speedup: ${(timeLinear / timeBinary).toFixed(2)}x faster</code>);
  console.log(
    <code class="language-plaintext highlighter-rouge">Results match: ${resultLinear === resultBinary ? "✅ Yes" : "❌ No"}</code>
  );
}</p>

<p>// Run tests if this file is executed directly
if (require.main === module) {
  runTests();
}</p>

<p>export {
  firstBadVersion,
  firstBadVersionAlternative,
  firstBadVersionWithCount,
  firstBadVersionLinear,
  firstBadVersionWithHistory,
  firstBadVersionRecursive,
  isBadVersion,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>