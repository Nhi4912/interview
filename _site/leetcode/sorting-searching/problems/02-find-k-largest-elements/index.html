<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kth Largest Element in an Array | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/sorting-searching/">Sorting searching</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/sorting-searching/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Kth largest element in an array</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Kth Largest Element in an Array</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Sorting/Searching</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Sorting/Searching</span>
                                
                                    <span class="tag">Sorting</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="kth-largest-element-in-an-array">Kth Largest Element in an Array</h1>

<p><strong>LeetCode Problem # * 215. Kth Largest Element in an Array</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Kth Largest Element in an Array</li>
    </ol>
  </li>
  <li></li>
  <li>Given an integer array nums and an integer k, return the kth largest element in the array.</li>
  <li>Note that it is the kth largest element in the sorted order, not the kth distinct element.</li>
  <li>Can you solve it without sorting?</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: nums = [3,2,1,5,6,4], k = 2</li>
  <li>Output: 5</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: nums = [3,2,3,1,2,4,5,5,6], k = 4</li>
  <li>Output: 4</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>1 &lt;= k &lt;= nums.length &lt;= 10^5</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>-10^4 &lt;= nums[i] &lt;= 10^4</li>
    </ul>
  </li>
  <li></li>
  <li>Follow up: Can you solve it in O(n) time complexity?
 */</li>
</ul>

<p>// Solution 1: Min Heap (Priority Queue)
// Time: O(n log k), Space: O(k)
export function findKthLargest1(nums: number[], k: number): number {
    class MinHeap {
        heap: number[] = [];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="rouge-code"><pre>    push(val: number): void {
        this.heap.push(val);
        this.heapifyUp(this.heap.length - 1);
    }
    
    pop(): number | undefined {
        if (this.heap.length === 0) return undefined;
        
        const min = this.heap[0];
        const last = this.heap.pop()!;
        
        if (this.heap.length &gt; 0) {
            this.heap[0] = last;
            this.heapifyDown(0);
        }
        
        return min;
    }
    
    peek(): number | undefined {
        return this.heap.length &gt; 0 ? this.heap[0] : undefined;
    }
    
    size(): number {
        return this.heap.length;
    }
    
    private heapifyUp(idx: number): void {
        while (idx &gt; 0) {
            const parentIdx = Math.floor((idx - 1) / 2);
            if (this.heap[parentIdx] &lt;= this.heap[idx]) break;
            
            [this.heap[parentIdx], this.heap[idx]] = [this.heap[idx], this.heap[parentIdx]];
            idx = parentIdx;
        }
    }
    
    private heapifyDown(idx: number): void {
        while (true) {
            let minIdx = idx;
            const leftChild = 2 * idx + 1;
            const rightChild = 2 * idx + 2;
            
            if (leftChild &lt; this.heap.length &amp;&amp; this.heap[leftChild] &lt; this.heap[minIdx]) {
                minIdx = leftChild;
            }
            
            if (rightChild &lt; this.heap.length &amp;&amp; this.heap[rightChild] &lt; this.heap[minIdx]) {
                minIdx = rightChild;
            }
            
            if (minIdx === idx) break;
            
            [this.heap[idx], this.heap[minIdx]] = [this.heap[minIdx], this.heap[idx]];
            idx = minIdx;
        }
    }
}

const minHeap = new MinHeap();

for (const num of nums) {
    minHeap.push(num);
    
    if (minHeap.size() &gt; k) {
        minHeap.pop();
    }
}

return minHeap.peek()!; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Quick Select (Optimal)
// Time: O(n) average, O(n²) worst, Space: O(1)
export function findKthLargest2(nums: number[], k: number): number {
    const targetIndex = nums.length - k; // Convert to kth smallest</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre>function quickSelect(left: number, right: number): number {
    const pivotIndex = partition(left, right);
    
    if (pivotIndex === targetIndex) {
        return nums[pivotIndex];
    } else if (pivotIndex &lt; targetIndex) {
        return quickSelect(pivotIndex + 1, right);
    } else {
        return quickSelect(left, pivotIndex - 1);
    }
}

function partition(left: number, right: number): number {
    // Choose random pivot to avoid worst case
    const randomIndex = left + Math.floor(Math.random() * (right - left + 1));
    [nums[randomIndex], nums[right]] = [nums[right], nums[randomIndex]];
    
    const pivot = nums[right];
    let i = left;
    
    for (let j = left; j &lt; right; j++) {
        if (nums[j] &lt;= pivot) {
            [nums[i], nums[j]] = [nums[j], nums[i]];
            i++;
        }
    }
    
    [nums[i], nums[right]] = [nums[right], nums[i]];
    return i;
}

return quickSelect(0, nums.length - 1); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Counting Sort (when range is limited)
// Time: O(n + range), Space: O(range)
export function findKthLargest3(nums: number[], k: number): number {
    // Find min and max values
    let min = Math.min(…nums);
    let max = Math.max(…nums);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>// Create count array
const count = new Array(max - min + 1).fill(0);

// Count frequencies
for (const num of nums) {
    count[num - min]++;
}

// Find kth largest by counting from the end
let remaining = k;
for (let i = count.length - 1; i &gt;= 0; i--) {
    remaining -= count[i];
    if (remaining &lt;= 0) {
        return i + min;
    }
}

return -1; // Should never reach here }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Quick Select with 3-Way Partitioning
// Time: O(n) average, Space: O(1)
export function findKthLargest4(nums: number[], k: number): number {
    const targetIndex = nums.length - k;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre>function quickSelect(left: number, right: number): number {
    if (left === right) return nums[left];
    
    const [lt, gt] = threeWayPartition(left, right);
    
    if (targetIndex &gt;= left &amp;&amp; targetIndex &lt;= lt) {
        return nums[lt];
    } else if (targetIndex &lt; lt) {
        return quickSelect(left, lt - 1);
    } else {
        return quickSelect(gt + 1, right);
    }
}

function threeWayPartition(left: number, right: number): [number, number] {
    // Choose random pivot
    const randomIndex = left + Math.floor(Math.random() * (right - left + 1));
    [nums[randomIndex], nums[left]] = [nums[left], nums[randomIndex]];
    
    const pivot = nums[left];
    let lt = left; // nums[left...lt-1] &lt; pivot
    let i = left + 1; // nums[lt...i-1] = pivot
    let gt = right; // nums[gt+1...right] &gt; pivot
    
    while (i &lt;= gt) {
        if (nums[i] &lt; pivot) {
            [nums[lt], nums[i]] = [nums[i], nums[lt]];
            lt++;
            i++;
        } else if (nums[i] &gt; pivot) {
            [nums[i], nums[gt]] = [nums[gt], nums[i]];
            gt--;
        } else {
            i++;
        }
    }
    
    return [lt, gt];
}

return quickSelect(0, nums.length - 1); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Sorting Approach
// Time: O(n log n), Space: O(1)
export function findKthLargest5(nums: number[], k: number): number {
    nums.sort((a, b) =&gt; b - a); // Sort in descending order
    return nums[k - 1];
}</p>

<p>// Solution 6: Median of Medians (Guaranteed O(n))
// Time: O(n), Space: O(log n)
export function findKthLargest6(nums: number[], k: number): number {
    const targetIndex = nums.length - k;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="rouge-code"><pre>function medianOfMedians(arr: number[], left: number, right: number): number {
    const n = right - left + 1;
    if (n &lt;= 5) {
        // Sort small array and return median
        const subarray = arr.slice(left, right + 1).sort((a, b) =&gt; a - b);
        return subarray[Math.floor(subarray.length / 2)];
    }
    
    const medians: number[] = [];
    for (let i = left; i &lt;= right; i += 5) {
        const subRight = Math.min(i + 4, right);
        const subarray = arr.slice(i, subRight + 1).sort((a, b) =&gt; a - b);
        medians.push(subarray[Math.floor(subarray.length / 2)]);
    }
    
    return medianOfMedians(medians, 0, medians.length - 1);
}

function quickSelect(left: number, right: number): number {
    if (left === right) return nums[left];
    
    // Find median of medians as pivot
    const pivotValue = medianOfMedians(nums, left, right);
    
    // Find pivot index
    let pivotIndex = left;
    for (let i = left; i &lt;= right; i++) {
        if (nums[i] === pivotValue) {
            pivotIndex = i;
            break;
        }
    }
    
    // Partition around pivot
    const partitionIndex = partition(left, right, pivotIndex);
    
    if (partitionIndex === targetIndex) {
        return nums[partitionIndex];
    } else if (partitionIndex &lt; targetIndex) {
        return quickSelect(partitionIndex + 1, right);
    } else {
        return quickSelect(left, partitionIndex - 1);
    }
}

function partition(left: number, right: number, pivotIndex: number): number {
    const pivotValue = nums[pivotIndex];
    [nums[pivotIndex], nums[right]] = [nums[right], nums[pivotIndex]];
    
    let storeIndex = left;
    for (let i = left; i &lt; right; i++) {
        if (nums[i] &lt;= pivotValue) {
            [nums[storeIndex], nums[i]] = [nums[i], nums[storeIndex]];
            storeIndex++;
        }
    }
    
    [nums[right], nums[storeIndex]] = [nums[storeIndex], nums[right]];
    return storeIndex;
}

return quickSelect(0, nums.length - 1); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testFindKthLargest() {
    console.log(“Testing Kth Largest Element in Array:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="rouge-code"><pre>const testCases = [
    {
        nums: [3, 2, 1, 5, 6, 4],
        k: 2,
        expected: 5
    },
    {
        nums: [3, 2, 3, 1, 2, 4, 5, 5, 6],
        k: 4,
        expected: 4
    },
    {
        nums: [1],
        k: 1,
        expected: 1
    },
    {
        nums: [1, 2],
        k: 1,
        expected: 2
    },
    {
        nums: [2, 1],
        k: 2,
        expected: 1
    },
    {
        nums: [7, 10, 4, 3, 20, 15],
        k: 3,
        expected: 10
    }
];

const solutions = [
    { name: "Min Heap", fn: findKthLargest1 },
    { name: "Quick Select", fn: findKthLargest2 },
    { name: "Counting Sort", fn: findKthLargest3 },
    { name: "3-Way Partition", fn: findKthLargest4 },
    { name: "Sorting", fn: findKthLargest5 },
    { name: "Median of Medians", fn: findKthLargest6 }
];

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        // Create copy since some algorithms modify the array
        const numsCopy = [...test.nums];
        const result = solution.fn(numsCopy, test.k);
        const passed = result === test.expected;
        console.log(`  Test ${i + 1}: ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Input: nums=${JSON.stringify(test.nums)}, k=${test.k}`);
            console.log(`    Expected: ${test.expected}`);
            console.log(`    Got: ${result}`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Problem Understanding</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Find kth largest element (not kth distinct)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Can solve without sorting in O(n) average time</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Multiple approaches with different trade-offs</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Heap Approach</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Maintain min heap of size k</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Root always contains kth largest element</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Efficient when k « n</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Quick Select Algorithm</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Based on quicksort partitioning</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Average O(n), worst case O(n²)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>In-place algorithm with O(1) space</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Index Transformation</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Kth largest = (n-k)th smallest</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Allows using ascending order algorithms</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Critical for quickselect implementation</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity Comparison</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Sorting: O(n log n) - straightforward</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Min Heap: O(n log k) - good when k is small</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Quick Select: O(n) average - optimal for general case</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Counting Sort: O(n + range) - best for limited range</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Heap: O(k) - proportional to k</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Quick Select: O(1) - in-place</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Counting Sort: O(range) - depends on value range</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Quick Select Optimizations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Random pivot selection to avoid worst case</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>3-way partitioning for duplicate elements</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Median-of-medians for guaranteed O(n)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with sorting approach (simple)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Progress to heap solution (when k « n)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Implement quickselect for optimal solution</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Discuss trade-offs between approaches</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>k = 1 (largest element)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>k = n (smallest element)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Array with duplicates</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Single element array</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Confusing kth largest vs kth smallest</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Wrong index calculation in quickselect</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not handling duplicates properly</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Modifying input array when not allowed</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Pivot Selection Strategies</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Random pivot: Simple, good average case</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Median-of-three: Better than first/last</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Median-of-medians: Guaranteed O(n)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>When to Use Each Approach</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>k « n: Min heap</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>General case: Quick select</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Limited range: Counting sort</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Need stable/simple: Sorting</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: Kth largest in stream</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Kth largest in multiple arrays</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Top k frequent elements</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Kth smallest in matrix</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Find k largest elements (not just kth)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle stream of numbers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory-constrained environments</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Parallel/distributed scenarios</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Database query optimization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Statistics and data analysis</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Gaming leaderboards</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Resource allocation systems</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Performance monitoring</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Pattern Recognition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Selection problem pattern</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Divide and conquer optimization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Heap for top-k problems</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Partitioning for order statistics
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>