<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Copy List with Random Pointer | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/linked-list/">Linked list</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/linked-list/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Copy list with random pointer</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Copy List with Random Pointer</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Linked List</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Linked List</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="copy-list-with-random-pointer">Copy List with Random Pointer</h1>

<p><strong>LeetCode Problem # * 138. Copy List with Random Pointer</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Copy List with Random Pointer</li>
    </ol>
  </li>
  <li></li>
  <li>A linked list of length n is given such that each node contains an additional random pointer,</li>
  <li>which could point to any node in the list, or null.</li>
  <li></li>
  <li>Construct a deep copy of the list. The deep copy should consist of exactly n new nodes,</li>
  <li>where each new node has its value set to the value of its corresponding original node.</li>
  <li>Both the next and random pointers of the new nodes should point to new nodes in the copied list</li>
  <li>such that the pointers in the original list and copied list represent the same list state.</li>
  <li>None of the pointers in the new list should point to nodes in the original list.</li>
  <li></li>
  <li>For example, if there are two nodes X and Y in the original list, where X.random –&gt; Y,</li>
  <li>then for the corresponding two nodes x and y in the copied list, x.random –&gt; y.</li>
  <li></li>
  <li>Return the head of the copied list.</li>
  <li></li>
  <li>The linked list is represented in the input/output as a list of n nodes. Each node is</li>
  <li>represented as a pair of [val, random_index] where:</li>
  <li>
    <ul>
      <li>val: an integer representing Node.val</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>random_index: the index of the node (range from 0 to n-1) that the random pointer points to,</li>
    </ul>
  </li>
  <li>or null if it does not point to any node.</li>
  <li></li>
  <li>Your code will only be given the head of the original linked list.</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</li>
  <li>Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: head = [[1,1],[2,1]]</li>
  <li>Output: [[1,1],[2,1]]</li>
  <li></li>
  <li>Example 3:</li>
  <li>Input: head = [[3,null],[3,0],[3,null]]</li>
  <li>Output: [[3,null],[3,0],[3,null]]</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>0 &lt;= n &lt;= 1000</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>-10^4 &lt;= Node.val &lt;= 10^4</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Node.random is null or is pointing to some node in the linked list.
 */</li>
    </ul>
  </li>
</ul>

<p>// Definition for a Node with random pointer
class RandomListNode {
    val: number;
    next: RandomListNode | null;
    random: RandomListNode | null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>constructor(val?: number, next?: RandomListNode | null, random?: RandomListNode | null) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
    this.random = (random === undefined ? null : random);
} }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 1: HashMap Two-Pass
// Time: O(n), Space: O(n)
export function copyRandomList1(head: RandomListNode | null): RandomListNode | null {
    if (!head) return null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>const nodeMap = new Map&lt;RandomListNode, RandomListNode&gt;();

// First pass: create all nodes and store mapping
let current = head;
while (current) {
    nodeMap.set(current, new RandomListNode(current.val));
    current = current.next;
}

// Second pass: connect next and random pointers
current = head;
while (current) {
    const copiedNode = nodeMap.get(current)!;
    copiedNode.next = current.next ? nodeMap.get(current.next)! : null;
    copiedNode.random = current.random ? nodeMap.get(current.random)! : null;
    current = current.next;
}

return nodeMap.get(head)!; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Recursive with Memoization
// Time: O(n), Space: O(n)
export function copyRandomList2(head: RandomListNode | null): RandomListNode | null {
    const nodeMap = new Map&lt;RandomListNode, RandomListNode&gt;();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>function copyNode(node: RandomListNode | null): RandomListNode | null {
    if (!node) return null;
    
    // If already copied, return the copy
    if (nodeMap.has(node)) {
        return nodeMap.get(node)!;
    }
    
    // Create new node
    const newNode = new RandomListNode(node.val);
    nodeMap.set(node, newNode);
    
    // Recursively copy next and random
    newNode.next = copyNode(node.next);
    newNode.random = copyNode(node.random);
    
    return newNode;
}

return copyNode(head); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Interweaving Approach (O(1) Space)
// Time: O(n), Space: O(1)
export function copyRandomList3(head: RandomListNode | null): RandomListNode | null {
    if (!head) return null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre>// Step 1: Create copied nodes and interweave them
let current = head;
while (current) {
    const copiedNode = new RandomListNode(current.val);
    copiedNode.next = current.next;
    current.next = copiedNode;
    current = copiedNode.next;
}

// Step 2: Set random pointers for copied nodes
current = head;
while (current) {
    if (current.random) {
        current.next!.random = current.random.next;
    }
    current = current.next!.next;
}

// Step 3: Separate the two lists
const dummy = new RandomListNode(0);
let copiedCurrent = dummy;
current = head;

while (current) {
    const copiedNode = current.next!;
    current.next = copiedNode.next;
    copiedCurrent.next = copiedNode;
    copiedCurrent = copiedNode;
    current = current.next;
}

return dummy.next; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: DFS with Stack
// Time: O(n), Space: O(n)
export function copyRandomList4(head: RandomListNode | null): RandomListNode | null {
    if (!head) return null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre>const nodeMap = new Map&lt;RandomListNode, RandomListNode&gt;();
const stack: RandomListNode[] = [head];
const visited = new Set&lt;RandomListNode&gt;();

// Create all nodes using DFS
while (stack.length &gt; 0) {
    const node = stack.pop()!;
    
    if (visited.has(node)) continue;
    visited.add(node);
    
    // Create copied node if not exists
    if (!nodeMap.has(node)) {
        nodeMap.set(node, new RandomListNode(node.val));
    }
    
    // Add next and random to stack for processing
    if (node.next &amp;&amp; !visited.has(node.next)) {
        stack.push(node.next);
    }
    if (node.random &amp;&amp; !visited.has(node.random)) {
        stack.push(node.random);
    }
}

// Connect pointers
for (const [original, copied] of nodeMap) {
    copied.next = original.next ? nodeMap.get(original.next)! : null;
    copied.random = original.random ? nodeMap.get(original.random)! : null;
}

return nodeMap.get(head)!; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: BFS with Queue
// Time: O(n), Space: O(n)
export function copyRandomList5(head: RandomListNode | null): RandomListNode | null {
    if (!head) return null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre>const nodeMap = new Map&lt;RandomListNode, RandomListNode&gt;();
const queue: RandomListNode[] = [head];
const visited = new Set&lt;RandomListNode&gt;();

// BFS to create all nodes
while (queue.length &gt; 0) {
    const node = queue.shift()!;
    
    if (visited.has(node)) continue;
    visited.add(node);
    
    // Create copied node
    if (!nodeMap.has(node)) {
        nodeMap.set(node, new RandomListNode(node.val));
    }
    
    // Add neighbors to queue
    if (node.next &amp;&amp; !visited.has(node.next)) {
        queue.push(node.next);
    }
    if (node.random &amp;&amp; !visited.has(node.random)) {
        queue.push(node.random);
    }
}

// Connect all pointers
for (const [original, copied] of nodeMap) {
    copied.next = original.next ? nodeMap.get(original.next)! : null;
    copied.random = original.random ? nodeMap.get(original.random)! : null;
}

return nodeMap.get(head)!; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 6: Index-Based Approach
// Time: O(n), Space: O(n)
export function copyRandomList6(head: RandomListNode | null): RandomListNode | null {
    if (!head) return null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre>// Step 1: Create array of original nodes and index mapping
const nodes: RandomListNode[] = [];
const indexMap = new Map&lt;RandomListNode, number&gt;();

let current = head;
let index = 0;

while (current) {
    nodes.push(current);
    indexMap.set(current, index);
    current = current.next;
    index++;
}

// Step 2: Create copied nodes
const copiedNodes: RandomListNode[] = nodes.map(node =&gt; new RandomListNode(node.val));

// Step 3: Connect pointers using indices
for (let i = 0; i &lt; nodes.length; i++) {
    const originalNode = nodes[i];
    const copiedNode = copiedNodes[i];
    
    // Connect next pointer
    if (originalNode.next) {
        const nextIndex = indexMap.get(originalNode.next)!;
        copiedNode.next = copiedNodes[nextIndex];
    }
    
    // Connect random pointer
    if (originalNode.random) {
        const randomIndex = indexMap.get(originalNode.random)!;
        copiedNode.random = copiedNodes[randomIndex];
    }
}

return copiedNodes[0]; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Helper functions for testing
function createRandomList(values: Array&lt;[number, number | null]&gt;): RandomListNode | null {
    if (values.length === 0) return null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>const nodes: RandomListNode[] = [];

// Create all nodes
for (const [val] of values) {
    nodes.push(new RandomListNode(val));
}

// Connect next pointers
for (let i = 0; i &lt; nodes.length - 1; i++) {
    nodes[i].next = nodes[i + 1];
}

// Connect random pointers
for (let i = 0; i &lt; values.length; i++) {
    const [, randomIndex] = values[i];
    if (randomIndex !== null) {
        nodes[i].random = nodes[randomIndex];
    }
}

return nodes[0]; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>function listToArray(head: RandomListNode | null): Array&lt;[number, number | null]&gt; {
    if (!head) return [];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>const result: Array&lt;[number, number | null]&gt; = [];
const nodeToIndex = new Map&lt;RandomListNode, number&gt;();

// First pass: create index mapping
let current = head;
let index = 0;
while (current) {
    nodeToIndex.set(current, index);
    current = current.next;
    index++;
}

// Second pass: build result array
current = head;
while (current) {
    const randomIndex = current.random ? nodeToIndex.get(current.random)! : null;
    result.push([current.val, randomIndex]);
    current = current.next;
}

return result; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testCopyRandomList() {
    console.log(“Testing Copy List with Random Pointer:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre>const testCases = [
    {
        input: [[7, null], [13, 0], [11, 4], [10, 2], [1, 0]] as Array&lt;[number, number | null]&gt;,
        description: "Complex random pointers"
    },
    {
        input: [[1, 1], [2, 1]] as Array&lt;[number, number | null]&gt;,
        description: "Simple random pointers"
    },
    {
        input: [[3, null], [3, 0], [3, null]] as Array&lt;[number, number | null]&gt;,
        description: "Mixed random pointers"
    },
    {
        input: [] as Array&lt;[number, number | null]&gt;,
        description: "Empty list"
    },
    {
        input: [[1, null]] as Array&lt;[number, number | null]&gt;,
        description: "Single node"
    }
];

const solutions = [
    { name: "HashMap Two-Pass", fn: copyRandomList1 },
    { name: "Recursive Memoization", fn: copyRandomList2 },
    { name: "Interweaving O(1)", fn: copyRandomList3 },
    { name: "DFS with Stack", fn: copyRandomList4 },
    { name: "BFS with Queue", fn: copyRandomList5 },
    { name: "Index-Based", fn: copyRandomList6 }
];

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        const originalList = createRandomList(test.input);
        const copiedList = solution.fn(originalList);
        const result = listToArray(copiedList);
        
        const passed = JSON.stringify(result) === JSON.stringify(test.input);
        console.log(`  Test ${i + 1} (${test.description}): ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Expected: ${JSON.stringify(test.input)}`);
            console.log(`    Got: ${JSON.stringify(result)}`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Deep Copy Challenge</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Must create entirely new nodes</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Original and copied lists should be independent</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Both next and random pointers need correct mapping</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Random Pointer Complexity</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Random pointers can create cycles</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>May point to nodes not yet processed</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Requires mapping between original and copied nodes</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Two-Phase Approach</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Phase 1: Create all nodes and establish mapping</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Phase 2: Connect next and random pointers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Ensures all target nodes exist before linking</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>HashMap Solution</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Maps original nodes to copied nodes</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Enables O(1) lookup for pointer assignment</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Most intuitive and commonly used approach</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interweaving Optimization</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Achieves O(1) space complexity</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Temporarily modifies original list structure</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Clever technique but more complex implementation</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(n)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Must visit each node at least once</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>HashMap operations are O(1) on average</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Cannot be optimized further</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>HashMap approach: O(n) for node mapping</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Interweaving approach: O(1) extra space</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Recursive: O(n) for call stack</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with HashMap two-pass approach</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Explain the need for node mapping</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Consider space optimization with interweaving</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Discuss recursive alternative</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Empty list (null head)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Single node with self-reference</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Cycles in random pointers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>All random pointers null</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Creating nodes multiple times</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not handling null random pointers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Circular references in random pointers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Forgetting to restore original list in interweaving</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Graph Perspective</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Can view as graph copying problem</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Nodes are vertices, pointers are edges</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>DFS/BFS traversal strategies applicable</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Memory Management</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Deep copy ensures independence</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Original list remains unchanged</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Proper cleanup in interweaving approach</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: Multi-threaded deep copy</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Copy with additional pointer types</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Memory-constrained copying</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Streaming copy for large lists</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Copy list with multiple random pointers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle very large lists (external memory)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Thread-safe copying</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Copy with lazy evaluation</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Object serialization/deserialization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory management in VMs</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Data structure persistence</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Undo/redo functionality</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Database replication</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Pattern Recognition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Classic graph traversal problem</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Node mapping for pointer redirection</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Two-phase construction pattern</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Space-time trade-off considerations
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>