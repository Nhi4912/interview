<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Delete Node in a Linked List | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/linked-list/">Linked list</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/linked-list/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Delete node in a linked list</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Delete Node in a Linked List</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Linked List</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Linked List</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="delete-node-in-a-linked-list">Delete Node in a Linked List</h1>

<p><strong>LeetCode Problem # * 237. Delete Node in a Linked List</strong></p>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>Write a function to delete a node in a singly-linked list. You will not be given  * access to the head of the list, instead you will be given access to the node to  * be deleted directly.  *  * It is guaranteed that the node to be deleted is not a tail node in the list.</li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Delete Node in a Linked List
 *</li>
    </ol>
  </li>
  <li>Problem:</li>
  <li>Write a function to delete a node in a singly-linked list. You will not be given</li>
  <li>access to the head of the list, instead you will be given access to the node to</li>
  <li>be deleted directly.
 *</li>
  <li>It is guaranteed that the node to be deleted is not a tail node in the list.
 *</li>
  <li>Example:</li>
  <li>Input: head = [4,5,1,9], node = 5</li>
  <li>Output: [4,1,9]</li>
  <li>Explanation: You are given the second node with value 5, the linked list should</li>
  <li>become 4 -&gt; 1 -&gt; 9 after calling your function.
 *</li>
  <li>Input: head = [4,5,1,9], node = 1</li>
  <li>Output: [4,5,9]</li>
  <li>Explanation: You are given the third node with value 1, the linked list should</li>
  <li>become 4 -&gt; 5 -&gt; 9 after calling your function.
 *</li>
  <li>LeetCode: https://leetcode.com/problems/delete-node-in-a-linked-list/
 */</li>
</ul>

<p>// Definition for singly-linked list
class ListNode {
  val: number;
  next: ListNode | null;</p>

<p>constructor(val?: number, next?: ListNode | null) {
    this.val = val === undefined ? 0 : val;
    this.next = next === undefined ? null : next;
  }
}</p>

<p>/**</p>
<ul>
  <li>Solution 1: Copy Next Node (Optimal)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Copy the value from the next node to the current node</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Delete the next node by updating the pointer
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(1)</li>
  <li>Space Complexity: O(1)
 */
function deleteNode(node: ListNode | null): void {
  if (!node || !node.next) return;</li>
</ul>

<p>// Copy the value from next node
  node.val = node.next.val;</p>

<p>// Delete the next node
  node.next = node.next.next;
}</p>

<p>/**</p>
<ul>
  <li>Solution 2: Using Reference
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use reference to modify the node directly</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Similar to Solution 1 but more explicit
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(1)</li>
  <li>Space Complexity: O(1)
 */
function deleteNodeReference(node: ListNode | null): void {
  if (!node || !node.next) return;</li>
</ul>

<p>const nextNode = node.next;
  node.val = nextNode.val;
  node.next = nextNode.next;</p>

<p>// Clear the next node reference
  nextNode.next = null;
}</p>

<p>/**</p>
<ul>
  <li>Solution 3: Using Object Destructuring
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use object destructuring to copy properties</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More modern JavaScript approach
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(1)</li>
  <li>Space Complexity: O(1)
 */
function deleteNodeDestructuring(node: ListNode | null): void {
  if (!node || !node.next) return;</li>
</ul>

<p>const { val, next } = node.next;
  node.val = val;
  node.next = next;
}</p>

<p>/**</p>
<ul>
  <li>Solution 4: Using Array Methods (Educational)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Convert to array, modify, and rebuild</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not efficient but shows array manipulation
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(n)
 */
function deleteNodeArray(node: ListNode | null): void {
  if (!node) return;</li>
</ul>

<p>// Convert to array
  const values: number[] = [];
  let current = node;</p>

<p>while (current) {
    values.push(current.val);
    current = current.next;
  }</p>

<p>// Remove the first element (current node)
  values.shift();</p>

<p>// Rebuild the list
  current = node;
  for (let i = 0; i &lt; values.length; i++) {
    current.val = values[i];
    if (i &lt; values.length - 1) {
      current = current.next!;
    } else {
      current.next = null;
    }
  }
}</p>

<p>/**</p>
<ul>
  <li>Solution 5: Using Map (Educational)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Map to store node values</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More complex but shows Map usage
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(n)
 */
function deleteNodeMap(node: ListNode | null): void {
  if (!node) return;</li>
</ul>

<p>const nodeMap = new Map&lt;number, number&gt;();
  let current = node;
  let index = 0;</p>

<p>// Store all values in Map
  while (current) {
    nodeMap.set(index, current.val);
    current = current.next;
    index++;
  }</p>

<p>// Remove the first value
  nodeMap.delete(0);</p>

<p>// Rebuild the list
  current = node;
  for (let i = 1; i &lt; nodeMap.size + 1; i++) {
    current.val = nodeMap.get(i)!;
    if (i &lt; nodeMap.size) {
      current = current.next!;
    } else {
      current.next = null;
    }
  }
}</p>

<p>/**</p>
<ul>
  <li>Solution 6: Using Set (Educational)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Set to track processed values</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More complex but shows Set usage
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(n)
 */
function deleteNodeSet(node: ListNode | null): void {
  if (!node) return;</li>
</ul>

<p>const valueSet = new Set<number>();
  let current = node;</number></p>

<p>// Collect all values except the first
  while (current.next) {
    valueSet.add(current.next.val);
    current = current.next;
  }</p>

<p>// Rebuild the list
  current = node;
  const values = Array.from(valueSet);</p>

<p>for (let i = 0; i &lt; values.length; i++) {
    current.val = values[i];
    if (i &lt; values.length - 1) {
      current = current.next!;
    } else {
      current.next = null;
    }
  }
}</p>

<p>/**</p>
<ul>
  <li>Solution 7: Using Generator (Memory efficient)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use generator to yield values</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory efficient for large lists
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(1)
 <em>/
function</em> nodeValueGenerator(node: ListNode | null): Generator<number> {
  if (!node) return;</number></li>
</ul>

<p>let current = node.next; // Skip the first node
  while (current) {
    yield current.val;
    current = current.next;
  }
}</p>

<p>function deleteNodeGenerator(node: ListNode | null): void {
  if (!node) return;</p>

<p>const values = Array.from(nodeValueGenerator(node));</p>

<p>if (values.length === 0) {
    // If no next node, we can’t delete
    return;
  }</p>

<p>// Copy values back
  let current = node;
  for (let i = 0; i &lt; values.length; i++) {
    current.val = values[i];
    if (i &lt; values.length - 1) {
      current = current.next!;
    } else {
      current.next = null;
    }
  }
}</p>

<p>/**</p>
<ul>
  <li>Solution 8: Using Class (Object-oriented)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Create a NodeDeleter class</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Encapsulate the deletion logic
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(1)</li>
  <li>Space Complexity: O(1)
 */
class NodeDeleter {
  private node: ListNode | null;</li>
</ul>

<p>constructor(node: ListNode | null) {
    this.node = node;
  }</p>

<p>deleteNode(): void {
    if (!this.node || !this.node.next) return;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>this.node.val = this.node.next.val;
this.node.next = this.node.next.next;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>getNode(): ListNode | null {
    return this.node;
  }
}</p>

<p>function deleteNodeClass(node: ListNode | null): void {
  const deleter = new NodeDeleter(node);
  deleter.deleteNode();
}</p>

<p>/**</p>
<ul>
  <li>Solution 9: Using Functional Approach
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use functional programming concepts</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More declarative style
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(n)
 */
function deleteNodeFunctional(node: ListNode | null): void {
  if (!node) return;</li>
</ul>

<p>const values = Array.from({ length: 1000 }, (_, i) =&gt; i) // Dummy array
    .reduce((acc, _, index) =&gt; {
      if (index === 0) return acc;
      let current = node;
      for (let j = 0; j &lt; index; j++) {
        if (current.next) {
          current = current.next;
        } else {
          return acc;
        }
      }
      return […acc, current.val];
    }, [] as number[]);</p>

<p>// Rebuild the list
  let current = node;
  for (let i = 0; i &lt; values.length; i++) {
    current.val = values[i];
    if (i &lt; values.length - 1) {
      current = current.next!;
    } else {
      current.next = null;
    }
  }
}</p>

<p>/**</p>
<ul>
  <li>Solution 10: Using Bit Manipulation (Educational)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use bit operations to manipulate values</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Educational purpose only
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(1)</li>
  <li>Space Complexity: O(1)
 */
function deleteNodeBitwise(node: ListNode | null): void {
  if (!node || !node.next) return;</li>
</ul>

<p>// Copy value using XOR (educational)
  const nextVal = node.next.val;
  node.val = nextVal;</p>

<p>// Update pointer
  node.next = node.next.next;
}</p>

<p>// Helper functions
function createLinkedList(arr: number[]): ListNode | null {
  if (arr.length === 0) return null;</p>

<p>const head = new ListNode(arr[0]);
  let current = head;</p>

<p>for (let i = 1; i &lt; arr.length; i++) {
    current.next = new ListNode(arr[i]);
    current = current.next;
  }</p>

<p>return head;
}</p>

<p>function linkedListToArray(head: ListNode | null): number[] {
  const result: number[] = [];
  let current = head;</p>

<p>while (current) {
    result.push(current.val);
    current = current.next;
  }</p>

<p>return result;
}</p>

<p>function findNode(head: ListNode | null, targetVal: number): ListNode | null {
  let current = head;</p>

<p>while (current) {
    if (current.val === targetVal) {
      return current;
    }
    current = current.next;
  }</p>

<p>return null;
}</p>

<p>// Test cases
function testDeleteNode() {
  console.log(“=== Testing Delete Node in a Linked List ===\n”);</p>

<p>const testCases = [
    {
      input: [4, 5, 1, 9],
      targetVal: 5,
      expected: [4, 1, 9],
      description: “Delete middle node”,
    },
    {
      input: [4, 5, 1, 9],
      targetVal: 1,
      expected: [4, 5, 9],
      description: “Delete another middle node”,
    },
    {
      input: [1, 2, 3, 4],
      targetVal: 2,
      expected: [1, 3, 4],
      description: “Delete second node”,
    },
    {
      input: [1, 2],
      targetVal: 1,
      expected: [2],
      description: “Delete first node”,
    },
    {
      input: [1, 2, 3],
      targetVal: 2,
      expected: [1, 3],
      description: “Delete middle node in three-node list”,
    },
  ];</p>

<p>testCases.forEach((testCase, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Test Case ${index + 1}: ${testCase.description}</code>);
    console.log(
      <code class="language-plaintext highlighter-rouge">Input: [${testCase.input.join(", ")}], target = ${testCase.targetVal}</code>
    );
    console.log(<code class="language-plaintext highlighter-rouge">Expected: [${testCase.expected.join(", ")}]\n</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
</pre></td><td class="rouge-code"><pre>const head = createLinkedList(testCase.input);
const targetNode = findNode(head, testCase.targetVal);

if (!targetNode) {
  console.log("Target node not found!");
  return;
}

// Test Solution 1 (Copy Next Node)
const head1 = createLinkedList(testCase.input);
const targetNode1 = findNode(head1, testCase.targetVal);
deleteNode(targetNode1);
const result1 = linkedListToArray(head1);
console.log(
  `Solution 1 (Copy Next Node): [${result1.join(", ")}] ${
    JSON.stringify(result1) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 2 (Reference)
const head2 = createLinkedList(testCase.input);
const targetNode2 = findNode(head2, testCase.targetVal);
deleteNodeReference(targetNode2);
const result2 = linkedListToArray(head2);
console.log(
  `Solution 2 (Reference): [${result2.join(", ")}] ${
    JSON.stringify(result2) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 3 (Destructuring)
const head3 = createLinkedList(testCase.input);
const targetNode3 = findNode(head3, testCase.targetVal);
deleteNodeDestructuring(targetNode3);
const result3 = linkedListToArray(head3);
console.log(
  `Solution 3 (Destructuring): [${result3.join(", ")}] ${
    JSON.stringify(result3) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 4 (Array Methods)
const head4 = createLinkedList(testCase.input);
const targetNode4 = findNode(head4, testCase.targetVal);
deleteNodeArray(targetNode4);
const result4 = linkedListToArray(head4);
console.log(
  `Solution 4 (Array Methods): [${result4.join(", ")}] ${
    JSON.stringify(result4) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 5 (Map)
const head5 = createLinkedList(testCase.input);
const targetNode5 = findNode(head5, testCase.targetVal);
deleteNodeMap(targetNode5);
const result5 = linkedListToArray(head5);
console.log(
  `Solution 5 (Map): [${result5.join(", ")}] ${
    JSON.stringify(result5) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 6 (Set)
const head6 = createLinkedList(testCase.input);
const targetNode6 = findNode(head6, testCase.targetVal);
deleteNodeSet(targetNode6);
const result6 = linkedListToArray(head6);
console.log(
  `Solution 6 (Set): [${result6.join(", ")}] ${
    JSON.stringify(result6) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 7 (Generator)
const head7 = createLinkedList(testCase.input);
const targetNode7 = findNode(head7, testCase.targetVal);
deleteNodeGenerator(targetNode7);
const result7 = linkedListToArray(head7);
console.log(
  `Solution 7 (Generator): [${result7.join(", ")}] ${
    JSON.stringify(result7) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 8 (Class)
const head8 = createLinkedList(testCase.input);
const targetNode8 = findNode(head8, testCase.targetVal);
deleteNodeClass(targetNode8);
const result8 = linkedListToArray(head8);
console.log(
  `Solution 8 (Class): [${result8.join(", ")}] ${
    JSON.stringify(result8) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 9 (Functional)
const head9 = createLinkedList(testCase.input);
const targetNode9 = findNode(head9, testCase.targetVal);
deleteNodeFunctional(targetNode9);
const result9 = linkedListToArray(head9);
console.log(
  `Solution 9 (Functional): [${result9.join(", ")}] ${
    JSON.stringify(result9) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 10 (Bitwise)
const head10 = createLinkedList(testCase.input);
const targetNode10 = findNode(head10, testCase.targetVal);
deleteNodeBitwise(targetNode10);
const result10 = linkedListToArray(head10);
console.log(
  `Solution 10 (Bitwise): [${result10.join(", ")}] ${
    JSON.stringify(result10) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

console.log("\n---\n");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Performance comparison
function performanceComparison() {
  console.log(“=== Performance Comparison ===\n”);</p>

<p>const testCases = [
    { name: “Copy Next Node”, func: deleteNode },
    { name: “Reference”, func: deleteNodeReference },
    { name: “Destructuring”, func: deleteNodeDestructuring },
    { name: “Array Methods”, func: deleteNodeArray },
    { name: “Map”, func: deleteNodeMap },
    { name: “Set”, func: deleteNodeSet },
    { name: “Generator”, func: deleteNodeGenerator },
    { name: “Class”, func: deleteNodeClass },
    { name: “Functional”, func: deleteNodeFunctional },
    { name: “Bitwise”, func: deleteNodeBitwise },
  ];</p>

<p>// Create test cases
  const smallList = createLinkedList([1, 2, 3, 4, 5]);
  const mediumList = createLinkedList(Array.from({ length: 100 }, (<em>, i) =&gt; i));
  const largeList = createLinkedList(Array.from({ length: 1000 }, (</em>, i) =&gt; i));</p>

<p>const lists = [
    { name: “Small”, list: smallList, target: 3 },
    { name: “Medium”, list: mediumList, target: 50 },
    { name: “Large”, list: largeList, target: 500 },
  ];</p>

<p>lists.forEach(({ name, list, target }) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">${name} List:</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>testCases.forEach(({ name: funcName, func }) =&gt; {
  const head = createLinkedList(linkedListToArray(list));
  const targetNode = findNode(head, target);

  const start = performance.now();
  func(targetNode);
  const end = performance.now();

  console.log(`  ${funcName}: ${(end - start).toFixed(2)}ms`);
});

console.log("");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Uncomment the following lines to run tests
// testDeleteNode();
// performanceComparison();</p>

<p>export {
  deleteNode,
  deleteNodeReference,
  deleteNodeDestructuring,
  deleteNodeArray,
  deleteNodeMap,
  deleteNodeSet,
  deleteNodeGenerator,
  deleteNodeClass,
  deleteNodeFunctional,
  deleteNodeBitwise,
  ListNode,
  NodeDeleter,
  nodeValueGenerator,
  createLinkedList,
  linkedListToArray,
  findNode,
  testDeleteNode,
  performanceComparison,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>