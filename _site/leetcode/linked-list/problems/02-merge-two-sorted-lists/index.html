<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge Two Sorted List | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/linked-list/">Linked list</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/linked-list/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Merge two sorted list</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Merge Two Sorted List</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Linked List</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Linked List</span>
                                
                                    <span class="tag">Two Pointers</span>
                                
                                    <span class="tag">Sorting</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="merge-two-sorted-list">Merge Two Sorted List</h1>

<p><strong>LeetCode Problem # * 21. Merge Two Sorted Lists</strong></p>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>You are given the heads of two sorted linked lists list1 and list2.  * Merge the two lists into one sorted list. The list should be made by  * splicing together the nodes of the first two lists.  * Return the head of the merged linked list.  *</li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Merge Two Sorted Lists
 *</li>
    </ol>
  </li>
  <li>Problem:</li>
  <li>You are given the heads of two sorted linked lists list1 and list2.</li>
  <li>Merge the two lists into one sorted list. The list should be made by</li>
  <li>splicing together the nodes of the first two lists.</li>
  <li>Return the head of the merged linked list.
 *</li>
  <li>Example:</li>
  <li>Input: list1 = [1,2,4], list2 = [1,3,4]</li>
  <li>Output: [1,1,2,3,4,4]
 *</li>
  <li>Input: list1 = [], list2 = []</li>
  <li>Output: []
 *</li>
  <li>Input: list1 = [], list2 = [0]</li>
  <li>Output: [0]
 *</li>
  <li>LeetCode: https://leetcode.com/problems/merge-two-sorted-lists/
 */</li>
</ul>

<p>// ListNode class definition
class ListNode {
  val: number;
  next: ListNode | null;</p>

<p>constructor(val: number = 0, next: ListNode | null = null) {
    this.val = val;
    this.next = next;
  }
}</p>

<p>/**</p>
<ul>
  <li>Solution 1: Iterative with Dummy Node (Optimal)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use dummy node to handle edge cases</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Compare nodes from both lists</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Link smaller node to result
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n + m)</li>
  <li>Space Complexity: O(1)
 */
function mergeTwoLists(
  list1: ListNode | null,
  list2: ListNode | null
): ListNode | null {
  const dummy = new ListNode(0);
  let current = dummy;</li>
</ul>

<p>while (list1 &amp;&amp; list2) {
    if (list1.val &lt;= list2.val) {
      current.next = list1;
      list1 = list1.next;
    } else {
      current.next = list2;
      list2 = list2.next;
    }
    current = current.next;
  }</p>

<p>// Attach remaining nodes
  current.next = list1 || list2;</p>

<p>return dummy.next;
}</p>

<p>/**</p>
<ul>
  <li>Solution 2: Recursive Approach
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use recursion to merge lists</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Base case: when one list is empty
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n + m)</li>
  <li>Space Complexity: O(n + m) - recursion stack
 */
function mergeTwoListsRecursive(
  list1: ListNode | null,
  list2: ListNode | null
): ListNode | null {
  if (!list1) return list2;
  if (!list2) return list1;</li>
</ul>

<p>if (list1.val &lt;= list2.val) {
    list1.next = mergeTwoListsRecursive(list1.next, list2);
    return list1;
  } else {
    list2.next = mergeTwoListsRecursive(list1, list2.next);
    return list2;
  }
}</p>

<p>/**</p>
<ul>
  <li>Solution 3: In-place Merge (Modifies input)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Merge in-place by modifying pointers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More complex but space efficient
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n + m)</li>
  <li>Space Complexity: O(1)
 */
function mergeTwoListsInPlace(
  list1: ListNode | null,
  list2: ListNode | null
): ListNode | null {
  if (!list1) return list2;
  if (!list2) return list1;</li>
</ul>

<p>let head: ListNode;
  let current: ListNode;</p>

<p>// Choose head
  if (list1.val &lt;= list2.val) {
    head = list1;
    list1 = list1.next;
  } else {
    head = list2;
    list2 = list2.next;
  }</p>

<p>current = head;</p>

<p>while (list1 &amp;&amp; list2) {
    if (list1.val &lt;= list2.val) {
      current.next = list1;
      list1 = list1.next;
    } else {
      current.next = list2;
      list2 = list2.next;
    }
    current = current.next;
  }</p>

<p>current.next = list1 || list2;
  return head;
}</p>

<p>/**</p>
<ul>
  <li>Solution 4: Using Array Conversion
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Convert lists to arrays</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Merge arrays and create new list
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n + m)</li>
  <li>Space Complexity: O(n + m)
 */
function mergeTwoListsArray(
  list1: ListNode | null,
  list2: ListNode | null
): ListNode | null {
  const array1 = linkedListToArray(list1);
  const array2 = linkedListToArray(list2);</li>
</ul>

<p>const mergedArray = mergeArrays(array1, array2);
  return arrayToLinkedList(mergedArray);
}</p>

<p>/**</p>
<ul>
  <li>Solution 5: Two Pointers with Sentinel
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use sentinel node for cleaner code</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Similar to Solution 1 but more explicit
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n + m)</li>
  <li>Space Complexity: O(1)
 */
function mergeTwoListsSentinel(
  list1: ListNode | null,
  list2: ListNode | null
): ListNode | null {
  const sentinel = new ListNode(-1);
  let tail = sentinel;</li>
</ul>

<p>while (list1 &amp;&amp; list2) {
    if (list1.val &lt;= list2.val) {
      tail.next = list1;
      list1 = list1.next;
    } else {
      tail.next = list2;
      list2 = list2.next;
    }
    tail = tail.next;
  }</p>

<p>tail.next = list1 || list2;
  return sentinel.next;
}</p>

<p>/**</p>
<ul>
  <li>Solution 6: Using Priority Queue (Overkill)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use priority queue to merge</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Educational but inefficient
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O((n + m) log(n + m))</li>
  <li>Space Complexity: O(n + m)
 */
class PriorityQueue {
  private heap: ListNode[] = [];</li>
</ul>

<p>enqueue(node: ListNode): void {
    this.heap.push(node);
    this.heapifyUp();
  }</p>

<p>dequeue(): ListNode | null {
    if (this.heap.length === 0) return null;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>const min = this.heap[0];
const last = this.heap.pop()!;

if (this.heap.length &gt; 0) {
  this.heap[0] = last;
  this.heapifyDown();
}

return min;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>private heapifyUp(): void {
    let index = this.heap.length - 1;
    while (index &gt; 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      if (this.heap[parentIndex].val &lt;= this.heap[index].val) break;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>  [this.heap[parentIndex], this.heap[index]] = [
    this.heap[index],
    this.heap[parentIndex],
  ];
  index = parentIndex;
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>private heapifyDown(): void {
    let index = 0;
    while (true) {
      let smallest = index;
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>  if (
    leftChild &lt; this.heap.length &amp;&amp;
    this.heap[leftChild].val &lt; this.heap[smallest].val
  ) {
    smallest = leftChild;
  }

  if (
    rightChild &lt; this.heap.length &amp;&amp;
    this.heap[rightChild].val &lt; this.heap[smallest].val
  ) {
    smallest = rightChild;
  }

  if (smallest === index) break;

  [this.heap[index], this.heap[smallest]] = [
    this.heap[smallest],
    this.heap[index],
  ];
  index = smallest;
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>isEmpty(): boolean {
    return this.heap.length === 0;
  }
}</p>

<p>function mergeTwoListsPriorityQueue(
  list1: ListNode | null,
  list2: ListNode | null
): ListNode | null {
  const pq = new PriorityQueue();</p>

<p>// Add all nodes to priority queue
  let current = list1;
  while (current) {
    pq.enqueue(new ListNode(current.val));
    current = current.next;
  }</p>

<p>current = list2;
  while (current) {
    pq.enqueue(new ListNode(current.val));
    current = current.next;
  }</p>

<p>// Build result list
  const dummy = new ListNode(0);
  let tail = dummy;</p>

<p>while (!pq.isEmpty()) {
    const node = pq.dequeue()!;
    tail.next = node;
    tail = tail.next;
  }</p>

<p>return dummy.next;
}</p>

<p>// Helper functions
function linkedListToArray(head: ListNode | null): number[] {
  const result: number[] = [];
  let current = head;</p>

<p>while (current) {
    result.push(current.val);
    current = current.next;
  }</p>

<p>return result;
}</p>

<p>function arrayToLinkedList(arr: number[]): ListNode | null {
  if (arr.length === 0) return null;</p>

<p>const head = new ListNode(arr[0]);
  let current = head;</p>

<p>for (let i = 1; i &lt; arr.length; i++) {
    current.next = new ListNode(arr[i]);
    current = current.next;
  }</p>

<p>return head;
}</p>

<p>function mergeArrays(arr1: number[], arr2: number[]): number[] {
  const result: number[] = [];
  let i = 0,
    j = 0;</p>

<p>while (i &lt; arr1.length &amp;&amp; j &lt; arr2.length) {
    if (arr1[i] &lt;= arr2[j]) {
      result.push(arr1[i]);
      i++;
    } else {
      result.push(arr2[j]);
      j++;
    }
  }</p>

<p>while (i &lt; arr1.length) {
    result.push(arr1[i]);
    i++;
  }</p>

<p>while (j &lt; arr2.length) {
    result.push(arr2[j]);
    j++;
  }</p>

<p>return result;
}</p>

<p>function createLinkedList(arr: number[]): ListNode | null {
  return arrayToLinkedList(arr);
}</p>

<p>function printLinkedList(head: ListNode | null): string {
  const result: number[] = [];
  let current = head;</p>

<p>while (current) {
    result.push(current.val);
    current = current.next;
  }</p>

<p>return <code class="language-plaintext highlighter-rouge">[${result.join(" -&gt; ")}]</code>;
}</p>

<p>// Test cases
function testMergeTwoSortedLists() {
  console.log(“=== Testing Merge Two Sorted Lists ===\n”);</p>

<p>const testCases = [
    {
      list1: [1, 2, 4],
      list2: [1, 3, 4],
      expected: [1, 1, 2, 3, 4, 4],
      description: “Basic merge”,
    },
    {
      list1: [],
      list2: [],
      expected: [],
      description: “Empty lists”,
    },
    {
      list1: [],
      list2: [0],
      expected: [0],
      description: “One empty list”,
    },
    {
      list1: [1, 3, 5],
      list2: [2, 4, 6],
      expected: [1, 2, 3, 4, 5, 6],
      description: “Alternating values”,
    },
    {
      list1: [1, 2, 3],
      list2: [4, 5, 6],
      expected: [1, 2, 3, 4, 5, 6],
      description: “Sequential lists”,
    },
    {
      list1: [4, 5, 6],
      list2: [1, 2, 3],
      expected: [1, 2, 3, 4, 5, 6],
      description: “Second list smaller”,
    },
  ];</p>

<p>testCases.forEach((testCase, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Test Case ${index + 1}: ${testCase.description}</code>);
    console.log(
      <code class="language-plaintext highlighter-rouge">Input: list1 = [${testCase.list1.join(
        ", "
      )}], list2 = [${testCase.list2.join(", ")}]</code>
    );
    console.log(<code class="language-plaintext highlighter-rouge">Expected: [${testCase.expected.join(", ")}]\n</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="rouge-code"><pre>const list1 = createLinkedList(testCase.list1);
const list2 = createLinkedList(testCase.list2);

// Test Solution 1 (Iterative with Dummy)
const result1 = mergeTwoLists(list1, list2);
const result1Array = linkedListToArray(result1);
console.log(
  `Solution 1 (Iterative): [${result1Array.join(", ")}] ${
    JSON.stringify(result1Array) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 2 (Recursive)
const list1Rec = createLinkedList(testCase.list1);
const list2Rec = createLinkedList(testCase.list2);
const result2 = mergeTwoListsRecursive(list1Rec, list2Rec);
const result2Array = linkedListToArray(result2);
console.log(
  `Solution 2 (Recursive): [${result2Array.join(", ")}] ${
    JSON.stringify(result2Array) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 3 (In-place)
const list1InPlace = createLinkedList(testCase.list1);
const list2InPlace = createLinkedList(testCase.list2);
const result3 = mergeTwoListsInPlace(list1InPlace, list2InPlace);
const result3Array = linkedListToArray(result3);
console.log(
  `Solution 3 (In-place): [${result3Array.join(", ")}] ${
    JSON.stringify(result3Array) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 4 (Array)
const list1Array = createLinkedList(testCase.list1);
const list2Array = createLinkedList(testCase.list2);
const result4 = mergeTwoListsArray(list1Array, list2Array);
const result4Array = linkedListToArray(result4);
console.log(
  `Solution 4 (Array): [${result4Array.join(", ")}] ${
    JSON.stringify(result4Array) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 5 (Sentinel)
const list1Sentinel = createLinkedList(testCase.list1);
const list2Sentinel = createLinkedList(testCase.list2);
const result5 = mergeTwoListsSentinel(list1Sentinel, list2Sentinel);
const result5Array = linkedListToArray(result5);
console.log(
  `Solution 5 (Sentinel): [${result5Array.join(", ")}] ${
    JSON.stringify(result5Array) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 6 (Priority Queue)
const list1PQ = createLinkedList(testCase.list1);
const list2PQ = createLinkedList(testCase.list2);
const result6 = mergeTwoListsPriorityQueue(list1PQ, list2PQ);
const result6Array = linkedListToArray(result6);
console.log(
  `Solution 6 (Priority Queue): [${result6Array.join(", ")}] ${
    JSON.stringify(result6Array) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

console.log("\n---\n");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Performance comparison
function performanceComparison() {
  console.log(“=== Performance Comparison ===\n”);</p>

<p>const testCases = [
    { name: “Iterative”, func: mergeTwoLists },
    { name: “Recursive”, func: mergeTwoListsRecursive },
    { name: “In-place”, func: mergeTwoListsInPlace },
    { name: “Array”, func: mergeTwoListsArray },
    { name: “Sentinel”, func: mergeTwoListsSentinel },
    { name: “Priority Queue”, func: mergeTwoListsPriorityQueue },
  ];</p>

<p>// Create test lists
  const list1 = createLinkedList(Array.from({ length: 1000 }, (<em>, i) =&gt; i * 2));
  const list2 = createLinkedList(
    Array.from({ length: 1000 }, (</em>, i) =&gt; i * 2 + 1)
  );</p>

<p>testCases.forEach(({ name, func }) =&gt; {
    const start = performance.now();
    const result = func(list1, list2);
    const end = performance.now();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>console.log(`${name}:`);
console.log(`  Time: ${(end - start).toFixed(2)}ms`);
console.log(`  Result length: ${linkedListToArray(result).length}`);
console.log(
  `  Memory: ${
    name === "Recursive"
      ? "O(n+m)"
      : name === "Array" || name === "Priority Queue"
      ? "O(n+m)"
      : "O(1)"
  }\n`
);   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Uncomment the following lines to run tests
// testMergeTwoSortedLists();
// performanceComparison();</p>

<p>export {
  ListNode,
  mergeTwoLists,
  mergeTwoListsRecursive,
  mergeTwoListsInPlace,
  mergeTwoListsArray,
  mergeTwoListsSentinel,
  mergeTwoListsPriorityQueue,
  PriorityQueue,
  linkedListToArray,
  arrayToLinkedList,
  createLinkedList,
  printLinkedList,
  testMergeTwoSortedLists,
  performanceComparison,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>