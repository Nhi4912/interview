<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting Rooms II | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/array/">Array</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/array/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Meeting rooms ii</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Meeting Rooms II</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Array</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Array</span>
                                
                                    <span class="tag">Two Pointers</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                                    <span class="tag">Greedy</span>
                                
                                    <span class="tag">Sorting</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="meeting-rooms-ii">Meeting Rooms II</h1>

<p><strong>LeetCode Problem # * 253. Meeting Rooms II</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Meeting Rooms II</li>
    </ol>
  </li>
  <li></li>
  <li>Given an array of meeting time intervals consisting of start and end times</li>
  <li>[[s1,e1],[s2,e2],…] (si &lt; ei), find the minimum number of conference rooms required.</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: [[0,30],[5,10],[15,20]]</li>
  <li>Output: 2</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: [[7,10],[2,4]]</li>
  <li>Output: 1</li>
  <li></li>
  <li>Example 3:</li>
  <li>Input: [[9,10],[4,9],[4,17]]</li>
  <li>Output: 2</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>1 &lt;= intervals.length &lt;= 10^4</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>0 &lt;= starti &lt; endi &lt;= 10^6
 */</li>
    </ul>
  </li>
</ul>

<p>// Solution 1: Min Heap (Priority Queue)
// Time: O(n log n), Space: O(n)
export function minMeetingRooms1(intervals: number[][]): number {
    if (intervals.length === 0) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="rouge-code"><pre>// Sort by start time
intervals.sort((a, b) =&gt; a[0] - b[0]);

// Min heap to store end times of ongoing meetings
const endTimes: number[] = [];

function push(val: number): void {
    endTimes.push(val);
    // Heapify up
    let idx = endTimes.length - 1;
    while (idx &gt; 0) {
        const parentIdx = Math.floor((idx - 1) / 2);
        if (endTimes[parentIdx] &lt;= endTimes[idx]) break;
        [endTimes[parentIdx], endTimes[idx]] = [endTimes[idx], endTimes[parentIdx]];
        idx = parentIdx;
    }
}

function pop(): number {
    if (endTimes.length === 0) return -1;
    
    const min = endTimes[0];
    const last = endTimes.pop()!;
    
    if (endTimes.length &gt; 0) {
        endTimes[0] = last;
        // Heapify down
        let idx = 0;
        while (true) {
            let minIdx = idx;
            const left = 2 * idx + 1;
            const right = 2 * idx + 2;
            
            if (left &lt; endTimes.length &amp;&amp; endTimes[left] &lt; endTimes[minIdx]) {
                minIdx = left;
            }
            if (right &lt; endTimes.length &amp;&amp; endTimes[right] &lt; endTimes[minIdx]) {
                minIdx = right;
            }
            
            if (minIdx === idx) break;
            [endTimes[idx], endTimes[minIdx]] = [endTimes[minIdx], endTimes[idx]];
            idx = minIdx;
        }
    }
    
    return min;
}

function peek(): number {
    return endTimes.length &gt; 0 ? endTimes[0] : -1;
}

// Process meetings
for (const [start, end] of intervals) {
    // Check if any meeting has ended
    while (endTimes.length &gt; 0 &amp;&amp; peek() &lt;= start) {
        pop();
    }
    
    // Add current meeting's end time
    push(end);
}

return endTimes.length; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Sweep Line Algorithm
// Time: O(n log n), Space: O(n)
export function minMeetingRooms2(intervals: number[][]): number {
    if (intervals.length === 0) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>// Create events: start = +1, end = -1
const events: [number, number][] = [];

for (const [start, end] of intervals) {
    events.push([start, 1]);   // Meeting starts
    events.push([end, -1]);    // Meeting ends
}

// Sort events by time, with end events before start events at same time
events.sort((a, b) =&gt; a[0] - b[0] || a[1] - b[1]);

let activeRooms = 0;
let maxRooms = 0;

for (const [time, type] of events) {
    activeRooms += type;
    maxRooms = Math.max(maxRooms, activeRooms);
}

return maxRooms; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Two Pointers
// Time: O(n log n), Space: O(n)
export function minMeetingRooms3(intervals: number[][]): number {
    if (intervals.length === 0) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>const starts = intervals.map(interval =&gt; interval[0]).sort((a, b) =&gt; a - b);
const ends = intervals.map(interval =&gt; interval[1]).sort((a, b) =&gt; a - b);

let roomsNeeded = 0;
let maxRooms = 0;
let startPtr = 0;
let endPtr = 0;

while (startPtr &lt; starts.length) {
    if (starts[startPtr] &lt; ends[endPtr]) {
        // Meeting starts, need a room
        roomsNeeded++;
        startPtr++;
    } else {
        // Meeting ends, free a room
        roomsNeeded--;
        endPtr++;
    }
    
    maxRooms = Math.max(maxRooms, roomsNeeded);
}

return maxRooms; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Chronological Ordering
// Time: O(n log n), Space: O(n)
export function minMeetingRooms4(intervals: number[][]): number {
    if (intervals.length === 0) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>// Sort by start time
intervals.sort((a, b) =&gt; a[0] - b[0]);

const rooms: number[] = []; // Array of end times

for (const [start, end] of intervals) {
    // Find the earliest available room
    let earliestRoom = -1;
    let earliestTime = Infinity;
    
    for (let i = 0; i &lt; rooms.length; i++) {
        if (rooms[i] &lt;= start &amp;&amp; rooms[i] &lt; earliestTime) {
            earliestTime = rooms[i];
            earliestRoom = i;
        }
    }
    
    if (earliestRoom === -1) {
        // No available room, need a new one
        rooms.push(end);
    } else {
        // Use existing room
        rooms[earliestRoom] = end;
    }
}

return rooms.length; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Interval Merging Approach
// Time: O(n log n), Space: O(n)
export function minMeetingRooms5(intervals: number[][]): number {
    if (intervals.length === 0) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>intervals.sort((a, b) =&gt; a[0] - b[0]);

const roomSchedules: number[][] = [];

for (const [start, end] of intervals) {
    let assigned = false;
    
    // Try to assign to existing room
    for (let i = 0; i &lt; roomSchedules.length; i++) {
        const lastMeeting = roomSchedules[i][roomSchedules[i].length - 1];
        if (lastMeeting &lt;= start) {
            roomSchedules[i].push(end);
            assigned = true;
            break;
        }
    }
    
    // If no room available, create new room
    if (!assigned) {
        roomSchedules.push([end]);
    }
}

return roomSchedules.length; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 6: Map-based Counting
// Time: O(n log n), Space: O(n)
export function minMeetingRooms6(intervals: number[][]): number {
    if (intervals.length === 0) return 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>const timeMap = new Map&lt;number, number&gt;();

// Count start and end events
for (const [start, end] of intervals) {
    timeMap.set(start, (timeMap.get(start) || 0) + 1);
    timeMap.set(end, (timeMap.get(end) || 0) - 1);
}

// Sort times and process events
const sortedTimes = Array.from(timeMap.keys()).sort((a, b) =&gt; a - b);

let activeRooms = 0;
let maxRooms = 0;

for (const time of sortedTimes) {
    activeRooms += timeMap.get(time)!;
    maxRooms = Math.max(maxRooms, activeRooms);
}

return maxRooms; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testMinMeetingRooms() {
    console.log(“Testing Meeting Rooms II:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="rouge-code"><pre>const testCases = [
    {
        intervals: [[0, 30], [5, 10], [15, 20]],
        expected: 2
    },
    {
        intervals: [[7, 10], [2, 4]],
        expected: 1
    },
    {
        intervals: [[9, 10], [4, 9], [4, 17]],
        expected: 2
    },
    {
        intervals: [[1, 4], [2, 3], [3, 6]],
        expected: 2
    },
    {
        intervals: [[1, 4], [4, 5]],
        expected: 1
    },
    {
        intervals: [[1, 2], [2, 3], [3, 4], [4, 5]],
        expected: 1
    },
    {
        intervals: [[1, 3], [1, 3], [1, 3]],
        expected: 3
    },
    {
        intervals: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5]],
        expected: 1
    },
    {
        intervals: [[1, 10], [2, 9], [3, 8], [4, 7], [5, 6]],
        expected: 5
    }
];

const solutions = [
    { name: "Min Heap", fn: minMeetingRooms1 },
    { name: "Sweep Line", fn: minMeetingRooms2 },
    { name: "Two Pointers", fn: minMeetingRooms3 },
    { name: "Chronological Ordering", fn: minMeetingRooms4 },
    { name: "Interval Merging", fn: minMeetingRooms5 },
    { name: "Map-based Counting", fn: minMeetingRooms6 }
];

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        const input = test.intervals.map(interval =&gt; [...interval]);
        const result = solution.fn(input);
        const passed = result === test.expected;
        console.log(`  Test ${i + 1}: ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Input: ${JSON.stringify(test.intervals)}`);
            console.log(`    Expected: ${test.expected}`);
            console.log(`    Got: ${result}`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Problem Understanding</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Find minimum conference rooms needed for all meetings</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meetings with same start/end time don’t overlap</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Need to track maximum concurrent meetings</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Core Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Track when meetings start and end</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Count maximum simultaneous meetings</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use efficient data structures for tracking</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Min Heap Approach</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Sort meetings by start time</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use heap to track end times of active meetings</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Remove finished meetings before starting new ones</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Sweep Line Algorithm</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Create events for meeting starts (+1) and ends (-1)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Sort events by time (end before start at same time)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Track running count of active meetings</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Two Pointers Technique</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Separate and sort start times and end times</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use two pointers to track meetings starting vs ending</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Maintain count of active meetings</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(n log n)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Sorting dominates the complexity</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Heap operations: O(log n) per meeting</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Cannot be improved without additional constraints</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>: O(n)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Heap/priority queue: O(n) in worst case</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Sweep line: O(n) for events</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Two pointers: O(n) for sorted arrays</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Empty intervals array</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Single meeting</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>All meetings at same time</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Non-overlapping meetings</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with sweep line (most intuitive)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Explain min heap approach</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Discuss two pointers optimization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle edge cases systematically</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Key Insight - Event Processing</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Meeting end at time T means room available at T</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meeting start at time T needs room at T</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Critical: process ends before starts at same time</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimization Considerations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Min heap: efficient for finding earliest end time</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Two pointers: simpler implementation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Sweep line: easy to understand and debug</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Not handling meeting boundaries correctly</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect event ordering at same time</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not removing finished meetings from heap</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Wrong initialization of room count</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: Weighted meetings (priority-based)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Maximum profit meeting scheduling</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Multi-resource scheduling</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Recurring meeting patterns</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Schedule meetings optimally</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Find actual room assignments</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle meeting priorities</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Minimize room changes</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Conference room booking systems</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Resource allocation algorithms</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>CPU scheduling problems</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Network bandwidth allocation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Parking space management</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Pattern Recognition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Interval scheduling pattern</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Event-based processing</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Greedy algorithm application</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Priority queue utilization</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Implementation Tips</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Sort meetings by start time first</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use appropriate data structure for tracking</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle boundary conditions carefully</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Test with overlapping and non-overlapping cases</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Complexity Analysis</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Best case: O(n log n) - cannot avoid sorting</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Worst case: O(n log n) - same as best case</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Space: O(n) - for storing intervals/events</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimal for comparison-based approaches
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>