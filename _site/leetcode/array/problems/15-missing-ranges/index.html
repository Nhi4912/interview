<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Missing Range | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/array/">Array</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/array/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Missing range</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Missing Range</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Array</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Array</span>
                                
                                    <span class="tag">Two Pointers</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                                    <span class="tag">Binary Search</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="missing-range">Missing Range</h1>

<p><strong>LeetCode Problem # * 163. Missing Ranges</strong></p>

<h2 id="problem-description">Problem Description</h2>

<ul>
  <li>You are given an inclusive range [lower, upper] and a sorted unique integer  * array nums, where all elements are in the inclusive range.  *  * A number x is considered missing if x is in the range [lower, upper] and x is  * not in nums.</li>
</ul>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Missing Ranges
 *</li>
    </ol>
  </li>
  <li>Problem:</li>
  <li>You are given an inclusive range [lower, upper] and a sorted unique integer</li>
  <li>array nums, where all elements are in the inclusive range.
 *</li>
  <li>A number x is considered missing if x is in the range [lower, upper] and x is</li>
  <li>not in nums.
 *</li>
  <li>Return the shortest sorted list of ranges that exactly covers all the missing</li>
  <li>numbers. That is, no element of nums is included in any of the ranges, and each</li>
  <li>missing number is covered by one of the ranges.
 *</li>
  <li>Example:</li>
  <li>Input: nums = [0,1,3,50,75], lower = 0, upper = 99</li>
  <li>Output: [“2”,”4-&gt;49”,”51-&gt;74”,”76-&gt;99”]
 *</li>
  <li>Input: nums = [-1], lower = -1, upper = -1</li>
  <li>Output: []
 *</li>
  <li>LeetCode: https://leetcode.com/problems/missing-ranges/
 */</li>
</ul>

<p>/**</p>
<ul>
  <li>Solution 1: Linear Scan (Optimal)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Scan through the array and check gaps between numbers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle edge cases for lower and upper bounds
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(1) - excluding result space
 */
function findMissingRanges(
  nums: number[],
  lower: number,
  upper: number
): string[] {
  const result: string[] = [];</li>
</ul>

<p>// Handle empty array
  if (nums.length === 0) {
    if (lower &lt;= upper) {
      result.push(formatRange(lower, upper));
    }
    return result;
  }</p>

<p>// Check range before first number
  if (lower &lt; nums[0]) {
    result.push(formatRange(lower, nums[0] - 1));
  }</p>

<p>// Check ranges between numbers
  for (let i = 0; i &lt; nums.length - 1; i++) {
    if (nums[i + 1] - nums[i] &gt; 1) {
      result.push(formatRange(nums[i] + 1, nums[i + 1] - 1));
    }
  }</p>

<p>// Check range after last number
  if (nums[nums.length - 1] &lt; upper) {
    result.push(formatRange(nums[nums.length - 1] + 1, upper));
  }</p>

<p>return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 2: Using Array Methods
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use array methods to process the array</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More functional approach
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(n)
 */
function findMissingRangesArray(
  nums: number[],
  lower: number,
  upper: number
): string[] {
  const result: string[] = [];</li>
</ul>

<p>// Add bounds to array for easier processing
  const extendedNums = [lower - 1, …nums, upper + 1];</p>

<p>// Find gaps between consecutive numbers
  for (let i = 0; i &lt; extendedNums.length - 1; i++) {
    const start = extendedNums[i] + 1;
    const end = extendedNums[i + 1] - 1;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>if (start &lt;= end) {
  result.push(formatRange(start, end));
}   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 3: Using Map
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Map to track existing numbers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Check each number in range
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(upper - lower)</li>
  <li>Space Complexity: O(n)
 */
function findMissingRangesMap(
  nums: number[],
  lower: number,
  upper: number
): string[] {
  const result: string[] = [];
  const numSet = new Map&lt;number, boolean&gt;();</li>
</ul>

<p>// Add all numbers to map
  for (const num of nums) {
    numSet.set(num, true);
  }</p>

<p>let start = lower;
  let end = lower;</p>

<p>// Scan through the range
  for (let i = lower; i &lt;= upper; i++) {
    if (!numSet.has(i)) {
      end = i;
    } else {
      if (start &lt;= end) {
        result.push(formatRange(start, end));
      }
      start = i + 1;
      end = i + 1;
    }
  }</p>

<p>// Handle last range
  if (start &lt;= end) {
    result.push(formatRange(start, end));
  }</p>

<p>return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 4: Using Set
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use Set to track existing numbers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Similar to Map approach but with Set
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(upper - lower)</li>
  <li>Space Complexity: O(n)
 */
function findMissingRangesSet(
  nums: number[],
  lower: number,
  upper: number
): string[] {
  const result: string[] = [];
  const numSet = new Set(nums);</li>
</ul>

<p>let start = lower;
  let end = lower;</p>

<p>// Scan through the range
  for (let i = lower; i &lt;= upper; i++) {
    if (!numSet.has(i)) {
      end = i;
    } else {
      if (start &lt;= end) {
        result.push(formatRange(start, end));
      }
      start = i + 1;
      end = i + 1;
    }
  }</p>

<p>// Handle last range
  if (start &lt;= end) {
    result.push(formatRange(start, end));
  }</p>

<p>return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 5: Functional Approach
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use functional programming concepts</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More declarative style
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(n)
 */
function findMissingRangesFunctional(
  nums: number[],
  lower: number,
  upper: number
): string[] {
  if (nums.length === 0) {
 return lower &lt;= upper ? [formatRange(lower, upper)] : [];
  }</li>
</ul>

<p>const extendedNums = [lower - 1, …nums, upper + 1];</p>

<p>return extendedNums
    .slice(0, -1)
    .map((num, i) =&gt; [num + 1, extendedNums[i + 1] - 1])
    .filter(([start, end]) =&gt; start &lt;= end)
    .map(([start, end]) =&gt; formatRange(start, end));
}</p>

<p>/**</p>
<ul>
  <li>Solution 6: Using Generator (Memory efficient)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use generator to yield missing ranges</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory efficient for large ranges
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(1)
 <em>/
function</em> missingRangesGenerator(
  nums: number[],
  lower: number,
  upper: number
): Generator<string> {
  if (nums.length === 0) {
 if (lower &lt;= upper) {
   yield formatRange(lower, upper);
 }
 return;
  }</string></li>
</ul>

<p>// Check range before first number
  if (lower &lt; nums[0]) {
    yield formatRange(lower, nums[0] - 1);
  }</p>

<p>// Check ranges between numbers
  for (let i = 0; i &lt; nums.length - 1; i++) {
    if (nums[i + 1] - nums[i] &gt; 1) {
      yield formatRange(nums[i] + 1, nums[i + 1] - 1);
    }
  }</p>

<p>// Check range after last number
  if (nums[nums.length - 1] &lt; upper) {
    yield formatRange(nums[nums.length - 1] + 1, upper);
  }
}</p>

<p>function findMissingRangesWithGenerator(
  nums: number[],
  lower: number,
  upper: number
): string[] {
  return Array.from(missingRangesGenerator(nums, lower, upper));
}</p>

<p>/**</p>
<ul>
  <li>Solution 7: Using Class (Object-oriented)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Create a MissingRangesFinder class</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Encapsulate finding logic
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(1)
 */
class MissingRangesFinder {
  private nums: number[];
  private lower: number;
  private upper: number;</li>
</ul>

<p>constructor(nums: number[], lower: number, upper: number) {
    this.nums = nums;
    this.lower = lower;
    this.upper = upper;
  }</p>

<p>findMissingRanges(): string[] {
    const result: string[] = [];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>if (this.nums.length === 0) {
  if (this.lower &lt;= this.upper) {
    result.push(this.formatRange(this.lower, this.upper));
  }
  return result;
}

// Check range before first number
if (this.lower &lt; this.nums[0]) {
  result.push(this.formatRange(this.lower, this.nums[0] - 1));
}

// Check ranges between numbers
for (let i = 0; i &lt; this.nums.length - 1; i++) {
  if (this.nums[i + 1] - this.nums[i] &gt; 1) {
    result.push(this.formatRange(this.nums[i] + 1, this.nums[i + 1] - 1));
  }
}

// Check range after last number
if (this.nums[this.nums.length - 1] &lt; this.upper) {
  result.push(
    this.formatRange(this.nums[this.nums.length - 1] + 1, this.upper)
  );
}

return result;   }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>private formatRange(start: number, end: number): string {
    return start === end ? start.toString() : <code class="language-plaintext highlighter-rouge">${start}-&gt;${end}</code>;
  }
}</p>

<p>function findMissingRangesClass(
  nums: number[],
  lower: number,
  upper: number
): string[] {
  const finder = new MissingRangesFinder(nums, lower, upper);
  return finder.findMissingRanges();
}</p>

<p>/**</p>
<ul>
  <li>Solution 8: Using Two Pointers
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use two pointers to track current position and next number</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More explicit control over the process
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n)</li>
  <li>Space Complexity: O(1)
 */
function findMissingRangesTwoPointers(
  nums: number[],
  lower: number,
  upper: number
): string[] {
  const result: string[] = [];
  let current = lower;
  let index = 0;</li>
</ul>

<p>while (current &lt;= upper) {
    if (index &lt; nums.length &amp;&amp; nums[index] === current) {
      current++;
      index++;
    } else {
      let end = current;
      while (end &lt;= upper &amp;&amp; (index &gt;= nums.length || nums[index] &gt; end)) {
        end++;
      }
      result.push(formatRange(current, end - 1));
      current = end;
    }
  }</p>

<p>return result;
}</p>

<p>/**</p>
<ul>
  <li>Solution 9: Using Binary Search (Educational)
 *</li>
  <li>Approach:</li>
  <li>
    <ul>
      <li>Use binary search to find missing ranges</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>More complex but shows binary search application
 *</li>
    </ul>
  </li>
  <li>Time Complexity: O(n log n)</li>
  <li>Space Complexity: O(1)
 */
function findMissingRangesBinarySearch(
  nums: number[],
  lower: number,
  upper: number
): string[] {
  const result: string[] = [];</li>
</ul>

<p>// Find first missing number
  let start = lower;
  while (start &lt;= upper) {
    const found = binarySearch(nums, start);
    if (found) {
      start++;
    } else {
      break;
    }
  }</p>

<p>if (start &gt; upper) return result;</p>

<p>// Find ranges
  let end = start;
  while (end &lt;= upper) {
    const found = binarySearch(nums, end);
    if (found) {
      result.push(formatRange(start, end - 1));
      start = end + 1;
      while (start &lt;= upper &amp;&amp; binarySearch(nums, start)) {
        start++;
      }
      end = start;
    } else {
      end++;
    }
  }</p>

<p>if (start &lt;= upper) {
    result.push(formatRange(start, upper));
  }</p>

<p>return result;
}</p>

<p>function binarySearch(nums: number[], target: number): boolean {
  let left = 0;
  let right = nums.length - 1;</p>

<p>while (left &lt;= right) {
    const mid = Math.floor((left + right) / 2);
    if (nums[mid] === target) {
      return true;
    } else if (nums[mid] &lt; target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }</p>

<p>return false;
}</p>

<p>// Helper functions
function formatRange(start: number, end: number): string {
  return start === end ? start.toString() : <code class="language-plaintext highlighter-rouge">${start}-&gt;${end}</code>;
}</p>

<p>// Test cases
function testMissingRanges() {
  console.log(“=== Testing Missing Ranges ===\n”);</p>

<p>const testCases = [
    {
      nums: [0, 1, 3, 50, 75],
      lower: 0,
      upper: 99,
      expected: [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”],
      description: “Standard case with multiple ranges”,
    },
    {
      nums: [-1],
      lower: -1,
      upper: -1,
      expected: [],
      description: “Single number matching bounds”,
    },
    {
      nums: [],
      lower: 1,
      upper: 1,
      expected: [“1”],
      description: “Empty array with single number range”,
    },
    {
      nums: [],
      lower: -3,
      upper: -1,
      expected: [“-3-&gt;-1”],
      description: “Empty array with negative range”,
    },
    {
      nums: [1, 3, 5, 7],
      lower: 0,
      upper: 9,
      expected: [“0”, “2”, “4”, “6”, “8-&gt;9”],
      description: “Alternating numbers”,
    },
    {
      nums: [1, 2, 3, 4, 5],
      lower: 1,
      upper: 5,
      expected: [],
      description: “No missing numbers”,
    },
    {
      nums: [1, 2, 3, 4, 5],
      lower: 0,
      upper: 6,
      expected: [“0”, “6”],
      description: “Missing numbers at bounds”,
    },
  ];</p>

<p>testCases.forEach((testCase, index) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">Test Case ${index + 1}: ${testCase.description}</code>);
    console.log(
      <code class="language-plaintext highlighter-rouge">Input: nums = [${testCase.nums.join(", ")}], lower = ${
        testCase.lower
      }, upper = ${testCase.upper}</code>
    );
    console.log(<code class="language-plaintext highlighter-rouge">Expected: [${testCase.expected.join(", ")}]\n</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
</pre></td><td class="rouge-code"><pre>// Test Solution 1 (Linear Scan)
const result1 = findMissingRanges(
  [...testCase.nums],
  testCase.lower,
  testCase.upper
);
console.log(
  `Solution 1 (Linear Scan): [${result1.join(", ")}] ${
    JSON.stringify(result1) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 2 (Array Methods)
const result2 = findMissingRangesArray(
  [...testCase.nums],
  testCase.lower,
  testCase.upper
);
console.log(
  `Solution 2 (Array Methods): [${result2.join(", ")}] ${
    JSON.stringify(result2) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 3 (Map)
const result3 = findMissingRangesMap(
  [...testCase.nums],
  testCase.lower,
  testCase.upper
);
console.log(
  `Solution 3 (Map): [${result3.join(", ")}] ${
    JSON.stringify(result3) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 4 (Set)
const result4 = findMissingRangesSet(
  [...testCase.nums],
  testCase.lower,
  testCase.upper
);
console.log(
  `Solution 4 (Set): [${result4.join(", ")}] ${
    JSON.stringify(result4) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 5 (Functional)
const result5 = findMissingRangesFunctional(
  [...testCase.nums],
  testCase.lower,
  testCase.upper
);
console.log(
  `Solution 5 (Functional): [${result5.join(", ")}] ${
    JSON.stringify(result5) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 6 (Generator)
const result6 = findMissingRangesWithGenerator(
  [...testCase.nums],
  testCase.lower,
  testCase.upper
);
console.log(
  `Solution 6 (Generator): [${result6.join(", ")}] ${
    JSON.stringify(result6) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 7 (Class)
const result7 = findMissingRangesClass(
  [...testCase.nums],
  testCase.lower,
  testCase.upper
);
console.log(
  `Solution 7 (Class): [${result7.join(", ")}] ${
    JSON.stringify(result7) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 8 (Two Pointers)
const result8 = findMissingRangesTwoPointers(
  [...testCase.nums],
  testCase.lower,
  testCase.upper
);
console.log(
  `Solution 8 (Two Pointers): [${result8.join(", ")}] ${
    JSON.stringify(result8) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

// Test Solution 9 (Binary Search)
const result9 = findMissingRangesBinarySearch(
  [...testCase.nums],
  testCase.lower,
  testCase.upper
);
console.log(
  `Solution 9 (Binary Search): [${result9.join(", ")}] ${
    JSON.stringify(result9) === JSON.stringify(testCase.expected)
      ? "✅"
      : "❌"
  }`
);

console.log("\n---\n");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Performance comparison
function performanceComparison() {
  console.log(“=== Performance Comparison ===\n”);</p>

<p>const testCases = [
    { name: “Linear Scan”, func: findMissingRanges },
    { name: “Array Methods”, func: findMissingRangesArray },
    { name: “Map”, func: findMissingRangesMap },
    { name: “Set”, func: findMissingRangesSet },
    { name: “Functional”, func: findMissingRangesFunctional },
    { name: “Generator”, func: findMissingRangesWithGenerator },
    { name: “Class”, func: findMissingRangesClass },
    { name: “Two Pointers”, func: findMissingRangesTwoPointers },
    { name: “Binary Search”, func: findMissingRangesBinarySearch },
  ];</p>

<p>// Create test cases
  const smallCase = { nums: [0, 1, 3, 50, 75], lower: 0, upper: 99 };
  const mediumCase = {
    nums: Array.from({ length: 100 }, (<em>, i) =&gt; i * 2),
    lower: 0,
    upper: 200,
  };
  const largeCase = {
    nums: Array.from({ length: 1000 }, (</em>, i) =&gt; i * 3),
    lower: 0,
    upper: 3000,
  };</p>

<p>const cases = [
    { name: “Small”, case: smallCase },
    { name: “Medium”, case: mediumCase },
    { name: “Large”, case: largeCase },
  ];</p>

<p>cases.forEach(({ name, case: testCase }) =&gt; {
    console.log(<code class="language-plaintext highlighter-rouge">${name} Case:</code>);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>testCases.forEach(({ name: funcName, func }) =&gt; {
  const start = performance.now();
  const result = func([...testCase.nums], testCase.lower, testCase.upper);
  const end = performance.now();

  console.log(
    `  ${funcName}: ${(end - start).toFixed(2)}ms (${result.length} ranges)`
  );
});

console.log("");   }); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Uncomment the following lines to run tests
// testMissingRanges();
// performanceComparison();</p>

<p>export {
  findMissingRanges,
  findMissingRangesArray,
  findMissingRangesMap,
  findMissingRangesSet,
  findMissingRangesFunctional,
  findMissingRangesWithGenerator,
  findMissingRangesClass,
  findMissingRangesTwoPointers,
  findMissingRangesBinarySearch,
  MissingRangesFinder,
  missingRangesGenerator,
  formatRange,
  binarySearch,
  testMissingRanges,
  performanceComparison,
};</p>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>