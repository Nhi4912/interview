<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Insert Interval | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/array/">Array</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/array/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Insert interval</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Insert Interval</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Array</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Array</span>
                                
                                    <span class="tag">Binary Search</span>
                                
                                    <span class="tag">Greedy</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="insert-interval">Insert Interval</h1>

<p><strong>LeetCode Problem # * 57. Insert Interval</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Insert Interval</li>
    </ol>
  </li>
  <li></li>
  <li>You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi]</li>
  <li>represent the start and the end of the ith interval and intervals is sorted in ascending order by starti.</li>
  <li>You are also given an interval newInterval = [start, end] that represents the start and end of another interval.</li>
  <li></li>
  <li>Insert newInterval into intervals such that intervals is still sorted in ascending order by starti</li>
  <li>and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).</li>
  <li></li>
  <li>Return intervals after the insertion.</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: intervals = [[1,3],[6,9]], newInterval = [2,5]</li>
  <li>Output: [[1,5],[6,9]]</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</li>
  <li>Output: [[1,2],[3,10],[12,16]]</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>0 &lt;= intervals.length &lt;= 10^4</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>intervals[i].length == 2</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>0 &lt;= starti &lt;= endi &lt;= 10^5</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>intervals is sorted by starti.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>newInterval.length == 2</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>0 &lt;= start &lt;= end &lt;= 10^5
 */</li>
    </ul>
  </li>
</ul>

<p>// Solution 1: Linear Scan and Merge
// Time: O(n), Space: O(n)
export function insert1(intervals: number[][], newInterval: number[]): number[][] {
    const result: number[][] = [];
    let i = 0;
    const n = intervals.length;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>// Add all intervals that end before newInterval starts
while (i &lt; n &amp;&amp; intervals[i][1] &lt; newInterval[0]) {
    result.push(intervals[i]);
    i++;
}

// Merge overlapping intervals with newInterval
while (i &lt; n &amp;&amp; intervals[i][0] &lt;= newInterval[1]) {
    // Merge intervals
    newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
    newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
    i++;
}

// Add the merged interval
result.push(newInterval);

// Add remaining intervals
while (i &lt; n) {
    result.push(intervals[i]);
    i++;
}

return result; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Binary Search + Merge
// Time: O(n), Space: O(n)
export function insert2(intervals: number[][], newInterval: number[]): number[][] {
    if (intervals.length === 0) return [newInterval];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="rouge-code"><pre>// Binary search for insertion position
function binarySearchLeft(target: number): number {
    let left = 0, right = intervals.length;
    while (left &lt; right) {
        const mid = Math.floor((left + right) / 2);
        if (intervals[mid][0] &lt; target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

function binarySearchRight(target: number): number {
    let left = 0, right = intervals.length;
    while (left &lt; right) {
        const mid = Math.floor((left + right) / 2);
        if (intervals[mid][1] &lt;= target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}

const result: number[][] = [];

// Find range of intervals that overlap with newInterval
let start = 0, end = intervals.length;

// Find first interval that might overlap
for (let i = 0; i &lt; intervals.length; i++) {
    if (intervals[i][1] &gt;= newInterval[0]) {
        start = i;
        break;
    }
}

// Find last interval that might overlap
for (let i = intervals.length - 1; i &gt;= 0; i--) {
    if (intervals[i][0] &lt;= newInterval[1]) {
        end = i + 1;
        break;
    }
}

// Add intervals before overlap
for (let i = 0; i &lt; start; i++) {
    result.push(intervals[i]);
}

// Merge overlapping intervals
let mergedStart = newInterval[0];
let mergedEnd = newInterval[1];

for (let i = start; i &lt; end; i++) {
    if (intervals[i][0] &lt;= newInterval[1] &amp;&amp; intervals[i][1] &gt;= newInterval[0]) {
        mergedStart = Math.min(mergedStart, intervals[i][0]);
        mergedEnd = Math.max(mergedEnd, intervals[i][1]);
    }
}

result.push([mergedStart, mergedEnd]);

// Add intervals after overlap
for (let i = end; i &lt; intervals.length; i++) {
    result.push(intervals[i]);
}

return result; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Three-Phase Approach
// Time: O(n), Space: O(n)
export function insert3(intervals: number[][], newInterval: number[]): number[][] {
    const result: number[][] = [];
    let inserted = false;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>for (const interval of intervals) {
    if (interval[1] &lt; newInterval[0]) {
        // No overlap, interval ends before newInterval starts
        result.push(interval);
    } else if (interval[0] &gt; newInterval[1]) {
        // No overlap, interval starts after newInterval ends
        if (!inserted) {
            result.push(newInterval);
            inserted = true;
        }
        result.push(interval);
    } else {
        // Overlap, merge intervals
        newInterval[0] = Math.min(newInterval[0], interval[0]);
        newInterval[1] = Math.max(newInterval[1], interval[1]);
    }
}

// Add newInterval if not inserted yet
if (!inserted) {
    result.push(newInterval);
}

return result; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Stack-based Approach
// Time: O(n), Space: O(n)
export function insert4(intervals: number[][], newInterval: number[]): number[][] {
    const stack: number[][] = [];
    let inserted = false;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>for (let i = 0; i &lt;= intervals.length; i++) {
    let current: number[];
    
    if (i === intervals.length) {
        if (!inserted) {
            current = newInterval;
        } else {
            break;
        }
    } else if (!inserted &amp;&amp; intervals[i][0] &gt;= newInterval[0]) {
        current = newInterval;
        inserted = true;
        i--; // Process current interval in next iteration
        continue;
    } else {
        current = intervals[i];
    }
    
    if (stack.length === 0 || stack[stack.length - 1][1] &lt; current[0]) {
        // No overlap
        stack.push(current);
    } else {
        // Overlap, merge
        stack[stack.length - 1][1] = Math.max(stack[stack.length - 1][1], current[1]);
    }
}

return stack; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Recursive Approach
// Time: O(n), Space: O(n)
export function insert5(intervals: number[][], newInterval: number[]): number[][] {
    function insertHelper(intervals: number[][], newInterval: number[], index: number): number[][] {
        if (index &gt;= intervals.length) {
            return [newInterval];
        }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre>    const current = intervals[index];
    
    if (newInterval[1] &lt; current[0]) {
        // Insert before current
        return [newInterval, ...intervals.slice(index)];
    } else if (newInterval[0] &gt; current[1]) {
        // Insert after current
        return [current, ...insertHelper(intervals, newInterval, index + 1)];
    } else {
        // Merge with current
        const merged = [
            Math.min(newInterval[0], current[0]),
            Math.max(newInterval[1], current[1])
        ];
        return insertHelper(intervals, merged, index + 1);
    }
}

return insertHelper(intervals, newInterval, 0); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 6: Two-Pass Approach
// Time: O(n), Space: O(n)
export function insert6(intervals: number[][], newInterval: number[]): number[][] {
    const result: number[][] = [];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="rouge-code"><pre>// First pass: find merge range
let mergeStart = -1;
let mergeEnd = -1;

for (let i = 0; i &lt; intervals.length; i++) {
    const interval = intervals[i];
    
    if (interval[0] &lt;= newInterval[1] &amp;&amp; interval[1] &gt;= newInterval[0]) {
        // Overlapping interval
        if (mergeStart === -1) {
            mergeStart = i;
        }
        mergeEnd = i;
    }
}

// Second pass: build result
let i = 0;

// Add intervals before merge range
while (i &lt; mergeStart) {
    result.push(intervals[i]);
    i++;
}

// Add merged interval
if (mergeStart === -1) {
    // No overlaps, find insertion position
    let insertPos = 0;
    while (insertPos &lt; intervals.length &amp;&amp; intervals[insertPos][0] &lt; newInterval[0]) {
        insertPos++;
    }
    
    // Build result with insertion
    for (let j = 0; j &lt; insertPos; j++) {
        result.push(intervals[j]);
    }
    result.push(newInterval);
    for (let j = insertPos; j &lt; intervals.length; j++) {
        result.push(intervals[j]);
    }
} else {
    // Merge overlapping intervals
    let mergedStart = newInterval[0];
    let mergedEnd = newInterval[1];
    
    for (let j = mergeStart; j &lt;= mergeEnd; j++) {
        mergedStart = Math.min(mergedStart, intervals[j][0]);
        mergedEnd = Math.max(mergedEnd, intervals[j][1]);
    }
    
    result.push([mergedStart, mergedEnd]);
    
    // Add intervals after merge range
    for (let j = mergeEnd + 1; j &lt; intervals.length; j++) {
        result.push(intervals[j]);
    }
}

return result; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testInsert() {
    console.log(“Testing Insert Interval:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="rouge-code"><pre>const testCases = [
    {
        intervals: [[1, 3], [6, 9]],
        newInterval: [2, 5],
        expected: [[1, 5], [6, 9]]
    },
    {
        intervals: [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]],
        newInterval: [4, 8],
        expected: [[1, 2], [3, 10], [12, 16]]
    },
    {
        intervals: [],
        newInterval: [5, 7],
        expected: [[5, 7]]
    },
    {
        intervals: [[1, 5]],
        newInterval: [2, 3],
        expected: [[1, 5]]
    },
    {
        intervals: [[1, 5]],
        newInterval: [6, 8],
        expected: [[1, 5], [6, 8]]
    },
    {
        intervals: [[1, 5]],
        newInterval: [0, 0],
        expected: [[0, 0], [1, 5]]
    },
    {
        intervals: [[1, 3], [6, 9]],
        newInterval: [2, 5],
        expected: [[1, 5], [6, 9]]
    },
    {
        intervals: [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]],
        newInterval: [4, 8],
        expected: [[1, 2], [3, 10], [12, 16]]
    }
];

const solutions = [
    { name: "Linear Scan and Merge", fn: insert1 },
    { name: "Binary Search + Merge", fn: insert2 },
    { name: "Three-Phase Approach", fn: insert3 },
    { name: "Stack-based", fn: insert4 },
    { name: "Recursive", fn: insert5 },
    { name: "Two-Pass", fn: insert6 }
];

function arraysEqual(a: number[][], b: number[][]): boolean {
    if (a.length !== b.length) return false;
    for (let i = 0; i &lt; a.length; i++) {
        if (a[i].length !== b[i].length) return false;
        for (let j = 0; j &lt; a[i].length; j++) {
            if (a[i][j] !== b[i][j]) return false;
        }
    }
    return true;
}

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        const intervals = test.intervals.map(interval =&gt; [...interval]);
        const newInterval = [...test.newInterval];
        const result = solution.fn(intervals, newInterval);
        const passed = arraysEqual(result, test.expected);
        console.log(`  Test ${i + 1}: ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Intervals: ${JSON.stringify(test.intervals)}`);
            console.log(`    New Interval: ${JSON.stringify(test.newInterval)}`);
            console.log(`    Expected: ${JSON.stringify(test.expected)}`);
            console.log(`    Got: ${JSON.stringify(result)}`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Problem Structure</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Intervals are already sorted and non-overlapping</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Need to insert and merge new interval</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Maintain sorted order and no overlaps</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Three Phases Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Phase 1: Add intervals that end before newInterval starts</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Phase 2: Merge overlapping intervals with newInterval</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Phase 3: Add intervals that start after newInterval ends</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Overlap Detection</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Two intervals [a,b] and [c,d] overlap if: max(a,c) &lt;= min(b,d)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Or equivalently: a &lt;= d &amp;&amp; c &lt;= b</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>No overlap if: b &lt; c or d &lt; a</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Merging Logic</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Merged interval: [min(start1, start2), max(end1, end2)]</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Keep expanding newInterval as we find overlaps</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Add final merged interval to result</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(n)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Single pass through intervals</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Constant work per interval</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Cannot be improved (must examine all intervals)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>: O(n)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Result array stores all intervals</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Input modification could reduce to O(1)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Depends on whether input can be modified</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Empty intervals array</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>NewInterval doesn’t overlap with any</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>NewInterval overlaps with all</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>NewInterval is subset of existing interval</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with three-phase approach</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Explain overlap detection clearly</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle edge cases systematically</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Discuss optimization opportunities</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Key Observations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Input is already sorted (don’t need to sort)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Can process in single left-to-right pass</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Merge operations extend newInterval boundaries</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Implementation Patterns</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Linear scan: most straightforward</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Binary search: helpful for very large inputs</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Stack-based: natural for interval problems</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimization Considerations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Early termination after processing overlaps</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Binary search for insertion point (large inputs)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>In-place modification if allowed</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Incorrect overlap detection logic</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not handling boundary cases (touching intervals)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Forgetting to add newInterval when no overlaps</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Wrong order in final result</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: Insert multiple intervals at once</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Insert with priority/weight considerations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Calendar scheduling with conflicts</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Meeting room booking systems</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>What if intervals weren’t sorted?</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Insert multiple new intervals efficiently</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Remove intervals that overlap with new one</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Find gaps in interval coverage</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Calendar management systems</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Resource booking platforms</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Network bandwidth allocation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory management (free/allocated blocks)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Timeline visualization tools</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Pattern Recognition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Interval merging pattern</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Linear scan with state tracking</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Greedy algorithm approach</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Boundary condition handling</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Testing Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Test with no overlaps</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Test with complete overlap</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Test with partial overlaps</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Test edge cases (empty, single interval)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Alternative Approaches</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Recursive divide and conquer</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Event-based processing</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Interval tree data structure</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Segment tree for range queries
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>