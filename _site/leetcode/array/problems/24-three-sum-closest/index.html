<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Given an integer array nums of length n and an integer target, find three integers  | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/array/">Array</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/array/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Given an integer array nums of length n and an integer target, find three integers </li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Given an integer array nums of length n and an integer target, find three integers </h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Array</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Array</span>
                                
                                    <span class="tag">Two Pointers</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                                    <span class="tag">Binary Search</span>
                                
                                    <span class="tag">Greedy</span>
                                
                                    <span class="tag">Sorting</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="given-an-integer-array-nums-of-length-n-and-an-integer-target-find-three-integers">Given an integer array nums of length n and an integer target, find three integers</h1>

<p><strong>LeetCode Problem # * 16. 3Sum Closest</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>3Sum Closest</li>
    </ol>
  </li>
  <li></li>
  <li>Given an integer array nums of length n and an integer target, find three integers</li>
  <li>in nums such that the sum is closest to target.</li>
  <li></li>
  <li>Return the sum of the three integers.</li>
  <li></li>
  <li>You may assume that each input would have exactly one solution.</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: nums = [-1,2,1,-4], target = 1</li>
  <li>Output: 2</li>
  <li>Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: nums = [0,0,0], target = 1</li>
  <li>Output: 0</li>
  <li>Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>3 &lt;= nums.length &lt;= 500</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>-1000 &lt;= nums[i] &lt;= 1000</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>-10^4 &lt;= target &lt;= 10^4
 */</li>
    </ul>
  </li>
</ul>

<p>// Solution 1: Two Pointers (Optimal)
// Time: O(n^2), Space: O(1)
export function threeSumClosest1(nums: number[], target: number): number {
    nums.sort((a, b) =&gt; a - b);
    let closestSum = nums[0] + nums[1] + nums[2];
    let minDiff = Math.abs(closestSum - target);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre>for (let i = 0; i &lt; nums.length - 2; i++) {
    // Skip duplicates for first element
    if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) continue;
    
    let left = i + 1;
    let right = nums.length - 1;
    
    while (left &lt; right) {
        const currentSum = nums[i] + nums[left] + nums[right];
        const currentDiff = Math.abs(currentSum - target);
        
        if (currentDiff &lt; minDiff) {
            minDiff = currentDiff;
            closestSum = currentSum;
        }
        
        if (currentSum === target) {
            return currentSum; // Exact match found
        } else if (currentSum &lt; target) {
            left++;
            // Skip duplicates
            while (left &lt; right &amp;&amp; nums[left] === nums[left - 1]) left++;
        } else {
            right--;
            // Skip duplicates
            while (left &lt; right &amp;&amp; nums[right] === nums[right + 1]) right--;
        }
    }
}

return closestSum; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Binary Search Enhancement
// Time: O(n^2 log n), Space: O(1)
export function threeSumClosest2(nums: number[], target: number): number {
    nums.sort((a, b) =&gt; a - b);
    let closestSum = nums[0] + nums[1] + nums[2];
    let minDiff = Math.abs(closestSum - target);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="rouge-code"><pre>for (let i = 0; i &lt; nums.length - 2; i++) {
    if (i &gt; 0 &amp;&amp; nums[i] === nums[i - 1]) continue;
    
    for (let j = i + 1; j &lt; nums.length - 1; j++) {
        if (j &gt; i + 1 &amp;&amp; nums[j] === nums[j - 1]) continue;
        
        const twoSum = nums[i] + nums[j];
        const needed = target - twoSum;
        
        // Binary search for closest value to needed
        let left = j + 1, right = nums.length - 1;
        
        while (left &lt;= right) {
            const mid = Math.floor((left + right) / 2);
            const currentSum = twoSum + nums[mid];
            const currentDiff = Math.abs(currentSum - target);
            
            if (currentDiff &lt; minDiff) {
                minDiff = currentDiff;
                closestSum = currentSum;
            }
            
            if (nums[mid] === needed) {
                return currentSum;
            } else if (nums[mid] &lt; needed) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        // Check boundaries
        if (j + 1 &lt; nums.length) {
            const sum1 = twoSum + nums[j + 1];
            if (Math.abs(sum1 - target) &lt; minDiff) {
                minDiff = Math.abs(sum1 - target);
                closestSum = sum1;
            }
        }
        
        if (nums.length - 1 &gt;= j + 1) {
            const sum2 = twoSum + nums[nums.length - 1];
            if (Math.abs(sum2 - target) &lt; minDiff) {
                minDiff = Math.abs(sum2 - target);
                closestSum = sum2;
            }
        }
    }
}

return closestSum; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Brute Force with Optimization
// Time: O(n^3), Space: O(1)
export function threeSumClosest3(nums: number[], target: number): number {
    let closestSum = nums[0] + nums[1] + nums[2];
    let minDiff = Math.abs(closestSum - target);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>for (let i = 0; i &lt; nums.length - 2; i++) {
    for (let j = i + 1; j &lt; nums.length - 1; j++) {
        for (let k = j + 1; k &lt; nums.length; k++) {
            const currentSum = nums[i] + nums[j] + nums[k];
            const currentDiff = Math.abs(currentSum - target);
            
            if (currentDiff &lt; minDiff) {
                minDiff = currentDiff;
                closestSum = currentSum;
                
                // Early termination if exact match
                if (currentDiff === 0) return closestSum;
            }
        }
    }
}

return closestSum; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Two Pointers with Early Termination
// Time: O(n^2), Space: O(1)
export function threeSumClosest4(nums: number[], target: number): number {
    nums.sort((a, b) =&gt; a - b);
    let closestSum = nums[0] + nums[1] + nums[2];
    let minDiff = Math.abs(closestSum - target);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre>for (let i = 0; i &lt; nums.length - 2; i++) {
    // Early termination checks
    const minPossible = nums[i] + nums[i + 1] + nums[i + 2];
    if (minPossible &gt; target &amp;&amp; Math.abs(minPossible - target) &gt;= minDiff) {
        break;
    }
    
    const maxPossible = nums[i] + nums[nums.length - 2] + nums[nums.length - 1];
    if (maxPossible &lt; target &amp;&amp; Math.abs(maxPossible - target) &gt;= minDiff) {
        continue;
    }
    
    let left = i + 1;
    let right = nums.length - 1;
    
    while (left &lt; right) {
        const currentSum = nums[i] + nums[left] + nums[right];
        
        if (currentSum === target) {
            return currentSum;
        }
        
        const currentDiff = Math.abs(currentSum - target);
        if (currentDiff &lt; minDiff) {
            minDiff = currentDiff;
            closestSum = currentSum;
        }
        
        if (currentSum &lt; target) {
            left++;
        } else {
            right--;
        }
    }
}

return closestSum; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Divide and Conquer
// Time: O(n^2 log n), Space: O(log n)
export function threeSumClosest5(nums: number[], target: number): number {
    nums.sort((a, b) =&gt; a - b);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre>function findClosestInRange(start: number, end: number, currentSum: number, remaining: number): number {
    if (remaining === 0) {
        return currentSum;
    }
    
    if (remaining === 1) {
        let closest = nums[start];
        let minDiff = Math.abs(closest + currentSum - target);
        
        for (let i = start; i &lt;= end; i++) {
            const diff = Math.abs(nums[i] + currentSum - target);
            if (diff &lt; minDiff) {
                minDiff = diff;
                closest = nums[i];
            }
        }
        
        return currentSum + closest;
    }
    
    let bestSum = currentSum;
    let minDiff = Infinity;
    
    for (let i = start; i &lt;= end - remaining + 1; i++) {
        const newSum = findClosestInRange(i + 1, end, currentSum + nums[i], remaining - 1);
        const diff = Math.abs(newSum - target);
        
        if (diff &lt; minDiff) {
            minDiff = diff;
            bestSum = newSum;
        }
        
        if (diff === 0) break;
    }
    
    return bestSum;
}

return findClosestInRange(0, nums.length - 1, 0, 3); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 6: Hash Map with Complement Search
// Time: O(n^2), Space: O(n)
export function threeSumClosest6(nums: number[], target: number): number {
    let closestSum = nums[0] + nums[1] + nums[2];
    let minDiff = Math.abs(closestSum - target);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre>// Create frequency map
const freq = new Map&lt;number, number&gt;();
for (const num of nums) {
    freq.set(num, (freq.get(num) || 0) + 1);
}

const uniqueNums = Array.from(freq.keys()).sort((a, b) =&gt; a - b);

for (let i = 0; i &lt; uniqueNums.length; i++) {
    for (let j = i; j &lt; uniqueNums.length; j++) {
        const num1 = uniqueNums[i];
        const num2 = uniqueNums[j];
        
        // Check if we can use these numbers
        let availableCount1 = freq.get(num1)!;
        let availableCount2 = freq.get(num2)!;
        
        if (i === j &amp;&amp; availableCount1 &lt; 2) continue;
        
        const twoSum = num1 + num2;
        const needed = target - twoSum;
        
        // Find closest available third number
        for (const num3 of uniqueNums) {
            let availableCount3 = freq.get(num3)!;
            
            // Check availability constraints
            if (num3 === num1) availableCount3--;
            if (num3 === num2) availableCount3--;
            if (availableCount3 &lt;= 0) continue;
            
            const currentSum = twoSum + num3;
            const currentDiff = Math.abs(currentSum - target);
            
            if (currentDiff &lt; minDiff) {
                minDiff = currentDiff;
                closestSum = currentSum;
            }
        }
    }
}

return closestSum; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testThreeSumClosest() {
    console.log(“Testing 3Sum Closest:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="rouge-code"><pre>const testCases = [
    {
        nums: [-1, 2, 1, -4],
        target: 1,
        expected: 2
    },
    {
        nums: [0, 0, 0],
        target: 1,
        expected: 0
    },
    {
        nums: [1, 1, 1, 0],
        target: -100,
        expected: 2
    },
    {
        nums: [1, 2, 3],
        target: 6,
        expected: 6
    },
    {
        nums: [1, 1, -1, -1, 3],
        target: 3,
        expected: 3
    },
    {
        nums: [-1, 0, 1, 1, 55],
        target: 3,
        expected: 2
    },
    {
        nums: [1, 6, 9, 14, 16, 70],
        target: 81,
        expected: 80
    }
];

const solutions = [
    { name: "Two Pointers (Optimal)", fn: threeSumClosest1 },
    { name: "Binary Search Enhancement", fn: threeSumClosest2 },
    { name: "Brute Force", fn: threeSumClosest3 },
    { name: "Two Pointers + Early Termination", fn: threeSumClosest4 },
    { name: "Divide and Conquer", fn: threeSumClosest5 },
    { name: "Hash Map + Complement", fn: threeSumClosest6 }
];

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        const result = solution.fn([...test.nums], test.target);
        const passed = result === test.expected;
        console.log(`  Test ${i + 1}: ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Input: nums=${JSON.stringify(test.nums)}, target=${test.target}`);
            console.log(`    Expected: ${test.expected}`);
            console.log(`    Got: ${result}`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Problem Core</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Find three numbers with sum closest to target</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Unlike 3Sum, we want closest sum, not exact sum</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Always has exactly one solution (guaranteed)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Two Pointers Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Sort array first for two-pointer technique</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Fix first element, use two pointers for remaining</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Track closest sum and minimum difference</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimization Techniques</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Skip duplicate elements to avoid redundant calculations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Early termination when exact target found</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Boundary checks for impossible ranges</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Distance Tracking</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Use Math.abs(currentSum - target) for distance</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Update closest sum when smaller distance found</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Return immediately if distance is 0 (exact match)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(n^2)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>O(n log n) for sorting</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>O(n^2) for nested loops with two pointers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimal for comparison-based approach</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>: O(1)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Only uses constant extra space</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Sorting can be in-place</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>No additional data structures needed</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Minimum array size (3 elements)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>All same elements</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Target much larger/smaller than possible sums</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Exact match exists</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with brute force explanation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimize to two pointers approach</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Discuss duplicate handling</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Add early termination optimizations</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Key Observations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Sorting enables two-pointer technique</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Only need to track one closest sum</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Can terminate early on exact match</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Implementation Details</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Careful with duplicate skipping logic</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Proper initialization of closest sum</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Correct boundary handling in loops</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimization Opportunities</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Early termination based on impossible ranges</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Binary search for third element (though not always better)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Skip redundant combinations</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Not handling duplicates properly</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect distance calculation</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Wrong initialization of closest sum</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Off-by-one errors in pointer movement</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: k-Sum closest problems</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Closest sum with constraints</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Multiple closest sums</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Weighted closest sum</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Find all triplets with sum closest to target</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>k-Sum closest generalization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Closest sum with distinct elements</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Multiple targets simultaneously</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Resource allocation optimization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Portfolio optimization in finance</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Approximation algorithms</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Machine learning feature selection</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Chemical compound analysis</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Pattern Recognition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Two pointers on sorted array</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimization problem (minimize difference)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Greedy approach with local decisions</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Search space reduction techniques</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Alternative Approaches</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Binary search for third element</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Hash map for complement lookup</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Divide and conquer strategies</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Dynamic programming (overkill for this)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Performance Considerations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Input size affects algorithm choice</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Memory constraints may limit approaches</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Early termination can significantly improve average case</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Duplicate handling affects practical performance
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>