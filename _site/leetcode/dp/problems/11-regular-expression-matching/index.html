<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regular Expression Matching | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/dp/">Dp</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/dp/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Regular expression matching</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Regular Expression Matching</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-easy">Easy</span>
                        
                            <span class="category">Dynamic Programming</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Dynamic Programming</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                                    <span class="tag">Greedy</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="regular-expression-matching">Regular Expression Matching</h1>

<p><strong>LeetCode Problem # * 10. Regular Expression Matching</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Regular Expression Matching</li>
    </ol>
  </li>
  <li></li>
  <li>Given an input string s and a pattern p, implement regular expression matching with support for ‘.’ and ‘*’ where:</li>
  <li>
    <ul>
      <li>’.’ Matches any single character.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>‘*’ Matches zero or more of the preceding element.</li>
    </ul>
  </li>
  <li></li>
  <li>The matching should cover the entire input string (not partial).</li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: s = “aa”, p = “a”</li>
  <li>Output: false</li>
  <li>Explanation: “a” does not match the entire string “aa”.</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: s = “aa”, p = “a*”</li>
  <li>Output: true</li>
  <li>Explanation: ‘*’ means zero or more of the preceding element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.</li>
  <li></li>
  <li>Example 3:</li>
  <li>Input: s = “ab”, p = “.*”</li>
  <li>Output: true</li>
  <li>Explanation: “.<em>” means “zero or more (</em>) of any character (.)”.</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>1 &lt;= s.length &lt;= 20</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>1 &lt;= p.length &lt;= 20</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>s contains only lowercase English letters.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>p contains only lowercase English letters, ‘.’, and ‘*’.</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>It is guaranteed that for each appearance of the character ‘*’, there will be a previous valid character to match.
 */</li>
    </ul>
  </li>
</ul>

<p>// Solution 1: Recursive with Memoization
// Time: O(m×n), Space: O(m×n)
export function isMatch1(s: string, p: string): boolean {
    const memo = new Map&lt;string, boolean&gt;();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>function dp(i: number, j: number): boolean {
    // Base case: pattern exhausted
    if (j &gt;= p.length) {
        return i &gt;= s.length;
    }
    
    const key = `${i},${j}`;
    if (memo.has(key)) {
        return memo.get(key)!;
    }
    
    // Check if current characters match
    const firstMatch = i &lt; s.length &amp;&amp; (p[j] === s[i] || p[j] === '.');
    
    let result;
    if (j + 1 &lt; p.length &amp;&amp; p[j + 1] === '*') {
        // Pattern has '*' as next character
        // Two choices: skip pattern (0 matches) or use pattern (1+ matches)
        result = dp(i, j + 2) || (firstMatch &amp;&amp; dp(i + 1, j));
    } else {
        // No '*', must match current character and continue
        result = firstMatch &amp;&amp; dp(i + 1, j + 1);
    }
    
    memo.set(key, result);
    return result;
}

return dp(0, 0); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Bottom-Up Dynamic Programming
// Time: O(m×n), Space: O(m×n)
export function isMatch2(s: string, p: string): boolean {
    const m = s.length;
    const n = p.length;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre>// dp[i][j] = does s[0...i-1] match p[0...j-1]
const dp = Array(m + 1).fill(null).map(() =&gt; Array(n + 1).fill(false));

// Base case: empty string matches empty pattern
dp[m][n] = true;

// Fill from bottom-right to top-left
for (let i = m; i &gt;= 0; i--) {
    for (let j = n - 1; j &gt;= 0; j--) {
        const firstMatch = i &lt; m &amp;&amp; (p[j] === s[i] || p[j] === '.');
        
        if (j + 1 &lt; n &amp;&amp; p[j + 1] === '*') {
            // Pattern has '*' as next character
            dp[i][j] = dp[i][j + 2] || (firstMatch &amp;&amp; dp[i + 1][j]);
        } else {
            // No '*', must match current character
            dp[i][j] = firstMatch &amp;&amp; dp[i + 1][j + 1];
        }
    }
}

return dp[0][0]; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Space-Optimized DP
// Time: O(m×n), Space: O(n)
export function isMatch3(s: string, p: string): boolean {
    const m = s.length;
    const n = p.length;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>let prev = new Array(n + 1).fill(false);
let curr = new Array(n + 1).fill(false);

// Base case
prev[n] = true;

for (let i = m; i &gt;= 0; i--) {
    curr[n] = (i === m);
    
    for (let j = n - 1; j &gt;= 0; j--) {
        const firstMatch = i &lt; m &amp;&amp; (p[j] === s[i] || p[j] === '.');
        
        if (j + 1 &lt; n &amp;&amp; p[j + 1] === '*') {
            curr[j] = curr[j + 2] || (firstMatch &amp;&amp; prev[j]);
        } else {
            curr[j] = firstMatch &amp;&amp; prev[j + 1];
        }
    }
    
    [prev, curr] = [curr, prev];
}

return prev[0]; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Iterative with Stack (Simulate Recursion)
// Time: O(m×n), Space: O(m×n)
export function isMatch4(s: string, p: string): boolean {
    const memo = new Map&lt;string, boolean&gt;();
    const stack: [number, number][] = [[0, 0]];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre>while (stack.length &gt; 0) {
    const [i, j] = stack.pop()!;
    const key = `${i},${j}`;
    
    if (memo.has(key)) continue;
    
    if (j &gt;= p.length) {
        memo.set(key, i &gt;= s.length);
        continue;
    }
    
    const firstMatch = i &lt; s.length &amp;&amp; (p[j] === s[i] || p[j] === '.');
    
    if (j + 1 &lt; p.length &amp;&amp; p[j + 1] === '*') {
        // Need to check both options
        const skipKey = `${i},${j + 2}`;
        const useKey = `${i + 1},${j}`;
        
        if (!memo.has(skipKey)) {
            stack.push([i, j]);
            stack.push([i, j + 2]);
            continue;
        }
        
        if (firstMatch &amp;&amp; !memo.has(useKey)) {
            stack.push([i, j]);
            stack.push([i + 1, j]);
            continue;
        }
        
        const skipMatch = memo.get(skipKey)!;
        const useMatch = firstMatch &amp;&amp; memo.get(useKey)!;
        memo.set(key, skipMatch || useMatch);
    } else {
        const nextKey = `${i + 1},${j + 1}`;
        if (firstMatch &amp;&amp; !memo.has(nextKey)) {
            stack.push([i, j]);
            stack.push([i + 1, j + 1]);
            continue;
        }
        
        memo.set(key, firstMatch &amp;&amp; memo.has(nextKey) &amp;&amp; memo.get(nextKey)!);
    }
}

return memo.get('0,0') || false; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Finite State Automaton
// Time: O(m×n), Space: O(n²)
export function isMatch5(s: string, p: string): boolean {
    // Build NFA (Non-deterministic Finite Automaton)
    class NFAState {
        isEnd: boolean = false;
        transitions: Map&lt;string, NFAState[]&gt; = new Map();
        epsilonTransitions: NFAState[] = [];
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
</pre></td><td class="rouge-code"><pre>function buildNFA(pattern: string): { start: NFAState; end: NFAState } {
    const start = new NFAState();
    let current = start;
    
    for (let i = 0; i &lt; pattern.length; i++) {
        const char = pattern[i];
        
        if (i + 1 &lt; pattern.length &amp;&amp; pattern[i + 1] === '*') {
            // Create star transition
            const starState = new NFAState();
            
            // Zero matches: epsilon transition
            current.epsilonTransitions.push(starState);
            
            // One or more matches: transition back to current
            if (!starState.transitions.has(char)) {
                starState.transitions.set(char, []);
            }
            starState.transitions.get(char)!.push(starState);
            
            current = starState;
            i++; // Skip the '*'
        } else {
            // Regular character transition
            const nextState = new NFAState();
            
            if (!current.transitions.has(char)) {
                current.transitions.set(char, []);
            }
            current.transitions.get(char)!.push(nextState);
            
            current = nextState;
        }
    }
    
    current.isEnd = true;
    return { start, end: current };
}

function getEpsilonClosure(states: Set&lt;NFAState&gt;): Set&lt;NFAState&gt; {
    const closure = new Set(states);
    const stack = Array.from(states);
    
    while (stack.length &gt; 0) {
        const state = stack.pop()!;
        
        for (const epsilonState of state.epsilonTransitions) {
            if (!closure.has(epsilonState)) {
                closure.add(epsilonState);
                stack.push(epsilonState);
            }
        }
    }
    
    return closure;
}

const { start, end } = buildNFA(p);
let currentStates = getEpsilonClosure(new Set([start]));

for (const char of s) {
    const nextStates = new Set&lt;NFAState&gt;();
    
    for (const state of currentStates) {
        // Check direct character transitions
        if (state.transitions.has(char)) {
            for (const nextState of state.transitions.get(char)!) {
                nextStates.add(nextState);
            }
        }
        
        // Check wildcard transitions
        if (state.transitions.has('.')) {
            for (const nextState of state.transitions.get('.')!) {
                nextStates.add(nextState);
            }
        }
    }
    
    currentStates = getEpsilonClosure(nextStates);
}

return currentStates.has(end); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 6: Backtracking with Pruning
// Time: O(2^(m+n)) worst case, Space: O(m+n)
export function isMatch6(s: string, p: string): boolean {
    function backtrack(sIdx: number, pIdx: number): boolean {
        // Pattern exhausted
        if (pIdx &gt;= p.length) {
            return sIdx &gt;= s.length;
        }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre>    // String exhausted but pattern has non-star characters
    if (sIdx &gt;= s.length) {
        // Pattern must only have "x*" patterns remaining
        for (let i = pIdx; i &lt; p.length; i += 2) {
            if (i + 1 &gt;= p.length || p[i + 1] !== '*') {
                return false;
            }
        }
        return true;
    }
    
    const currentPatternChar = p[pIdx];
    const hasStarNext = pIdx + 1 &lt; p.length &amp;&amp; p[pIdx + 1] === '*';
    
    if (hasStarNext) {
        // Try zero matches
        if (backtrack(sIdx, pIdx + 2)) {
            return true;
        }
        
        // Try one or more matches
        let currentSIdx = sIdx;
        while (currentSIdx &lt; s.length &amp;&amp; 
               (currentPatternChar === '.' || s[currentSIdx] === currentPatternChar)) {
            currentSIdx++;
            if (backtrack(currentSIdx, pIdx + 2)) {
                return true;
            }
        }
        
        return false;
    } else {
        // Must match exactly one character
        if (currentPatternChar === '.' || s[sIdx] === currentPatternChar) {
            return backtrack(sIdx + 1, pIdx + 1);
        }
        return false;
    }
}

return backtrack(0, 0); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testIsMatch() {
    console.log(“Testing Regular Expression Matching:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre>const testCases = [
    { s: "aa", p: "a", expected: false },
    { s: "aa", p: "a*", expected: true },
    { s: "ab", p: ".*", expected: true },
    { s: "aab", p: "c*a*b", expected: true },
    { s: "mississippi", p: "mis*is*p*.", expected: false },
    { s: "", p: ".*", expected: true },
    { s: "a", p: "ab*", expected: true },
    { s: "bbbba", p: ".*a*a", expected: true },
    { s: "a", p: ".*..a*", expected: false },
    { s: "ab", p: ".*c", expected: false }
];

const solutions = [
    { name: "Memoization", fn: isMatch1 },
    { name: "Bottom-Up DP", fn: isMatch2 },
    { name: "Space Optimized", fn: isMatch3 },
    { name: "Iterative Stack", fn: isMatch4 },
    { name: "Finite Automaton", fn: isMatch5 },
    { name: "Backtracking", fn: isMatch6 }
];

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        try {
            const result = solution.fn(test.s, test.p);
            const passed = result === test.expected;
            console.log(`  Test ${i + 1}: ${passed ? 'PASS' : 'FAIL'}`);
            if (!passed) {
                console.log(`    Input: s="${test.s}", p="${test.p}"`);
                console.log(`    Expected: ${test.expected}`);
                console.log(`    Got: ${result}`);
            }
        } catch (error) {
            console.log(`  Test ${i + 1}: ERROR - ${error}`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Pattern Analysis</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>’.’ matches any single character</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>‘*’ matches zero or more of preceding element</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Pattern “a*” can match “”, “a”, “aa”, “aaa”, etc.</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Core Decision Points</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>When seeing ‘*’: try 0 matches or 1+ matches</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>For character match: advance both pointers</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>For ‘.’ wildcard: advance both pointers</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Recursive Structure</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>dp(i, j) = can s[i:] match p[j:]</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle ‘*’ separately from regular characters</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Base case: pattern exhausted</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Star Pattern Handling</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Skip entirely: dp(i, j+2)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use once and stay: firstMatch &amp;&amp; dp(i+1, j)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Greedy matching can fail, need to try both</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(m×n)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>With memoization: each subproblem solved once</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Without memoization: exponential worst case</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>DP ensures polynomial time</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Memoization: O(m×n) for cache</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Bottom-up DP: O(m×n) for table</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Space optimized: O(n) with rolling arrays</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with recursive approach</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle ‘*’ cases carefully</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Add memoization for efficiency</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Consider edge cases</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Empty string and/or pattern</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Pattern with only ‘*’ patterns</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>String longer than pattern</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Consecutive ‘*’ in pattern</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Wrong ‘*’ handling logic</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not considering zero matches for ‘*’</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect base case handling</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Off-by-one errors in indices</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimization Techniques</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Bottom-up DP avoids recursion overhead</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Space optimization with rolling arrays</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Early termination in some cases</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Alternative Approaches</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Finite State Automaton (theoretical)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Backtracking with pruning</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Converting to standard regex engine</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Variations</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: Extended regex features</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Pattern matching with costs</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Multiple pattern matching</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Case-insensitive matching</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Add ‘+’ (one or more matches)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Add ‘?’ (zero or one match)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle character classes [a-z]</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Return all matching substrings</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Text editors (find/replace)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Input validation systems</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Log parsing and analysis</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Bioinformatics pattern matching</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Command-line tools (grep, sed)</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Pattern Complexity</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Simple patterns: O(1) per character</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Complex patterns: may require backtracking</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Pathological cases: exponential without DP</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Implementation Tips</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Handle ‘*’ before regular characters</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Use clear variable names for indices</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Test with empty inputs thoroughly</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Consider string lengths for optimization
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/main.js"></script>
</body>
</html>