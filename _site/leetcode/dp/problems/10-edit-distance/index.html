<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edit Distance | Frontend Interview Preparation Guide</title>
    <meta name="description" content="Comprehensive frontend interview materials for Big Tech companies">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Styles -->
    <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
    <!-- Navigation -->
    <header>
        <nav class="container">
            <div class="logo">Frontend Interview Hub</div>
            <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
                <span aria-hidden="true">☰</span>
            </button>
            <ul class="nav-links" role="navigation" aria-label="Main navigation">
                <li><a href="/">Home</a></li>
                <li><a href="#progress">Progress</a></li>
                <li><a href="#knowledge">Knowledge</a></li>
                <li><a href="https://github.com/nee/interview" target="_blank" rel="noopener">GitHub</a></li>
            </ul>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <div class="content-container">
    
        <nav class="breadcrumb">
            <ol>
                <li><a href="/">Home</a></li>
                
                
                
                    
                
                    
                        
                        
                            <li><a href="/leetcode/">Leetcode</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/dp/">Dp</a></li>
                        
                    
                
                    
                        
                        
                            <li><a href="/leetcode/dp/problems/">Problems</a></li>
                        
                    
                
                    
                        
                        
                            <li class="active">Edit distance</li>
                        
                    
                
            </ol>
        </nav>
    
    
    <article class="content">
        
            <header class="content-header">
                <h1 class="content-title">Edit Distance</h1>
                
                
                    <div class="content-meta">
                        <span class="difficulty difficulty-hard">Hard</span>
                        
                            <span class="category">Dynamic Programming</span>
                        
                        
                            <div class="tags">
                                
                                    <span class="tag">Dynamic Programming</span>
                                
                                    <span class="tag">Hash Table</span>
                                
                            </div>
                        
                    </div>
                
            </header>
        
        
        <div class="content-body">
            <h1 id="edit-distance">Edit Distance</h1>

<p><strong>LeetCode Problem # * 72. Edit Distance</strong></p>

<h2 id="problem-description">Problem Description</h2>

<p>LeetCode problem solution with multiple approaches and explanations.</p>

<h2 id="solutions">Solutions</h2>

<p>/**</p>
<ul>
  <li>
    <ol>
      <li>Edit Distance</li>
    </ol>
  </li>
  <li></li>
  <li>Given two strings word1 and word2, return the minimum number of operations required</li>
  <li>to convert word1 to word2.</li>
  <li></li>
  <li>You have the following three operations permitted on a word:</li>
  <li>
    <ul>
      <li>Insert a character</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Delete a character</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Replace a character</li>
    </ul>
  </li>
  <li></li>
  <li>Example 1:</li>
  <li>Input: word1 = “horse”, word2 = “ros”</li>
  <li>Output: 3</li>
  <li>Explanation:</li>
  <li>horse -&gt; rorse (replace ‘h’ with ‘r’)</li>
  <li>rorse -&gt; rose (remove ‘r’)</li>
  <li>rose -&gt; ros (remove ‘e’)</li>
  <li></li>
  <li>Example 2:</li>
  <li>Input: word1 = “intention”, word2 = “execution”</li>
  <li>Output: 5</li>
  <li>Explanation:</li>
  <li>intention -&gt; inention (remove ‘t’)</li>
  <li>inention -&gt; enention (replace ‘i’ with ‘e’)</li>
  <li>enention -&gt; exention (replace ‘n’ with ‘x’)</li>
  <li>exention -&gt; exection (replace ‘n’ with ‘c’)</li>
  <li>exection -&gt; execution (insert ‘u’)</li>
  <li></li>
  <li>Constraints:</li>
  <li>
    <ul>
      <li>0 &lt;= word1.length, word2.length &lt;= 500</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>word1 and word2 consist of lowercase English letters.
 */</li>
    </ul>
  </li>
</ul>

<p>// Solution 1: 2D Dynamic Programming (Classic)
// Time: O(m×n), Space: O(m×n)
export function minDistance1(word1: string, word2: string): number {
    const m = word1.length;
    const n = word2.length;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>// dp[i][j] = min operations to convert word1[0...i-1] to word2[0...j-1]
const dp = Array(m + 1).fill(null).map(() =&gt; Array(n + 1).fill(0));

// Base cases: converting empty string
for (let i = 0; i &lt;= m; i++) {
    dp[i][0] = i; // Delete all characters from word1
}
for (let j = 0; j &lt;= n; j++) {
    dp[0][j] = j; // Insert all characters to match word2
}

// Fill the DP table
for (let i = 1; i &lt;= m; i++) {
    for (let j = 1; j &lt;= n; j++) {
        if (word1[i - 1] === word2[j - 1]) {
            // Characters match, no operation needed
            dp[i][j] = dp[i - 1][j - 1];
        } else {
            // Take minimum of three operations
            dp[i][j] = Math.min(
                dp[i - 1][j] + 1,     // Delete from word1
                dp[i][j - 1] + 1,     // Insert into word1
                dp[i - 1][j - 1] + 1  // Replace in word1
            );
        }
    }
}

return dp[m][n]; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 2: Space Optimized DP (1D Array)
// Time: O(m×n), Space: O(min(m,n))
export function minDistance2(word1: string, word2: string): number {
    // Ensure word1 is the shorter string for space optimization
    if (word1.length &gt; word2.length) {
        [word1, word2] = [word2, word1];
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre>const m = word1.length;
const n = word2.length;

let prev = Array.from({ length: m + 1 }, (_, i) =&gt; i);
let curr = new Array(m + 1);

for (let j = 1; j &lt;= n; j++) {
    curr[0] = j;
    
    for (let i = 1; i &lt;= m; i++) {
        if (word1[i - 1] === word2[j - 1]) {
            curr[i] = prev[i - 1];
        } else {
            curr[i] = Math.min(
                prev[i] + 1,      // Delete
                curr[i - 1] + 1,  // Insert
                prev[i - 1] + 1   // Replace
            );
        }
    }
    
    [prev, curr] = [curr, prev];
}

return prev[m]; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 3: Memoization (Top-Down)
// Time: O(m×n), Space: O(m×n)
export function minDistance3(word1: string, word2: string): number {
    const memo = new Map&lt;string, number&gt;();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>function dp(i: number, j: number): number {
    // Base cases
    if (i === 0) return j; // Insert all remaining characters from word2
    if (j === 0) return i; // Delete all remaining characters from word1
    
    const key = `${i},${j}`;
    if (memo.has(key)) {
        return memo.get(key)!;
    }
    
    let result;
    if (word1[i - 1] === word2[j - 1]) {
        // Characters match
        result = dp(i - 1, j - 1);
    } else {
        // Try all three operations
        result = 1 + Math.min(
            dp(i - 1, j),     // Delete
            dp(i, j - 1),     // Insert
            dp(i - 1, j - 1)  // Replace
        );
    }
    
    memo.set(key, result);
    return result;
}

return dp(word1.length, word2.length); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 4: Optimized with Two Variables
// Time: O(m×n), Space: O(min(m,n))
export function minDistance4(word1: string, word2: string): number {
    const m = word1.length;
    const n = word2.length;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>if (m === 0) return n;
if (n === 0) return m;

// Use the shorter string for the array dimension
if (m &gt; n) {
    return minDistance4(word2, word1);
}

let dp = Array.from({ length: m + 1 }, (_, i) =&gt; i);

for (let j = 1; j &lt;= n; j++) {
    let prev = dp[0];
    dp[0] = j;
    
    for (let i = 1; i &lt;= m; i++) {
        const temp = dp[i];
        
        if (word1[i - 1] === word2[j - 1]) {
            dp[i] = prev;
        } else {
            dp[i] = 1 + Math.min(dp[i], dp[i - 1], prev);
        }
        
        prev = temp;
    }
}

return dp[m]; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 5: Recursive with Path Tracking
// Time: O(m×n), Space: O(m×n)
export function minDistance5(word1: string, word2: string): number {
    const memo = new Map&lt;string, { cost: number; path: string[] }&gt;();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="rouge-code"><pre>function dp(i: number, j: number): { cost: number; path: string[] } {
    if (i === 0) {
        return {
            cost: j,
            path: Array.from({ length: j }, (_, k) =&gt; `Insert '${word2[k]}'`)
        };
    }
    
    if (j === 0) {
        return {
            cost: i,
            path: Array.from({ length: i }, (_, k) =&gt; `Delete '${word1[i - 1 - k]}'`)
        };
    }
    
    const key = `${i},${j}`;
    if (memo.has(key)) {
        return memo.get(key)!;
    }
    
    let result;
    if (word1[i - 1] === word2[j - 1]) {
        result = dp(i - 1, j - 1);
    } else {
        const deleteOp = dp(i - 1, j);
        const insertOp = dp(i, j - 1);
        const replaceOp = dp(i - 1, j - 1);
        
        const operations = [
            {
                cost: deleteOp.cost + 1,
                path: [...deleteOp.path, `Delete '${word1[i - 1]}'`]
            },
            {
                cost: insertOp.cost + 1,
                path: [...insertOp.path, `Insert '${word2[j - 1]}'`]
            },
            {
                cost: replaceOp.cost + 1,
                path: [...replaceOp.path, `Replace '${word1[i - 1]}' with '${word2[j - 1]}'`]
            }
        ];
        
        result = operations.reduce((min, op) =&gt; op.cost &lt; min.cost ? op : min);
    }
    
    memo.set(key, result);
    return result;
}

const result = dp(word1.length, word2.length);
// Uncomment to see the operations:
// console.log("Operations:", result.path);
return result.cost; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Solution 6: Iterative with Diagonal Optimization
// Time: O(m×n), Space: O(min(m,n))
export function minDistance6(word1: string, word2: string): number {
    const m = word1.length;
    const n = word2.length;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre>if (m === 0) return n;
if (n === 0) return m;

// Process diagonally to optimize cache usage
const maxLen = Math.max(m, n);
const minLen = Math.min(m, n);

// Use rolling array
let prev = new Array(minLen + 1);
let curr = new Array(minLen + 1);

// Initialize
for (let i = 0; i &lt;= minLen; i++) {
    prev[i] = i;
}

const longer = m &gt; n ? word1 : word2;
const shorter = m &gt; n ? word2 : word1;

for (let i = 1; i &lt;= maxLen; i++) {
    curr[0] = i;
    
    for (let j = 1; j &lt;= Math.min(i, minLen); j++) {
        const longIdx = m &gt; n ? i - 1 : j - 1;
        const shortIdx = m &gt; n ? j - 1 : i - 1;
        
        if (longer[longIdx] === shorter[shortIdx]) {
            curr[j] = prev[j - 1];
        } else {
            curr[j] = 1 + Math.min(
                prev[j],      // Delete
                curr[j - 1],  // Insert
                prev[j - 1]   // Replace
            );
        }
    }
    
    [prev, curr] = [curr, prev];
}

return prev[minLen]; }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>// Test cases
export function testMinDistance() {
    console.log(“Testing Edit Distance:”);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="rouge-code"><pre>const testCases = [
    {
        word1: "horse",
        word2: "ros",
        expected: 3
    },
    {
        word1: "intention",
        word2: "execution",
        expected: 5
    },
    {
        word1: "",
        word2: "abc",
        expected: 3
    },
    {
        word1: "abc",
        word2: "",
        expected: 3
    },
    {
        word1: "abc",
        word2: "abc",
        expected: 0
    },
    {
        word1: "a",
        word2: "b",
        expected: 1
    },
    {
        word1: "kitten",
        word2: "sitting",
        expected: 3
    }
];

const solutions = [
    { name: "2D DP", fn: minDistance1 },
    { name: "Space Optimized", fn: minDistance2 },
    { name: "Memoization", fn: minDistance3 },
    { name: "Two Variables", fn: minDistance4 },
    { name: "Path Tracking", fn: minDistance5 },
    { name: "Diagonal Optimization", fn: minDistance6 }
];

solutions.forEach(solution =&gt; {
    console.log(`\n${solution.name}:`);
    testCases.forEach((test, i) =&gt; {
        const result = solution.fn(test.word1, test.word2);
        const passed = result === test.expected;
        console.log(`  Test ${i + 1}: ${passed ? 'PASS' : 'FAIL'}`);
        if (!passed) {
            console.log(`    Input: "${test.word1}" -&gt; "${test.word2}"`);
            console.log(`    Expected: ${test.expected}`);
            console.log(`    Got: ${result}`);
        }
    });
}); }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>/**</p>
<ul>
  <li>Key Insights:</li>
  <li></li>
  <li>
    <ol>
      <li><strong>Problem Definition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Levenshtein Distance: minimum edit operations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Three operations: insert, delete, replace</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Transform word1 to word2 with minimum cost</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>DP State Definition</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>dp[i][j] = min operations to convert word1[0…i-1] to word2[0…j-1]</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Base cases: dp[i][0] = i, dp[0][j] = j</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Recurrence Relation</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>If chars match: dp[i][j] = dp[i-1][j-1]</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Else: dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Three choices correspond to delete, insert, replace</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Optimization</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>2D → 1D: Only need previous row</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Two variables: Track diagonal value separately</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Choose shorter string for space dimension</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Time Complexity</strong>: O(m×n)</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Must fill m×n table entries</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Each entry computed in O(1)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Cannot be improved asymptotically</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Space Complexity</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Naive: O(m×n) for 2D table</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimized: O(min(m,n)) using rolling arrays</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Extreme: O(1) with careful variable management</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Operation Interpretation</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>dp[i-1][j] + 1: Delete char from word1</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>dp[i][j-1] + 1: Insert char into word1</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>dp[i-1][j-1] + 1: Replace char in word1</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Interview Strategy</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Start with recursive solution</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Identify overlapping subproblems</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Apply memoization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Convert to bottom-up DP</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimize space if needed</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Edge Cases</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Empty strings (one or both)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Identical strings</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Single character strings</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>No common characters</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Path Reconstruction</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Track which operation led to optimal solution</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Backtrack from dp[m][n] to dp[0][0]</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Build sequence of operations</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Variants and Extensions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Weighted operations (different costs)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Allow transposition (Damerau-Levenshtein)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Multiple string alignment</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Approximate string matching</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Big Tech Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Google: Spell checkers, search suggestions</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Meta: Content similarity, deduplication</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Amazon: Product matching, recommendations</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Microsoft: Auto-correction, text comparison</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Follow-up Questions</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Return the actual edit sequence</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle different operation costs</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Optimize for very long strings</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Handle Unicode/multibyte characters</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Real-world Applications</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>DNA sequence alignment</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Plagiarism detection</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Version control (diff algorithms)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Natural language processing</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Database record matching</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Optimization Techniques</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Early termination with distance bounds</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Diagonal processing for cache efficiency</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Bit-parallel algorithms for small alphabets</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Suffix tree/array optimizations</li>
    </ul>
  </li>
  <li></li>
  <li>
    <ol>
      <li><strong>Common Mistakes</strong>:</li>
    </ol>
  </li>
  <li>
    <ul>
      <li>Wrong base case initialization</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Incorrect operation cost accounting</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Off-by-one errors in indexing</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>Not handling empty string cases
 */</li>
    </ul>
  </li>
</ul>


        </div>
    </article>
</div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Study Resources</h3>
                    <p>Comprehensive collection of frontend interview questions, coding challenges, and system design problems.</p>
                </div>
                <div class="footer-section">
                    <h3>Progress Tracking</h3>
                    <p>Monitor your learning journey with detailed progress indicators and completion status.</p>
                </div>
                <div class="footer-section">
                    <h3>Big Tech Ready</h3>
                    <p>Curated content specifically designed for interviews at Google, Meta, Amazon, Apple, and Netflix.</p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 Frontend Interview Hub. Built for aspiring frontend engineers.</p>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="/assets/js/app.js"></script>
</body>
</html>