"use strict";(self.webpackChunkfrontend_interview_guide=self.webpackChunkfrontend_interview_guide||[]).push([[3446],{3570:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"frontend/coding-problems/performance-optimization","title":"Frontend Performance Optimization Problems","description":"Problem 1: Virtual Scrolling Implementation","source":"@site/docs/frontend/coding-problems/performance-optimization.md","sourceDirName":"frontend/coding-problems","slug":"/frontend/coding-problems/performance-optimization","permalink":"/interview/docs/frontend/coding-problems/performance-optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/Nhi4912/interview/tree/main/docs/frontend/coding-problems/performance-optimization.md","tags":[],"version":"current","frontMatter":{},"sidebar":"frontendSidebar","previous":{"title":"Problem: Lazy Loading Images and Components","permalink":"/interview/docs/frontend/performance/lazy-loading"},"next":{"title":"Networking Interview Preparation","permalink":"/interview/docs/frontend/networking/"}}');var s=t(4848),r=t(8453);const o={},l="Frontend Performance Optimization Problems",a={},c=[{value:"Problem 1: Virtual Scrolling Implementation",id:"problem-1-virtual-scrolling-implementation",level:2},{value:"Problem Description",id:"problem-description",level:3},{value:"Requirements",id:"requirements",level:3},{value:"Solution",id:"solution",level:3},{value:"Problem 2: Image Lazy Loading",id:"problem-2-image-lazy-loading",level:2},{value:"Problem Description",id:"problem-description-1",level:3},{value:"Requirements",id:"requirements-1",level:3},{value:"Solution",id:"solution-1",level:3},{value:"Problem 3: Debounced Search with Cache",id:"problem-3-debounced-search-with-cache",level:2},{value:"Problem Description",id:"problem-description-2",level:3},{value:"Requirements",id:"requirements-2",level:3},{value:"Solution",id:"solution-2",level:3},{value:"Key Performance Features",id:"key-performance-features",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"frontend-performance-optimization-problems",children:"Frontend Performance Optimization Problems"})}),"\n",(0,s.jsx)(e.h2,{id:"problem-1-virtual-scrolling-implementation",children:"Problem 1: Virtual Scrolling Implementation"}),"\n",(0,s.jsx)(e.h3,{id:"problem-description",children:"Problem Description"}),"\n",(0,s.jsx)(e.p,{children:"Implement virtual scrolling for a large list of items to improve performance."}),"\n",(0,s.jsx)(e.h3,{id:"requirements",children:"Requirements"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Handle thousands of items efficiently"}),"\n",(0,s.jsx)(e.li,{children:"Maintain smooth scrolling"}),"\n",(0,s.jsx)(e.li,{children:"Support dynamic item heights"}),"\n",(0,s.jsx)(e.li,{children:"Implement proper recycling"}),"\n",(0,s.jsx)(e.li,{children:"Handle scroll events optimally"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"solution",children:"Solution"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'class VirtualScroller {\n  constructor(container, options = {}) {\n    this.container = container;\n    this.itemHeight = options.itemHeight || 50;\n    this.overscan = options.overscan || 5;\n    this.items = [];\n    this.visibleItems = new Map();\n    this.scrollTop = 0;\n    this.containerHeight = 0;\n    this.totalHeight = 0;\n\n    this.init();\n  }\n\n  init() {\n    this.setupContainer();\n    this.attachEventListeners();\n    this.updateDimensions();\n  }\n\n  setupContainer() {\n    this.container.innerHTML = `\n      <div class="virtual-scroller">\n        <div class="virtual-scroller-content"></div>\n        <div class="virtual-scroller-spacer"></div>\n      </div>\n    `;\n\n    this.content = this.container.querySelector(".virtual-scroller-content");\n    this.spacer = this.container.querySelector(".virtual-scroller-spacer");\n  }\n\n  attachEventListeners() {\n    let ticking = false;\n\n    this.container.addEventListener("scroll", () => {\n      if (!ticking) {\n        requestAnimationFrame(() => {\n          this.handleScroll();\n          ticking = false;\n        });\n        ticking = true;\n      }\n    });\n\n    window.addEventListener("resize", () => {\n      this.updateDimensions();\n      this.render();\n    });\n  }\n\n  handleScroll() {\n    const newScrollTop = this.container.scrollTop;\n    if (Math.abs(newScrollTop - this.scrollTop) > this.itemHeight / 2) {\n      this.scrollTop = newScrollTop;\n      this.render();\n    }\n  }\n\n  updateDimensions() {\n    this.containerHeight = this.container.clientHeight;\n    this.totalHeight = this.items.length * this.itemHeight;\n    this.spacer.style.height = `${this.totalHeight}px`;\n  }\n\n  setItems(items) {\n    this.items = items;\n    this.updateDimensions();\n    this.render();\n  }\n\n  render() {\n    const startIndex = Math.floor(this.scrollTop / this.itemHeight);\n    const endIndex = Math.min(\n      startIndex +\n        Math.ceil(this.containerHeight / this.itemHeight) +\n        this.overscan,\n      this.items.length\n    );\n\n    const startIndexWithOverscan = Math.max(0, startIndex - this.overscan);\n    const endIndexWithOverscan = Math.min(\n      this.items.length,\n      endIndex + this.overscan\n    );\n\n    // Remove items that are no longer visible\n    for (const [index, element] of this.visibleItems) {\n      if (index < startIndexWithOverscan || index >= endIndexWithOverscan) {\n        element.remove();\n        this.visibleItems.delete(index);\n      }\n    }\n\n    // Add new visible items\n    for (let i = startIndexWithOverscan; i < endIndexWithOverscan; i++) {\n      if (!this.visibleItems.has(i)) {\n        const element = this.renderItem(this.items[i], i);\n        element.style.position = "absolute";\n        element.style.top = `${i * this.itemHeight}px`;\n        element.style.width = "100%";\n        element.style.height = `${this.itemHeight}px`;\n\n        this.content.appendChild(element);\n        this.visibleItems.set(i, element);\n      }\n    }\n  }\n\n  renderItem(item, index) {\n    const element = document.createElement("div");\n    element.className = "virtual-item";\n    element.innerHTML = `\n      <div class="item-content">\n        <span class="item-index">${index + 1}</span>\n        <span class="item-text">${item.text}</span>\n      </div>\n    `;\n    return element;\n  }\n\n  scrollToIndex(index) {\n    const scrollTop = index * this.itemHeight;\n    this.container.scrollTop = scrollTop;\n  }\n\n  getVisibleRange() {\n    const startIndex = Math.floor(this.scrollTop / this.itemHeight);\n    const endIndex = Math.min(\n      startIndex + Math.ceil(this.containerHeight / this.itemHeight),\n      this.items.length\n    );\n    return { startIndex, endIndex };\n  }\n}\n\n// Usage\nconst container = document.getElementById("virtual-scroll-container");\nconst virtualScroller = new VirtualScroller(container, {\n  itemHeight: 60,\n  overscan: 10,\n});\n\n// Generate large dataset\nconst items = Array.from({ length: 10000 }, (_, i) => ({\n  id: i,\n  text: `Item ${\n    i + 1\n  } - Lorem ipsum dolor sit amet, consectetur adipiscing elit.`,\n}));\n\nvirtualScroller.setItems(items);\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-css",children:".virtual-scroller {\n  position: relative;\n  height: 100%;\n  overflow: hidden;\n}\n\n.virtual-scroller-content {\n  position: relative;\n  width: 100%;\n}\n\n.virtual-scroller-spacer {\n  width: 100%;\n}\n\n.virtual-item {\n  border-bottom: 1px solid #eee;\n  background: white;\n  transition: background-color 0.2s;\n}\n\n.virtual-item:hover {\n  background-color: #f8f9fa;\n}\n\n.item-content {\n  padding: 16px;\n  display: flex;\n  align-items: center;\n  gap: 12px;\n}\n\n.item-index {\n  font-weight: 600;\n  color: #007bff;\n  min-width: 40px;\n}\n\n.item-text {\n  color: #333;\n  line-height: 1.4;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"problem-2-image-lazy-loading",children:"Problem 2: Image Lazy Loading"}),"\n",(0,s.jsx)(e.h3,{id:"problem-description-1",children:"Problem Description"}),"\n",(0,s.jsx)(e.p,{children:"Implement efficient lazy loading for images with intersection observer."}),"\n",(0,s.jsx)(e.h3,{id:"requirements-1",children:"Requirements"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Load images only when they're about to enter viewport"}),"\n",(0,s.jsx)(e.li,{children:"Support multiple image formats"}),"\n",(0,s.jsx)(e.li,{children:"Handle loading states"}),"\n",(0,s.jsx)(e.li,{children:"Implement error handling"}),"\n",(0,s.jsx)(e.li,{children:"Support responsive images"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"solution-1",children:"Solution"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'class LazyImageLoader {\n  constructor(options = {}) {\n    this.options = {\n      rootMargin: "50px",\n      threshold: 0.1,\n      placeholder:\n        "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2Y4ZjlmYSIvPjwvc3ZnPg==",\n      ...options,\n    };\n\n    this.observer = null;\n    this.init();\n  }\n\n  init() {\n    this.observer = new IntersectionObserver(\n      this.handleIntersection.bind(this),\n      this.options\n    );\n  }\n\n  handleIntersection(entries) {\n    entries.forEach((entry) => {\n      if (entry.isIntersecting) {\n        this.loadImage(entry.target);\n        this.observer.unobserve(entry.target);\n      }\n    });\n  }\n\n  loadImage(imgElement) {\n    const src = imgElement.dataset.src;\n    const srcset = imgElement.dataset.srcset;\n\n    if (!src) return;\n\n    // Create a new image to preload\n    const tempImage = new Image();\n\n    tempImage.onload = () => {\n      imgElement.src = src;\n      if (srcset) {\n        imgElement.srcset = srcset;\n      }\n      imgElement.classList.remove("lazy");\n      imgElement.classList.add("loaded");\n    };\n\n    tempImage.onerror = () => {\n      imgElement.classList.add("error");\n      imgElement.src = this.options.errorImage || this.options.placeholder;\n    };\n\n    tempImage.src = src;\n  }\n\n  observe(element) {\n    if (element.tagName === "IMG") {\n      this.observer.observe(element);\n    } else {\n      const images = element.querySelectorAll("img[data-src]");\n      images.forEach((img) => this.observer.observe(img));\n    }\n  }\n\n  unobserve(element) {\n    this.observer.unobserve(element);\n  }\n\n  disconnect() {\n    this.observer.disconnect();\n  }\n}\n\n// Usage\nconst lazyLoader = new LazyImageLoader({\n  rootMargin: "100px",\n  threshold: 0.1,\n});\n\n// Observe all lazy images\ndocument.addEventListener("DOMContentLoaded", () => {\n  lazyLoader.observe(document.body);\n});\n\n// Example HTML\nconst imageGallery = `\n  <div class="image-gallery">\n    <img \n      class="lazy" \n      data-src="https://picsum.photos/400/300?random=1" \n      src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2Y4ZjlmYSIvPjwvc3ZnPg==" \n      alt="Image 1"\n    />\n    <img \n      class="lazy" \n      data-src="https://picsum.photos/400/300?random=2" \n      src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2Y4ZjlmYSIvPjwvc3ZnPg==" \n      alt="Image 2"\n    />\n    <img \n      class="lazy" \n      data-src="https://picsum.photos/400/300?random=3" \n      src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgZmlsbD0iI2Y4ZjlmYSIvPjwvc3ZnPg==" \n      alt="Image 3"\n    />\n  </div>\n`;\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-css",children:".image-gallery {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n  gap: 20px;\n  padding: 20px;\n}\n\n.lazy {\n  width: 100%;\n  height: 300px;\n  object-fit: cover;\n  border-radius: 8px;\n  transition: opacity 0.3s ease;\n  opacity: 0.7;\n}\n\n.lazy.loaded {\n  opacity: 1;\n}\n\n.lazy.error {\n  opacity: 0.5;\n  filter: grayscale(1);\n}\n\n/* Loading animation */\n.lazy:not(.loaded):not(.error) {\n  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);\n  background-size: 200% 100%;\n  animation: loading 1.5s infinite;\n}\n\n@keyframes loading {\n  0% {\n    background-position: 200% 0;\n  }\n  100% {\n    background-position: -200% 0;\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"problem-3-debounced-search-with-cache",children:"Problem 3: Debounced Search with Cache"}),"\n",(0,s.jsx)(e.h3,{id:"problem-description-2",children:"Problem Description"}),"\n",(0,s.jsx)(e.p,{children:"Implement a search functionality with debouncing and caching for better performance."}),"\n",(0,s.jsx)(e.h3,{id:"requirements-2",children:"Requirements"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Debounce search input"}),"\n",(0,s.jsx)(e.li,{children:"Cache search results"}),"\n",(0,s.jsx)(e.li,{children:"Handle loading states"}),"\n",(0,s.jsx)(e.li,{children:"Implement cache invalidation"}),"\n",(0,s.jsx)(e.li,{children:"Support pagination"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"solution-2",children:"Solution"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:'class SearchManager {\n  constructor(options = {}) {\n    this.options = {\n      debounceDelay: 300,\n      cacheSize: 100,\n      maxResults: 50,\n      ...options,\n    };\n\n    this.cache = new Map();\n    this.pendingRequests = new Map();\n    this.debounceTimers = new Map();\n\n    this.init();\n  }\n\n  init() {\n    this.setupEventListeners();\n  }\n\n  setupEventListeners() {\n    const searchInput = document.getElementById("search-input");\n    if (searchInput) {\n      searchInput.addEventListener("input", (e) => {\n        this.debouncedSearch(e.target.value);\n      });\n    }\n  }\n\n  debouncedSearch(query) {\n    const key = `search_${query}`;\n\n    // Clear existing timer\n    if (this.debounceTimers.has(key)) {\n      clearTimeout(this.debounceTimers.get(key));\n    }\n\n    // Set new timer\n    const timer = setTimeout(() => {\n      this.performSearch(query);\n    }, this.options.debounceDelay);\n\n    this.debounceTimers.set(key, timer);\n  }\n\n  async performSearch(query) {\n    if (!query.trim()) {\n      this.displayResults([]);\n      return;\n    }\n\n    // Check cache first\n    const cached = this.cache.get(query);\n    if (cached) {\n      this.displayResults(cached);\n      return;\n    }\n\n    // Check if request is already pending\n    if (this.pendingRequests.has(query)) {\n      return this.pendingRequests.get(query);\n    }\n\n    // Show loading state\n    this.showLoading(true);\n\n    // Create new request\n    const request = this.fetchSearchResults(query);\n    this.pendingRequests.set(query, request);\n\n    try {\n      const results = await request;\n\n      // Cache results\n      this.cacheResults(query, results);\n\n      // Display results\n      this.displayResults(results);\n    } catch (error) {\n      console.error("Search error:", error);\n      this.showError("Search failed. Please try again.");\n    } finally {\n      this.pendingRequests.delete(query);\n      this.showLoading(false);\n    }\n  }\n\n  async fetchSearchResults(query) {\n    // Simulate API call\n    await new Promise((resolve) => setTimeout(resolve, 500));\n\n    const results = Array.from({ length: 20 }, (_, i) => ({\n      id: i,\n      title: `Result ${i + 1} for "${query}"`,\n      description: `This is a search result for "${query}". It contains relevant information.`,\n      score: Math.random() * 100,\n    })).sort((a, b) => b.score - a.score);\n\n    return results.slice(0, this.options.maxResults);\n  }\n\n  cacheResults(query, results) {\n    // Implement LRU cache\n    if (this.cache.size >= this.options.cacheSize) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n\n    this.cache.set(query, results);\n  }\n\n  displayResults(results) {\n    const resultsContainer = document.getElementById("search-results");\n    if (!resultsContainer) return;\n\n    if (results.length === 0) {\n      resultsContainer.innerHTML =\n        \'<div class="no-results">No results found</div>\';\n      return;\n    }\n\n    const resultsHTML = results\n      .map(\n        (result) => `\n      <div class="search-result" data-id="${result.id}">\n        <h3 class="result-title">${result.title}</h3>\n        <p class="result-description">${result.description}</p>\n        <span class="result-score">${result.score.toFixed(1)}%</span>\n      </div>\n    `\n      )\n      .join("");\n\n    resultsContainer.innerHTML = resultsHTML;\n  }\n\n  showLoading(show) {\n    const loadingElement = document.getElementById("loading-indicator");\n    if (loadingElement) {\n      loadingElement.style.display = show ? "block" : "none";\n    }\n  }\n\n  showError(message) {\n    const errorElement = document.getElementById("error-message");\n    if (errorElement) {\n      errorElement.textContent = message;\n      errorElement.style.display = "block";\n\n      setTimeout(() => {\n        errorElement.style.display = "none";\n      }, 3000);\n    }\n  }\n\n  clearCache() {\n    this.cache.clear();\n  }\n\n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      keys: Array.from(this.cache.keys()),\n    };\n  }\n}\n\n// Usage\nconst searchManager = new SearchManager({\n  debounceDelay: 400,\n  cacheSize: 50,\n  maxResults: 30,\n});\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-css",children:".search-container {\n  max-width: 800px;\n  margin: 0 auto;\n  padding: 20px;\n}\n\n.search-input {\n  width: 100%;\n  padding: 12px 16px;\n  border: 2px solid #ddd;\n  border-radius: 8px;\n  font-size: 16px;\n  transition: border-color 0.3s;\n}\n\n.search-input:focus {\n  outline: none;\n  border-color: #007bff;\n}\n\n.search-results {\n  margin-top: 20px;\n}\n\n.search-result {\n  padding: 16px;\n  border: 1px solid #eee;\n  border-radius: 8px;\n  margin-bottom: 12px;\n  background: white;\n  transition: transform 0.2s, box-shadow 0.2s;\n}\n\n.search-result:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n}\n\n.result-title {\n  margin: 0 0 8px 0;\n  color: #2c3e50;\n  font-size: 18px;\n}\n\n.result-description {\n  margin: 0 0 8px 0;\n  color: #666;\n  line-height: 1.5;\n}\n\n.result-score {\n  color: #007bff;\n  font-weight: 600;\n  font-size: 14px;\n}\n\n.loading-indicator {\n  display: none;\n  text-align: center;\n  padding: 20px;\n  color: #666;\n}\n\n.error-message {\n  display: none;\n  background: #f8d7da;\n  color: #721c24;\n  padding: 12px;\n  border-radius: 4px;\n  margin: 10px 0;\n  text-align: center;\n}\n\n.no-results {\n  text-align: center;\n  padding: 40px;\n  color: #666;\n  font-style: italic;\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"key-performance-features",children:"Key Performance Features"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Virtual Scrolling"}),": Efficient rendering of large lists"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Lazy Loading"}),": Images load only when needed"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Debouncing"}),": Reduces unnecessary API calls"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Caching"}),": Stores results to avoid repeated requests"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Request Deduplication"}),": Prevents duplicate requests"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Memory Management"}),": LRU cache with size limits"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Loading States"}),": Clear user feedback"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Error Handling"}),": Graceful error recovery"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function o(n){const e=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),i.createElement(r.Provider,{value:e},n.children)}}}]);