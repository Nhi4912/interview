"use strict";(self.webpackChunkfrontend_interview_guide=self.webpackChunkfrontend_interview_guide||[]).push([[8312],{210:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"frontend/security/README","title":"Security Interview Preparation","description":"Core Concepts","source":"@site/docs/frontend/security/README.md","sourceDirName":"frontend/security","slug":"/frontend/security/","permalink":"/interview/docs/frontend/security/","draft":false,"unlisted":false,"editUrl":"https://github.com/Nhi4912/interview/tree/main/docs/frontend/security/README.md","tags":[],"version":"current","frontMatter":{},"sidebar":"frontendSidebar","previous":{"title":"Problem: Component Unit Testing","permalink":"/interview/docs/frontend/testing/component-testing"},"next":{"title":"Problem: Preventing XSS and CSRF","permalink":"/interview/docs/frontend/security/xss-csrf"}}');var i=t(4848),r=t(8453);const o={},a="Security Interview Preparation",c={},l=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Frontend Security Fundamentals",id:"frontend-security-fundamentals",level:3},{value:"Security Headers",id:"security-headers",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Modern Security Features",id:"modern-security-features",level:3},{value:"Security Testing",id:"security-testing",level:3},{value:"Common Interview Questions &amp; Answers",id:"common-interview-questions--answers",level:2},{value:"Security Questions",id:"security-questions",level:3},{value:"Advanced Interview Questions",id:"advanced-interview-questions",level:2},{value:"Practical Problems &amp; Solutions",id:"practical-problems--solutions",level:2},{value:"Problem 1: Implement Secure Session Management",id:"problem-1-implement-secure-session-management",level:3},{value:"Problem 2: Implement Secure Data Encryption",id:"problem-2-implement-secure-data-encryption",level:3},{value:"Security Best Practices",id:"security-best-practices",level:2},{value:"Input Validation",id:"input-validation",level:3},{value:"Security Headers Implementation",id:"security-headers-implementation",level:3},{value:"Resources",id:"resources",level:2},{value:"Documentation",id:"documentation",level:3},{value:"Tools",id:"tools",level:3},{value:"Practice Platforms",id:"practice-platforms",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"security-interview-preparation",children:"Security Interview Preparation"})}),"\n",(0,i.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(n.h3,{id:"frontend-security-fundamentals",children:"Frontend Security Fundamentals"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cross-Site Scripting (XSS)"}),": Malicious scripts injected into web pages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cross-Site Request Forgery (CSRF)"}),": Unauthorized actions performed on behalf of users"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Content Security Policy (CSP)"}),": Security headers to prevent code injection"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Same-Origin Policy"}),": Browser security mechanism for isolating resources"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Authentication & Authorization"}),": User identity verification and access control"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"security-headers",children:"Security Headers"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Content-Security-Policy"}),": Controls resource loading"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"X-Frame-Options"}),": Prevents clickjacking attacks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"X-Content-Type-Options"}),": Prevents MIME type sniffing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Strict-Transport-Security"}),": Enforces HTTPS connections"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Referrer-Policy"}),": Controls referrer information"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,i.jsx)(n.h3,{id:"modern-security-features",children:"Modern Security Features"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Subresource Integrity (SRI)"}),": Verifies external resource integrity"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Trusted Types"}),": Prevents DOM-based XSS"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feature Policy"}),": Controls browser feature usage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Web Crypto API"}),": Client-side cryptography"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Service Worker Security"}),": Secure offline functionality"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"security-testing",children:"Security Testing"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Static Analysis"}),": Code scanning for vulnerabilities"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dynamic Analysis"}),": Runtime security testing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Penetration Testing"}),": Manual security assessment"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security Headers Testing"}),": CSP and header validation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dependency Scanning"}),": Third-party vulnerability detection"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"common-interview-questions--answers",children:"Common Interview Questions & Answers"}),"\n",(0,i.jsx)(n.h3,{id:"security-questions",children:"Security Questions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Q: What is XSS and how do you prevent it?"}),"\nA: XSS (Cross-Site Scripting) allows attackers to inject malicious scripts into web pages."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Types of XSS:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stored XSS"}),": Malicious script stored in database"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Reflected XSS"}),": Malicious script reflected in response"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"DOM-based XSS"}),": Malicious script manipulating DOM"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Prevention Techniques:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"// 1. Input validation and sanitization\nfunction sanitizeInput(input) {\n  return input\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#x27;');\n}\n\n// 2. Use safe DOM methods\n// \u274c Dangerous\nelement.innerHTML = userInput;\n\n// \u2705 Safe\nelement.textContent = userInput;\n\n// 3. Use React's built-in XSS protection\nfunction SafeComponent({ userInput }) {\n  return <div>{userInput}</div>; // React automatically escapes\n}\n\n// 4. Content Security Policy\n// Add to HTML head\n<meta http-equiv=\"Content-Security-Policy\"\n      content=\"default-src 'self'; script-src 'self' 'unsafe-inline'\">\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Q: What is CSRF and how do you prevent it?"}),"\nA: CSRF (Cross-Site Request Forgery) tricks users into performing unwanted actions."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Prevention Techniques:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// 1. CSRF Tokens\nclass CSRFProtection {\n  constructor() {\n    this.token = this.generateToken();\n  }\n\n  generateToken() {\n    return crypto\n      .getRandomValues(new Uint8Array(32))\n      .reduce((acc, val) => acc + val.toString(16).padStart(2, "0"), "");\n  }\n\n  addTokenToRequest(request) {\n    request.headers["X-CSRF-Token"] = this.token;\n    return request;\n  }\n\n  validateToken(token) {\n    return token === this.token;\n  }\n}\n\n// 2. SameSite Cookies\ndocument.cookie = "sessionId=abc123; SameSite=Strict; Secure; HttpOnly";\n\n// 3. Double Submit Cookie Pattern\nclass DoubleSubmitCookie {\n  constructor() {\n    this.token = this.generateToken();\n    this.setCookie();\n  }\n\n  setCookie() {\n    document.cookie = `csrf-token=${this.token}; SameSite=Strict; Secure`;\n  }\n\n  addTokenToForm(form) {\n    const tokenInput = document.createElement("input");\n    tokenInput.type = "hidden";\n    tokenInput.name = "csrf-token";\n    tokenInput.value = this.token;\n    form.appendChild(tokenInput);\n  }\n}\n\n// 4. Custom Headers\nfetch("/api/update", {\n  method: "POST",\n  headers: {\n    "Content-Type": "application/json",\n    "X-CSRF-Token": csrfToken,\n    "X-Requested-With": "XMLHttpRequest",\n  },\n  body: JSON.stringify(data),\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Q: How do you implement Content Security Policy?"}),"\nA: CSP is a security header that controls which resources can be loaded."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// 1. Basic CSP Implementation\nconst cspHeader = {\n  "default-src": ["\'self\'"],\n  "script-src": ["\'self\'", "\'unsafe-inline\'", "https://cdn.example.com"],\n  "style-src": ["\'self\'", "\'unsafe-inline\'", "https://fonts.googleapis.com"],\n  "img-src": ["\'self\'", "data:", "https:"],\n  "font-src": ["\'self\'", "https://fonts.gstatic.com"],\n  "connect-src": ["\'self\'", "https://api.example.com"],\n  "frame-src": ["\'none\'"],\n  "object-src": ["\'none\'"],\n  "base-uri": ["\'self\'"],\n  "form-action": ["\'self\'"],\n};\n\n// 2. Dynamic CSP for different pages\nclass CSPManager {\n  constructor() {\n    this.basePolicy = {\n      "default-src": ["\'self\'"],\n      "script-src": ["\'self\'"],\n      "style-src": ["\'self\'"],\n      "img-src": ["\'self\'", "data:"],\n      "connect-src": ["\'self\'"],\n    };\n  }\n\n  addPolicy(page, additionalRules) {\n    const policy = { ...this.basePolicy };\n\n    Object.keys(additionalRules).forEach((key) => {\n      if (policy[key]) {\n        policy[key] = [...policy[key], ...additionalRules[key]];\n      } else {\n        policy[key] = additionalRules[key];\n      }\n    });\n\n    return this.stringifyPolicy(policy);\n  }\n\n  stringifyPolicy(policy) {\n    return Object.entries(policy)\n      .map(([key, values]) => `${key} ${values.join(" ")}`)\n      .join("; ");\n  }\n\n  // 3. Nonce-based CSP\n  generateNonce() {\n    return crypto\n      .getRandomValues(new Uint8Array(16))\n      .reduce((acc, val) => acc + val.toString(16).padStart(2, "0"), "");\n  }\n\n  addNonceToScript(nonce) {\n    const script = document.createElement("script");\n    script.nonce = nonce;\n    script.textContent = \'console.log("Safe script");\';\n    document.head.appendChild(script);\n  }\n}\n\n// 4. Hash-based CSP\nclass HashCSP {\n  constructor() {\n    this.hashes = new Set();\n  }\n\n  addScriptHash(scriptContent) {\n    const hash = this.generateHash(scriptContent);\n    this.hashes.add(hash);\n    return hash;\n  }\n\n  generateHash(content) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode(content);\n    return crypto.subtle.digest("SHA-256", data).then((hash) => {\n      const hashArray = Array.from(new Uint8Array(hash));\n      return `\'sha256-${btoa(String.fromCharCode(...hashArray))}\'`;\n    });\n  }\n\n  getPolicy() {\n    const scriptSrc = ["\'self\'", ...Array.from(this.hashes)];\n    return `script-src ${scriptSrc.join(" ")}`;\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-interview-questions",children:"Advanced Interview Questions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Q: How would you implement secure authentication in a frontend application?"}),"\nA: Comprehensive authentication security implementation:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class SecureAuthManager {\n  constructor() {\n    this.tokenKey = 'auth_token';\n    this.refreshTokenKey = 'refresh_token';\n    this.tokenExpiryKey = 'token_expiry';\n  }\n\n  // 1. Secure token storage\n  storeTokens(accessToken, refreshToken, expiresIn) {\n    const expiryTime = Date.now() + (expiresIn * 1000);\n\n    // Store in memory for sensitive operations\n    this.accessToken = accessToken;\n    this.refreshToken = refreshToken;\n\n    // Store refresh token in httpOnly cookie (server-side)\n    this.setHttpOnlyCookie(this.refreshTokenKey, refreshToken);\n\n    // Store expiry time in localStorage\n    localStorage.setItem(this.tokenExpiryKey, expiryTime.toString());\n  }\n\n  // 2. Token validation\n  isTokenValid() {\n    const expiryTime = localStorage.getItem(this.tokenExpiryKey);\n    if (!expiryTime) return false;\n\n    return Date.now() < parseInt(expiryTime);\n  }\n\n  // 3. Automatic token refresh\n  async refreshTokenIfNeeded() {\n    if (!this.isTokenValid() && this.refreshToken) {\n      try {\n        const response = await fetch('/api/auth/refresh', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${this.refreshToken}`\n          }\n        });\n\n        if (response.ok) {\n          const { accessToken, expiresIn } = await response.json();\n          this.storeTokens(accessToken, this.refreshToken, expiresIn);\n          return accessToken;\n        } else {\n          this.logout();\n          throw new Error('Token refresh failed');\n        }\n      } catch (error) {\n        this.logout();\n        throw error;\n      }\n    }\n\n    return this.accessToken;\n  }\n\n  // 4. Secure logout\n  logout() {\n    this.accessToken = null;\n    this.refreshToken = null;\n    localStorage.removeItem(this.tokenExpiryKey);\n\n    // Clear httpOnly cookie\n    this.clearHttpOnlyCookie(this.refreshTokenKey);\n\n    // Redirect to login\n    window.location.href = '/login';\n  }\n\n  // 5. Secure API requests\n  async makeSecureRequest(url, options = {}) {\n    const token = await this.refreshTokenIfNeeded();\n\n    const secureOptions = {\n      ...options,\n      headers: {\n        ...options.headers,\n        'Authorization': `Bearer ${token}`,\n        'X-Requested-With': 'XMLHttpRequest'\n      }\n    };\n\n    const response = await fetch(url, secureOptions);\n\n    if (response.status === 401) {\n      this.logout();\n      throw new Error('Unauthorized');\n    }\n\n    return response;\n  }\n\n  // 6. Password strength validation\n  validatePassword(password) {\n    const requirements = {\n      minLength: 8,\n      hasUpperCase: /[A-Z]/,\n      hasLowerCase: /[a-z]/,\n      hasNumbers: /\\d/,\n      hasSpecialChar: /[!@#$%^&*(),.?\":{}|<>]/\n    };\n\n    const errors = [];\n\n    if (password.length < requirements.minLength) {\n      errors.push(`Password must be at least ${requirements.minLength} characters`);\n    }\n\n    if (!requirements.hasUpperCase.test(password)) {\n      errors.push('Password must contain at least one uppercase letter');\n    }\n\n    if (!requirements.hasLowerCase.test(password)) {\n      errors.push('Password must contain at least one lowercase letter');\n    }\n\n    if (!requirements.hasNumbers.test(password)) {\n      errors.push('Password must contain at least one number');\n    }\n\n    if (!requirements.hasSpecialChar.test(password)) {\n      errors.push('Password must contain at least one special character');\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n\n  // 7. Rate limiting for login attempts\n  constructor() {\n    this.loginAttempts = new Map();\n    this.maxAttempts = 5;\n    this.lockoutDuration = 15 * 60 * 1000; // 15 minutes\n  }\n\n  checkLoginAttempts(email) {\n    const attempts = this.loginAttempts.get(email) || { count: 0, lastAttempt: 0 };\n\n    if (attempts.count >= this.maxAttempts) {\n      const timeSinceLastAttempt = Date.now() - attempts.lastAttempt;\n\n      if (timeSinceLastAttempt < this.lockoutDuration) {\n        const remainingTime = Math.ceil((this.lockoutDuration - timeSinceLastAttempt) / 1000 / 60);\n        throw new Error(`Account temporarily locked. Try again in ${remainingTime} minutes.`);\n      } else {\n        // Reset attempts after lockout period\n        this.loginAttempts.delete(email);\n      }\n    }\n  }\n\n  recordLoginAttempt(email, success) {\n    const attempts = this.loginAttempts.get(email) || { count: 0, lastAttempt: 0 };\n\n    if (success) {\n      this.loginAttempts.delete(email);\n    } else {\n      attempts.count++;\n      attempts.lastAttempt = Date.now();\n      this.loginAttempts.set(email, attempts);\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Q: How do you implement secure file uploads?"}),"\nA: Secure file upload implementation with validation and scanning:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class SecureFileUpload {\n  constructor() {\n    this.allowedTypes = [\n      "image/jpeg",\n      "image/png",\n      "image/gif",\n      "application/pdf",\n    ];\n    this.maxFileSize = 5 * 1024 * 1024; // 5MB\n    this.maxFiles = 10;\n  }\n\n  // 1. File type validation\n  validateFileType(file) {\n    // Check MIME type\n    if (!this.allowedTypes.includes(file.type)) {\n      throw new Error("File type not allowed");\n    }\n\n    // Check file extension\n    const extension = file.name.split(".").pop().toLowerCase();\n    const allowedExtensions = ["jpg", "jpeg", "png", "gif", "pdf"];\n\n    if (!allowedExtensions.includes(extension)) {\n      throw new Error("File extension not allowed");\n    }\n\n    // Check file signature (magic numbers)\n    return this.checkFileSignature(file);\n  }\n\n  // 2. File signature validation\n  async checkFileSignature(file) {\n    const signatures = {\n      "image/jpeg": [0xff, 0xd8, 0xff],\n      "image/png": [0x89, 0x50, 0x4e, 0x47],\n      "image/gif": [0x47, 0x49, 0x46],\n      "application/pdf": [0x25, 0x50, 0x44, 0x46],\n    };\n\n    const buffer = await file.arrayBuffer();\n    const bytes = new Uint8Array(buffer);\n    const expectedSignature = signatures[file.type];\n\n    if (expectedSignature) {\n      for (let i = 0; i < expectedSignature.length; i++) {\n        if (bytes[i] !== expectedSignature[i]) {\n          throw new Error("Invalid file signature");\n        }\n      }\n    }\n\n    return true;\n  }\n\n  // 3. File size validation\n  validateFileSize(file) {\n    if (file.size > this.maxFileSize) {\n      throw new Error(\n        `File size exceeds ${this.maxFileSize / 1024 / 1024}MB limit`\n      );\n    }\n    return true;\n  }\n\n  // 4. Image processing and sanitization\n  async processImage(file) {\n    return new Promise((resolve, reject) => {\n      const canvas = document.createElement("canvas");\n      const ctx = canvas.getContext("2d");\n      const img = new Image();\n\n      img.onload = () => {\n        // Resize image if too large\n        const maxWidth = 1920;\n        const maxHeight = 1080;\n\n        let { width, height } = img;\n\n        if (width > maxWidth || height > maxHeight) {\n          const ratio = Math.min(maxWidth / width, maxHeight / height);\n          width *= ratio;\n          height *= ratio;\n        }\n\n        canvas.width = width;\n        canvas.height = height;\n\n        // Draw image to canvas (removes any embedded scripts)\n        ctx.drawImage(img, 0, 0, width, height);\n\n        // Convert to blob\n        canvas.toBlob(resolve, "image/jpeg", 0.8);\n      };\n\n      img.onerror = () => reject(new Error("Invalid image file"));\n      img.src = URL.createObjectURL(file);\n    });\n  }\n\n  // 5. Secure upload with progress\n  async uploadFile(file, onProgress) {\n    try {\n      // Validate file\n      this.validateFileType(file);\n      this.validateFileSize(file);\n\n      // Process file if it\'s an image\n      let processedFile = file;\n      if (file.type.startsWith("image/")) {\n        processedFile = await this.processImage(file);\n      }\n\n      // Generate secure filename\n      const secureFilename = this.generateSecureFilename(file.name);\n\n      // Create FormData\n      const formData = new FormData();\n      formData.append("file", processedFile, secureFilename);\n      formData.append("timestamp", Date.now().toString());\n\n      // Upload with progress\n      const xhr = new XMLHttpRequest();\n\n      return new Promise((resolve, reject) => {\n        xhr.upload.addEventListener("progress", (event) => {\n          if (event.lengthComputable) {\n            const progress = (event.loaded / event.total) * 100;\n            onProgress?.(progress);\n          }\n        });\n\n        xhr.addEventListener("load", () => {\n          if (xhr.status === 200) {\n            resolve(JSON.parse(xhr.responseText));\n          } else {\n            reject(new Error("Upload failed"));\n          }\n        });\n\n        xhr.addEventListener("error", () => {\n          reject(new Error("Upload failed"));\n        });\n\n        xhr.open("POST", "/api/upload");\n        xhr.send(formData);\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  // 6. Generate secure filename\n  generateSecureFilename(originalName) {\n    const extension = originalName.split(".").pop();\n    const timestamp = Date.now();\n    const randomString = crypto\n      .getRandomValues(new Uint8Array(8))\n      .reduce((acc, val) => acc + val.toString(16).padStart(2, "0"), "");\n\n    return `${timestamp}_${randomString}.${extension}`;\n  }\n\n  // 7. Multiple file upload with validation\n  async uploadMultipleFiles(files, onProgress) {\n    const validFiles = [];\n    const errors = [];\n\n    // Validate all files first\n    for (let i = 0; i < files.length; i++) {\n      try {\n        this.validateFileType(files[i]);\n        this.validateFileSize(files[i]);\n        validFiles.push(files[i]);\n      } catch (error) {\n        errors.push({ file: files[i].name, error: error.message });\n      }\n    }\n\n    if (validFiles.length === 0) {\n      throw new Error("No valid files to upload");\n    }\n\n    // Upload valid files\n    const uploadPromises = validFiles.map((file, index) => {\n      return this.uploadFile(file, (progress) => {\n        onProgress?.(index, progress);\n      });\n    });\n\n    const results = await Promise.allSettled(uploadPromises);\n\n    return {\n      successful: results\n        .filter((r) => r.status === "fulfilled")\n        .map((r) => r.value),\n      failed: results\n        .filter((r) => r.status === "rejected")\n        .map((r) => r.reason),\n      validationErrors: errors,\n    };\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"practical-problems--solutions",children:"Practical Problems & Solutions"}),"\n",(0,i.jsx)(n.h3,{id:"problem-1-implement-secure-session-management",children:"Problem 1: Implement Secure Session Management"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Challenge"}),": Create a secure session management system with automatic cleanup and security features."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class SecureSessionManager {\n  constructor() {\n    this.sessions = new Map();\n    this.sessionTimeout = 30 * 60 * 1000; // 30 minutes\n    this.maxSessionsPerUser = 5;\n    this.cleanupInterval = 5 * 60 * 1000; // 5 minutes\n\n    this.startCleanupTimer();\n  }\n\n  createSession(userId, userAgent, ipAddress) {\n    // Check existing sessions for user\n    const userSessions = this.getUserSessions(userId);\n\n    if (userSessions.length >= this.maxSessionsPerUser) {\n      // Remove oldest session\n      const oldestSession = userSessions.sort(\n        (a, b) => a.createdAt - b.createdAt\n      )[0];\n      this.removeSession(oldestSession.id);\n    }\n\n    const session = {\n      id: this.generateSessionId(),\n      userId,\n      userAgent,\n      ipAddress,\n      createdAt: Date.now(),\n      lastActivity: Date.now(),\n      isActive: true,\n    };\n\n    this.sessions.set(session.id, session);\n    return session;\n  }\n\n  validateSession(sessionId, userAgent, ipAddress) {\n    const session = this.sessions.get(sessionId);\n\n    if (!session || !session.isActive) {\n      return false;\n    }\n\n    // Check session timeout\n    if (Date.now() - session.lastActivity > this.sessionTimeout) {\n      this.removeSession(sessionId);\n      return false;\n    }\n\n    // Check for suspicious activity\n    if (session.userAgent !== userAgent || session.ipAddress !== ipAddress) {\n      this.flagSuspiciousActivity(session);\n      return false;\n    }\n\n    // Update last activity\n    session.lastActivity = Date.now();\n    return true;\n  }\n\n  removeSession(sessionId) {\n    this.sessions.delete(sessionId);\n  }\n\n  getUserSessions(userId) {\n    return Array.from(this.sessions.values()).filter(\n      (session) => session.userId === userId\n    );\n  }\n\n  generateSessionId() {\n    return crypto\n      .getRandomValues(new Uint8Array(32))\n      .reduce((acc, val) => acc + val.toString(16).padStart(2, "0"), "");\n  }\n\n  flagSuspiciousActivity(session) {\n    session.isActive = false;\n    // Log suspicious activity\n    console.warn("Suspicious session activity detected:", session);\n  }\n\n  startCleanupTimer() {\n    setInterval(() => {\n      this.cleanupExpiredSessions();\n    }, this.cleanupInterval);\n  }\n\n  cleanupExpiredSessions() {\n    const now = Date.now();\n\n    for (const [sessionId, session] of this.sessions.entries()) {\n      if (now - session.lastActivity > this.sessionTimeout) {\n        this.removeSession(sessionId);\n      }\n    }\n  }\n\n  getSessionStats() {\n    const totalSessions = this.sessions.size;\n    const activeSessions = Array.from(this.sessions.values()).filter(\n      (session) => session.isActive\n    ).length;\n\n    return {\n      total: totalSessions,\n      active: activeSessions,\n      expired: totalSessions - activeSessions,\n    };\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"problem-2-implement-secure-data-encryption",children:"Problem 2: Implement Secure Data Encryption"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Challenge"}),": Create a client-side encryption system for sensitive data."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class SecureDataEncryption {\n  constructor() {\n    this.algorithm = "AES-GCM";\n    this.keyLength = 256;\n  }\n\n  async generateKey(password, salt) {\n    const encoder = new TextEncoder();\n    const keyMaterial = await crypto.subtle.importKey(\n      "raw",\n      encoder.encode(password),\n      "PBKDF2",\n      false,\n      ["deriveBits", "deriveKey"]\n    );\n\n    return crypto.subtle.deriveKey(\n      {\n        name: "PBKDF2",\n        salt: encoder.encode(salt),\n        iterations: 100000,\n        hash: "SHA-256",\n      },\n      keyMaterial,\n      { name: this.algorithm, length: this.keyLength },\n      false,\n      ["encrypt", "decrypt"]\n    );\n  }\n\n  async encrypt(data, password) {\n    const salt = crypto.getRandomValues(new Uint8Array(16));\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n\n    const key = await this.generateKey(password, salt);\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(JSON.stringify(data));\n\n    const encryptedData = await crypto.subtle.encrypt(\n      {\n        name: this.algorithm,\n        iv: iv,\n      },\n      key,\n      encodedData\n    );\n\n    return {\n      data: Array.from(new Uint8Array(encryptedData)),\n      salt: Array.from(salt),\n      iv: Array.from(iv),\n    };\n  }\n\n  async decrypt(encryptedData, password) {\n    const key = await this.generateKey(password, encryptedData.salt);\n\n    const decryptedData = await crypto.subtle.decrypt(\n      {\n        name: this.algorithm,\n        iv: new Uint8Array(encryptedData.iv),\n      },\n      key,\n      new Uint8Array(encryptedData.data)\n    );\n\n    const decoder = new TextDecoder();\n    return JSON.parse(decoder.decode(decryptedData));\n  }\n\n  // Secure storage with encryption\n  async secureStore(key, data, password) {\n    const encrypted = await this.encrypt(data, password);\n    localStorage.setItem(key, JSON.stringify(encrypted));\n  }\n\n  async secureRetrieve(key, password) {\n    const encrypted = JSON.parse(localStorage.getItem(key));\n    if (!encrypted) return null;\n\n    return await this.decrypt(encrypted, password);\n  }\n\n  // Secure communication\n  async encryptForTransmission(data, publicKey) {\n    // Generate a random AES key for data encryption\n    const aesKey = await crypto.subtle.generateKey(\n      { name: "AES-GCM", length: 256 },\n      true,\n      ["encrypt"]\n    );\n\n    // Encrypt data with AES key\n    const iv = crypto.getRandomValues(new Uint8Array(12));\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(JSON.stringify(data));\n\n    const encryptedData = await crypto.subtle.encrypt(\n      { name: "AES-GCM", iv: iv },\n      aesKey,\n      encodedData\n    );\n\n    // Export AES key and encrypt it with public key\n    const exportedAesKey = await crypto.subtle.exportKey("raw", aesKey);\n\n    const encryptedKey = await crypto.subtle.encrypt(\n      { name: "RSA-OAEP" },\n      publicKey,\n      exportedAesKey\n    );\n\n    return {\n      encryptedData: Array.from(new Uint8Array(encryptedData)),\n      encryptedKey: Array.from(new Uint8Array(encryptedKey)),\n      iv: Array.from(iv),\n    };\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"security-best-practices",children:"Security Best Practices"}),"\n",(0,i.jsx)(n.h3,{id:"input-validation",children:"Input Validation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'class InputValidator {\n  static validateEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email) && email.length <= 254;\n  }\n\n  static validatePassword(password) {\n    return (\n      password.length >= 8 &&\n      /[A-Z]/.test(password) &&\n      /[a-z]/.test(password) &&\n      /\\d/.test(password) &&\n      /[!@#$%^&*]/.test(password)\n    );\n  }\n\n  static sanitizeHTML(input) {\n    const div = document.createElement("div");\n    div.textContent = input;\n    return div.innerHTML;\n  }\n\n  static validateURL(url) {\n    try {\n      const parsed = new URL(url);\n      return ["http:", "https:"].includes(parsed.protocol);\n    } catch {\n      return false;\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"security-headers-implementation",children:"Security Headers Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'// Security headers middleware (server-side)\nconst securityHeaders = {\n  "Content-Security-Policy":\n    "default-src \'self\'; script-src \'self\' \'unsafe-inline\'; style-src \'self\' \'unsafe-inline\';",\n  "X-Frame-Options": "DENY",\n  "X-Content-Type-Options": "nosniff",\n  "Strict-Transport-Security": "max-age=31536000; includeSubDomains",\n  "Referrer-Policy": "strict-origin-when-cross-origin",\n  "Permissions-Policy": "geolocation=(), microphone=(), camera=()",\n};\n\n// Client-side security checks\nclass SecurityChecker {\n  static checkSecurityHeaders() {\n    const requiredHeaders = [\n      "content-security-policy",\n      "x-frame-options",\n      "x-content-type-options",\n    ];\n\n    const missingHeaders = [];\n\n    requiredHeaders.forEach((header) => {\n      if (!document.head.querySelector(`meta[http-equiv="${header}"]`)) {\n        missingHeaders.push(header);\n      }\n    });\n\n    if (missingHeaders.length > 0) {\n      console.warn("Missing security headers:", missingHeaders);\n    }\n  }\n\n  static checkHTTPS() {\n    if (location.protocol !== "https:" && location.hostname !== "localhost") {\n      console.error("Application should be served over HTTPS");\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,i.jsx)(n.h3,{id:"documentation",children:"Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://owasp.org/www-project-top-ten/",children:"OWASP Top 10"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP",children:"Content Security Policy"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API",children:"Web Crypto API"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers",children:"Security Headers"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"tools",children:"Tools"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://owasp.org/www-project-zap/",children:"OWASP ZAP"})," - Security testing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://securityheaders.com/",children:"Security Headers"})," - Header analysis"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://csp-evaluator.withgoogle.com/",children:"CSP Evaluator"})," - CSP validation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://snyk.io/",children:"Snyk"})," - Vulnerability scanning"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"practice-platforms",children:"Practice Platforms"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://owasp.org/www-project-juice-shop/",children:"OWASP Juice Shop"})," - Security training"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://portswigger.net/web-security",children:"PortSwigger Web Security Academy"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://hackerone.com/",children:"HackerOne"})," - Bug bounty programs"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.em,{children:"This guide covers essential security concepts for frontend interviews, including practical problems and advanced techniques commonly asked at companies companies."})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);