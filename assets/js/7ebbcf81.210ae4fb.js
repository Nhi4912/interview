"use strict";(self.webpackChunkfrontend_interview_guide=self.webpackChunkfrontend_interview_guide||[]).push([[9993],{2851:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>a});var t=s(4848),r=s(8453);const i={},c="JavaScript Fundamentals: Definitions, Interview Questions & Answers",o={id:"frontend/javascript/fundamentals",title:"JavaScript Fundamentals: Definitions, Interview Questions & Answers",description:"1. Variables & Data Types",source:"@site/docs/frontend/javascript/fundamentals.md",sourceDirName:"frontend/javascript",slug:"/frontend/javascript/fundamentals",permalink:"/interview/docs/frontend/javascript/fundamentals",draft:!1,unlisted:!1,editUrl:"https://github.com/Nhi4912/interview/tree/main/docs/frontend/javascript/fundamentals.md",tags:[],version:"current",frontMatter:{},sidebar:"frontendSidebar",next:{title:"JavaScript Closures & Scope: Complete Deep Dive",permalink:"/interview/docs/frontend/fundamentals/closure-scope-deep-dive"}},l={},a=[{value:"1. Variables &amp; Data Types",id:"1-variables--data-types",level:2},{value:"2. Scope &amp; Hoisting",id:"2-scope--hoisting",level:2},{value:"3. Closures",id:"3-closures",level:2},{value:"4. Prototype &amp; Inheritance",id:"4-prototype--inheritance",level:2},{value:"5. The <code>this</code> Keyword",id:"5-the-this-keyword",level:2},{value:"6. ES6+ Features",id:"6-es6-features",level:2},{value:"7. Event Loop &amp; Asynchronous JS",id:"7-event-loop--asynchronous-js",level:2},{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"JavaScript Fundamentals",id:"javascript-fundamentals",level:3},{value:"1. Variables and Data Types",id:"1-variables-and-data-types",level:4},{value:"2. Scope and Hoisting",id:"2-scope-and-hoisting",level:4},{value:"3. Closures",id:"3-closures-1",level:4},{value:"4. Prototypes and Inheritance",id:"4-prototypes-and-inheritance",level:4},{value:"Common Interview Questions",id:"common-interview-questions",level:2},{value:"Q1: Explain the difference between <code>var</code>, <code>let</code>, and <code>const</code>",id:"q1-explain-the-difference-between-var-let-and-const",level:3},{value:"Q2: What is the difference between <code>==</code> and <code>===</code>?",id:"q2-what-is-the-difference-between--and-",level:3},{value:"Q3: Explain closures with an example",id:"q3-explain-closures-with-an-example",level:3},{value:"Q4: What is the event loop in JavaScript?",id:"q4-what-is-the-event-loop-in-javascript",level:3},{value:"Q5: Explain promises and async/await",id:"q5-explain-promises-and-asyncawait",level:3},{value:"Advanced Questions",id:"advanced-questions",level:2},{value:"Q6: Implement a debounce function",id:"q6-implement-a-debounce-function",level:3},{value:"Q7: Implement a throttle function",id:"q7-implement-a-throttle-function",level:3},{value:"Q8: Deep clone an object",id:"q8-deep-clone-an-object",level:3},{value:"Q9: Implement a memoization function",id:"q9-implement-a-memoization-function",level:3},{value:"Q10: Create a custom event emitter",id:"q10-create-a-custom-event-emitter",level:3},{value:"Practice Problems",id:"practice-problems",level:2},{value:"Problem 1: Implement Array Methods",id:"problem-1-implement-array-methods",level:3},{value:"Problem 2: Implement a Promise.all",id:"problem-2-implement-a-promiseall",level:3},{value:"Problem 3: Implement a sleep function",id:"problem-3-implement-a-sleep-function",level:3},{value:"Problem 4: Create a singleton pattern",id:"problem-4-create-a-singleton-pattern",level:3},{value:"Problem 5: Implement a queue with two stacks",id:"problem-5-implement-a-queue-with-two-stacks",level:3},{value:"Problem 6: Implement a LRU Cache",id:"problem-6-implement-a-lru-cache",level:3},{value:"Problem 7: Implement a binary search tree",id:"problem-7-implement-a-binary-search-tree",level:3},{value:"Problem 8: Implement a graph with BFS and DFS",id:"problem-8-implement-a-graph-with-bfs-and-dfs",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"javascript-fundamentals-definitions-interview-questions--answers",children:"JavaScript Fundamentals: Definitions, Interview Questions & Answers"}),"\n",(0,t.jsx)(n.h2,{id:"1-variables--data-types",children:"1. Variables & Data Types"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition:"})," Variables store data. JavaScript has primitive types (number, string, boolean, null, undefined, symbol, bigint) and reference types (object, array, function)."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Common Questions:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["What is the difference between ",(0,t.jsx)(n.code,{children:"var"}),", ",(0,t.jsx)(n.code,{children:"let"}),", and ",(0,t.jsx)(n.code,{children:"const"}),"?"]}),"\n",(0,t.jsx)(n.li,{children:"What are primitive vs reference types?"}),"\n",(0,t.jsx)(n.li,{children:"How does type coercion work in JavaScript?"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Answers:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"var"})," is function-scoped and hoisted; ",(0,t.jsx)(n.code,{children:"let"})," and ",(0,t.jsx)(n.code,{children:"const"})," are block-scoped. ",(0,t.jsx)(n.code,{children:"const"})," cannot be reassigned."]}),"\n",(0,t.jsx)(n.li,{children:"Primitive types are immutable and compared by value; reference types are mutable and compared by reference."}),"\n",(0,t.jsxs)(n.li,{children:["Type coercion is JavaScript's automatic conversion between types, e.g., ",(0,t.jsx)(n.code,{children:"'5' + 1"})," becomes ",(0,t.jsx)(n.code,{children:"'51'"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"2-scope--hoisting",children:"2. Scope & Hoisting"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition:"})," Scope determines variable accessibility. Hoisting moves declarations to the top of scope."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Common Questions:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"What is lexical scope?"}),"\n",(0,t.jsx)(n.li,{children:"How does hoisting work?"}),"\n",(0,t.jsx)(n.li,{children:"What is the Temporal Dead Zone?"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Answers:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Lexical scope means a variable's scope is determined by its position in code."}),"\n",(0,t.jsxs)(n.li,{children:["Hoisting moves declarations (not initializations) to the top. ",(0,t.jsx)(n.code,{children:"var"})," is hoisted and initialized as ",(0,t.jsx)(n.code,{children:"undefined"}),"; ",(0,t.jsx)(n.code,{children:"let"}),"/",(0,t.jsx)(n.code,{children:"const"})," are hoisted but not initialized."]}),"\n",(0,t.jsxs)(n.li,{children:["The Temporal Dead Zone is the period between entering scope and variable declaration with ",(0,t.jsx)(n.code,{children:"let"}),"/",(0,t.jsx)(n.code,{children:"const"})," where the variable cannot be accessed."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"3-closures",children:"3. Closures"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition:"})," A closure is a function that remembers its lexical scope even when executed outside that scope."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Common Questions:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"What is a closure?"}),"\n",(0,t.jsx)(n.li,{children:"Give a practical use case for closures."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Answers:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A closure is created when a function accesses variables from its outer scope."}),"\n",(0,t.jsx)(n.li,{children:"Use cases: data privacy, function factories, event handlers, currying."}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"4-prototype--inheritance",children:"4. Prototype & Inheritance"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition:"})," Every JS object has a prototype. Inheritance is achieved via the prototype chain."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Common Questions:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"How does prototypal inheritance work?"}),"\n",(0,t.jsxs)(n.li,{children:["What is the difference between ",(0,t.jsx)(n.code,{children:"__proto__"})," and ",(0,t.jsx)(n.code,{children:"prototype"}),"?"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Answers:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Objects inherit properties from their prototype. If a property is not found, JS looks up the prototype chain."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"prototype"})," is a property of constructor functions; ",(0,t.jsx)(n.code,{children:"__proto__"})," is an internal property of all objects pointing to their prototype."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.h2,{id:"5-the-this-keyword",children:["5. The ",(0,t.jsx)(n.code,{children:"this"})," Keyword"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition:"})," ",(0,t.jsx)(n.code,{children:"this"})," refers to the object that is executing the current function."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Common Questions:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["How is ",(0,t.jsx)(n.code,{children:"this"})," determined?"]}),"\n",(0,t.jsxs)(n.li,{children:["How does ",(0,t.jsx)(n.code,{children:"this"})," behave in arrow functions?"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Answers:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"this"})," is determined by how a function is called: global, object, constructor, call/apply/bind."]}),"\n",(0,t.jsxs)(n.li,{children:["Arrow functions do not have their own ",(0,t.jsx)(n.code,{children:"this"}),"; they inherit from the enclosing scope."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"6-es6-features",children:"6. ES6+ Features"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition:"})," Modern JavaScript (ES6+) introduced let/const, arrow functions, classes, template literals, destructuring, spread/rest, promises, modules, etc."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Common Questions:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"What are arrow functions and how do they differ from regular functions?"}),"\n",(0,t.jsx)(n.li,{children:"What is destructuring?"}),"\n",(0,t.jsx)(n.li,{children:"How do promises work?"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Answers:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Arrow functions are concise, do not have their own ",(0,t.jsx)(n.code,{children:"this"}),", cannot be used as constructors."]}),"\n",(0,t.jsx)(n.li,{children:"Destructuring allows unpacking values from arrays/objects into variables."}),"\n",(0,t.jsxs)(n.li,{children:["Promises represent asynchronous operations; they have ",(0,t.jsx)(n.code,{children:"then"}),", ",(0,t.jsx)(n.code,{children:"catch"}),", and ",(0,t.jsx)(n.code,{children:"finally"})," methods."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"7-event-loop--asynchronous-js",children:"7. Event Loop & Asynchronous JS"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition:"})," The event loop handles async operations by managing the call stack, callback queue, and microtask queue."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Common Questions:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"What is the event loop?"}),"\n",(0,t.jsx)(n.li,{children:"What is the difference between microtasks and macrotasks?"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Answers:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The event loop checks the call stack and processes tasks from the callback/microtask queue when the stack is empty."}),"\n",(0,t.jsx)(n.li,{children:"Microtasks (promises, mutation observers) are processed before macrotasks (setTimeout, setInterval)."}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"javascript-fundamentals-interview-preparation-guide",children:"JavaScript Fundamentals Interview Preparation Guide"}),"\n",(0,t.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#core-concepts",children:"Core Concepts"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#common-interview-questions",children:"Common Interview Questions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#advanced-questions",children:"Advanced Questions"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#practice-problems",children:"Practice Problems"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"#solutions",children:"Solutions"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(n.h3,{id:"javascript-fundamentals",children:"JavaScript Fundamentals"}),"\n",(0,t.jsx)(n.h4,{id:"1-variables-and-data-types",children:"1. Variables and Data Types"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition"}),": JavaScript has dynamic typing with primitive and reference types."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Primitive Types"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"string"}),", ",(0,t.jsx)(n.code,{children:"number"}),", ",(0,t.jsx)(n.code,{children:"boolean"}),", ",(0,t.jsx)(n.code,{children:"null"}),", ",(0,t.jsx)(n.code,{children:"undefined"}),", ",(0,t.jsx)(n.code,{children:"symbol"}),", ",(0,t.jsx)(n.code,{children:"bigint"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reference Types"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"object"}),", ",(0,t.jsx)(n.code,{children:"array"}),", ",(0,t.jsx)(n.code,{children:"function"})]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"2-scope-and-hoisting",children:"2. Scope and Hoisting"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition"}),": Scope determines variable accessibility, hoisting moves declarations to the top."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Types of Scope"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Global scope"}),"\n",(0,t.jsx)(n.li,{children:"Function scope"}),"\n",(0,t.jsx)(n.li,{children:"Block scope (ES6)"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"3-closures-1",children:"3. Closures"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition"}),": Function that has access to variables in its outer scope."]}),"\n",(0,t.jsx)(n.h4,{id:"4-prototypes-and-inheritance",children:"4. Prototypes and Inheritance"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Definition"}),": JavaScript uses prototypal inheritance for object-oriented programming."]}),"\n",(0,t.jsx)(n.h2,{id:"common-interview-questions",children:"Common Interview Questions"}),"\n",(0,t.jsxs)(n.h3,{id:"q1-explain-the-difference-between-var-let-and-const",children:["Q1: Explain the difference between ",(0,t.jsx)(n.code,{children:"var"}),", ",(0,t.jsx)(n.code,{children:"let"}),", and ",(0,t.jsx)(n.code,{children:"const"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"var"})}),": Function-scoped, hoisted, can be redeclared"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"let"})}),": Block-scoped, not hoisted, cannot be redeclared"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"const"})}),": Block-scoped, not hoisted, cannot be reassigned"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// var - function scoped\nfunction example() {\n  var x = 1;\n  if (true) {\n    var x = 2; // Same variable\n  }\n  console.log(x); // 2\n}\n\n// let - block scoped\nfunction example() {\n  let x = 1;\n  if (true) {\n    let x = 2; // Different variable\n  }\n  console.log(x); // 1\n}\n\n// const - cannot be reassigned\nconst PI = 3.14;\nPI = 3.15; // Error: Assignment to constant variable\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"q2-what-is-the-difference-between--and-",children:["Q2: What is the difference between ",(0,t.jsx)(n.code,{children:"=="})," and ",(0,t.jsx)(n.code,{children:"==="}),"?"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"=="})}),": Loose equality (type coercion)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"==="})}),": Strict equality (no type coercion)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Examples"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'console.log(5 == "5"); // true (type coercion)\nconsole.log(5 === "5"); // false (no coercion)\n\nconsole.log(null == undefined); // true\nconsole.log(null === undefined); // false\n\nconsole.log(0 == false); // true\nconsole.log(0 === false); // false\n'})}),"\n",(0,t.jsx)(n.h3,{id:"q3-explain-closures-with-an-example",children:"Q3: Explain closures with an example"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer"}),":\nA closure is a function that has access to variables in its outer scope."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function createCounter() {\n  let count = 0;\n\n  return function () {\n    count++;\n    return count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\nconsole.log(counter()); // 3\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Practical Example"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function createGreeter(greeting) {\n  return function (name) {\n    return `${greeting}, ${name}!`;\n  };\n}\n\nconst sayHello = createGreeter("Hello");\nconst sayGoodbye = createGreeter("Goodbye");\n\nconsole.log(sayHello("John")); // "Hello, John!"\nconsole.log(sayGoodbye("John")); // "Goodbye, John!"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"q4-what-is-the-event-loop-in-javascript",children:"Q4: What is the event loop in JavaScript?"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer"}),":\nThe event loop is JavaScript's mechanism for handling asynchronous operations."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"How it works"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Synchronous code executes in the call stack"}),"\n",(0,t.jsx)(n.li,{children:"Asynchronous operations are moved to Web APIs"}),"\n",(0,t.jsx)(n.li,{children:"When complete, callbacks go to the callback queue"}),"\n",(0,t.jsx)(n.li,{children:"Event loop checks if call stack is empty"}),"\n",(0,t.jsx)(n.li,{children:"If empty, moves callback from queue to stack"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'console.log("1"); // Synchronous\n\nsetTimeout(() => {\n  console.log("2"); // Asynchronous\n}, 0);\n\nconsole.log("3"); // Synchronous\n\n// Output: 1, 3, 2\n'})}),"\n",(0,t.jsx)(n.h3,{id:"q5-explain-promises-and-asyncawait",children:"Q5: Explain promises and async/await"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer"}),":\nPromises represent eventual completion of asynchronous operations."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Promise Example"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const fetchData = () => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const data = { id: 1, name: "John" };\n      resolve(data);\n    }, 1000);\n  });\n};\n\nfetchData()\n  .then((data) => console.log(data))\n  .catch((error) => console.error(error));\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Async/Await Example"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"async function getData() {\n  try {\n    const data = await fetchData();\n    console.log(data);\n  } catch (error) {\n    console.error(error);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-questions",children:"Advanced Questions"}),"\n",(0,t.jsx)(n.h3,{id:"q6-implement-a-debounce-function",children:"Q6: Implement a debounce function"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function debounce(func, delay) {\n  let timeoutId;\n\n  return function (...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}\n\n// Usage\nconst debouncedSearch = debounce((query) => {\n  console.log(`Searching for: ${query}`);\n}, 300);\n\n// Only executes after 300ms of no calls\ndebouncedSearch("hello");\ndebouncedSearch("hello world");\n'})}),"\n",(0,t.jsx)(n.h3,{id:"q7-implement-a-throttle-function",children:"Q7: Implement a throttle function"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function throttle(func, limit) {\n  let inThrottle;\n\n  return function (...args) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n    }\n  };\n}\n\n// Usage\nconst throttledScroll = throttle(() => {\n  console.log("Scroll event");\n}, 100);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"q8-deep-clone-an-object",children:"Q8: Deep clone an object"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// Method 1: JSON (limited)\nfunction deepCloneJSON(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n\n// Method 2: Recursive\nfunction deepClone(obj) {\n  if (obj === null || typeof obj !== "object") {\n    return obj;\n  }\n\n  if (obj instanceof Date) {\n    return new Date(obj.getTime());\n  }\n\n  if (obj instanceof Array) {\n    return obj.map((item) => deepClone(item));\n  }\n\n  if (typeof obj === "object") {\n    const clonedObj = {};\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        clonedObj[key] = deepClone(obj[key]);\n      }\n    }\n    return clonedObj;\n  }\n}\n\n// Usage\nconst original = {\n  name: "John",\n  age: 30,\n  hobbies: ["reading", "gaming"],\n  address: {\n    city: "New York",\n    country: "USA",\n  },\n};\n\nconst cloned = deepClone(original);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"q9-implement-a-memoization-function",children:"Q9: Implement a memoization function"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function memoize(func) {\n  const cache = new Map();\n\n  return function (...args) {\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    const result = func.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Usage\nconst expensiveFunction = memoize((n) => {\n  console.log("Computing...");\n  return n * 2;\n});\n\nconsole.log(expensiveFunction(5)); // Computing... 10\nconsole.log(expensiveFunction(5)); // 10 (from cache)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"q10-create-a-custom-event-emitter",children:"Q10: Create a custom event emitter"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Answer"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'class EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(callback);\n  }\n\n  emit(event, ...args) {\n    if (this.events[event]) {\n      this.events[event].forEach((callback) => callback(...args));\n    }\n  }\n\n  off(event, callback) {\n    if (this.events[event]) {\n      this.events[event] = this.events[event].filter((cb) => cb !== callback);\n    }\n  }\n\n  once(event, callback) {\n    const onceCallback = (...args) => {\n      callback(...args);\n      this.off(event, onceCallback);\n    };\n    this.on(event, onceCallback);\n  }\n}\n\n// Usage\nconst emitter = new EventEmitter();\n\nemitter.on("userLogin", (user) => {\n  console.log(`User logged in: ${user.name}`);\n});\n\nemitter.emit("userLogin", { name: "John", id: 1 });\n'})}),"\n",(0,t.jsx)(n.h2,{id:"practice-problems",children:"Practice Problems"}),"\n",(0,t.jsx)(n.h3,{id:"problem-1-implement-array-methods",children:"Problem 1: Implement Array Methods"}),"\n",(0,t.jsxs)(n.p,{children:["Implement your own versions of ",(0,t.jsx)(n.code,{children:"map"}),", ",(0,t.jsx)(n.code,{children:"filter"}),", ",(0,t.jsx)(n.code,{children:"reduce"}),", and ",(0,t.jsx)(n.code,{children:"forEach"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// forEach\nArray.prototype.myForEach = function (callback) {\n  for (let i = 0; i < this.length; i++) {\n    callback(this[i], i, this);\n  }\n};\n\n// map\nArray.prototype.myMap = function (callback) {\n  const result = [];\n  for (let i = 0; i < this.length; i++) {\n    result.push(callback(this[i], i, this));\n  }\n  return result;\n};\n\n// filter\nArray.prototype.myFilter = function (callback) {\n  const result = [];\n  for (let i = 0; i < this.length; i++) {\n    if (callback(this[i], i, this)) {\n      result.push(this[i]);\n    }\n  }\n  return result;\n};\n\n// reduce\nArray.prototype.myReduce = function (callback, initialValue) {\n  let accumulator = initialValue !== undefined ? initialValue : this[0];\n  const startIndex = initialValue !== undefined ? 0 : 1;\n\n  for (let i = startIndex; i < this.length; i++) {\n    accumulator = callback(accumulator, this[i], i, this);\n  }\n\n  return accumulator;\n};\n\n// Usage\nconst numbers = [1, 2, 3, 4, 5];\n\nnumbers.myForEach((num) => console.log(num));\nconst doubled = numbers.myMap((num) => num * 2);\nconst evens = numbers.myFilter((num) => num % 2 === 0);\nconst sum = numbers.myReduce((acc, num) => acc + num, 0);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-2-implement-a-promiseall",children:"Problem 2: Implement a Promise.all"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function promiseAll(promises) {\n  return new Promise((resolve, reject) => {\n    const results = [];\n    let completed = 0;\n\n    if (promises.length === 0) {\n      resolve(results);\n      return;\n    }\n\n    promises.forEach((promise, index) => {\n      Promise.resolve(promise)\n        .then((result) => {\n          results[index] = result;\n          completed++;\n\n          if (completed === promises.length) {\n            resolve(results);\n          }\n        })\n        .catch(reject);\n    });\n  });\n}\n\n// Usage\nconst promises = [Promise.resolve(1), Promise.resolve(2), Promise.resolve(3)];\n\npromiseAll(promises).then((results) => {\n  console.log(results); // [1, 2, 3]\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-3-implement-a-sleep-function",children:"Problem 3: Implement a sleep function"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function sleep(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n// Usage with async/await\nasync function example() {\n  console.log("Start");\n  await sleep(2000);\n  console.log("After 2 seconds");\n}\n\n// Usage with then\nsleep(1000).then(() => {\n  console.log("After 1 second");\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"problem-4-create-a-singleton-pattern",children:"Problem 4: Create a singleton pattern"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'class Singleton {\n  constructor() {\n    if (Singleton.instance) {\n      return Singleton.instance;\n    }\n    Singleton.instance = this;\n  }\n\n  getInstance() {\n    return this;\n  }\n}\n\n// Alternative with module pattern\nconst singleton = (function () {\n  let instance;\n\n  function createInstance() {\n    return {\n      data: "singleton data",\n      getData: function () {\n        return this.data;\n      },\n    };\n  }\n\n  return {\n    getInstance: function () {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    },\n  };\n})();\n\n// Usage\nconst instance1 = new Singleton();\nconst instance2 = new Singleton();\nconsole.log(instance1 === instance2); // true\n'})}),"\n",(0,t.jsx)(n.h3,{id:"problem-5-implement-a-queue-with-two-stacks",children:"Problem 5: Implement a queue with two stacks"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'class QueueWithStacks {\n  constructor() {\n    this.stack1 = [];\n    this.stack2 = [];\n  }\n\n  enqueue(item) {\n    this.stack1.push(item);\n  }\n\n  dequeue() {\n    if (this.stack2.length === 0) {\n      while (this.stack1.length > 0) {\n        this.stack2.push(this.stack1.pop());\n      }\n    }\n\n    if (this.stack2.length === 0) {\n      throw new Error("Queue is empty");\n    }\n\n    return this.stack2.pop();\n  }\n\n  peek() {\n    if (this.stack2.length === 0) {\n      while (this.stack1.length > 0) {\n        this.stack2.push(this.stack1.pop());\n      }\n    }\n\n    if (this.stack2.length === 0) {\n      throw new Error("Queue is empty");\n    }\n\n    return this.stack2[this.stack2.length - 1];\n  }\n\n  isEmpty() {\n    return this.stack1.length === 0 && this.stack2.length === 0;\n  }\n}\n\n// Usage\nconst queue = new QueueWithStacks();\nqueue.enqueue(1);\nqueue.enqueue(2);\nqueue.enqueue(3);\n\nconsole.log(queue.dequeue()); // 1\nconsole.log(queue.peek()); // 2\n'})}),"\n",(0,t.jsx)(n.h3,{id:"problem-6-implement-a-lru-cache",children:"Problem 6: Implement a LRU Cache"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n\n  get(key) {\n    if (this.cache.has(key)) {\n      const value = this.cache.get(key);\n      this.cache.delete(key);\n      this.cache.set(key, value);\n      return value;\n    }\n    return -1;\n  }\n\n  put(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.capacity) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    this.cache.set(key, value);\n  }\n}\n\n// Usage\nconst cache = new LRUCache(2);\ncache.put(1, 1);\ncache.put(2, 2);\nconsole.log(cache.get(1)); // 1\ncache.put(3, 3);\nconsole.log(cache.get(2)); // -1 (not found)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-7-implement-a-binary-search-tree",children:"Problem 7: Implement a binary search tree"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"class Node {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(value) {\n    const newNode = new Node(value);\n\n    if (!this.root) {\n      this.root = newNode;\n      return this;\n    }\n\n    let current = this.root;\n\n    while (true) {\n      if (value === current.value) return this;\n\n      if (value < current.value) {\n        if (!current.left) {\n          current.left = newNode;\n          return this;\n        }\n        current = current.left;\n      } else {\n        if (!current.right) {\n          current.right = newNode;\n          return this;\n        }\n        current = current.right;\n      }\n    }\n  }\n\n  find(value) {\n    if (!this.root) return false;\n\n    let current = this.root;\n    let found = false;\n\n    while (current && !found) {\n      if (value < current.value) {\n        current = current.left;\n      } else if (value > current.value) {\n        current = current.right;\n      } else {\n        found = true;\n      }\n    }\n\n    return found;\n  }\n\n  // In-order traversal\n  inOrder() {\n    const result = [];\n\n    function traverse(node) {\n      if (node.left) traverse(node.left);\n      result.push(node.value);\n      if (node.right) traverse(node.right);\n    }\n\n    if (this.root) traverse(this.root);\n    return result;\n  }\n}\n\n// Usage\nconst bst = new BinarySearchTree();\nbst.insert(10);\nbst.insert(6);\nbst.insert(15);\nbst.insert(3);\nbst.insert(8);\n\nconsole.log(bst.find(8)); // true\nconsole.log(bst.inOrder()); // [3, 6, 8, 10, 15]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"problem-8-implement-a-graph-with-bfs-and-dfs",children:"Problem 8: Implement a graph with BFS and DFS"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'class Graph {\n  constructor() {\n    this.adjacencyList = {};\n  }\n\n  addVertex(vertex) {\n    if (!this.adjacencyList[vertex]) {\n      this.adjacencyList[vertex] = [];\n    }\n  }\n\n  addEdge(vertex1, vertex2) {\n    this.adjacencyList[vertex1].push(vertex2);\n    this.adjacencyList[vertex2].push(vertex1);\n  }\n\n  removeEdge(vertex1, vertex2) {\n    this.adjacencyList[vertex1] = this.adjacencyList[vertex1].filter(\n      (v) => v !== vertex2\n    );\n    this.adjacencyList[vertex2] = this.adjacencyList[vertex2].filter(\n      (v) => v !== vertex1\n    );\n  }\n\n  removeVertex(vertex) {\n    while (this.adjacencyList[vertex].length) {\n      const adjacentVertex = this.adjacencyList[vertex].pop();\n      this.removeEdge(vertex, adjacentVertex);\n    }\n    delete this.adjacencyList[vertex];\n  }\n\n  // Breadth First Search\n  bfs(start) {\n    const queue = [start];\n    const result = [];\n    const visited = {};\n    visited[start] = true;\n\n    while (queue.length) {\n      const currentVertex = queue.shift();\n      result.push(currentVertex);\n\n      this.adjacencyList[currentVertex].forEach((neighbor) => {\n        if (!visited[neighbor]) {\n          visited[neighbor] = true;\n          queue.push(neighbor);\n        }\n      });\n    }\n\n    return result;\n  }\n\n  // Depth First Search (Recursive)\n  dfsRecursive(start) {\n    const result = [];\n    const visited = {};\n\n    const dfs = (vertex) => {\n      if (!vertex) return null;\n      visited[vertex] = true;\n      result.push(vertex);\n\n      this.adjacencyList[vertex].forEach((neighbor) => {\n        if (!visited[neighbor]) {\n          return dfs(neighbor);\n        }\n      });\n    };\n\n    dfs(start);\n    return result;\n  }\n\n  // Depth First Search (Iterative)\n  dfsIterative(start) {\n    const stack = [start];\n    const result = [];\n    const visited = {};\n    visited[start] = true;\n\n    while (stack.length) {\n      const currentVertex = stack.pop();\n      result.push(currentVertex);\n\n      this.adjacencyList[currentVertex].forEach((neighbor) => {\n        if (!visited[neighbor]) {\n          visited[neighbor] = true;\n          stack.push(neighbor);\n        }\n      });\n    }\n\n    return result;\n  }\n}\n\n// Usage\nconst graph = new Graph();\ngraph.addVertex("A");\ngraph.addVertex("B");\ngraph.addVertex("C");\ngraph.addVertex("D");\ngraph.addVertex("E");\ngraph.addVertex("F");\n\ngraph.addEdge("A", "B");\ngraph.addEdge("A", "C");\ngraph.addEdge("B", "D");\ngraph.addEdge("C", "E");\ngraph.addEdge("D", "E");\ngraph.addEdge("D", "F");\ngraph.addEdge("E", "F");\n\nconsole.log(graph.bfs("A")); // ["A", "B", "C", "D", "E", "F"]\nconsole.log(graph.dfsRecursive("A")); // ["A", "B", "D", "E", "C", "F"]\nconsole.log(graph.dfsIterative("A")); // ["A", "C", "E", "F", "D", "B"]\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"This comprehensive guide covers essential JavaScript concepts, advanced patterns, and practical implementation problems. Practice these concepts thoroughly for frontend interviews at Big Tech companies."})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>o});var t=s(6540);const r={},i=t.createContext(r);function c(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);