"use strict";(self.webpackChunkfrontend_interview_guide=self.webpackChunkfrontend_interview_guide||[]).push([[6278],{6488:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"theory-and-visuals/network-protocols-deep-dive","title":"\ud83c\udf10 Network Protocols Deep Dive","description":"\ud83d\udccb Table of Contents","source":"@site/docs/theory-and-visuals/network-protocols-deep-dive.md","sourceDirName":"theory-and-visuals","slug":"/theory-and-visuals/network-protocols-deep-dive","permalink":"/interview/docs/theory-and-visuals/network-protocols-deep-dive","draft":false,"unlisted":false,"editUrl":"https://github.com/Nhi4912/interview/tree/main/docs/theory-and-visuals/network-protocols-deep-dive.md","tags":[],"version":"current","frontMatter":{},"sidebar":"theorySidebar","previous":{"title":"Browser Architecture","permalink":"/interview/docs/theory-and-visuals/browser-architecture"},"next":{"title":"Knowledge Integration","permalink":"/interview/docs/theory-and-visuals/knowledge-integration-map"}}');var r=t(4848),a=t(8453);const o={},i="\ud83c\udf10 Network Protocols Deep Dive",c={},l=[{value:"\ud83d\udccb Table of Contents",id:"-table-of-contents",level:2},{value:"\ud83c\udf0d HTTP/HTTPS Fundamentals",id:"-httphttps-fundamentals",level:2},{value:"HTTP Request/Response Flow",id:"http-requestresponse-flow",level:3},{value:"HTTP Methods &amp; Status Codes",id:"http-methods--status-codes",level:3},{value:"HTTP Headers Deep Dive",id:"http-headers-deep-dive",level:3},{value:"\ud83d\udd0c WebSocket Protocol",id:"-websocket-protocol",level:2},{value:"WebSocket Handshake &amp; Communication",id:"websocket-handshake--communication",level:3},{value:"WebSocket Implementation",id:"websocket-implementation",level:3},{value:"\ud83d\ude80 HTTP/2 &amp; HTTP/3",id:"-http2--http3",level:2},{value:"HTTP/2 Features",id:"http2-features",level:3},{value:"HTTP/2 Implementation",id:"http2-implementation",level:3},{value:"\ud83d\udcbe Caching Strategies",id:"-caching-strategies",level:2},{value:"Cache Hierarchy",id:"cache-hierarchy",level:3},{value:"Advanced Caching Implementation",id:"advanced-caching-implementation",level:3},{value:"\ud83d\udd12 Security Protocols",id:"-security-protocols",level:2},{value:"TLS/SSL Handshake",id:"tlsssl-handshake",level:3},{value:"Security Implementation",id:"security-implementation",level:3},{value:"\u26a1 Performance Optimization",id:"-performance-optimization",level:2},{value:"Network Performance Monitoring",id:"network-performance-monitoring",level:3},{value:"\ud83c\udfaf Summary",id:"-summary",level:2},{value:"Key Takeaways",id:"key-takeaways",level:3},{value:"Next Steps",id:"next-steps",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"-network-protocols-deep-dive",children:"\ud83c\udf10 Network Protocols Deep Dive"})}),"\n",(0,r.jsx)(n.h2,{id:"-table-of-contents",children:"\ud83d\udccb Table of Contents"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#httphttps-fundamentals",children:"HTTP/HTTPS Fundamentals"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#websocket-protocol",children:"WebSocket Protocol"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#http2--http3",children:"HTTP/2 & HTTP/3"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#caching-strategies",children:"Caching Strategies"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#security-protocols",children:"Security Protocols"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#performance-optimization",children:"Performance Optimization"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#visual-diagrams",children:"Visual Diagrams"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"-httphttps-fundamentals",children:"\ud83c\udf0d HTTP/HTTPS Fundamentals"}),"\n",(0,r.jsx)(n.h3,{id:"http-requestresponse-flow",children:"HTTP Request/Response Flow"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant Client\n    participant DNS\n    participant Server\n    participant CDN\n\n    Client->>DNS: DNS Lookup\n    DNS--\x3e>Client: IP Address\n    Client->>Server: TCP Connection\n    Server--\x3e>Client: Connection Established\n    Client->>Server: HTTP Request\n    Server->>CDN: Check Cache\n    CDN--\x3e>Server: Cache Response\n    Server--\x3e>Client: HTTP Response\n    Client->>Client: Parse & Process\n"})}),"\n",(0,r.jsx)(n.h3,{id:"http-methods--status-codes",children:"HTTP Methods & Status Codes"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:'graph TB\n    subgraph "HTTP Methods"\n        A[GET] --\x3e B[Safe, Idempotent]\n        C[POST] --\x3e D[Not Safe, Not Idempotent]\n        E[PUT] --\x3e F[Not Safe, Idempotent]\n        G[DELETE] --\x3e H[Not Safe, Idempotent]\n        I[PATCH] --\x3e J[Not Safe, Not Idempotent]\n    end\n\n    subgraph "Status Code Ranges"\n        K[1xx Informational] --\x3e L[100 Continue]\n        M[2xx Success] --\x3e N[200 OK, 201 Created]\n        O[3xx Redirection] --\x3e P[301 Moved, 304 Not Modified]\n        Q[4xx Client Error] --\x3e R[400 Bad Request, 404 Not Found]\n        S[5xx Server Error] --\x3e T[500 Internal Server Error]\n    end\n'})}),"\n",(0,r.jsx)(n.h3,{id:"http-headers-deep-dive",children:"HTTP Headers Deep Dive"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// Common HTTP Headers\nconst httpHeaders = {\n  // Request Headers\n  request: {\n    Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",\n    "Accept-Language": "en-US,en;q=0.5",\n    "Accept-Encoding": "gzip, deflate, br",\n    "User-Agent":\n      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",\n    Authorization: "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",\n    "Content-Type": "application/json",\n    "Cache-Control": "no-cache",\n    "If-None-Match": \'"abc123"\',\n    "If-Modified-Since": "Wed, 21 Oct 2015 07:28:00 GMT",\n  },\n\n  // Response Headers\n  response: {\n    "Content-Type": "application/json; charset=utf-8",\n    "Content-Length": "1234",\n    "Cache-Control": "public, max-age=3600",\n    ETag: \'"abc123"\',\n    "Last-Modified": "Wed, 21 Oct 2015 07:28:00 GMT",\n    "Set-Cookie": "sessionId=abc123; HttpOnly; Secure; SameSite=Strict",\n    "Access-Control-Allow-Origin": "*",\n    "X-Frame-Options": "DENY",\n    "X-Content-Type-Options": "nosniff",\n    "Strict-Transport-Security": "max-age=31536000; includeSubDomains",\n  },\n};\n\n// HTTP Client Implementation\nclass HTTPClient {\n  constructor(baseURL, options = {}) {\n    this.baseURL = baseURL;\n    this.defaultHeaders = {\n      "Content-Type": "application/json",\n      ...options.headers,\n    };\n    this.timeout = options.timeout || 5000;\n    this.retries = options.retries || 3;\n  }\n\n  async request(method, endpoint, data = null, options = {}) {\n    const url = `${this.baseURL}${endpoint}`;\n    const headers = { ...this.defaultHeaders, ...options.headers };\n\n    const config = {\n      method,\n      headers,\n      timeout: this.timeout,\n      ...options,\n    };\n\n    if (data && method !== "GET") {\n      config.body = JSON.stringify(data);\n    }\n\n    let lastError;\n\n    for (let attempt = 0; attempt < this.retries; attempt++) {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n        const response = await fetch(url, {\n          ...config,\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n\n        if (!response.ok) {\n          throw new HTTPError(response.status, response.statusText);\n        }\n\n        return await this.parseResponse(response);\n      } catch (error) {\n        lastError = error;\n\n        if (error.name === "AbortError") {\n          console.warn(`Request timeout on attempt ${attempt + 1}`);\n        } else if (error instanceof HTTPError && error.status >= 500) {\n          console.warn(\n            `Server error on attempt ${attempt + 1}: ${error.status}`\n          );\n        } else {\n          throw error; // Don\'t retry client errors\n        }\n\n        if (attempt < this.retries - 1) {\n          await this.delay(Math.pow(2, attempt) * 1000); // Exponential backoff\n        }\n      }\n    }\n\n    throw lastError;\n  }\n\n  async parseResponse(response) {\n    const contentType = response.headers.get("content-type");\n\n    if (contentType && contentType.includes("application/json")) {\n      return await response.json();\n    } else if (contentType && contentType.includes("text/")) {\n      return await response.text();\n    } else {\n      return await response.blob();\n    }\n  }\n\n  delay(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  // Convenience methods\n  async get(endpoint, options = {}) {\n    return this.request("GET", endpoint, null, options);\n  }\n\n  async post(endpoint, data, options = {}) {\n    return this.request("POST", endpoint, data, options);\n  }\n\n  async put(endpoint, data, options = {}) {\n    return this.request("PUT", endpoint, data, options);\n  }\n\n  async delete(endpoint, options = {}) {\n    return this.request("DELETE", endpoint, null, options);\n  }\n\n  async patch(endpoint, data, options = {}) {\n    return this.request("PATCH", endpoint, data, options);\n  }\n}\n\nclass HTTPError extends Error {\n  constructor(status, statusText) {\n    super(`HTTP ${status}: ${statusText}`);\n    this.status = status;\n    this.statusText = statusText;\n    this.name = "HTTPError";\n  }\n}\n\n// Usage\nconst client = new HTTPClient("https://api.example.com", {\n  timeout: 10000,\n  retries: 3,\n  headers: {\n    Authorization: "Bearer token",\n  },\n});\n\n// Example usage\ntry {\n  const users = await client.get("/users");\n  const newUser = await client.post("/users", {\n    name: "John",\n    email: "john@example.com",\n  });\n  const updatedUser = await client.put("/users/1", { name: "John Updated" });\n  await client.delete("/users/1");\n} catch (error) {\n  console.error("HTTP request failed:", error);\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"-websocket-protocol",children:"\ud83d\udd0c WebSocket Protocol"}),"\n",(0,r.jsx)(n.h3,{id:"websocket-handshake--communication",children:"WebSocket Handshake & Communication"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:'sequenceDiagram\n    participant Client\n    participant Server\n\n    Client->>Server: HTTP Upgrade Request\n    Note over Client,Server: GET /chat HTTP/1.1<br/>Upgrade: websocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n\n    Server--\x3e>Client: HTTP 101 Switching Protocols\n    Note over Client,Server: HTTP/1.1 101 Switching Protocols<br/>Upgrade: websocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n\n    Note over Client,Server: WebSocket Connection Established\n\n    Client->>Server: Text Frame: "Hello Server"\n    Server--\x3e>Client: Text Frame: "Hello Client"\n    Client->>Server: Binary Frame: [binary data]\n    Server--\x3e>Client: Ping Frame\n    Client--\x3e>Server: Pong Frame\n'})}),"\n",(0,r.jsx)(n.h3,{id:"websocket-implementation",children:"WebSocket Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'class WebSocketClient {\n  constructor(url, options = {}) {\n    this.url = url;\n    this.options = {\n      reconnectAttempts: 5,\n      reconnectInterval: 1000,\n      heartbeatInterval: 30000,\n      ...options,\n    };\n\n    this.socket = null;\n    this.reconnectCount = 0;\n    this.heartbeatTimer = null;\n    this.messageQueue = [];\n    this.eventListeners = new Map();\n\n    this.connect();\n  }\n\n  connect() {\n    try {\n      this.socket = new WebSocket(this.url);\n\n      this.socket.onopen = this.handleOpen.bind(this);\n      this.socket.onmessage = this.handleMessage.bind(this);\n      this.socket.onclose = this.handleClose.bind(this);\n      this.socket.onerror = this.handleError.bind(this);\n    } catch (error) {\n      console.error("WebSocket connection failed:", error);\n      this.scheduleReconnect();\n    }\n  }\n\n  handleOpen(event) {\n    console.log("WebSocket connected");\n    this.reconnectCount = 0;\n    this.startHeartbeat();\n    this.flushMessageQueue();\n    this.emit("open", event);\n  }\n\n  handleMessage(event) {\n    try {\n      const data = JSON.parse(event.data);\n      this.emit("message", data);\n\n      // Handle specific message types\n      if (data.type === "pong") {\n        this.handlePong();\n      }\n    } catch (error) {\n      console.error("Failed to parse WebSocket message:", error);\n    }\n  }\n\n  handleClose(event) {\n    console.log("WebSocket disconnected:", event.code, event.reason);\n    this.stopHeartbeat();\n    this.emit("close", event);\n\n    if (\n      !event.wasClean &&\n      this.reconnectCount < this.options.reconnectAttempts\n    ) {\n      this.scheduleReconnect();\n    }\n  }\n\n  handleError(error) {\n    console.error("WebSocket error:", error);\n    this.emit("error", error);\n  }\n\n  send(data) {\n    if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify(data));\n    } else {\n      this.messageQueue.push(data);\n    }\n  }\n\n  flushMessageQueue() {\n    while (this.messageQueue.length > 0) {\n      const message = this.messageQueue.shift();\n      this.send(message);\n    }\n  }\n\n  startHeartbeat() {\n    this.heartbeatTimer = setInterval(() => {\n      this.send({ type: "ping", timestamp: Date.now() });\n    }, this.options.heartbeatInterval);\n  }\n\n  stopHeartbeat() {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = null;\n    }\n  }\n\n  handlePong() {\n    // Reset heartbeat on pong received\n    this.stopHeartbeat();\n    this.startHeartbeat();\n  }\n\n  scheduleReconnect() {\n    this.reconnectCount++;\n    const delay =\n      this.options.reconnectInterval * Math.pow(2, this.reconnectCount - 1);\n\n    console.log(\n      `Scheduling reconnect attempt ${this.reconnectCount} in ${delay}ms`\n    );\n\n    setTimeout(() => {\n      this.connect();\n    }, delay);\n  }\n\n  // Event handling\n  on(event, callback) {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event).push(callback);\n  }\n\n  off(event, callback) {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      const index = listeners.indexOf(callback);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n\n  emit(event, data) {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.forEach((callback) => callback(data));\n    }\n  }\n\n  close() {\n    if (this.socket) {\n      this.socket.close(1000, "Client initiated close");\n    }\n  }\n}\n\n// Real-time Chat Implementation\nclass ChatClient {\n  constructor(serverUrl, userId) {\n    this.userId = userId;\n    this.ws = new WebSocketClient(serverUrl);\n    this.messages = [];\n    this.onlineUsers = new Set();\n\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    this.ws.on("open", () => {\n      this.sendMessage({\n        type: "join",\n        userId: this.userId,\n      });\n    });\n\n    this.ws.on("message", (data) => {\n      this.handleMessage(data);\n    });\n\n    this.ws.on("close", () => {\n      console.log("Chat disconnected");\n    });\n  }\n\n  handleMessage(data) {\n    switch (data.type) {\n      case "chat":\n        this.messages.push({\n          id: data.id,\n          userId: data.userId,\n          message: data.message,\n          timestamp: data.timestamp,\n        });\n        this.emit("message", data);\n        break;\n\n      case "userJoined":\n        this.onlineUsers.add(data.userId);\n        this.emit("userJoined", data.userId);\n        break;\n\n      case "userLeft":\n        this.onlineUsers.delete(data.userId);\n        this.emit("userLeft", data.userId);\n        break;\n\n      case "userList":\n        this.onlineUsers = new Set(data.users);\n        this.emit("userList", data.users);\n        break;\n    }\n  }\n\n  sendMessage(data) {\n    this.ws.send({\n      ...data,\n      timestamp: Date.now(),\n    });\n  }\n\n  sendChatMessage(message) {\n    this.sendMessage({\n      type: "chat",\n      message: message,\n    });\n  }\n\n  // Event handling\n  on(event, callback) {\n    this.ws.on(event, callback);\n  }\n\n  emit(event, data) {\n    this.ws.emit(event, data);\n  }\n}\n\n// Usage\nconst chat = new ChatClient("wss://chat.example.com", "user123");\n\nchat.on("message", (data) => {\n  console.log(`${data.userId}: ${data.message}`);\n});\n\nchat.on("userJoined", (userId) => {\n  console.log(`${userId} joined the chat`);\n});\n\nchat.on("userLeft", (userId) => {\n  console.log(`${userId} left the chat`);\n});\n\n// Send a message\nchat.sendChatMessage("Hello, everyone!");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"-http2--http3",children:"\ud83d\ude80 HTTP/2 & HTTP/3"}),"\n",(0,r.jsx)(n.h3,{id:"http2-features",children:"HTTP/2 Features"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:'graph TB\n    subgraph "HTTP/2 Features"\n        A[Multiplexing] --\x3e B[Multiple requests over single connection]\n        C[Server Push] --\x3e D[Proactive resource delivery]\n        E[Header Compression] --\x3e F[HPACK compression]\n        G[Binary Protocol] --\x3e H[More efficient parsing]\n        I[Stream Prioritization] --\x3e J[Resource priority management]\n    end\n\n    subgraph "Performance Benefits"\n        K[Reduced Latency] --\x3e L[Faster page loads]\n        M[Better Bandwidth] --\x3e N[Improved throughput]\n        O[Connection Reuse] --\x3e P[Fewer TCP connections]\n    end\n'})}),"\n",(0,r.jsx)(n.h3,{id:"http2-implementation",children:"HTTP/2 Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'// HTTP/2 Client with Server Push\nclass HTTP2Client {\n  constructor() {\n    this.connection = null;\n    this.pushHandlers = new Map();\n  }\n\n  async connect(url) {\n    try {\n      // Note: This is a simplified example\n      // Real HTTP/2 client would use a library like h2 or node:http2\n      this.connection = await this.createHTTP2Connection(url);\n\n      this.connection.on("push", this.handleServerPush.bind(this));\n      this.connection.on("error", this.handleError.bind(this));\n\n      console.log("HTTP/2 connection established");\n    } catch (error) {\n      console.error("HTTP/2 connection failed:", error);\n      throw error;\n    }\n  }\n\n  async request(method, path, headers = {}) {\n    if (!this.connection) {\n      throw new Error("Not connected");\n    }\n\n    const requestHeaders = {\n      ":method": method,\n      ":path": path,\n      ":scheme": "https",\n      ":authority": this.connection.authority,\n      ...headers,\n    };\n\n    return new Promise((resolve, reject) => {\n      const stream = this.connection.request(requestHeaders);\n\n      let data = "";\n      stream.on("data", (chunk) => {\n        data += chunk;\n      });\n\n      stream.on("end", () => {\n        resolve({\n          status: stream.headers[":status"],\n          headers: stream.headers,\n          data: data,\n        });\n      });\n\n      stream.on("error", reject);\n    });\n  }\n\n  handleServerPush(stream, headers) {\n    const path = headers[":path"];\n    console.log(`Server push for: ${path}`);\n\n    let data = "";\n    stream.on("data", (chunk) => {\n      data += chunk;\n    });\n\n    stream.on("end", () => {\n      // Handle pushed resource\n      this.handlePushedResource(path, data, headers);\n    });\n  }\n\n  handlePushedResource(path, data, headers) {\n    // Cache the pushed resource\n    if (path.endsWith(".css")) {\n      this.injectCSS(data);\n    } else if (path.endsWith(".js")) {\n      this.injectJS(data);\n    } else if (path.match(/\\.(png|jpg|jpeg|gif|svg|webp)$/)) {\n      this.preloadImage(path, data);\n    }\n  }\n\n  injectCSS(css) {\n    const style = document.createElement("style");\n    style.textContent = css;\n    document.head.appendChild(style);\n  }\n\n  injectJS(js) {\n    const script = document.createElement("script");\n    script.textContent = js;\n    document.head.appendChild(script);\n  }\n\n  preloadImage(path, data) {\n    const blob = new Blob([data]);\n    const url = URL.createObjectURL(blob);\n\n    // Preload the image\n    const img = new Image();\n    img.src = url;\n\n    // Store for later use\n    this.pushHandlers.set(path, url);\n  }\n\n  handleError(error) {\n    console.error("HTTP/2 connection error:", error);\n  }\n\n  close() {\n    if (this.connection) {\n      this.connection.close();\n    }\n  }\n}\n\n// HTTP/3 with QUIC\nclass HTTP3Client {\n  constructor() {\n    // HTTP/3 is still experimental\n    // This is a conceptual implementation\n    console.log("HTTP/3 client - experimental feature");\n  }\n\n  async connect(url) {\n    // HTTP/3 uses QUIC protocol over UDP\n    // Provides better performance over unreliable networks\n    console.log("Connecting via HTTP/3/QUIC...");\n  }\n\n  async request(method, path, headers = {}) {\n    // HTTP/3 benefits:\n    // - 0-RTT connection resumption\n    // - Better multiplexing\n    // - Improved congestion control\n    // - Connection migration\n    console.log("HTTP/3 request:", method, path);\n  }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"-caching-strategies",children:"\ud83d\udcbe Caching Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"cache-hierarchy",children:"Cache Hierarchy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:'graph TB\n    subgraph "Cache Layers"\n        A[Browser Cache] --\x3e B[Memory Cache]\n        A --\x3e C[Disk Cache]\n        D[CDN Cache] --\x3e E[Edge Servers]\n        F[Application Cache] --\x3e G[Service Workers]\n        H[Database Cache] --\x3e I[Redis/Memcached]\n    end\n\n    subgraph "Cache Strategies"\n        J[Cache-First] --\x3e K[Return cached, fallback to network]\n        L[Network-First] --\x3e M[Return network, fallback to cache]\n        N[Stale-While-Revalidate] --\x3e O[Return stale, update in background]\n        P[Cache-Only] --\x3e Q[Return cached only]\n    end\n'})}),"\n",(0,r.jsx)(n.h3,{id:"advanced-caching-implementation",children:"Advanced Caching Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'class CacheManager {\n  constructor() {\n    this.memoryCache = new Map();\n    this.serviceWorker = null;\n    this.init();\n  }\n\n  async init() {\n    if ("serviceWorker" in navigator) {\n      try {\n        this.serviceWorker = await navigator.serviceWorker.register("/sw.js");\n        console.log("Service Worker registered");\n      } catch (error) {\n        console.error("Service Worker registration failed:", error);\n      }\n    }\n  }\n\n  // Memory Cache\n  setMemoryCache(key, value, ttl = 300000) {\n    // 5 minutes default\n    this.memoryCache.set(key, {\n      value,\n      timestamp: Date.now(),\n      ttl,\n    });\n  }\n\n  getMemoryCache(key) {\n    const item = this.memoryCache.get(key);\n    if (!item) return null;\n\n    if (Date.now() - item.timestamp > item.ttl) {\n      this.memoryCache.delete(key);\n      return null;\n    }\n\n    return item.value;\n  }\n\n  // HTTP Cache Headers\n  setCacheHeaders(response, strategy = "public", maxAge = 3600) {\n    const headers = new Headers(response.headers);\n\n    switch (strategy) {\n      case "public":\n        headers.set("Cache-Control", `public, max-age=${maxAge}`);\n        break;\n      case "private":\n        headers.set("Cache-Control", `private, max-age=${maxAge}`);\n        break;\n      case "no-cache":\n        headers.set("Cache-Control", "no-cache, must-revalidate");\n        break;\n      case "no-store":\n        headers.set("Cache-Control", "no-store, no-cache, must-revalidate");\n        break;\n      case "stale-while-revalidate":\n        headers.set(\n          "Cache-Control",\n          `public, max-age=${maxAge}, stale-while-revalidate=${maxAge * 2}`\n        );\n        break;\n    }\n\n    return new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers,\n    });\n  }\n\n  // Cache Strategies\n  async cacheFirst(request, cacheName = "app-cache") {\n    const cache = await caches.open(cacheName);\n    const cachedResponse = await cache.match(request);\n\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    try {\n      const networkResponse = await fetch(request);\n      if (networkResponse.ok) {\n        await cache.put(request, networkResponse.clone());\n      }\n      return networkResponse;\n    } catch (error) {\n      throw new Error("Network request failed and no cache available");\n    }\n  }\n\n  async networkFirst(request, cacheName = "app-cache") {\n    const cache = await caches.open(cacheName);\n\n    try {\n      const networkResponse = await fetch(request);\n      if (networkResponse.ok) {\n        await cache.put(request, networkResponse.clone());\n      }\n      return networkResponse;\n    } catch (error) {\n      const cachedResponse = await cache.match(request);\n      if (cachedResponse) {\n        return cachedResponse;\n      }\n      throw error;\n    }\n  }\n\n  async staleWhileRevalidate(request, cacheName = "app-cache") {\n    const cache = await caches.open(cacheName);\n    const cachedResponse = await cache.match(request);\n\n    // Return cached response immediately if available\n    const fetchPromise = fetch(request).then(async (networkResponse) => {\n      if (networkResponse.ok) {\n        await cache.put(request, networkResponse.clone());\n      }\n      return networkResponse;\n    });\n\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    return fetchPromise;\n  }\n\n  // Cache Invalidation\n  async invalidateCache(pattern, cacheName = "app-cache") {\n    const cache = await caches.open(cacheName);\n    const keys = await cache.keys();\n\n    const matchingKeys = keys.filter((key) => {\n      return pattern.test(key.url);\n    });\n\n    await Promise.all(matchingKeys.map((key) => cache.delete(key)));\n    console.log(`Invalidated ${matchingKeys.length} cache entries`);\n  }\n\n  // Cache Analytics\n  async getCacheStats(cacheName = "app-cache") {\n    const cache = await caches.open(cacheName);\n    const keys = await cache.keys();\n\n    let totalSize = 0;\n    const stats = {\n      entries: keys.length,\n      totalSize: 0,\n      averageSize: 0,\n      oldestEntry: null,\n      newestEntry: null,\n    };\n\n    for (const key of keys) {\n      const response = await cache.match(key);\n      if (response) {\n        const blob = await response.blob();\n        totalSize += blob.size;\n\n        const date = new Date(response.headers.get("date") || Date.now());\n        if (!stats.oldestEntry || date < stats.oldestEntry) {\n          stats.oldestEntry = date;\n        }\n        if (!stats.newestEntry || date > stats.newestEntry) {\n          stats.newestEntry = date;\n        }\n      }\n    }\n\n    stats.totalSize = totalSize;\n    stats.averageSize = keys.length > 0 ? totalSize / keys.length : 0;\n\n    return stats;\n  }\n}\n\n// Service Worker Implementation\nclass ServiceWorkerCache {\n  constructor() {\n    this.cacheName = "app-cache-v1";\n    this.assets = [\n      "/",\n      "/index.html",\n      "/styles/main.css",\n      "/scripts/app.js",\n      "/images/logo.png",\n    ];\n  }\n\n  async install(event) {\n    console.log("Service Worker installing...");\n\n    event.waitUntil(\n      caches.open(this.cacheName).then((cache) => {\n        console.log("Caching app shell");\n        return cache.addAll(this.assets);\n      })\n    );\n  }\n\n  async fetch(event) {\n    event.respondWith(this.strategy(event.request));\n  }\n\n  async strategy(request) {\n    const cache = await caches.open(this.cacheName);\n\n    // Check cache first\n    const cachedResponse = await cache.match(request);\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    // Fallback to network\n    try {\n      const networkResponse = await fetch(request);\n\n      // Cache successful responses\n      if (networkResponse.ok) {\n        await cache.put(request, networkResponse.clone());\n      }\n\n      return networkResponse;\n    } catch (error) {\n      // Return offline page if available\n      const offlineResponse = await cache.match("/offline.html");\n      if (offlineResponse) {\n        return offlineResponse;\n      }\n\n      throw error;\n    }\n  }\n\n  async activate(event) {\n    console.log("Service Worker activating...");\n\n    event.waitUntil(\n      caches.keys().then((cacheNames) => {\n        return Promise.all(\n          cacheNames.map((cacheName) => {\n            if (cacheName !== this.cacheName) {\n              console.log("Deleting old cache:", cacheName);\n              return caches.delete(cacheName);\n            }\n          })\n        );\n      })\n    );\n  }\n}\n\n// Usage\nconst cacheManager = new CacheManager();\n\n// Cache API responses\nasync function fetchWithCache(url, options = {}) {\n  const cacheKey = `${url}-${JSON.stringify(options)}`;\n\n  // Check memory cache first\n  let data = cacheManager.getMemoryCache(cacheKey);\n  if (data) {\n    return data;\n  }\n\n  // Fetch from network\n  const response = await fetch(url, options);\n  data = await response.json();\n\n  // Cache the result\n  cacheManager.setMemoryCache(cacheKey, data, 300000); // 5 minutes\n\n  return data;\n}\n\n// Example usage\nconst users = await fetchWithCache("/api/users");\n'})}),"\n",(0,r.jsx)(n.h2,{id:"-security-protocols",children:"\ud83d\udd12 Security Protocols"}),"\n",(0,r.jsx)(n.h3,{id:"tlsssl-handshake",children:"TLS/SSL Handshake"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\n    participant Client\n    participant Server\n\n    Client->>Server: Client Hello\n    Note over Client,Server: Supported cipher suites, random number\n\n    Server--\x3e>Client: Server Hello\n    Note over Client,Server: Chosen cipher suite, random number, certificate\n\n    Client->>Server: Client Key Exchange\n    Note over Client,Server: Pre-master secret\n\n    Note over Client,Server: Both compute master secret\n\n    Client->>Server: Finished\n    Server--\x3e>Client: Finished\n\n    Note over Client,Server: Encrypted communication begins\n"})}),"\n",(0,r.jsx)(n.h3,{id:"security-implementation",children:"Security Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'class SecurityManager {\n  constructor() {\n    this.csp = this.createCSP();\n    this.hsts = this.createHSTS();\n    this.cors = this.createCORS();\n  }\n\n  createCSP() {\n    return {\n      "default-src": ["\'self\'"],\n      "script-src": ["\'self\'", "\'unsafe-inline\'", "https://cdn.example.com"],\n      "style-src": [\n        "\'self\'",\n        "\'unsafe-inline\'",\n        "https://fonts.googleapis.com",\n      ],\n      "img-src": ["\'self\'", "data:", "https:"],\n      "font-src": ["\'self\'", "https://fonts.gstatic.com"],\n      "connect-src": ["\'self\'", "https://api.example.com"],\n      "frame-src": ["\'none\'"],\n      "object-src": ["\'none\'"],\n      "base-uri": ["\'self\'"],\n      "form-action": ["\'self\'"],\n      "upgrade-insecure-requests": [],\n    };\n  }\n\n  createHSTS() {\n    return {\n      "max-age": 31536000, // 1 year\n      includeSubDomains: true,\n      preload: true,\n    };\n  }\n\n  createCORS() {\n    return {\n      "Access-Control-Allow-Origin": "https://app.example.com",\n      "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",\n      "Access-Control-Allow-Headers": "Content-Type, Authorization",\n      "Access-Control-Allow-Credentials": "true",\n      "Access-Control-Max-Age": "86400",\n    };\n  }\n\n  // XSS Prevention\n  sanitizeInput(input) {\n    const div = document.createElement("div");\n    div.textContent = input;\n    return div.innerHTML;\n  }\n\n  // CSRF Protection\n  generateCSRFToken() {\n    return crypto\n      .getRandomValues(new Uint8Array(32))\n      .reduce((acc, val) => acc + val.toString(16).padStart(2, "0"), "");\n  }\n\n  validateCSRFToken(token, storedToken) {\n    return token === storedToken;\n  }\n\n  // Content Security Policy\n  setCSPHeaders(response) {\n    const cspString = Object.entries(this.csp)\n      .map(([key, values]) => {\n        if (Array.isArray(values)) {\n          return `${key} ${values.join(" ")}`;\n        }\n        return key;\n      })\n      .join("; ");\n\n    const headers = new Headers(response.headers);\n    headers.set("Content-Security-Policy", cspString);\n\n    return new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers,\n    });\n  }\n\n  // HTTPS Enforcement\n  enforceHTTPS() {\n    if (location.protocol !== "https:" && location.hostname !== "localhost") {\n      location.replace(\n        `https://${location.host}${location.pathname}${location.search}`\n      );\n    }\n  }\n\n  // Secure Headers\n  setSecureHeaders(response) {\n    const headers = new Headers(response.headers);\n\n    // HSTS\n    headers.set(\n      "Strict-Transport-Security",\n      `max-age=${this.hsts["max-age"]}; includeSubDomains; preload`\n    );\n\n    // X-Frame-Options\n    headers.set("X-Frame-Options", "DENY");\n\n    // X-Content-Type-Options\n    headers.set("X-Content-Type-Options", "nosniff");\n\n    // Referrer Policy\n    headers.set("Referrer-Policy", "strict-origin-when-cross-origin");\n\n    // Permissions Policy\n    headers.set(\n      "Permissions-Policy",\n      "geolocation=(), microphone=(), camera=()"\n    );\n\n    return new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers,\n    });\n  }\n}\n\n// Usage\nconst security = new SecurityManager();\n\n// Enforce HTTPS\nsecurity.enforceHTTPS();\n\n// Sanitize user input\nconst userInput = \'<script>alert("xss")<\/script>\';\nconst sanitized = security.sanitizeInput(userInput);\nconsole.log(sanitized); // &lt;script&gt;alert("xss")&lt;/script&gt;\n\n// Generate CSRF token\nconst csrfToken = security.generateCSRFToken();\n'})}),"\n",(0,r.jsx)(n.h2,{id:"-performance-optimization",children:"\u26a1 Performance Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"network-performance-monitoring",children:"Network Performance Monitoring"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'class NetworkMonitor {\n  constructor() {\n    this.metrics = {\n      requests: [],\n      errors: [],\n      performance: {},\n    };\n\n    this.init();\n  }\n\n  init() {\n    // Monitor network requests\n    this.interceptFetch();\n    this.interceptXMLHttpRequest();\n    this.monitorResourceTiming();\n  }\n\n  interceptFetch() {\n    const originalFetch = window.fetch;\n\n    window.fetch = async (...args) => {\n      const startTime = performance.now();\n      const url = args[0];\n\n      try {\n        const response = await originalFetch(...args);\n        const endTime = performance.now();\n\n        this.recordRequest({\n          url,\n          method: "GET",\n          duration: endTime - startTime,\n          status: response.status,\n          size: response.headers.get("content-length"),\n          timestamp: Date.now(),\n        });\n\n        return response;\n      } catch (error) {\n        const endTime = performance.now();\n\n        this.recordError({\n          url,\n          method: "GET",\n          duration: endTime - startTime,\n          error: error.message,\n          timestamp: Date.now(),\n        });\n\n        throw error;\n      }\n    };\n  }\n\n  interceptXMLHttpRequest() {\n    const originalOpen = XMLHttpRequest.prototype.open;\n    const originalSend = XMLHttpRequest.prototype.send;\n\n    XMLHttpRequest.prototype.open = function (method, url) {\n      this._method = method;\n      this._url = url;\n      this._startTime = performance.now();\n\n      return originalOpen.apply(this, arguments);\n    };\n\n    XMLHttpRequest.prototype.send = function (data) {\n      this.addEventListener("load", () => {\n        const endTime = performance.now();\n\n        this.recordRequest({\n          url: this._url,\n          method: this._method,\n          duration: endTime - this._startTime,\n          status: this.status,\n          size: this.getResponseHeader("content-length"),\n          timestamp: Date.now(),\n        });\n      });\n\n      this.addEventListener("error", () => {\n        const endTime = performance.now();\n\n        this.recordError({\n          url: this._url,\n          method: this._method,\n          duration: endTime - this._startTime,\n          error: "Network error",\n          timestamp: Date.now(),\n        });\n      });\n\n      return originalSend.apply(this, arguments);\n    };\n  }\n\n  monitorResourceTiming() {\n    if ("PerformanceObserver" in window) {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach((entry) => {\n          if (entry.entryType === "resource") {\n            this.recordResourceTiming(entry);\n          }\n        });\n      });\n\n      observer.observe({ entryTypes: ["resource"] });\n    }\n  }\n\n  recordRequest(data) {\n    this.metrics.requests.push(data);\n    this.analyzePerformance();\n  }\n\n  recordError(data) {\n    this.metrics.errors.push(data);\n  }\n\n  recordResourceTiming(entry) {\n    this.metrics.performance[entry.name] = {\n      duration: entry.duration,\n      transferSize: entry.transferSize,\n      decodedBodySize: entry.decodedBodySize,\n      initiatorType: entry.initiatorType,\n      startTime: entry.startTime,\n    };\n  }\n\n  analyzePerformance() {\n    const requests = this.metrics.requests;\n    if (requests.length === 0) return;\n\n    const durations = requests.map((r) => r.duration);\n    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;\n    const maxDuration = Math.max(...durations);\n    const minDuration = Math.min(...durations);\n\n    const slowRequests = requests.filter((r) => r.duration > 1000);\n\n    this.metrics.analysis = {\n      totalRequests: requests.length,\n      averageDuration: avgDuration,\n      maxDuration,\n      minDuration,\n      slowRequests: slowRequests.length,\n      errorRate: this.metrics.errors.length / requests.length,\n    };\n\n    console.log("Network Performance Analysis:", this.metrics.analysis);\n  }\n\n  getReport() {\n    return {\n      ...this.metrics,\n      timestamp: Date.now(),\n    };\n  }\n\n  // Performance recommendations\n  getRecommendations() {\n    const analysis = this.metrics.analysis;\n    const recommendations = [];\n\n    if (analysis.averageDuration > 500) {\n      recommendations.push("Consider implementing caching strategies");\n    }\n\n    if (analysis.slowRequests > 0) {\n      recommendations.push("Optimize slow requests or implement lazy loading");\n    }\n\n    if (analysis.errorRate > 0.05) {\n      recommendations.push("Investigate and fix network errors");\n    }\n\n    return recommendations;\n  }\n}\n\n// Usage\nconst networkMonitor = new NetworkMonitor();\n\n// Get performance report\nsetInterval(() => {\n  const report = networkMonitor.getReport();\n  const recommendations = networkMonitor.getRecommendations();\n\n  console.log("Network Report:", report);\n  console.log("Recommendations:", recommendations);\n}, 30000); // Every 30 seconds\n'})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"-summary",children:"\ud83c\udfaf Summary"}),"\n",(0,r.jsx)(n.p,{children:"Understanding network protocols helps you:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimize performance"})," by leveraging protocol features"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement security"})," best practices"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debug network issues"})," more effectively"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Choose appropriate protocols"})," for different use cases"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor and improve"})," network performance"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HTTP/2"})," provides multiplexing and server push"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"WebSockets"})," enable real-time bidirectional communication"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Caching strategies"})," significantly improve performance"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Security protocols"})," protect data in transit"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance monitoring"})," helps identify bottlenecks"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Implement caching"})," strategies in your applications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor network performance"})," in production"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use appropriate protocols"})," for different use cases"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stay updated"})," with protocol improvements"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Test with different network conditions"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var s=t(6540);const r={},a=s.createContext(r);function o(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);