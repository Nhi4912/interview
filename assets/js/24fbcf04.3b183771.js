"use strict";(self.webpackChunkfrontend_interview_guide=self.webpackChunkfrontend_interview_guide||[]).push([[1966],{4987:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var s=t(4848),i=t(8453);const r={},a="TypeScript Coding Challenges",l={id:"frontend/coding-problems/typescript-challenges",title:"TypeScript Coding Challenges",description:"Problem 1: Advanced Type Utilities",source:"@site/docs/frontend/coding-problems/16-typescript-challenges.md",sourceDirName:"frontend/coding-problems",slug:"/frontend/coding-problems/typescript-challenges",permalink:"/interview/docs/frontend/coding-problems/typescript-challenges",draft:!1,unlisted:!1,editUrl:"https://github.com/Nhi4912/interview/tree/main/docs/frontend/coding-problems/16-typescript-challenges.md",tags:[],version:"current",sidebarPosition:16,frontMatter:{},sidebar:"frontendSidebar",previous:{title:"Problem: React Error Boundary",permalink:"/interview/docs/frontend/coding-problems/error-boundary"},next:{title:"CSS Grid Dashboard Layout",permalink:"/interview/docs/frontend/coding-problems/css-grid-dashboard"}},o={},d=[{value:"Problem 1: Advanced Type Utilities",id:"problem-1-advanced-type-utilities",level:2},{value:"Requirements:",id:"requirements",level:3},{value:"Solution:",id:"solution",level:3},{value:"Problem 2: Type-Safe Event System",id:"problem-2-type-safe-event-system",level:2},{value:"Requirements:",id:"requirements-1",level:3},{value:"Solution:",id:"solution-1",level:3},{value:"Problem 3: Generic Form Builder",id:"problem-3-generic-form-builder",level:2},{value:"Requirements:",id:"requirements-2",level:3},{value:"Solution:",id:"solution-2",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"typescript-coding-challenges",children:"TypeScript Coding Challenges"}),"\n",(0,s.jsx)(n.h2,{id:"problem-1-advanced-type-utilities",children:"Problem 1: Advanced Type Utilities"}),"\n",(0,s.jsx)(n.p,{children:"Create a comprehensive set of TypeScript utility types that can be used in real-world applications."}),"\n",(0,s.jsx)(n.h3,{id:"requirements",children:"Requirements:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DeepReadonly"}),": Make all properties deeply readonly"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"DeepPartial"}),": Make all properties deeply optional"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RequiredKeys"}),": Extract keys that are required"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"OptionalKeys"}),": Extract keys that are optional"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"PickByType"}),": Pick properties by their type"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"OmitByType"}),": Omit properties by their type"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"solution",children:"Solution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// DeepReadonly - makes all properties deeply readonly\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object\n    ? T[P] extends Function\n      ? T[P]\n      : DeepReadonly<T[P]>\n    : T[P];\n};\n\n// DeepPartial - makes all properties deeply optional\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object\n    ? T[P] extends Function\n      ? T[P]\n      : DeepPartial<T[P]>\n    : T[P];\n};\n\n// RequiredKeys - extract keys that are required\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\n// OptionalKeys - extract keys that are optional\ntype OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;\n}[keyof T];\n\n// PickByType - pick properties by their type\ntype PickByType<T, U> = {\n  [P in keyof T as T[P] extends U ? P : never]: T[P];\n};\n\n// OmitByType - omit properties by their type\ntype OmitByType<T, U> = {\n  [P in keyof T as T[P] extends U ? never : P]: T[P];\n};\n\n// NonNullable utility for deep objects\ntype DeepNonNullable<T> = {\n  [P in keyof T]-?: T[P] extends object\n    ? DeepNonNullable<T[P]>\n    : NonNullable<T[P]>;\n};\n\n// Function parameter types\ntype FunctionParams<T extends (...args: any[]) => any> = T extends (\n  ...args: infer P\n) => any\n  ? P\n  : never;\n\n// Promise unwrapping\ntype Awaited<T> = T extends Promise<infer U> ? Awaited<U> : T;\n\n// Example usage and tests\ninterface User {\n  id: number;\n  name: string;\n  email?: string;\n  profile: {\n    bio: string;\n    avatar?: string;\n    settings: {\n      theme: 'light' | 'dark';\n      notifications: boolean;\n    };\n  };\n  roles: string[];\n  createdAt: Date;\n  updateProfile: (data: Partial<User['profile']>) => void;\n}\n\n// Test the utility types\ntype ReadonlyUser = DeepReadonly<User>;\ntype PartialUser = DeepPartial<User>;\ntype RequiredUserKeys = RequiredKeys<User>; // 'id' | 'name' | 'profile' | 'roles' | 'createdAt' | 'updateProfile'\ntype OptionalUserKeys = OptionalKeys<User>; // 'email'\ntype StringProps = PickByType<User, string>; // { name: string }\ntype NonStringProps = OmitByType<User, string>; // Omits string properties\n\n// Advanced conditional type\ntype IsArray<T> = T extends readonly unknown[] ? true : false;\n\n// Tuple to Union\ntype TupleToUnion<T extends readonly unknown[]> = T[number];\n\n// Union to Intersection\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\n// Test cases\nfunction testUtilityTypes() {\n  // DeepReadonly test\n  const readonlyUser: ReadonlyUser = {} as ReadonlyUser;\n  // readonlyUser.profile.settings.theme = 'dark'; // Error: Cannot assign to readonly property\n  \n  // DeepPartial test\n  const partialUser: PartialUser = {\n    name: 'John',\n    profile: {\n      settings: {\n        theme: 'light'\n        // notifications is optional\n      }\n    }\n  };\n  \n  // PickByType test\n  const stringOnlyProps: StringProps = { name: 'John' };\n  \n  // Type assertions to verify correctness\n  const requiredKeys: RequiredUserKeys[] = ['id', 'name', 'profile', 'roles', 'createdAt', 'updateProfile'];\n  const optionalKeys: OptionalUserKeys[] = ['email'];\n}\n\n// Advanced example: API Response Type Builder\ntype ApiResponse<T> = {\n  data: T;\n  status: number;\n  message: string;\n  timestamp: Date;\n};\n\ntype PaginatedResponse<T> = ApiResponse<T> & {\n  pagination: {\n    page: number;\n    limit: number;\n    total: number;\n    hasNext: boolean;\n    hasPrev: boolean;\n  };\n};\n\n// Generic API client with typed responses\nclass ApiClient {\n  async get<T>(url: string): Promise<ApiResponse<T>> {\n    const response = await fetch(url);\n    return response.json();\n  }\n  \n  async getPaginated<T>(url: string, page: number = 1): Promise<PaginatedResponse<T[]>> {\n    const response = await fetch(`${url}?page=${page}`);\n    return response.json();\n  }\n  \n  async post<TRequest, TResponse>(\n    url: string, \n    data: TRequest\n  ): Promise<ApiResponse<TResponse>> {\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(data)\n    });\n    return response.json();\n  }\n}\n\n// Usage with proper typing\nconst api = new ApiClient();\n\nasync function fetchUsers() {\n  const response = await api.getPaginated<User>('/api/users');\n  // response.data is typed as User[]\n  // response.pagination is properly typed\n  \n  const createResponse = await api.post<Partial<User>, User>(\n    '/api/users',\n    { name: 'John', email: 'john@example.com' }\n  );\n  // createResponse.data is typed as User\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"problem-2-type-safe-event-system",children:"Problem 2: Type-Safe Event System"}),"\n",(0,s.jsx)(n.p,{children:"Build a type-safe event emitter system that ensures event names and payload types are correctly matched."}),"\n",(0,s.jsx)(n.h3,{id:"requirements-1",children:"Requirements:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type-safe event names"}),": Only registered events can be emitted/listened to"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Payload type safety"}),": Event payloads must match defined types"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Method chaining"}),": Support for method chaining"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unsubscribe functionality"}),": Ability to remove listeners"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Once listeners"}),": Support for one-time event listeners"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"solution-1",children:"Solution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Event map interface - defines available events and their payload types\ninterface EventMap {\n  [eventName: string]: any;\n}\n\n// Listener function type\ntype Listener<T> = (payload: T) => void;\n\n// Internal listener storage\ninterface ListenerData<T> {\n  listener: Listener<T>;\n  once: boolean;\n}\n\nclass TypedEventEmitter<TEventMap extends EventMap> {\n  private listeners = new Map<keyof TEventMap, Set<ListenerData<any>>>();\n  \n  // Add event listener\n  on<K extends keyof TEventMap>(\n    event: K,\n    listener: Listener<TEventMap[K]>\n  ): this {\n    return this.addListener(event, listener, false);\n  }\n  \n  // Add one-time event listener\n  once<K extends keyof TEventMap>(\n    event: K,\n    listener: Listener<TEventMap[K]>\n  ): this {\n    return this.addListener(event, listener, true);\n  }\n  \n  // Remove event listener\n  off<K extends keyof TEventMap>(\n    event: K,\n    listener: Listener<TEventMap[K]>\n  ): this {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.forEach(listenerData => {\n        if (listenerData.listener === listener) {\n          eventListeners.delete(listenerData);\n        }\n      });\n      \n      if (eventListeners.size === 0) {\n        this.listeners.delete(event);\n      }\n    }\n    return this;\n  }\n  \n  // Emit event\n  emit<K extends keyof TEventMap>(\n    event: K,\n    payload: TEventMap[K]\n  ): boolean {\n    const eventListeners = this.listeners.get(event);\n    if (!eventListeners || eventListeners.size === 0) {\n      return false;\n    }\n    \n    const listenersToRemove: ListenerData<TEventMap[K]>[] = [];\n    \n    eventListeners.forEach(listenerData => {\n      listenerData.listener(payload);\n      \n      if (listenerData.once) {\n        listenersToRemove.push(listenerData);\n      }\n    });\n    \n    // Remove one-time listeners\n    listenersToRemove.forEach(listenerData => {\n      eventListeners.delete(listenerData);\n    });\n    \n    if (eventListeners.size === 0) {\n      this.listeners.delete(event);\n    }\n    \n    return true;\n  }\n  \n  // Remove all listeners for an event\n  removeAllListeners<K extends keyof TEventMap>(event?: K): this {\n    if (event) {\n      this.listeners.delete(event);\n    } else {\n      this.listeners.clear();\n    }\n    return this;\n  }\n  \n  // Get listener count for an event\n  listenerCount<K extends keyof TEventMap>(event: K): number {\n    const eventListeners = this.listeners.get(event);\n    return eventListeners ? eventListeners.size : 0;\n  }\n  \n  // Get all event names that have listeners\n  eventNames(): (keyof TEventMap)[] {\n    return Array.from(this.listeners.keys());\n  }\n  \n  private addListener<K extends keyof TEventMap>(\n    event: K,\n    listener: Listener<TEventMap[K]>,\n    once: boolean\n  ): this {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    \n    const eventListeners = this.listeners.get(event)!;\n    eventListeners.add({ listener, once });\n    \n    return this;\n  }\n}\n\n// Example usage\ninterface AppEvents {\n  'user:login': { userId: string; username: string; timestamp: Date };\n  'user:logout': { userId: string; timestamp: Date };\n  'post:created': { postId: string; authorId: string; title: string };\n  'post:updated': { postId: string; changes: Record<string, any> };\n  'error': { message: string; code: number; stack?: string };\n  'notification': { type: 'info' | 'warning' | 'error'; message: string };\n}\n\nconst eventEmitter = new TypedEventEmitter<AppEvents>();\n\n// Type-safe event listeners\neventEmitter\n  .on('user:login', (data) => {\n    // data is typed as { userId: string; username: string; timestamp: Date }\n    console.log(`User ${data.username} logged in at ${data.timestamp}`);\n  })\n  .on('post:created', (data) => {\n    // data is typed as { postId: string; authorId: string; title: string }\n    console.log(`New post created: ${data.title}`);\n  })\n  .once('error', (error) => {\n    // data is typed as { message: string; code: number; stack?: string }\n    console.error(`Error ${error.code}: ${error.message}`);\n  });\n\n// Type-safe event emission\neventEmitter.emit('user:login', {\n  userId: '123',\n  username: 'john_doe',\n  timestamp: new Date()\n});\n\n// This would cause a TypeScript error:\n// eventEmitter.emit('user:login', { userId: 123 }); // Error: missing properties\n\n// Advanced: Event emitter with middleware\ntype EventMiddleware<TEventMap extends EventMap> = {\n  <K extends keyof TEventMap>(\n    event: K,\n    payload: TEventMap[K],\n    next: () => void\n  ): void;\n};\n\nclass AdvancedEventEmitter<TEventMap extends EventMap> extends TypedEventEmitter<TEventMap> {\n  private middleware: EventMiddleware<TEventMap>[] = [];\n  \n  use(middleware: EventMiddleware<TEventMap>): this {\n    this.middleware.push(middleware);\n    return this;\n  }\n  \n  emit<K extends keyof TEventMap>(\n    event: K,\n    payload: TEventMap[K]\n  ): boolean {\n    let index = 0;\n    \n    const runMiddleware = (): void => {\n      if (index >= this.middleware.length) {\n        super.emit(event, payload);\n        return;\n      }\n      \n      const middleware = this.middleware[index++];\n      middleware(event, payload, runMiddleware);\n    };\n    \n    runMiddleware();\n    return true;\n  }\n}\n\n// Usage with middleware\nconst advancedEmitter = new AdvancedEventEmitter<AppEvents>();\n\n// Logging middleware\nadvancedEmitter.use((event, payload, next) => {\n  console.log(`Event: ${String(event)}`, payload);\n  next();\n});\n\n// Validation middleware\nadvancedEmitter.use((event, payload, next) => {\n  if (event === 'error' && !payload.message) {\n    console.warn('Error event must have a message');\n    return;\n  }\n  next();\n});\n\nadvancedEmitter.emit('user:login', {\n  userId: '123',\n  username: 'john_doe',\n  timestamp: new Date()\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"problem-3-generic-form-builder",children:"Problem 3: Generic Form Builder"}),"\n",(0,s.jsx)(n.p,{children:"Create a type-safe form builder that generates forms based on schema definitions with validation."}),"\n",(0,s.jsx)(n.h3,{id:"requirements-2",children:"Requirements:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type-safe schema"}),": Form schema should define field types and validation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Dynamic form generation"}),": Generate form fields based on schema"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validation"}),": Built-in and custom validation with error messages"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type-safe values"}),": Form values should be correctly typed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Conditional fields"}),": Support for conditional field display"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"solution-2",children:"Solution:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Base field types\ntype FieldType = 'text' | 'email' | 'password' | 'number' | 'select' | 'checkbox' | 'date';\n\n// Validation rules\ninterface ValidationRule<T = any> {\n  rule: (value: T) => boolean;\n  message: string;\n}\n\n// Field configuration\ninterface BaseFieldConfig {\n  type: FieldType;\n  label: string;\n  placeholder?: string;\n  required?: boolean;\n  disabled?: boolean;\n  validation?: ValidationRule<any>[];\n  dependsOn?: string;\n  condition?: (values: Record<string, any>) => boolean;\n}\n\ninterface TextFieldConfig extends BaseFieldConfig {\n  type: 'text' | 'email' | 'password';\n  minLength?: number;\n  maxLength?: number;\n}\n\ninterface NumberFieldConfig extends BaseFieldConfig {\n  type: 'number';\n  min?: number;\n  max?: number;\n  step?: number;\n}\n\ninterface SelectFieldConfig extends BaseFieldConfig {\n  type: 'select';\n  options: { value: string | number; label: string }[];\n  multiple?: boolean;\n}\n\ninterface CheckboxFieldConfig extends BaseFieldConfig {\n  type: 'checkbox';\n}\n\ninterface DateFieldConfig extends BaseFieldConfig {\n  type: 'date';\n  min?: string;\n  max?: string;\n}\n\ntype FieldConfig = \n  | TextFieldConfig \n  | NumberFieldConfig \n  | SelectFieldConfig \n  | CheckboxFieldConfig \n  | DateFieldConfig;\n\n// Form schema\ntype FormSchema = Record<string, FieldConfig>;\n\n// Infer value types from schema\ntype InferFormValues<T extends FormSchema> = {\n  [K in keyof T]: T[K] extends { type: 'text' | 'email' | 'password' }\n    ? string\n    : T[K] extends { type: 'number' }\n    ? number\n    : T[K] extends { type: 'select'; multiple: true }\n    ? (string | number)[]\n    : T[K] extends { type: 'select' }\n    ? string | number\n    : T[K] extends { type: 'checkbox' }\n    ? boolean\n    : T[K] extends { type: 'date' }\n    ? Date\n    : any;\n};\n\n// Form validation result\ninterface ValidationResult {\n  isValid: boolean;\n  errors: Record<string, string[]>;\n}\n\n// Form builder class\nclass FormBuilder<TSchema extends FormSchema> {\n  private schema: TSchema;\n  private values: Partial<InferFormValues<TSchema>> = {};\n  private errors: Record<string, string[]> = {};\n  private touched: Record<string, boolean> = {};\n\n  constructor(schema: TSchema) {\n    this.schema = schema;\n    this.initializeValues();\n  }\n\n  private initializeValues(): void {\n    Object.keys(this.schema).forEach(key => {\n      const field = this.schema[key];\n      \n      switch (field.type) {\n        case 'checkbox':\n          this.values[key as keyof InferFormValues<TSchema>] = false as any;\n          break;\n        case 'select':\n          if ((field as SelectFieldConfig).multiple) {\n            this.values[key as keyof InferFormValues<TSchema>] = [] as any;\n          }\n          break;\n        default:\n          this.values[key as keyof InferFormValues<TSchema>] = undefined as any;\n      }\n    });\n  }\n\n  // Set field value\n  setValue<K extends keyof InferFormValues<TSchema>>(\n    field: K,\n    value: InferFormValues<TSchema>[K]\n  ): this {\n    this.values[field] = value;\n    this.touched[field as string] = true;\n    this.validateField(field as string);\n    return this;\n  }\n\n  // Get field value\n  getValue<K extends keyof InferFormValues<TSchema>>(\n    field: K\n  ): InferFormValues<TSchema>[K] | undefined {\n    return this.values[field];\n  }\n\n  // Get all values\n  getValues(): Partial<InferFormValues<TSchema>> {\n    return { ...this.values };\n  }\n\n  // Validate single field\n  private validateField(fieldName: string): void {\n    const field = this.schema[fieldName];\n    const value = this.values[fieldName as keyof InferFormValues<TSchema>];\n    const fieldErrors: string[] = [];\n\n    // Required validation\n    if (field.required && (value === undefined || value === null || value === '')) {\n      fieldErrors.push(`${field.label} is required`);\n    }\n\n    // Type-specific validation\n    if (value !== undefined && value !== null && value !== '') {\n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n          const textField = field as TextFieldConfig;\n          const textValue = value as string;\n          \n          if (textField.minLength && textValue.length < textField.minLength) {\n            fieldErrors.push(`${field.label} must be at least ${textField.minLength} characters`);\n          }\n          \n          if (textField.maxLength && textValue.length > textField.maxLength) {\n            fieldErrors.push(`${field.label} must be no more than ${textField.maxLength} characters`);\n          }\n          \n          if (field.type === 'email') {\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n            if (!emailRegex.test(textValue)) {\n              fieldErrors.push(`${field.label} must be a valid email address`);\n            }\n          }\n          break;\n\n        case 'number':\n          const numberField = field as NumberFieldConfig;\n          const numberValue = value as number;\n          \n          if (numberField.min !== undefined && numberValue < numberField.min) {\n            fieldErrors.push(`${field.label} must be at least ${numberField.min}`);\n          }\n          \n          if (numberField.max !== undefined && numberValue > numberField.max) {\n            fieldErrors.push(`${field.label} must be no more than ${numberField.max}`);\n          }\n          break;\n      }\n    }\n\n    // Custom validation rules\n    if (field.validation && value !== undefined && value !== null && value !== '') {\n      field.validation.forEach(rule => {\n        if (!rule.rule(value)) {\n          fieldErrors.push(rule.message);\n        }\n      });\n    }\n\n    if (fieldErrors.length > 0) {\n      this.errors[fieldName] = fieldErrors;\n    } else {\n      delete this.errors[fieldName];\n    }\n  }\n\n  // Validate entire form\n  validate(): ValidationResult {\n    const visibleFields = this.getVisibleFields();\n    \n    visibleFields.forEach(fieldName => {\n      this.validateField(fieldName);\n    });\n\n    return {\n      isValid: Object.keys(this.errors).length === 0,\n      errors: { ...this.errors }\n    };\n  }\n\n  // Get visible fields based on conditions\n  private getVisibleFields(): string[] {\n    return Object.keys(this.schema).filter(fieldName => {\n      const field = this.schema[fieldName];\n      \n      if (field.condition) {\n        return field.condition(this.values);\n      }\n      \n      if (field.dependsOn) {\n        const dependentValue = this.values[field.dependsOn as keyof InferFormValues<TSchema>];\n        return !!dependentValue;\n      }\n      \n      return true;\n    });\n  }\n\n  // Get field errors\n  getFieldErrors(fieldName: string): string[] {\n    return this.errors[fieldName] || [];\n  }\n\n  // Check if field has errors\n  hasFieldError(fieldName: string): boolean {\n    return !!this.errors[fieldName] && this.errors[fieldName].length > 0;\n  }\n\n  // Check if field is touched\n  isFieldTouched(fieldName: string): boolean {\n    return !!this.touched[fieldName];\n  }\n\n  // Reset form\n  reset(): this {\n    this.initializeValues();\n    this.errors = {};\n    this.touched = {};\n    return this;\n  }\n\n  // Generate form HTML (for demonstration)\n  generateHTML(): string {\n    const visibleFields = this.getVisibleFields();\n    \n    return visibleFields.map(fieldName => {\n      const field = this.schema[fieldName];\n      const value = this.values[fieldName as keyof InferFormValues<TSchema>];\n      const errors = this.getFieldErrors(fieldName);\n      const hasError = errors.length > 0;\n      \n      let input = '';\n      \n      switch (field.type) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'number':\n        case 'date':\n          input = `<input \n            type=\"${field.type}\" \n            id=\"${fieldName}\" \n            name=\"${fieldName}\"\n            placeholder=\"${field.placeholder || ''}\"\n            value=\"${value || ''}\"\n            ${field.required ? 'required' : ''}\n            ${field.disabled ? 'disabled' : ''}\n            class=\"${hasError ? 'error' : ''}\"\n          />`;\n          break;\n          \n        case 'select':\n          const selectField = field as SelectFieldConfig;\n          const options = selectField.options.map(option => \n            `<option value=\"${option.value}\" ${value === option.value ? 'selected' : ''}>\n              ${option.label}\n            </option>`\n          ).join('');\n          \n          input = `<select \n            id=\"${fieldName}\" \n            name=\"${fieldName}\"\n            ${selectField.multiple ? 'multiple' : ''}\n            ${field.required ? 'required' : ''}\n            ${field.disabled ? 'disabled' : ''}\n            class=\"${hasError ? 'error' : ''}\"\n          >${options}</select>`;\n          break;\n          \n        case 'checkbox':\n          input = `<input \n            type=\"checkbox\" \n            id=\"${fieldName}\" \n            name=\"${fieldName}\"\n            ${value ? 'checked' : ''}\n            ${field.required ? 'required' : ''}\n            ${field.disabled ? 'disabled' : ''}\n            class=\"${hasError ? 'error' : ''}\"\n          />`;\n          break;\n      }\n      \n      const errorHTML = errors.length > 0 \n        ? `<div class=\"error-messages\">${errors.map(error => `<span class=\"error\">${error}</span>`).join('')}</div>`\n        : '';\n      \n      return `\n        <div class=\"form-field ${hasError ? 'has-error' : ''}\">\n          <label for=\"${fieldName}\">${field.label}${field.required ? ' *' : ''}</label>\n          ${input}\n          ${errorHTML}\n        </div>\n      `;\n    }).join('');\n  }\n}\n\n// Example usage\nconst userFormSchema = {\n  firstName: {\n    type: 'text' as const,\n    label: 'First Name',\n    placeholder: 'Enter your first name',\n    required: true,\n    minLength: 2,\n    maxLength: 50\n  },\n  lastName: {\n    type: 'text' as const,\n    label: 'Last Name',\n    placeholder: 'Enter your last name',\n    required: true,\n    minLength: 2,\n    maxLength: 50\n  },\n  email: {\n    type: 'email' as const,\n    label: 'Email Address',\n    placeholder: 'Enter your email',\n    required: true,\n    validation: [\n      {\n        rule: (value: string) => !value.includes('+'),\n        message: 'Email cannot contain + symbol'\n      }\n    ]\n  },\n  age: {\n    type: 'number' as const,\n    label: 'Age',\n    required: true,\n    min: 18,\n    max: 120\n  },\n  country: {\n    type: 'select' as const,\n    label: 'Country',\n    required: true,\n    options: [\n      { value: 'us', label: 'United States' },\n      { value: 'ca', label: 'Canada' },\n      { value: 'uk', label: 'United Kingdom' }\n    ]\n  },\n  state: {\n    type: 'select' as const,\n    label: 'State',\n    dependsOn: 'country',\n    condition: (values) => values.country === 'us',\n    options: [\n      { value: 'ca', label: 'California' },\n      { value: 'ny', label: 'New York' },\n      { value: 'tx', label: 'Texas' }\n    ]\n  },\n  newsletter: {\n    type: 'checkbox' as const,\n    label: 'Subscribe to newsletter'\n  }\n} as const;\n\nconst form = new FormBuilder(userFormSchema);\n\n// Type-safe form manipulation\nform\n  .setValue('firstName', 'John') // Typed as string\n  .setValue('age', 25) // Typed as number\n  .setValue('newsletter', true) // Typed as boolean\n  .setValue('country', 'us'); // Typed as string | number\n\n// Get typed values\nconst values = form.getValues();\n// values.firstName is typed as string | undefined\n// values.age is typed as number | undefined\n// values.newsletter is typed as boolean | undefined\n\n// Validate and get results\nconst validation = form.validate();\nconsole.log('Is valid:', validation.isValid);\nconsole.log('Errors:', validation.errors);\n\n// Generate HTML\nconst formHTML = form.generateHTML();\ndocument.getElementById('form-container')!.innerHTML = formHTML;\n"})}),"\n",(0,s.jsx)(n.p,{children:"These TypeScript challenges demonstrate advanced type system usage, generic programming, and real-world application patterns that are commonly tested in senior frontend interviews at Big Tech companies."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);