"use strict";(self.webpackChunkfrontend_interview_guide=self.webpackChunkfrontend_interview_guide||[]).push([[5049],{3033:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>i,contentTitle:()=>l,default:()=>c,frontMatter:()=>t,metadata:()=>o,toc:()=>d});var r=a(4848),s=a(8453);const t={},l="React Form Validation with Custom Hooks",o={id:"frontend/coding-problems/react-form-validation",title:"React Form Validation with Custom Hooks",description:"Problem Description",source:"@site/docs/frontend/coding-problems/react-form-validation.md",sourceDirName:"frontend/coding-problems",slug:"/frontend/coding-problems/react-form-validation",permalink:"/interview/docs/frontend/coding-problems/react-form-validation",draft:!1,unlisted:!1,editUrl:"https://github.com/Nhi4912/interview/tree/main/docs/frontend/coding-problems/react-form-validation.md",tags:[],version:"current",frontMatter:{},sidebar:"frontendSidebar",previous:{title:"Debounce and Throttle Implementation",permalink:"/interview/docs/frontend/coding-problems/debounce-throttle"},next:{title:"Problem 4: Virtual Scrolling Implementation",permalink:"/interview/docs/frontend/coding-problems/virtual-scrolling"}},i={},d=[{value:"Problem Description",id:"problem-description",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Solution",id:"solution",level:2},{value:"CSS Styling",id:"css-styling",level:2},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Custom Validation Components",id:"custom-validation-components",level:3},{value:"Async Validation with Loading States",id:"async-validation-with-loading-states",level:3},{value:"Key Features",id:"key-features",level:2}];function u(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"react-form-validation-with-custom-hooks",children:"React Form Validation with Custom Hooks"}),"\n",(0,r.jsx)(e.h2,{id:"problem-description",children:"Problem Description"}),"\n",(0,r.jsx)(e.p,{children:"Create a custom React hook for form validation with multiple validation rules."}),"\n",(0,r.jsx)(e.h2,{id:"requirements",children:"Requirements"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Support multiple validation rules"}),"\n",(0,r.jsx)(e.li,{children:"Real-time validation"}),"\n",(0,r.jsx)(e.li,{children:"Custom error messages"}),"\n",(0,r.jsx)(e.li,{children:"Field-level and form-level validation"}),"\n",(0,r.jsx)(e.li,{children:"Async validation support"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"solution",children:"Solution"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// useFormValidation.js\nimport { useState, useCallback, useEffect } from "react";\n\nconst useFormValidation = (initialValues = {}, validationRules = {}) => {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const [isValid, setIsValid] = useState(false);\n\n  // Validation rules\n  const defaultRules = {\n    required: (value) =>\n      (value && value.trim() !== "") || "This field is required",\n    email: (value) => {\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      return emailRegex.test(value) || "Please enter a valid email address";\n    },\n    minLength: (min) => (value) =>\n      value.length >= min || `Must be at least ${min} characters`,\n    maxLength: (max) => (value) =>\n      value.length <= max || `Must be no more than ${max} characters`,\n    pattern: (regex, message) => (value) => regex.test(value) || message,\n    custom: (validator) => validator,\n    async: (asyncValidator) => asyncValidator,\n  };\n\n  const allRules = { ...defaultRules, ...validationRules };\n\n  // Validate a single field\n  const validateField = useCallback(\n    async (name, value) => {\n      const fieldRules = allRules[name];\n      if (!fieldRules) return null;\n\n      for (const rule of fieldRules) {\n        let validator;\n        let params;\n\n        if (typeof rule === "string") {\n          validator = allRules[rule];\n          params = [];\n        } else if (typeof rule === "function") {\n          validator = rule;\n          params = [];\n        } else if (rule.type && allRules[rule.type]) {\n          validator = allRules[rule.type];\n          params = rule.params || [];\n        } else {\n          continue;\n        }\n\n        const result = validator(value, ...params);\n\n        if (result instanceof Promise) {\n          try {\n            const asyncResult = await result;\n            if (asyncResult !== true) {\n              return asyncResult;\n            }\n          } catch (error) {\n            return error.message || "Validation failed";\n          }\n        } else if (result !== true) {\n          return result;\n        }\n      }\n\n      return null;\n    },\n    [allRules]\n  );\n\n  // Validate all fields\n  const validateForm = useCallback(async () => {\n    const newErrors = {};\n    const validationPromises = [];\n\n    for (const [name, value] of Object.entries(values)) {\n      validationPromises.push(\n        validateField(name, value).then((error) => {\n          if (error) newErrors[name] = error;\n        })\n      );\n    }\n\n    await Promise.all(validationPromises);\n    setErrors(newErrors);\n    setIsValid(Object.keys(newErrors).length === 0);\n    return newErrors;\n  }, [values, validateField]);\n\n  // Handle field change\n  const handleChange = useCallback(\n    (name, value) => {\n      setValues((prev) => ({ ...prev, [name]: value }));\n\n      // Clear error when user starts typing\n      if (errors[name]) {\n        setErrors((prev) => ({ ...prev, [name]: null }));\n      }\n    },\n    [errors]\n  );\n\n  // Handle field blur\n  const handleBlur = useCallback(\n    async (name) => {\n      setTouched((prev) => ({ ...prev, [name]: true }));\n\n      const error = await validateField(name, values[name]);\n      setErrors((prev) => ({ ...prev, [name]: error }));\n    },\n    [validateField, values]\n  );\n\n  // Handle form submission\n  const handleSubmit = useCallback(\n    async (onSubmit) => {\n      setIsSubmitting(true);\n\n      try {\n        const formErrors = await validateForm();\n\n        if (Object.keys(formErrors).length === 0) {\n          await onSubmit(values);\n        }\n      } catch (error) {\n        console.error("Form submission error:", error);\n      } finally {\n        setIsSubmitting(false);\n      }\n    },\n    [validateForm, values]\n  );\n\n  // Reset form\n  const reset = useCallback(() => {\n    setValues(initialValues);\n    setErrors({});\n    setTouched({});\n    setIsSubmitting(false);\n    setIsValid(false);\n  }, [initialValues]);\n\n  // Update form values\n  const setValue = useCallback((name, value) => {\n    setValues((prev) => ({ ...prev, [name]: value }));\n  }, []);\n\n  // Get field props\n  const getFieldProps = useCallback(\n    (name) => ({\n      value: values[name] || "",\n      onChange: (e) => handleChange(name, e.target.value),\n      onBlur: () => handleBlur(name),\n      error: touched[name] ? errors[name] : null,\n      hasError: touched[name] && errors[name],\n    }),\n    [values, handleChange, handleBlur, touched, errors]\n  );\n\n  // Effect to validate form when values change\n  useEffect(() => {\n    const timeoutId = setTimeout(() => {\n      if (Object.keys(touched).length > 0) {\n        validateForm();\n      }\n    }, 300);\n\n    return () => clearTimeout(timeoutId);\n  }, [values, touched, validateForm]);\n\n  return {\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    isValid,\n    handleChange,\n    handleBlur,\n    handleSubmit,\n    reset,\n    setValue,\n    getFieldProps,\n    validateField,\n    validateForm,\n  };\n};\n\n// Usage example\nconst RegistrationForm = () => {\n  const validationRules = {\n    username: [\n      "required",\n      { type: "minLength", params: [3] },\n      {\n        type: "pattern",\n        params: [\n          /^[a-zA-Z0-9_]+$/,\n          "Only letters, numbers, and underscores allowed",\n        ],\n      },\n      {\n        type: "async",\n        params: [\n          async (value) => {\n            // Simulate API call to check username availability\n            await new Promise((resolve) => setTimeout(resolve, 1000));\n            return value !== "admin" || "Username already taken";\n          },\n        ],\n      },\n    ],\n    email: ["required", "email"],\n    password: [\n      "required",\n      { type: "minLength", params: [8] },\n      {\n        type: "custom",\n        params: [\n          (value) => {\n            const hasUpperCase = /[A-Z]/.test(value);\n            const hasLowerCase = /[a-z]/.test(value);\n            const hasNumbers = /\\d/.test(value);\n            const hasSpecialChar = /[!@#$%^&*(),.?":{}|<>]/.test(value);\n\n            if (!hasUpperCase)\n              return "Must contain at least one uppercase letter";\n            if (!hasLowerCase)\n              return "Must contain at least one lowercase letter";\n            if (!hasNumbers) return "Must contain at least one number";\n            if (!hasSpecialChar)\n              return "Must contain at least one special character";\n\n            return true;\n          },\n        ],\n      },\n    ],\n    confirmPassword: [\n      "required",\n      {\n        type: "custom",\n        params: [\n          (value, allValues) =>\n            value === allValues.password || "Passwords do not match",\n        ],\n      },\n    ],\n  };\n\n  const { values, errors, isSubmitting, isValid, handleSubmit, getFieldProps } =\n    useFormValidation({}, validationRules);\n\n  const onSubmit = async (formData) => {\n    console.log("Form submitted:", formData);\n    // Handle form submission\n  };\n\n  return (\n    <form\n      onSubmit={(e) => {\n        e.preventDefault();\n        handleSubmit(onSubmit);\n      }}\n    >\n      <div className="form-group">\n        <label htmlFor="username">Username</label>\n        <input\n          id="username"\n          type="text"\n          {...getFieldProps("username")}\n          className={getFieldProps("username").hasError ? "error" : ""}\n        />\n        {getFieldProps("username").error && (\n          <span className="error-message">\n            {getFieldProps("username").error}\n          </span>\n        )}\n      </div>\n\n      <div className="form-group">\n        <label htmlFor="email">Email</label>\n        <input\n          id="email"\n          type="email"\n          {...getFieldProps("email")}\n          className={getFieldProps("email").hasError ? "error" : ""}\n        />\n        {getFieldProps("email").error && (\n          <span className="error-message">{getFieldProps("email").error}</span>\n        )}\n      </div>\n\n      <div className="form-group">\n        <label htmlFor="password">Password</label>\n        <input\n          id="password"\n          type="password"\n          {...getFieldProps("password")}\n          className={getFieldProps("password").hasError ? "error" : ""}\n        />\n        {getFieldProps("password").error && (\n          <span className="error-message">\n            {getFieldProps("password").error}\n          </span>\n        )}\n      </div>\n\n      <div className="form-group">\n        <label htmlFor="confirmPassword">Confirm Password</label>\n        <input\n          id="confirmPassword"\n          type="password"\n          {...getFieldProps("confirmPassword")}\n          className={getFieldProps("confirmPassword").hasError ? "error" : ""}\n        />\n        {getFieldProps("confirmPassword").error && (\n          <span className="error-message">\n            {getFieldProps("confirmPassword").error}\n          </span>\n        )}\n      </div>\n\n      <button\n        type="submit"\n        disabled={isSubmitting || !isValid}\n        className="submit-button"\n      >\n        {isSubmitting ? "Submitting..." : "Register"}\n      </button>\n    </form>\n  );\n};\n'})}),"\n",(0,r.jsx)(e.h2,{id:"css-styling",children:"CSS Styling"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-css",children:".form-group {\n  margin-bottom: 20px;\n}\n\n.form-group label {\n  display: block;\n  margin-bottom: 5px;\n  font-weight: 600;\n  color: #333;\n}\n\n.form-group input {\n  width: 100%;\n  padding: 12px;\n  border: 2px solid #ddd;\n  border-radius: 6px;\n  font-size: 16px;\n  transition: border-color 0.3s, box-shadow 0.3s;\n}\n\n.form-group input:focus {\n  outline: none;\n  border-color: #007bff;\n  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);\n}\n\n.form-group input.error {\n  border-color: #dc3545;\n  box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.1);\n}\n\n.error-message {\n  display: block;\n  margin-top: 5px;\n  color: #dc3545;\n  font-size: 14px;\n  font-weight: 500;\n}\n\n.submit-button {\n  width: 100%;\n  padding: 12px;\n  background-color: #007bff;\n  color: white;\n  border: none;\n  border-radius: 6px;\n  font-size: 16px;\n  font-weight: 600;\n  cursor: pointer;\n  transition: background-color 0.3s;\n}\n\n.submit-button:hover:not(:disabled) {\n  background-color: #0056b3;\n}\n\n.submit-button:disabled {\n  background-color: #6c757d;\n  cursor: not-allowed;\n}\n\n.form-group input:valid {\n  border-color: #28a745;\n}\n\n.form-group input:valid:focus {\n  box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.1);\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,r.jsx)(e.h3,{id:"custom-validation-components",children:"Custom Validation Components"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// Custom Input Component\nconst ValidatedInput = ({\n  name,\n  label,\n  type = "text",\n  validation,\n  ...props\n}) => {\n  const { getFieldProps } = useFormValidation();\n  const fieldProps = getFieldProps(name);\n\n  return (\n    <div className="form-group">\n      <label htmlFor={name}>{label}</label>\n      <input\n        id={name}\n        type={type}\n        {...fieldProps}\n        {...props}\n        className={`${fieldProps.hasError ? "error" : ""} ${\n          props.className || ""\n        }`}\n      />\n      {fieldProps.error && (\n        <span className="error-message">{fieldProps.error}</span>\n      )}\n    </div>\n  );\n};\n\n// Usage\nconst AdvancedForm = () => {\n  const { handleSubmit, isValid } = useFormValidation();\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <ValidatedInput\n        name="username"\n        label="Username"\n        placeholder="Enter username"\n      />\n      <ValidatedInput\n        name="email"\n        label="Email"\n        type="email"\n        placeholder="Enter email"\n      />\n      <ValidatedInput\n        name="password"\n        label="Password"\n        type="password"\n        placeholder="Enter password"\n      />\n      <button type="submit" disabled={!isValid}>\n        Submit\n      </button>\n    </form>\n  );\n};\n'})}),"\n",(0,r.jsx)(e.h3,{id:"async-validation-with-loading-states",children:"Async Validation with Loading States"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'const useAsyncValidation = (validator, delay = 500) => {\n  const [isValidating, setIsValidating] = useState(false);\n  const [validationResult, setValidationResult] = useState(null);\n\n  const validate = useCallback(\n    async (value) => {\n      if (!value) return null;\n\n      setIsValidating(true);\n\n      try {\n        const result = await validator(value);\n        setValidationResult(result);\n        return result;\n      } catch (error) {\n        setValidationResult(error.message);\n        return error.message;\n      } finally {\n        setIsValidating(false);\n      }\n    },\n    [validator]\n  );\n\n  return { validate, isValidating, validationResult };\n};\n\n// Usage in form\nconst UsernameField = () => {\n  const { validate, isValidating } = useAsyncValidation(async (username) => {\n    // API call to check username availability\n    const response = await fetch(`/api/check-username?username=${username}`);\n    const { available } = await response.json();\n    return available || "Username already taken";\n  });\n\n  return (\n    <div className="form-group">\n      <label>Username</label>\n      <div className="input-with-loader">\n        <input type="text" onChange={(e) => validate(e.target.value)} />\n        {isValidating && <div className="loader" />}\n      </div>\n    </div>\n  );\n};\n'})}),"\n",(0,r.jsx)(e.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Flexible Validation Rules"}),": Support for multiple validation types"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Real-time Validation"}),": Immediate feedback as user types"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Async Validation"}),": Support for API-based validation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Field-level Control"}),": Individual field validation and error handling"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Form-level Validation"}),": Complete form validation on submission"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Custom Error Messages"}),": Configurable error messages"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Performance Optimized"}),": Debounced validation to prevent excessive calls"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Accessibility"}),": Proper ARIA labels and error associations"]}),"\n"]})]})}function c(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(u,{...n})}):u(n)}},8453:(n,e,a)=>{a.d(e,{R:()=>l,x:()=>o});var r=a(6540);const s={},t=r.createContext(s);function l(n){const e=r.useContext(t);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);