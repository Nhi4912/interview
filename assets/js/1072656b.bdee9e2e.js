"use strict";(self.webpackChunkfrontend_interview_guide=self.webpackChunkfrontend_interview_guide||[]).push([[3856],{3198:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var r=t(4848),s=t(8453);const i={},a="TypeScript for Frontend Interviews",o={id:"frontend/typescript/README",title:"TypeScript for Frontend Interviews",description:"Table of Contents",source:"@site/docs/frontend/typescript/README.md",sourceDirName:"frontend/typescript",slug:"/frontend/typescript/",permalink:"/interview/docs/frontend/typescript/",draft:!1,unlisted:!1,editUrl:"https://github.com/Nhi4912/interview/tree/main/docs/frontend/typescript/README.md",tags:[],version:"current",frontMatter:{}},c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"TypeScript Fundamentals",id:"typescript-fundamentals",level:2},{value:"Why TypeScript?",id:"why-typescript",level:3},{value:"Basic Types",id:"basic-types",level:3},{value:"Objects and Interfaces",id:"objects-and-interfaces",level:3},{value:"Functions",id:"functions",level:3},{value:"Advanced Types",id:"advanced-types",level:2},{value:"Union and Intersection Types",id:"union-and-intersection-types",level:3},{value:"Generics",id:"generics",level:3},{value:"Utility Types",id:"utility-types",level:3},{value:"React with TypeScript",id:"react-with-typescript",level:2},{value:"Component Types",id:"component-types",level:3},{value:"Hooks with TypeScript",id:"hooks-with-typescript",level:3},{value:"Context with TypeScript",id:"context-with-typescript",level:3},{value:"Interview Questions",id:"interview-questions",level:2},{value:"1. What is TypeScript and why would you use it?",id:"1-what-is-typescript-and-why-would-you-use-it",level:3},{value:"2. Explain the difference between <code>interface</code> and <code>type</code> in TypeScript.",id:"2-explain-the-difference-between-interface-and-type-in-typescript",level:3},{value:"3. What are generics and why are they useful?",id:"3-what-are-generics-and-why-are-they-useful",level:3},{value:"4. How do you handle asynchronous operations in TypeScript?",id:"4-how-do-you-handle-asynchronous-operations-in-typescript",level:3},{value:"5. What are utility types and how do you use them?",id:"5-what-are-utility-types-and-how-do-you-use-them",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Type Definitions",id:"1-type-definitions",level:3},{value:"2. Function Types",id:"2-function-types",level:3},{value:"3. Error Handling",id:"3-error-handling",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"1. Builder Pattern",id:"1-builder-pattern",level:3},{value:"2. Factory Pattern",id:"2-factory-pattern",level:3},{value:"3. Repository Pattern",id:"3-repository-pattern",level:3}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"typescript-for-frontend-interviews",children:"TypeScript for Frontend Interviews"}),"\n",(0,r.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#typescript-fundamentals",children:"TypeScript Fundamentals"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#advanced-types",children:"Advanced Types"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#react-with-typescript",children:"React with TypeScript"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#interview-questions",children:"Interview Questions"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#best-practices",children:"Best Practices"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#common-patterns",children:"Common Patterns"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"typescript-fundamentals",children:"TypeScript Fundamentals"}),"\n",(0,r.jsx)(n.h3,{id:"why-typescript",children:"Why TypeScript?"}),"\n",(0,r.jsx)(n.p,{children:"TypeScript is a superset of JavaScript that adds static type definitions. It's essential for modern frontend development and frequently tested in interviews."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Benefits:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Static Type Checking"}),": Catch errors at compile time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better IDE Support"}),": Enhanced autocomplete, refactoring, and navigation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Self-Documenting Code"}),": Types serve as documentation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Easier Refactoring"}),": Compiler helps identify breaking changes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better Team Collaboration"}),": Clear interfaces and contracts"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"basic-types",children:"Basic Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Primitive types\nlet name: string = "John";\nlet age: number = 25;\nlet isActive: boolean = true;\nlet nothing: null = null;\nlet undefined: undefined = undefined;\n\n// Arrays\nlet numbers: number[] = [1, 2, 3];\nlet strings: Array<string> = ["a", "b", "c"];\n\n// Tuples\nlet person: [string, number] = ["John", 25];\n\n// Enums\nenum Color {\n  Red,\n  Green,\n  Blue\n}\nlet c: Color = Color.Green;\n\n// Any (use sparingly)\nlet anything: any = 42;\nanything = "hello";\nanything = true;\n\n// Unknown (safer than any)\nlet userInput: unknown;\nif (typeof userInput === "string") {\n  console.log(userInput.toUpperCase());\n}\n\n// Never (functions that never return)\nfunction throwError(message: string): never {\n  throw new Error(message);\n}\n\n// Void (no return value)\nfunction logMessage(message: string): void {\n  console.log(message);\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"objects-and-interfaces",children:"Objects and Interfaces"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Object types\nlet user: { name: string; age: number } = {\n  name: "John",\n  age: 25\n};\n\n// Interface definition\ninterface User {\n  readonly id: number;\n  name: string;\n  email: string;\n  age?: number; // Optional property\n}\n\n// Using interfaces\nconst createUser = (userData: User): User => {\n  return {\n    id: Math.random(),\n    ...userData\n  };\n};\n\n// Extending interfaces\ninterface AdminUser extends User {\n  permissions: string[];\n  isAdmin: boolean;\n}\n\n// Index signatures\ninterface StringDictionary {\n  [key: string]: string;\n}\n\nconst dictionary: StringDictionary = {\n  hello: "world",\n  foo: "bar"\n};\n'})}),"\n",(0,r.jsx)(n.h3,{id:"functions",children:"Functions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Function types\ntype MathOperation = (a: number, b: number) => number;\n\nconst add: MathOperation = (a, b) => a + b;\nconst multiply: MathOperation = (a, b) => a * b;\n\n// Function overloads\nfunction process(input: string): string;\nfunction process(input: number): number;\nfunction process(input: string | number): string | number {\n  if (typeof input === "string") {\n    return input.toUpperCase();\n  }\n  return input * 2;\n}\n\n// Rest parameters\nfunction sum(...numbers: number[]): number {\n  return numbers.reduce((total, num) => total + num, 0);\n}\n\n// Optional parameters\nfunction greet(name: string, greeting?: string): string {\n  return `${greeting || "Hello"}, ${name}!`;\n}\n\n// Default parameters\nfunction createUser(name: string, age: number = 18): User {\n  return { id: Math.random(), name, email: `${name}@example.com`, age };\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-types",children:"Advanced Types"}),"\n",(0,r.jsx)(n.h3,{id:"union-and-intersection-types",children:"Union and Intersection Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Union types\ntype StringOrNumber = string | number;\ntype Status = "loading" | "success" | "error";\n\nfunction processId(id: StringOrNumber): void {\n  if (typeof id === "string") {\n    console.log(id.toUpperCase());\n  } else {\n    console.log(id.toFixed(2));\n  }\n}\n\n// Intersection types\ninterface Person {\n  name: string;\n  age: number;\n}\n\ninterface Employee {\n  employeeId: number;\n  department: string;\n}\n\ntype PersonEmployee = Person & Employee;\n\nconst emp: PersonEmployee = {\n  name: "John",\n  age: 30,\n  employeeId: 123,\n  department: "Engineering"\n};\n'})}),"\n",(0,r.jsx)(n.h3,{id:"generics",children:"Generics"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Generic functions\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nconst stringResult = identity<string>("hello");\nconst numberResult = identity<number>(42);\n\n// Generic interfaces\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\ninterface User {\n  id: number;\n  name: string;\n}\n\nconst userResponse: ApiResponse<User> = {\n  data: { id: 1, name: "John" },\n  status: 200,\n  message: "Success"\n};\n\n// Generic classes\nclass Repository<T> {\n  private items: T[] = [];\n\n  add(item: T): void {\n    this.items.push(item);\n  }\n\n  findById(id: number): T | undefined {\n    return this.items.find((item: any) => item.id === id);\n  }\n\n  getAll(): T[] {\n    return [...this.items];\n  }\n}\n\n// Generic constraints\ninterface HasLength {\n  length: number;\n}\n\nfunction logLength<T extends HasLength>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n\n// Conditional types\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\n// Mapped types\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n\ntype Required<T> = {\n  [P in keyof T]-?: T[P];\n};\n\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n'})}),"\n",(0,r.jsx)(n.h3,{id:"utility-types",children:"Utility Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Built-in utility types\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\n// Partial - makes all properties optional\ntype PartialUser = Partial<User>;\n\n// Required - makes all properties required\ntype RequiredUser = Required<User>;\n\n// Readonly - makes all properties readonly\ntype ReadonlyUser = Readonly<User>;\n\n// Pick - selects specific properties\ntype UserPreview = Pick<User, "id" | "name">;\n\n// Omit - excludes specific properties\ntype UserWithoutId = Omit<User, "id">;\n\n// Record - creates an object type with specific key and value types\ntype UserRoles = Record<string, string[]>;\n\n// ReturnType - extracts return type of function\nfunction getUser(): User {\n  return { id: 1, name: "John", email: "john@example.com", age: 25 };\n}\n\ntype GetUserReturnType = ReturnType<typeof getUser>; // User\n\n// Parameters - extracts parameter types\nfunction updateUser(id: number, updates: Partial<User>): void {}\n\ntype UpdateUserParams = Parameters<typeof updateUser>; // [number, Partial<User>]\n'})}),"\n",(0,r.jsx)(n.h2,{id:"react-with-typescript",children:"React with TypeScript"}),"\n",(0,r.jsx)(n.h3,{id:"component-types",children:"Component Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import React, { useState, useEffect, ReactNode } from 'react';\n\n// Props interface\ninterface ButtonProps {\n  children: ReactNode;\n  onClick: () => void;\n  variant?: 'primary' | 'secondary';\n  disabled?: boolean;\n}\n\n// Function component\nconst Button: React.FC<ButtonProps> = ({ \n  children, \n  onClick, \n  variant = 'primary', \n  disabled = false \n}) => {\n  return (\n    <button \n      onClick={onClick} \n      disabled={disabled}\n      className={`btn btn-${variant}`}\n    >\n      {children}\n    </button>\n  );\n};\n\n// Generic component\ninterface ListProps<T> {\n  items: T[];\n  renderItem: (item: T) => ReactNode;\n  keyExtractor: (item: T) => string | number;\n}\n\nfunction List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={keyExtractor(item)}>\n          {renderItem(item)}\n        </li>\n      ))}\n    </ul>\n  );\n}\n\n// Using the generic component\ninterface User {\n  id: number;\n  name: string;\n}\n\nconst UserList: React.FC<{ users: User[] }> = ({ users }) => {\n  return (\n    <List\n      items={users}\n      keyExtractor={user => user.id}\n      renderItem={user => <span>{user.name}</span>}\n    />\n  );\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"hooks-with-typescript",children:"Hooks with TypeScript"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { useState, useEffect, useCallback, useMemo, useRef } from 'react';\n\n// useState with explicit types\nconst [count, setCount] = useState<number>(0);\nconst [user, setUser] = useState<User | null>(null);\nconst [loading, setLoading] = useState<boolean>(false);\n\n// useEffect with cleanup\nuseEffect(() => {\n  const timer = setTimeout(() => {\n    setCount(prev => prev + 1);\n  }, 1000);\n\n  return () => clearTimeout(timer);\n}, []);\n\n// useCallback with proper typing\nconst handleClick = useCallback((id: number) => {\n  console.log('Clicked:', id);\n}, []);\n\n// useMemo with type inference\nconst expensiveValue = useMemo(() => {\n  return items.filter(item => item.active).length;\n}, [items]);\n\n// useRef with DOM elements\nconst inputRef = useRef<HTMLInputElement>(null);\n\nconst focusInput = () => {\n  inputRef.current?.focus();\n};\n\n// Custom hook with TypeScript\ninterface UseApiResult<T> {\n  data: T | null;\n  loading: boolean;\n  error: string | null;\n  refetch: () => void;\n}\n\nfunction useApi<T>(url: string): UseApiResult<T> {\n  const [data, setData] = useState<T | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchData = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n      const response = await fetch(url);\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      const result = await response.json();\n      setData(result);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'An error occurred');\n    } finally {\n      setLoading(false);\n    }\n  }, [url]);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  return { data, loading, error, refetch: fetchData };\n}\n\n// Using the custom hook\ninterface ApiUser {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst UserComponent: React.FC = () => {\n  const { data: user, loading, error, refetch } = useApi<ApiUser>('/api/user/1');\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!user) return <div>No user found</div>;\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n      <button onClick={refetch}>Refresh</button>\n    </div>\n  );\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"context-with-typescript",children:"Context with TypeScript"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import React, { createContext, useContext, useReducer, ReactNode } from 'react';\n\n// State interface\ninterface AppState {\n  user: User | null;\n  theme: 'light' | 'dark';\n  notifications: Notification[];\n}\n\n// Actions\ntype AppAction = \n  | { type: 'SET_USER'; payload: User | null }\n  | { type: 'SET_THEME'; payload: 'light' | 'dark' }\n  | { type: 'ADD_NOTIFICATION'; payload: Notification }\n  | { type: 'REMOVE_NOTIFICATION'; payload: string };\n\n// Context type\ninterface AppContextType {\n  state: AppState;\n  dispatch: React.Dispatch<AppAction>;\n}\n\n// Create context\nconst AppContext = createContext<AppContextType | undefined>(undefined);\n\n// Reducer\nconst appReducer = (state: AppState, action: AppAction): AppState => {\n  switch (action.type) {\n    case 'SET_USER':\n      return { ...state, user: action.payload };\n    case 'SET_THEME':\n      return { ...state, theme: action.payload };\n    case 'ADD_NOTIFICATION':\n      return { \n        ...state, \n        notifications: [...state.notifications, action.payload] \n      };\n    case 'REMOVE_NOTIFICATION':\n      return {\n        ...state,\n        notifications: state.notifications.filter(n => n.id !== action.payload)\n      };\n    default:\n      return state;\n  }\n};\n\n// Provider component\ninterface AppProviderProps {\n  children: ReactNode;\n}\n\nexport const AppProvider: React.FC<AppProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(appReducer, {\n    user: null,\n    theme: 'light',\n    notifications: []\n  });\n\n  return (\n    <AppContext.Provider value={{ state, dispatch }}>\n      {children}\n    </AppContext.Provider>\n  );\n};\n\n// Custom hook\nexport const useAppContext = (): AppContextType => {\n  const context = useContext(AppContext);\n  if (!context) {\n    throw new Error('useAppContext must be used within an AppProvider');\n  }\n  return context;\n};\n"})}),"\n",(0,r.jsx)(n.h2,{id:"interview-questions",children:"Interview Questions"}),"\n",(0,r.jsx)(n.h3,{id:"1-what-is-typescript-and-why-would-you-use-it",children:"1. What is TypeScript and why would you use it?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer:"}),"\nTypeScript is a statically typed superset of JavaScript that compiles to plain JavaScript. Key benefits include:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Static Type Checking"}),": Catches errors at compile time rather than runtime"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better IDE Support"}),": Enhanced autocomplete, refactoring, and navigation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Self-Documenting Code"}),": Types serve as documentation for APIs and functions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Easier Refactoring"}),": Compiler helps identify breaking changes across codebase"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Better Team Collaboration"}),": Clear interfaces and contracts between team members"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"2-explain-the-difference-between-interface-and-type-in-typescript",children:["2. Explain the difference between ",(0,r.jsx)(n.code,{children:"interface"})," and ",(0,r.jsx)(n.code,{children:"type"})," in TypeScript."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Answer:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Interface - can be extended and merged\ninterface User {\n  name: string;\n  age: number;\n}\n\ninterface User {\n  email: string; // Declaration merging\n}\n\ninterface AdminUser extends User {\n  permissions: string[];\n}\n\n// Type - more flexible, supports unions, intersections\ntype Status = 'loading' | 'success' | 'error';\ntype User = {\n  name: string;\n  age: number;\n};\n\ntype AdminUser = User & {\n  permissions: string[];\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Key Differences:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interfaces"})," can be extended and merged, better for object shapes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Types"})," are more flexible, support unions, intersections, and primitives"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interfaces"})," are preferred for public APIs that might be extended"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Types"})," are preferred for complex type compositions"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-what-are-generics-and-why-are-they-useful",children:"3. What are generics and why are they useful?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer:"}),"\nGenerics allow you to write reusable code that works with multiple types while maintaining type safety."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'// Without generics - not reusable\nfunction identityString(arg: string): string {\n  return arg;\n}\n\nfunction identityNumber(arg: number): number {\n  return arg;\n}\n\n// With generics - reusable and type-safe\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nconst stringResult = identity<string>("hello"); // string\nconst numberResult = identity<number>(42); // number\n\n// Generic constraints\ninterface Lengthwise {\n  length: number;\n}\n\nfunction logLength<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); // Now we know it has a length property\n  return arg;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"4-how-do-you-handle-asynchronous-operations-in-typescript",children:"4. How do you handle asynchronous operations in TypeScript?"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Answer:"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Promise types\nasync function fetchUser(id: number): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  \n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n  \n  return response.json();\n}\n\n// Error handling with custom error types\nclass ApiError extends Error {\n  constructor(\n    message: string,\n    public status: number,\n    public code: string\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nasync function fetchUserWithErrorHandling(id: number): Promise<User> {\n  try {\n    const response = await fetch(`/api/users/${id}`);\n    \n    if (!response.ok) {\n      throw new ApiError(\n        `Failed to fetch user`,\n        response.status,\n        'FETCH_ERROR'\n      );\n    }\n    \n    return response.json();\n  } catch (error) {\n    if (error instanceof ApiError) {\n      console.error('API Error:', error.message, error.status);\n    } else {\n      console.error('Unknown error:', error);\n    }\n    throw error;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"5-what-are-utility-types-and-how-do-you-use-them",children:"5. What are utility types and how do you use them?"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Answer:"}),"\nUtility types are built-in TypeScript types that help transform existing types."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\n// Partial - makes all properties optional\ntype PartialUser = Partial<User>;\n// { id?: number; name?: string; email?: string; age?: number; }\n\n// Pick - selects specific properties\ntype UserPreview = Pick<User, 'id' | 'name'>;\n// { id: number; name: string; }\n\n// Omit - excludes specific properties\ntype CreateUserRequest = Omit<User, 'id'>;\n// { name: string; email: string; age: number; }\n\n// Record - creates object with specific key/value types\ntype UserRoles = Record<string, string[]>;\n// { [key: string]: string[] }\n\n// ReturnType - extracts function return type\nfunction getUser(): User {\n  return { id: 1, name: 'John', email: 'john@example.com', age: 25 };\n}\n\ntype GetUserReturn = ReturnType<typeof getUser>; // User\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-type-definitions",children:"1. Type Definitions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good - Use interfaces for object shapes\ninterface User {\n  readonly id: number;\n  name: string;\n  email: string;\n  age?: number;\n}\n\n// \u2705 Good - Use types for unions and computed types\ntype Status = 'loading' | 'success' | 'error';\ntype UserKeys = keyof User;\n\n// \u274c Avoid - Don't use any\nfunction process(data: any): any {\n  return data;\n}\n\n// \u2705 Good - Use unknown for unknown data\nfunction process(data: unknown): string {\n  if (typeof data === 'string') {\n    return data.toUpperCase();\n  }\n  return String(data);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-function-types",children:"2. Function Types"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good - Explicit return types for public APIs\nfunction calculateTotal(items: Item[]): number {\n  return items.reduce((sum, item) => sum + item.price, 0);\n}\n\n// \u2705 Good - Use readonly for arrays that shouldn't be modified\nfunction processItems(items: readonly Item[]): Item[] {\n  return items.filter(item => item.active);\n}\n\n// \u2705 Good - Use function overloads for multiple signatures\nfunction format(value: string): string;\nfunction format(value: number): string;\nfunction format(value: Date): string;\nfunction format(value: string | number | Date): string {\n  if (value instanceof Date) {\n    return value.toISOString();\n  }\n  return String(value);\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-error-handling",children:"3. Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// \u2705 Good - Custom error types\nclass ValidationError extends Error {\n  constructor(\n    message: string,\n    public field: string,\n    public code: string\n  ) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\n// \u2705 Good - Result type pattern\ntype Result<T, E = Error> = \n  | { success: true; data: T }\n  | { success: false; error: E };\n\nasync function safeApiCall<T>(url: string): Promise<Result<T>> {\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    return { success: true, data };\n  } catch (error) {\n    return { \n      success: false, \n      error: error instanceof Error ? error : new Error(String(error))\n    };\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"1-builder-pattern",children:"1. Builder Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"class UserBuilder {\n  private user: Partial<User> = {};\n\n  setName(name: string): this {\n    this.user.name = name;\n    return this;\n  }\n\n  setEmail(email: string): this {\n    this.user.email = email;\n    return this;\n  }\n\n  setAge(age: number): this {\n    this.user.age = age;\n    return this;\n  }\n\n  build(): User {\n    if (!this.user.name || !this.user.email) {\n      throw new Error('Name and email are required');\n    }\n    \n    return {\n      id: Math.random(),\n      name: this.user.name,\n      email: this.user.email,\n      age: this.user.age || 18\n    };\n  }\n}\n\n// Usage\nconst user = new UserBuilder()\n  .setName('John')\n  .setEmail('john@example.com')\n  .setAge(25)\n  .build();\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-factory-pattern",children:"2. Factory Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface Shape {\n  area(): number;\n  perimeter(): number;\n}\n\nclass Circle implements Shape {\n  constructor(private radius: number) {}\n\n  area(): number {\n    return Math.PI * this.radius ** 2;\n  }\n\n  perimeter(): number {\n    return 2 * Math.PI * this.radius;\n  }\n}\n\nclass Rectangle implements Shape {\n  constructor(private width: number, private height: number) {}\n\n  area(): number {\n    return this.width * this.height;\n  }\n\n  perimeter(): number {\n    return 2 * (this.width + this.height);\n  }\n}\n\ntype ShapeType = 'circle' | 'rectangle';\n\ninterface ShapeConfig {\n  type: 'circle';\n  radius: number;\n} | {\n  type: 'rectangle';\n  width: number;\n  height: number;\n};\n\nclass ShapeFactory {\n  static createShape(config: ShapeConfig): Shape {\n    switch (config.type) {\n      case 'circle':\n        return new Circle(config.radius);\n      case 'rectangle':\n        return new Rectangle(config.width, config.height);\n      default:\n        throw new Error('Unknown shape type');\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-repository-pattern",children:"3. Repository Pattern"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface Repository<T> {\n  findById(id: string): Promise<T | null>;\n  findAll(): Promise<T[]>;\n  create(item: Omit<T, 'id'>): Promise<T>;\n  update(id: string, item: Partial<T>): Promise<T>;\n  delete(id: string): Promise<void>;\n}\n\nclass UserRepository implements Repository<User> {\n  constructor(private apiClient: ApiClient) {}\n\n  async findById(id: string): Promise<User | null> {\n    try {\n      const response = await this.apiClient.get(`/users/${id}`);\n      return response.data;\n    } catch (error) {\n      if (error.status === 404) {\n        return null;\n      }\n      throw error;\n    }\n  }\n\n  async findAll(): Promise<User[]> {\n    const response = await this.apiClient.get('/users');\n    return response.data;\n  }\n\n  async create(userData: Omit<User, 'id'>): Promise<User> {\n    const response = await this.apiClient.post('/users', userData);\n    return response.data;\n  }\n\n  async update(id: string, userData: Partial<User>): Promise<User> {\n    const response = await this.apiClient.put(`/users/${id}`, userData);\n    return response.data;\n  }\n\n  async delete(id: string): Promise<void> {\n    await this.apiClient.delete(`/users/${id}`);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This comprehensive TypeScript guide covers all the essential concepts and patterns you'll need for frontend interviews. The key is to understand not just the syntax, but when and why to use different TypeScript features to write more maintainable and type-safe code."})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);