"use strict";(self.webpackChunkfrontend_interview_guide=self.webpackChunkfrontend_interview_guide||[]).push([[1044],{403:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var s=t(4848),r=t(8453);const a={},i="State Management for Frontend Interviews",o={id:"frontend/system-design/state-management",title:"State Management for Frontend Interviews",description:"Qu\u1ea3n l\xfd tr\u1ea1ng th\xe1i cho ph\u1ecfng v\u1ea5n Frontend",source:"@site/docs/frontend/system-design/state-management.md",sourceDirName:"frontend/system-design",slug:"/frontend/system-design/state-management",permalink:"/interview/docs/frontend/system-design/state-management",draft:!1,unlisted:!1,editUrl:"https://github.com/Nhi4912/interview/tree/main/docs/frontend/system-design/state-management.md",tags:[],version:"current",frontMatter:{},sidebar:"frontendSidebar",previous:{title:"Component Design for Frontend Interviews",permalink:"/interview/docs/frontend/system-design/component-design"},next:{title:"Frontend Performance for Interviews",permalink:"/interview/docs/frontend/system-design/performance"}},l={},c=[{value:"1. Why State Management?",id:"1-why-state-management",level:2},{value:"2. Tools &amp; Libraries",id:"2-tools--libraries",level:2},{value:"3. Patterns",id:"3-patterns",level:2},{value:"4. Best Practices",id:"4-best-practices",level:2},{value:"5. Interview Questions",id:"5-interview-questions",level:2},{value:"6. Resources",id:"6-resources",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"State Management Fundamentals",id:"state-management-fundamentals",level:3},{value:"State Management Patterns",id:"state-management-patterns",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Modern State Management",id:"modern-state-management",level:3},{value:"State Synchronization",id:"state-synchronization",level:3},{value:"Common Interview Questions &amp; Answers",id:"common-interview-questions--answers",level:2},{value:"State Management Questions",id:"state-management-questions",level:3},{value:"Advanced Questions",id:"advanced-questions",level:3},{value:"Practical Problems &amp; Solutions",id:"practical-problems--solutions",level:2},{value:"Problem 1: Implement a Custom State Management Library",id:"problem-1-implement-a-custom-state-management-library",level:3},{value:"Problem 2: Create a Form State Manager",id:"problem-2-create-a-form-state-manager",level:3},{value:"Problem 3: Implement Redux with Middleware",id:"problem-3-implement-redux-with-middleware",level:3},{value:"Problem 4: Create a State Persistence System",id:"problem-4-create-a-state-persistence-system",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"State Structure",id:"state-structure",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Testing",id:"testing",level:3},{value:"Resources",id:"resources",level:2},{value:"Documentation",id:"documentation",level:3},{value:"Tools",id:"tools",level:3},{value:"Practice Platforms",id:"practice-platforms",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"state-management-for-frontend-interviews",children:"State Management for Frontend Interviews"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Qu\u1ea3n l\xfd tr\u1ea1ng th\xe1i cho ph\u1ecfng v\u1ea5n Frontend"})}),"\n",(0,s.jsx)(n.h2,{id:"1-why-state-management",children:"1. Why State Management?"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Local state:"})," useState, useReducer, component state."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Global state:"})," Shared across app (user, theme, cart)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Server state:"})," Data from API, cache, sync."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"2-tools--libraries",children:"2. Tools & Libraries"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Redux:"})," Predictable, single source, middleware (thunk, saga), devtools."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Context API:"})," Lightweight, for small/medium apps, avoid prop drilling."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"MobX:"})," Observable, reactive, less boilerplate."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zustand:"})," Minimal, hooks-based, scalable."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Recoil:"})," Atom/selectors, async, React integration."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Jotai, XState, Akita:"})," Other options."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3-patterns",children:"3. Patterns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lifting state up:"})," Move state to common ancestor."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Derived state:"})," Compute from other state, avoid duplication."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Selector functions:"})," Memoize, reselect."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Normalized state:"})," Store by ID, avoid deep nesting."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"4-best-practices",children:"4. Best Practices"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Keep state minimal:"})," Only what you need."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Avoid prop drilling:"})," Use context or global store."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Immutable updates:"})," Spread/rest, immer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testing:"})," Mock store, test reducers/selectors."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance:"})," Avoid unnecessary re-renders, use memoization."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"5-interview-questions",children:"5. Interview Questions"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"When to use Redux vs Context?"}),"\n",(0,s.jsx)(n.li,{children:"How to handle async state (API calls)?"}),"\n",(0,s.jsx)(n.li,{children:"How to avoid prop drilling?"}),"\n",(0,s.jsx)(n.li,{children:"How to test state logic?"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"6-resources",children:"6. Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://redux.js.org/",children:"Redux Docs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://mobx.js.org/",children:"MobX Docs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.pmnd.rs/zustand/getting-started/introduction",children:"Zustand"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://recoiljs.org/",children:"Recoil"})}),"\n"]}),"\n",(0,s.jsx)(n.h1,{id:"state-management-interview-preparation",children:"State Management Interview Preparation"}),"\n",(0,s.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"state-management-fundamentals",children:"State Management Fundamentals"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Local State"}),": Component-level state (useState, useReducer)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Global State"}),": Application-wide state shared across components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Server State"}),": Data fetched from APIs and cached"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Form State"}),": User input and form validation state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"UI State"}),": Loading, error, modal, navigation states"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"state-management-patterns",children:"State Management Patterns"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Flux Architecture"}),": Unidirectional data flow"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Redux Pattern"}),": Predictable state container"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Context API"}),": React's built-in state sharing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Atomic State"}),": Small, focused state pieces"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Sourcing"}),": State as sequence of events"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,s.jsx)(n.h3,{id:"modern-state-management",children:"Modern State Management"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Redux Toolkit"}),": Simplified Redux with RTK Query"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Zustand"}),": Lightweight state management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Jotai"}),": Atomic state management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Recoil"}),": Facebook's experimental state management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"XState"}),": State machines and statecharts"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"state-synchronization",children:"State Synchronization"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimistic Updates"}),": Update UI before server confirmation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pessimistic Updates"}),": Wait for server response"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-time Sync"}),": WebSocket state synchronization"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Offline Support"}),": Local state with sync when online"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Conflict Resolution"}),": Handling concurrent updates"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-interview-questions--answers",children:"Common Interview Questions & Answers"}),"\n",(0,s.jsx)(n.h3,{id:"state-management-questions",children:"State Management Questions"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Q: When would you use Redux vs Context API vs local state?"}),"\nA:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Local State"}),": Component-specific data, form inputs, UI toggles"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Context API"}),": Theme, authentication, user preferences, simple global state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Redux"}),": Complex application state, multiple data sources, debugging needs"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Q: Explain the Redux flow and its three principles."}),"\nA: Redux follows unidirectional data flow:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Store"}),": Single source of truth"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Actions"}),": Plain objects describing what happened"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reducers"}),": Pure functions that update state"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Three Principles"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Single source of truth"}),"\n",(0,s.jsx)(n.li,{children:"State is read-only"}),"\n",(0,s.jsx)(n.li,{children:"Changes made with pure functions"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Q: What are the benefits and drawbacks of Redux?"}),"\nA:\n",(0,s.jsx)(n.strong,{children:"Benefits"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Predictable state updates"}),"\n",(0,s.jsx)(n.li,{children:"Great debugging with DevTools"}),"\n",(0,s.jsx)(n.li,{children:"Middleware ecosystem"}),"\n",(0,s.jsx)(n.li,{children:"Time-travel debugging"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Drawbacks"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Boilerplate code"}),"\n",(0,s.jsx)(n.li,{children:"Learning curve"}),"\n",(0,s.jsx)(n.li,{children:"Overkill for simple apps"}),"\n",(0,s.jsx)(n.li,{children:"Performance overhead"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"advanced-questions",children:"Advanced Questions"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Q: How would you implement optimistic updates in a state management system?"}),"\nA: Optimistic updates modify UI immediately, then sync with server:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Redux Toolkit example\nconst userSlice = createSlice({\n  name: "user",\n  initialState: { users: [], loading: false },\n  reducers: {\n    addUserOptimistic: (state, action) => {\n      state.users.push({ ...action.payload, id: "temp-" + Date.now() });\n    },\n    addUserSuccess: (state, action) => {\n      const index = state.users.findIndex((u) => u.id.startsWith("temp-"));\n      if (index !== -1) {\n        state.users[index] = action.payload;\n      }\n    },\n    addUserFailure: (state, action) => {\n      state.users = state.users.filter((u) => !u.id.startsWith("temp-"));\n    },\n  },\n});\n\n// Usage\nconst addUser = (userData) => async (dispatch) => {\n  // Optimistic update\n  dispatch(addUserOptimistic(userData));\n\n  try {\n    const response = await api.createUser(userData);\n    dispatch(addUserSuccess(response.data));\n  } catch (error) {\n    dispatch(addUserFailure(error));\n  }\n};\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Q: How would you implement real-time state synchronization?"}),"\nA: Using WebSockets with state management:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class RealTimeStateManager {\n  constructor(store) {\n    this.store = store;\n    this.socket = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n  }\n\n  connect(url) {\n    this.socket = new WebSocket(url);\n\n    this.socket.onopen = () => {\n      console.log("WebSocket connected");\n      this.reconnectAttempts = 0;\n    };\n\n    this.socket.onmessage = (event) => {\n      const data = JSON.parse(event.data);\n      this.handleMessage(data);\n    };\n\n    this.socket.onclose = () => {\n      console.log("WebSocket disconnected");\n      this.scheduleReconnect();\n    };\n  }\n\n  handleMessage(data) {\n    switch (data.type) {\n      case "USER_UPDATED":\n        this.store.dispatch(updateUser(data.payload));\n        break;\n      case "MESSAGE_RECEIVED":\n        this.store.dispatch(addMessage(data.payload));\n        break;\n      case "STATUS_CHANGED":\n        this.store.dispatch(updateUserStatus(data.payload));\n        break;\n    }\n  }\n\n  sendMessage(type, payload) {\n    if (this.socket?.readyState === WebSocket.OPEN) {\n      this.socket.send(JSON.stringify({ type, payload }));\n    }\n  }\n\n  scheduleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const delay = Math.pow(2, this.reconnectAttempts) * 1000;\n\n      setTimeout(() => {\n        this.connect(this.socket.url);\n      }, delay);\n    }\n  }\n}\n\n// Usage\nconst realTimeManager = new RealTimeStateManager(store);\nrealTimeManager.connect("wss://api.example.com/ws");\n'})}),"\n",(0,s.jsx)(n.h2,{id:"practical-problems--solutions",children:"Practical Problems & Solutions"}),"\n",(0,s.jsx)(n.h3,{id:"problem-1-implement-a-custom-state-management-library",children:"Problem 1: Implement a Custom State Management Library"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Challenge"}),": Create a lightweight state management library similar to Zustand."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class SimpleStore {\n  constructor(initialState = {}) {\n    this.state = initialState;\n    this.listeners = new Set();\n    this.middleware = [];\n  }\n\n  getState() {\n    return this.state;\n  }\n\n  setState(partial) {\n    const prevState = { ...this.state };\n    this.state = { ...this.state, ...partial };\n\n    // Run middleware\n    this.middleware.forEach((middleware) => {\n      middleware(prevState, this.state);\n    });\n\n    // Notify listeners\n    this.listeners.forEach((listener) => listener(this.state, prevState));\n  }\n\n  subscribe(listener) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  useMiddleware(middleware) {\n    this.middleware.push(middleware);\n  }\n\n  // Action creators\n  createAction(type, payload) {\n    return { type, payload, timestamp: Date.now() };\n  }\n\n  dispatch(action) {\n    // Log action for debugging\n    console.log("Action:", action);\n\n    // Update state based on action\n    switch (action.type) {\n      case "INCREMENT":\n        this.setState({ count: this.state.count + 1 });\n        break;\n      case "SET_USER":\n        this.setState({ user: action.payload });\n        break;\n      case "ADD_TODO":\n        this.setState({\n          todos: [...this.state.todos, action.payload],\n        });\n        break;\n      default:\n        console.warn("Unknown action type:", action.type);\n    }\n  }\n}\n\n// React hook for using the store\nfunction useStore(store, selector) {\n  const [state, setState] = React.useState(() => selector(store.getState()));\n\n  React.useEffect(() => {\n    const unsubscribe = store.subscribe((newState) => {\n      const newSelectedState = selector(newState);\n      setState(newSelectedState);\n    });\n\n    return unsubscribe;\n  }, [store, selector]);\n\n  return state;\n}\n\n// Usage\nconst store = new SimpleStore({\n  count: 0,\n  user: null,\n  todos: [],\n});\n\n// Add logging middleware\nstore.useMiddleware((prevState, newState) => {\n  console.log("State changed:", { prevState, newState });\n});\n\n// React component\nfunction Counter() {\n  const count = useStore(store, (state) => state.count);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => store.dispatch({ type: "INCREMENT" })}>\n        Increment\n      </button>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"problem-2-create-a-form-state-manager",children:"Problem 2: Create a Form State Manager"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Challenge"}),": Build a comprehensive form state management system with validation and error handling."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class FormStateManager {\n  constructor(initialValues = {}, validationSchema = {}) {\n    this.initialValues = initialValues;\n    this.validationSchema = validationSchema;\n    this.state = {\n      values: { ...initialValues },\n      errors: {},\n      touched: {},\n      isValid: true,\n      isDirty: false,\n      isSubmitting: false,\n    };\n    this.listeners = new Set();\n  }\n\n  getFieldValue(name) {\n    return this.state.values[name];\n  }\n\n  setFieldValue(name, value) {\n    const newValues = { ...this.state.values, [name]: value };\n    const newErrors = this.validateField(name, value);\n    const newTouched = { ...this.state.touched, [name]: true };\n\n    this.setState({\n      values: newValues,\n      errors: { ...this.state.errors, [name]: newErrors[name] },\n      touched: newTouched,\n      isDirty: true,\n      isValid: this.validateForm(newValues),\n    });\n  }\n\n  setFieldError(name, error) {\n    this.setState({\n      errors: { ...this.state.errors, [name]: error },\n      isValid: this.validateForm(this.state.values),\n    });\n  }\n\n  validateField(name, value) {\n    const fieldSchema = this.validationSchema[name];\n    if (!fieldSchema) return {};\n\n    const errors = {};\n\n    // Required validation\n    if (fieldSchema.required && (!value || value.trim() === "")) {\n      errors[name] = fieldSchema.required;\n    }\n\n    // Pattern validation\n    if (fieldSchema.pattern && value && !fieldSchema.pattern.test(value)) {\n      errors[name] = fieldSchema.patternMessage || "Invalid format";\n    }\n\n    // Custom validation\n    if (fieldSchema.validate) {\n      const customError = fieldSchema.validate(value, this.state.values);\n      if (customError) {\n        errors[name] = customError;\n      }\n    }\n\n    return errors;\n  }\n\n  validateForm(values) {\n    const errors = {};\n\n    Object.keys(this.validationSchema).forEach((fieldName) => {\n      const fieldErrors = this.validateField(fieldName, values[fieldName]);\n      Object.assign(errors, fieldErrors);\n    });\n\n    return Object.keys(errors).length === 0;\n  }\n\n  handleSubmit(onSubmit) {\n    return async (event) => {\n      event?.preventDefault();\n\n      if (!this.state.isValid) {\n        // Mark all fields as touched to show errors\n        const touched = {};\n        Object.keys(this.validationSchema).forEach((key) => {\n          touched[key] = true;\n        });\n\n        this.setState({ touched });\n        return;\n      }\n\n      this.setState({ isSubmitting: true });\n\n      try {\n        await onSubmit(this.state.values);\n        this.setState({ isSubmitting: false });\n      } catch (error) {\n        this.setState({\n          isSubmitting: false,\n          errors: { submit: error.message },\n        });\n      }\n    };\n  }\n\n  reset() {\n    this.setState({\n      values: { ...this.initialValues },\n      errors: {},\n      touched: {},\n      isValid: true,\n      isDirty: false,\n      isSubmitting: false,\n    });\n  }\n\n  setState(partial) {\n    this.state = { ...this.state, ...partial };\n    this.listeners.forEach((listener) => listener(this.state));\n  }\n\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n}\n\n// React hook for form state\nfunction useFormState(formManager) {\n  const [state, setState] = React.useState(formManager.state);\n\n  React.useEffect(() => {\n    return formManager.subscribe(setState);\n  }, [formManager]);\n\n  return {\n    ...state,\n    setFieldValue: formManager.setFieldValue.bind(formManager),\n    setFieldError: formManager.setFieldError.bind(formManager),\n    handleSubmit: formManager.handleSubmit.bind(formManager),\n    reset: formManager.reset.bind(formManager),\n  };\n}\n\n// Usage\nconst validationSchema = {\n  email: {\n    required: "Email is required",\n    pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n    patternMessage: "Invalid email format",\n  },\n  password: {\n    required: "Password is required",\n    validate: (value) => {\n      if (value.length < 8) {\n        return "Password must be at least 8 characters";\n      }\n      return null;\n    },\n  },\n};\n\nconst formManager = new FormStateManager(\n  { email: "", password: "" },\n  validationSchema\n);\n\nfunction LoginForm() {\n  const {\n    values,\n    errors,\n    touched,\n    isValid,\n    isSubmitting,\n    setFieldValue,\n    handleSubmit,\n  } = useFormState(formManager);\n\n  const onSubmit = async (values) => {\n    const response = await fetch("/api/login", {\n      method: "POST",\n      headers: { "Content-Type": "application/json" },\n      body: JSON.stringify(values),\n    });\n\n    if (!response.ok) {\n      throw new Error("Login failed");\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <div>\n        <input\n          type="email"\n          value={values.email}\n          onChange={(e) => setFieldValue("email", e.target.value)}\n          placeholder="Email"\n        />\n        {touched.email && errors.email && (\n          <span className="error">{errors.email}</span>\n        )}\n      </div>\n\n      <div>\n        <input\n          type="password"\n          value={values.password}\n          onChange={(e) => setFieldValue("password", e.target.value)}\n          placeholder="Password"\n        />\n        {touched.password && errors.password && (\n          <span className="error">{errors.password}</span>\n        )}\n      </div>\n\n      <button type="submit" disabled={!isValid || isSubmitting}>\n        {isSubmitting ? "Logging in..." : "Login"}\n      </button>\n    </form>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"problem-3-implement-redux-with-middleware",children:"Problem 3: Implement Redux with Middleware"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Challenge"}),": Create a Redux-like state management system with middleware support."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'// Action types\nconst ActionTypes = {\n  INIT: "@@redux/INIT",\n};\n\n// Create store\nfunction createStore(reducer, initialState, enhancer) {\n  if (typeof enhancer === "function") {\n    return enhancer(createStore)(reducer, initialState);\n  }\n\n  let state = initialState;\n  let listeners = [];\n  let isDispatching = false;\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error("Cannot call getState while dispatching");\n    }\n    return state;\n  }\n\n  function subscribe(listener) {\n    if (typeof listener !== "function") {\n      throw new Error("Listener must be a function");\n    }\n\n    let isSubscribed = true;\n    listeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) return;\n\n      isSubscribed = false;\n      const index = listeners.indexOf(listener);\n      listeners.splice(index, 1);\n    };\n  }\n\n  function dispatch(action) {\n    if (!action || typeof action.type === "undefined") {\n      throw new Error("Actions must have a type property");\n    }\n\n    if (isDispatching) {\n      throw new Error("Reducers may not dispatch actions");\n    }\n\n    try {\n      isDispatching = true;\n      state = reducer(state, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    listeners.forEach((listener) => listener());\n    return action;\n  }\n\n  // Initialize store\n  dispatch({ type: ActionTypes.INIT });\n\n  return {\n    getState,\n    subscribe,\n    dispatch,\n  };\n}\n\n// Apply middleware\nfunction applyMiddleware(...middlewares) {\n  return (createStore) => (reducer, initialState) => {\n    const store = createStore(reducer, initialState);\n    let dispatch = store.dispatch;\n\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) => dispatch(action),\n    };\n\n    const chain = middlewares.map((middleware) => middleware(middlewareAPI));\n    dispatch = compose(...chain)(store.dispatch);\n\n    return {\n      ...store,\n      dispatch,\n    };\n  };\n}\n\n// Compose functions\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return (arg) => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(\n    (a, b) =>\n      (...args) =>\n        a(b(...args))\n  );\n}\n\n// Logger middleware\nfunction logger(middlewareAPI) {\n  return (next) => (action) => {\n    console.group(action.type);\n    console.log("Previous State:", middlewareAPI.getState());\n    console.log("Action:", action);\n\n    const result = next(action);\n\n    console.log("Next State:", middlewareAPI.getState());\n    console.groupEnd();\n\n    return result;\n  };\n}\n\n// Thunk middleware\nfunction thunk(middlewareAPI) {\n  return (next) => (action) => {\n    if (typeof action === "function") {\n      return action(middlewareAPI.dispatch, middlewareAPI.getState);\n    }\n    return next(action);\n  };\n}\n\n// Example reducer\nfunction counterReducer(state = { count: 0 }, action) {\n  switch (action.type) {\n    case "INCREMENT":\n      return { ...state, count: state.count + 1 };\n    case "DECREMENT":\n      return { ...state, count: state.count - 1 };\n    case "SET_COUNT":\n      return { ...state, count: action.payload };\n    default:\n      return state;\n  }\n}\n\n// Action creators\nconst increment = () => ({ type: "INCREMENT" });\nconst decrement = () => ({ type: "DECREMENT" });\nconst setCount = (count) => ({ type: "SET_COUNT", payload: count });\n\n// Async action creator\nconst incrementAsync = () => (dispatch, getState) => {\n  setTimeout(() => {\n    dispatch(increment());\n  }, 1000);\n};\n\n// Create store with middleware\nconst store = createStore(\n  counterReducer,\n  { count: 0 },\n  applyMiddleware(logger, thunk)\n);\n\n// Usage\nstore.subscribe(() => {\n  console.log("State:", store.getState());\n});\n\nstore.dispatch(increment()); // 1\nstore.dispatch(incrementAsync()); // 2 (after 1 second)\nstore.dispatch(setCount(10)); // 10\n'})}),"\n",(0,s.jsx)(n.h3,{id:"problem-4-create-a-state-persistence-system",children:"Problem 4: Create a State Persistence System"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Challenge"}),": Implement a system to persist and rehydrate state across browser sessions."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'class StatePersistence {\n  constructor(storage = localStorage, key = "app-state") {\n    this.storage = storage;\n    this.key = key;\n    this.subscribers = new Set();\n  }\n\n  save(state, options = {}) {\n    const {\n      includeKeys = null,\n      excludeKeys = null,\n      transform = null,\n    } = options;\n\n    let stateToSave = state;\n\n    // Filter keys\n    if (includeKeys) {\n      stateToSave = Object.keys(state)\n        .filter((key) => includeKeys.includes(key))\n        .reduce((obj, key) => {\n          obj[key] = state[key];\n          return obj;\n        }, {});\n    }\n\n    if (excludeKeys) {\n      stateToSave = Object.keys(state)\n        .filter((key) => !excludeKeys.includes(key))\n        .reduce((obj, key) => {\n          obj[key] = state[key];\n          return obj;\n        }, {});\n    }\n\n    // Transform state\n    if (transform) {\n      stateToSave = transform(stateToSave);\n    }\n\n    try {\n      const serialized = JSON.stringify(stateToSave);\n      this.storage.setItem(this.key, serialized);\n      this.notifySubscribers("saved", stateToSave);\n    } catch (error) {\n      console.error("Failed to save state:", error);\n      this.notifySubscribers("error", error);\n    }\n  }\n\n  load(options = {}) {\n    const { transform = null, defaultValue = {} } = options;\n\n    try {\n      const serialized = this.storage.getItem(this.key);\n      if (!serialized) {\n        return defaultValue;\n      }\n\n      let state = JSON.parse(serialized);\n\n      // Transform state\n      if (transform) {\n        state = transform(state);\n      }\n\n      this.notifySubscribers("loaded", state);\n      return state;\n    } catch (error) {\n      console.error("Failed to load state:", error);\n      this.notifySubscribers("error", error);\n      return defaultValue;\n    }\n  }\n\n  clear() {\n    try {\n      this.storage.removeItem(this.key);\n      this.notifySubscribers("cleared");\n    } catch (error) {\n      console.error("Failed to clear state:", error);\n      this.notifySubscribers("error", error);\n    }\n  }\n\n  subscribe(callback) {\n    this.subscribers.add(callback);\n    return () => this.subscribers.delete(callback);\n  }\n\n  notifySubscribers(event, data) {\n    this.subscribers.forEach((callback) => {\n      try {\n        callback(event, data);\n      } catch (error) {\n        console.error("Subscriber error:", error);\n      }\n    });\n  }\n}\n\n// Enhanced store with persistence\nfunction createPersistentStore(reducer, initialState, options = {}) {\n  const {\n    storage = localStorage,\n    key = "app-state",\n    includeKeys = null,\n    excludeKeys = null,\n    transform = null,\n  } = options;\n\n  const persistence = new StatePersistence(storage, key);\n\n  // Load initial state from storage\n  const savedState = persistence.load({\n    transform,\n    defaultValue: initialState,\n  });\n  const store = createStore(reducer, savedState);\n\n  // Subscribe to state changes and save\n  store.subscribe(() => {\n    const currentState = store.getState();\n    persistence.save(currentState, { includeKeys, excludeKeys, transform });\n  });\n\n  // Add persistence methods to store\n  store.persist = {\n    clear: () => persistence.clear(),\n    on: (event, callback) => persistence.subscribe(callback),\n  };\n\n  return store;\n}\n\n// Usage\nconst counterReducer = (state = { count: 0, lastUpdated: null }, action) => {\n  switch (action.type) {\n    case "INCREMENT":\n      return {\n        ...state,\n        count: state.count + 1,\n        lastUpdated: new Date().toISOString(),\n      };\n    case "DECREMENT":\n      return {\n        ...state,\n        count: state.count - 1,\n        lastUpdated: new Date().toISOString(),\n      };\n    default:\n      return state;\n  }\n};\n\n// Create persistent store\nconst store = createPersistentStore(\n  counterReducer,\n  { count: 0, lastUpdated: null },\n  {\n    key: "counter-state",\n    includeKeys: ["count"], // Only persist count\n    transform: (state) => ({\n      ...state,\n      version: "1.0", // Add version for migration\n    }),\n  }\n);\n\n// Listen to persistence events\nstore.persist.on("saved", (state) => {\n  console.log("State saved:", state);\n});\n\nstore.persist.on("loaded", (state) => {\n  console.log("State loaded:", state);\n});\n\nstore.persist.on("error", (error) => {\n  console.error("Persistence error:", error);\n});\n\n// Use the store\nstore.dispatch({ type: "INCREMENT" });\n// State will be automatically saved to localStorage\n\n// Clear persisted state\n// store.persist.clear();\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"state-structure",children:"State Structure"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Normalize complex data structures"}),"\n",(0,s.jsx)(n.li,{children:"Keep state flat and avoid nesting"}),"\n",(0,s.jsx)(n.li,{children:"Separate UI state from business logic"}),"\n",(0,s.jsx)(n.li,{children:"Use selectors for derived state"}),"\n",(0,s.jsx)(n.li,{children:"Implement proper error boundaries"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use React.memo for expensive components"}),"\n",(0,s.jsx)(n.li,{children:"Implement proper memoization with useMemo/useCallback"}),"\n",(0,s.jsx)(n.li,{children:"Avoid unnecessary re-renders"}),"\n",(0,s.jsx)(n.li,{children:"Use React DevTools Profiler"}),"\n",(0,s.jsx)(n.li,{children:"Implement code splitting for large state"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"testing",children:"Testing"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Test reducers as pure functions"}),"\n",(0,s.jsx)(n.li,{children:"Mock external dependencies"}),"\n",(0,s.jsx)(n.li,{children:"Test async actions with proper setup/teardown"}),"\n",(0,s.jsx)(n.li,{children:"Use snapshot testing for UI components"}),"\n",(0,s.jsx)(n.li,{children:"Implement integration tests for state flows"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsx)(n.h3,{id:"documentation",children:"Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://redux.js.org/",children:"Redux Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://redux-toolkit.js.org/",children:"Redux Toolkit"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactjs.org/docs/context.html",children:"React Context API"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/pmndrs/zustand",children:"Zustand"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tools",children:"Tools"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/reduxjs/redux-devtools",children:"Redux DevTools"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://reactjs.org/blog/2019/08/15/new-react-devtools.html",children:"React DevTools"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://immerjs.github.io/immer/",children:"Immer"})," - Immutable updates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/reduxjs/reselect",children:"Reselect"})," - Memoized selectors"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"practice-platforms",children:"Practice Platforms"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://redux-toolkit.js.org/introduction/quick-start",children:"Redux Toolkit Examples"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://kentcdodds.com/blog/application-state-management-with-react",children:"React State Management Patterns"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://redux.js.org/style-guide/",children:"State Management Best Practices"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"This guide covers essential state management concepts for frontend interviews, including practical problems and advanced techniques commonly asked at companies companies."})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const r={},a=s.createContext(r);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);