"use strict";(self.webpackChunkfrontend_interview_guide=self.webpackChunkfrontend_interview_guide||[]).push([[1203],{8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var t=r(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}},8775:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"frontend/browser-apis/README","title":"Browser APIs & Modern Web Platform","description":"Table of Contents","source":"@site/docs/frontend/browser-apis/README.md","sourceDirName":"frontend/browser-apis","slug":"/frontend/browser-apis/","permalink":"/interview/docs/frontend/browser-apis/","draft":false,"unlisted":false,"editUrl":"https://github.com/Nhi4912/interview/tree/main/docs/frontend/browser-apis/README.md","tags":[],"version":"current","frontMatter":{}}');var s=r(4848),a=r(8453);const o={},i="Browser APIs & Modern Web Platform",c={},l=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Web Workers",id:"web-workers",level:2},{value:"Basic Web Worker",id:"basic-web-worker",level:3},{value:"Advanced Web Worker with Shared Array Buffer",id:"advanced-web-worker-with-shared-array-buffer",level:3},{value:"Service Workers",id:"service-workers",level:2},{value:"Basic Service Worker",id:"basic-service-worker",level:3},{value:"Advanced Service Worker with Strategies",id:"advanced-service-worker-with-strategies",level:3},{value:"Progressive Web Apps (PWA)",id:"progressive-web-apps-pwa",level:2},{value:"Web App Manifest",id:"web-app-manifest",level:3},{value:"PWA Installation",id:"pwa-installation",level:3},{value:"Web Storage APIs",id:"web-storage-apis",level:2},{value:"IndexedDB",id:"indexeddb",level:3},{value:"Cache API",id:"cache-api",level:3},{value:"Geolocation API",id:"geolocation-api",level:2},{value:"Camera &amp; Media APIs",id:"camera--media-apis",level:2},{value:"getUserMedia for Camera Access",id:"getusermedia-for-camera-access",level:3},{value:"Intersection Observer",id:"intersection-observer",level:2},{value:"Interview Questions",id:"interview-questions",level:2},{value:"1. What are Web Workers and when would you use them?",id:"1-what-are-web-workers-and-when-would-you-use-them",level:3},{value:"2. Explain the difference between Service Workers and Web Workers.",id:"2-explain-the-difference-between-service-workers-and-web-workers",level:3},{value:"3. How do you implement offline functionality in a web app?",id:"3-how-do-you-implement-offline-functionality-in-a-web-app",level:3},{value:"4. What is the Intersection Observer API and its benefits?",id:"4-what-is-the-intersection-observer-api-and-its-benefits",level:3},{value:"5. How do you handle camera and media access in web applications?",id:"5-how-do-you-handle-camera-and-media-access-in-web-applications",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"browser-apis--modern-web-platform",children:"Browser APIs & Modern Web Platform"})}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#web-workers",children:"Web Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#service-workers",children:"Service Workers"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#progressive-web-apps-pwa",children:"Progressive Web Apps (PWA)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#web-storage-apis",children:"Web Storage APIs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#geolocation-api",children:"Geolocation API"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#camera--media-apis",children:"Camera & Media APIs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#notification-api",children:"Notification API"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#websockets--real-time-communication",children:"WebSockets & Real-time Communication"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#intersection-observer",children:"Intersection Observer"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#resize-observer",children:"Resize Observer"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#mutation-observer",children:"Mutation Observer"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#webassembly-wasm",children:"WebAssembly (WASM)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#file-system-access-api",children:"File System Access API"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#web-authentication-api",children:"Web Authentication API"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#performance-apis",children:"Performance APIs"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#interview-questions",children:"Interview Questions"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"web-workers",children:"Web Workers"}),"\n",(0,s.jsx)(n.p,{children:"Web Workers allow you to run JavaScript in the background, separate from the main UI thread."}),"\n",(0,s.jsx)(n.h3,{id:"basic-web-worker",children:"Basic Web Worker"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// main.js\nconst worker = new Worker('worker.js');\n\n// Send data to worker\nworker.postMessage({ command: 'start', data: [1, 2, 3, 4, 5] });\n\n// Receive data from worker\nworker.onmessage = function(e) {\n  console.log('Result from worker:', e.data);\n};\n\n// Handle errors\nworker.onerror = function(error) {\n  console.error('Worker error:', error);\n};\n\n// Terminate worker when done\nworker.terminate();\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// worker.js\nself.onmessage = function(e) {\n  const { command, data } = e.data;\n  \n  if (command === 'start') {\n    // Perform expensive computation\n    const result = performHeavyCalculation(data);\n    \n    // Send result back to main thread\n    self.postMessage(result);\n  }\n};\n\nfunction performHeavyCalculation(data) {\n  // Simulate expensive operation\n  let result = 0;\n  for (let i = 0; i < 1000000; i++) {\n    result += data.reduce((sum, num) => sum + num, 0);\n  }\n  return result;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-web-worker-with-shared-array-buffer",children:"Advanced Web Worker with Shared Array Buffer"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// main.js\nclass WorkerPool {\n  constructor(workerScript, poolSize = 4) {\n    this.workers = [];\n    this.taskQueue = [];\n    this.activeTasks = new Map();\n    \n    for (let i = 0; i < poolSize; i++) {\n      this.createWorker(workerScript, i);\n    }\n  }\n  \n  createWorker(script, id) {\n    const worker = new Worker(script);\n    worker.id = id;\n    worker.busy = false;\n    \n    worker.onmessage = (e) => {\n      const { taskId, result, error } = e.data;\n      const task = this.activeTasks.get(taskId);\n      \n      if (task) {\n        if (error) {\n          task.reject(new Error(error));\n        } else {\n          task.resolve(result);\n        }\n        this.activeTasks.delete(taskId);\n      }\n      \n      worker.busy = false;\n      this.processQueue();\n    };\n    \n    worker.onerror = (error) => {\n      console.error(`Worker ${id} error:`, error);\n    };\n    \n    this.workers.push(worker);\n  }\n  \n  execute(data) {\n    return new Promise((resolve, reject) => {\n      const taskId = Date.now() + Math.random();\n      const task = { taskId, data, resolve, reject };\n      \n      this.taskQueue.push(task);\n      this.processQueue();\n    });\n  }\n  \n  processQueue() {\n    if (this.taskQueue.length === 0) return;\n    \n    const availableWorker = this.workers.find(w => !w.busy);\n    if (!availableWorker) return;\n    \n    const task = this.taskQueue.shift();\n    availableWorker.busy = true;\n    this.activeTasks.set(task.taskId, task);\n    \n    availableWorker.postMessage({\n      taskId: task.taskId,\n      data: task.data\n    });\n  }\n  \n  terminate() {\n    this.workers.forEach(worker => worker.terminate());\n    this.workers = [];\n    this.activeTasks.clear();\n    this.taskQueue = [];\n  }\n}\n\n// Usage\nconst pool = new WorkerPool('calculation-worker.js', 4);\n\nasync function processLargeDataset(dataset) {\n  const chunks = chunkArray(dataset, 1000);\n  const promises = chunks.map(chunk => pool.execute(chunk));\n  \n  try {\n    const results = await Promise.all(promises);\n    return results.flat();\n  } catch (error) {\n    console.error('Processing failed:', error);\n    throw error;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"service-workers",children:"Service Workers"}),"\n",(0,s.jsx)(n.p,{children:"Service Workers act as a proxy between your web app and the network, enabling offline functionality and background sync."}),"\n",(0,s.jsx)(n.h3,{id:"basic-service-worker",children:"Basic Service Worker"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// main.js\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('/sw.js')\n    .then(registration => {\n      console.log('SW registered:', registration);\n    })\n    .catch(error => {\n      console.log('SW registration failed:', error);\n    });\n}\n\n// Listen for SW updates\nnavigator.serviceWorker.addEventListener('controllerchange', () => {\n  window.location.reload();\n});\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// sw.js\nconst CACHE_NAME = 'my-app-v1';\nconst urlsToCache = [\n  '/',\n  '/static/js/bundle.js',\n  '/static/css/main.css',\n  '/manifest.json'\n];\n\n// Install event - cache resources\nself.addEventListener('install', (event) => {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(cache => cache.addAll(urlsToCache))\n  );\n});\n\n// Activate event - clean up old caches\nself.addEventListener('activate', (event) => {\n  event.waitUntil(\n    caches.keys().then(cacheNames => {\n      return Promise.all(\n        cacheNames.map(cacheName => {\n          if (cacheName !== CACHE_NAME) {\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n\n// Fetch event - serve from cache or network\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request)\n      .then(response => {\n        // Return cached version or fetch from network\n        return response || fetch(event.request);\n      })\n  );\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"advanced-service-worker-with-strategies",children:"Advanced Service Worker with Strategies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// sw.js\nclass CacheStrategy {\n  static cacheFirst(request, cacheName) {\n    return caches.open(cacheName).then(cache => {\n      return cache.match(request).then(cachedResponse => {\n        if (cachedResponse) {\n          return cachedResponse;\n        }\n        \n        return fetch(request).then(networkResponse => {\n          cache.put(request, networkResponse.clone());\n          return networkResponse;\n        });\n      });\n    });\n  }\n  \n  static networkFirst(request, cacheName, timeout = 3000) {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        // Fallback to cache if network is slow\n        caches.match(request).then(cachedResponse => {\n          if (cachedResponse) {\n            resolve(cachedResponse);\n          } else {\n            reject(new Error('Network timeout and no cache'));\n          }\n        });\n      }, timeout);\n      \n      fetch(request).then(networkResponse => {\n        clearTimeout(timeoutId);\n        \n        if (networkResponse.ok) {\n          caches.open(cacheName).then(cache => {\n            cache.put(request, networkResponse.clone());\n          });\n        }\n        \n        resolve(networkResponse);\n      }).catch(error => {\n        clearTimeout(timeoutId);\n        \n        caches.match(request).then(cachedResponse => {\n          if (cachedResponse) {\n            resolve(cachedResponse);\n          } else {\n            reject(error);\n          }\n        });\n      });\n    });\n  }\n  \n  static staleWhileRevalidate(request, cacheName) {\n    return caches.open(cacheName).then(cache => {\n      return cache.match(request).then(cachedResponse => {\n        const fetchPromise = fetch(request).then(networkResponse => {\n          cache.put(request, networkResponse.clone());\n          return networkResponse;\n        });\n        \n        return cachedResponse || fetchPromise;\n      });\n    });\n  }\n}\n\n// Background sync\nself.addEventListener('sync', (event) => {\n  if (event.tag === 'background-sync') {\n    event.waitUntil(syncData());\n  }\n});\n\nasync function syncData() {\n  try {\n    const pendingRequests = await getPendingRequests();\n    \n    for (const request of pendingRequests) {\n      await fetch(request.url, request.options);\n      await removePendingRequest(request.id);\n    }\n  } catch (error) {\n    console.error('Background sync failed:', error);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"progressive-web-apps-pwa",children:"Progressive Web Apps (PWA)"}),"\n",(0,s.jsx)(n.h3,{id:"web-app-manifest",children:"Web App Manifest"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "name": "My Progressive Web App",\n  "short_name": "MyPWA",\n  "description": "A sample progressive web application",\n  "start_url": "/",\n  "display": "standalone",\n  "background_color": "#ffffff",\n  "theme_color": "#000000",\n  "orientation": "portrait-primary",\n  "icons": [\n    {\n      "src": "/icons/icon-72x72.png",\n      "sizes": "72x72",\n      "type": "image/png",\n      "purpose": "maskable any"\n    },\n    {\n      "src": "/icons/icon-192x192.png",\n      "sizes": "192x192",\n      "type": "image/png",\n      "purpose": "maskable any"\n    },\n    {\n      "src": "/icons/icon-512x512.png",\n      "sizes": "512x512",\n      "type": "image/png",\n      "purpose": "maskable any"\n    }\n  ],\n  "categories": ["productivity", "utilities"],\n  "screenshots": [\n    {\n      "src": "/screenshots/desktop.png",\n      "sizes": "1920x1080",\n      "type": "image/png",\n      "form_factor": "wide"\n    },\n    {\n      "src": "/screenshots/mobile.png",\n      "sizes": "750x1334",\n      "type": "image/png",\n      "form_factor": "narrow"\n    }\n  ]\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"pwa-installation",children:"PWA Installation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// PWA install prompt\nlet deferredPrompt;\n\nwindow.addEventListener('beforeinstallprompt', (e) => {\n  // Prevent the mini-infobar from appearing\n  e.preventDefault();\n  \n  // Store the event so it can be triggered later\n  deferredPrompt = e;\n  \n  // Show custom install button\n  showInstallButton();\n});\n\nfunction showInstallButton() {\n  const installBtn = document.getElementById('install-btn');\n  installBtn.style.display = 'block';\n  \n  installBtn.addEventListener('click', async () => {\n    if (deferredPrompt) {\n      // Show the install prompt\n      deferredPrompt.prompt();\n      \n      // Wait for the user's response\n      const { outcome } = await deferredPrompt.userChoice;\n      \n      if (outcome === 'accepted') {\n        console.log('User accepted the install prompt');\n      } else {\n        console.log('User dismissed the install prompt');\n      }\n      \n      deferredPrompt = null;\n      installBtn.style.display = 'none';\n    }\n  });\n}\n\n// Listen for app installation\nwindow.addEventListener('appinstalled', (e) => {\n  console.log('PWA was installed');\n  hideInstallButton();\n});\n\n// Check if app is running in standalone mode\nfunction isStandalone() {\n  return window.matchMedia('(display-mode: standalone)').matches ||\n         window.navigator.standalone === true;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"web-storage-apis",children:"Web Storage APIs"}),"\n",(0,s.jsx)(n.h3,{id:"indexeddb",children:"IndexedDB"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class IndexedDBManager {\n  constructor(dbName, version = 1) {\n    this.dbName = dbName;\n    this.version = version;\n    this.db = null;\n  }\n  \n  async open(stores = []) {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n      \n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve(this.db);\n      };\n      \n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        \n        stores.forEach(store => {\n          if (!db.objectStoreNames.contains(store.name)) {\n            const objectStore = db.createObjectStore(store.name, {\n              keyPath: store.keyPath || 'id',\n              autoIncrement: store.autoIncrement || false\n            });\n            \n            // Create indexes\n            if (store.indexes) {\n              store.indexes.forEach(index => {\n                objectStore.createIndex(index.name, index.keyPath, {\n                  unique: index.unique || false\n                });\n              });\n            }\n          }\n        });\n      };\n    });\n  }\n  \n  async add(storeName, data) {\n    const transaction = this.db.transaction([storeName], 'readwrite');\n    const store = transaction.objectStore(storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.add(data);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  \n  async get(storeName, key) {\n    const transaction = this.db.transaction([storeName], 'readonly');\n    const store = transaction.objectStore(storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.get(key);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  \n  async getAll(storeName) {\n    const transaction = this.db.transaction([storeName], 'readonly');\n    const store = transaction.objectStore(storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.getAll();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  \n  async update(storeName, data) {\n    const transaction = this.db.transaction([storeName], 'readwrite');\n    const store = transaction.objectStore(storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.put(data);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n  \n  async delete(storeName, key) {\n    const transaction = this.db.transaction([storeName], 'readwrite');\n    const store = transaction.objectStore(storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.delete(key);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n  \n  async query(storeName, indexName, keyRange) {\n    const transaction = this.db.transaction([storeName], 'readonly');\n    const store = transaction.objectStore(storeName);\n    const index = store.index(indexName);\n    \n    return new Promise((resolve, reject) => {\n      const request = index.getAll(keyRange);\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n}\n\n// Usage\nconst dbManager = new IndexedDBManager('MyAppDB', 1);\n\nconst stores = [\n  {\n    name: 'users',\n    keyPath: 'id',\n    autoIncrement: true,\n    indexes: [\n      { name: 'email', keyPath: 'email', unique: true },\n      { name: 'name', keyPath: 'name', unique: false }\n    ]\n  },\n  {\n    name: 'posts',\n    keyPath: 'id',\n    autoIncrement: true,\n    indexes: [\n      { name: 'userId', keyPath: 'userId', unique: false },\n      { name: 'createdAt', keyPath: 'createdAt', unique: false }\n    ]\n  }\n];\n\nasync function initDB() {\n  await dbManager.open(stores);\n  \n  // Add user\n  await dbManager.add('users', {\n    name: 'John Doe',\n    email: 'john@example.com',\n    age: 30\n  });\n  \n  // Get user\n  const user = await dbManager.get('users', 1);\n  console.log('User:', user);\n  \n  // Query by email\n  const usersByEmail = await dbManager.query(\n    'users', \n    'email', \n    IDBKeyRange.only('john@example.com')\n  );\n  console.log('Users by email:', usersByEmail);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"cache-api",children:"Cache API"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class CacheManager {\n  constructor(cacheName) {\n    this.cacheName = cacheName;\n  }\n  \n  async add(request, response) {\n    const cache = await caches.open(this.cacheName);\n    return cache.put(request, response);\n  }\n  \n  async get(request) {\n    const cache = await caches.open(this.cacheName);\n    return cache.match(request);\n  }\n  \n  async delete(request) {\n    const cache = await caches.open(this.cacheName);\n    return cache.delete(request);\n  }\n  \n  async clear() {\n    return caches.delete(this.cacheName);\n  }\n  \n  async addAll(requests) {\n    const cache = await caches.open(this.cacheName);\n    return cache.addAll(requests);\n  }\n  \n  async keys() {\n    const cache = await caches.open(this.cacheName);\n    return cache.keys();\n  }\n}\n\n// Advanced caching with expiration\nclass ExpiringCache extends CacheManager {\n  constructor(cacheName, defaultTTL = 3600000) { // 1 hour default\n    super(cacheName);\n    this.defaultTTL = defaultTTL;\n  }\n  \n  async add(request, response, ttl = this.defaultTTL) {\n    const cache = await caches.open(this.cacheName);\n    const expirationTime = Date.now() + ttl;\n    \n    // Clone response to add expiration header\n    const responseToCache = new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: {\n        ...Object.fromEntries(response.headers.entries()),\n        'cache-expiration': expirationTime.toString()\n      }\n    });\n    \n    return cache.put(request, responseToCache);\n  }\n  \n  async get(request) {\n    const cache = await caches.open(this.cacheName);\n    const response = await cache.match(request);\n    \n    if (!response) return null;\n    \n    const expirationTime = response.headers.get('cache-expiration');\n    if (expirationTime && Date.now() > parseInt(expirationTime)) {\n      // Cache expired, remove it\n      await cache.delete(request);\n      return null;\n    }\n    \n    return response;\n  }\n  \n  async cleanup() {\n    const cache = await caches.open(this.cacheName);\n    const requests = await cache.keys();\n    \n    for (const request of requests) {\n      const response = await cache.match(request);\n      const expirationTime = response.headers.get('cache-expiration');\n      \n      if (expirationTime && Date.now() > parseInt(expirationTime)) {\n        await cache.delete(request);\n      }\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"geolocation-api",children:"Geolocation API"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class GeolocationManager {\n  constructor() {\n    this.watchId = null;\n    this.currentPosition = null;\n  }\n  \n  async getCurrentPosition(options = {}) {\n    const defaultOptions = {\n      enableHighAccuracy: true,\n      timeout: 10000,\n      maximumAge: 300000 // 5 minutes\n    };\n    \n    const finalOptions = { ...defaultOptions, ...options };\n    \n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        reject(new Error('Geolocation is not supported'));\n        return;\n      }\n      \n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          this.currentPosition = position;\n          resolve(position);\n        },\n        (error) => {\n          reject(this.formatError(error));\n        },\n        finalOptions\n      );\n    });\n  }\n  \n  startWatching(callback, errorCallback, options = {}) {\n    if (!navigator.geolocation) {\n      errorCallback(new Error('Geolocation is not supported'));\n      return;\n    }\n    \n    const defaultOptions = {\n      enableHighAccuracy: true,\n      timeout: 30000,\n      maximumAge: 60000 // 1 minute\n    };\n    \n    const finalOptions = { ...defaultOptions, ...options };\n    \n    this.watchId = navigator.geolocation.watchPosition(\n      (position) => {\n        this.currentPosition = position;\n        callback(position);\n      },\n      (error) => {\n        errorCallback(this.formatError(error));\n      },\n      finalOptions\n    );\n    \n    return this.watchId;\n  }\n  \n  stopWatching() {\n    if (this.watchId !== null) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = null;\n    }\n  }\n  \n  formatError(error) {\n    const errorMessages = {\n      1: 'Permission denied by user',\n      2: 'Position unavailable',\n      3: 'Request timeout'\n    };\n    \n    return new Error(errorMessages[error.code] || 'Unknown geolocation error');\n  }\n  \n  calculateDistance(lat1, lon1, lat2, lon2) {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = this.toRadians(lat2 - lat1);\n    const dLon = this.toRadians(lon2 - lon1);\n    \n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n              Math.cos(this.toRadians(lat1)) * Math.cos(this.toRadians(lat2)) *\n              Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    \n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c; // Distance in kilometers\n  }\n  \n  toRadians(degrees) {\n    return degrees * (Math.PI / 180);\n  }\n}\n\n// Usage\nconst geoManager = new GeolocationManager();\n\nasync function trackUserLocation() {\n  try {\n    // Get current position\n    const position = await geoManager.getCurrentPosition({\n      enableHighAccuracy: true,\n      timeout: 15000\n    });\n    \n    console.log('Current position:', {\n      latitude: position.coords.latitude,\n      longitude: position.coords.longitude,\n      accuracy: position.coords.accuracy\n    });\n    \n    // Start watching for position changes\n    geoManager.startWatching(\n      (position) => {\n        console.log('Position updated:', position.coords);\n        updateMapLocation(position.coords);\n      },\n      (error) => {\n        console.error('Geolocation error:', error.message);\n      },\n      {\n        enableHighAccuracy: true,\n        timeout: 30000,\n        maximumAge: 60000\n      }\n    );\n    \n  } catch (error) {\n    console.error('Failed to get location:', error.message);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"camera--media-apis",children:"Camera & Media APIs"}),"\n",(0,s.jsx)(n.h3,{id:"getusermedia-for-camera-access",children:"getUserMedia for Camera Access"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class CameraManager {\n  constructor() {\n    this.stream = null;\n    this.mediaRecorder = null;\n    this.recordedChunks = [];\n  }\n  \n  async getDevices() {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      return {\n        videoInputs: devices.filter(device => device.kind === 'videoinput'),\n        audioInputs: devices.filter(device => device.kind === 'audioinput')\n      };\n    } catch (error) {\n      throw new Error(`Failed to enumerate devices: ${error.message}`);\n    }\n  }\n  \n  async startCamera(constraints = {}) {\n    const defaultConstraints = {\n      video: {\n        width: { ideal: 1920 },\n        height: { ideal: 1080 },\n        frameRate: { ideal: 30 }\n      },\n      audio: true\n    };\n    \n    const finalConstraints = this.mergeConstraints(defaultConstraints, constraints);\n    \n    try {\n      this.stream = await navigator.mediaDevices.getUserMedia(finalConstraints);\n      return this.stream;\n    } catch (error) {\n      throw new Error(`Failed to access camera: ${error.message}`);\n    }\n  }\n  \n  async startScreenCapture(constraints = {}) {\n    const defaultConstraints = {\n      video: {\n        mediaSource: 'screen'\n      },\n      audio: true\n    };\n    \n    const finalConstraints = this.mergeConstraints(defaultConstraints, constraints);\n    \n    try {\n      this.stream = await navigator.mediaDevices.getDisplayMedia(finalConstraints);\n      return this.stream;\n    } catch (error) {\n      throw new Error(`Failed to capture screen: ${error.message}`);\n    }\n  }\n  \n  stopStream() {\n    if (this.stream) {\n      this.stream.getTracks().forEach(track => track.stop());\n      this.stream = null;\n    }\n  }\n  \n  async startRecording(options = {}) {\n    if (!this.stream) {\n      throw new Error('No active stream to record');\n    }\n    \n    const defaultOptions = {\n      mimeType: 'video/webm; codecs=vp9',\n      videoBitsPerSecond: 2500000\n    };\n    \n    const finalOptions = { ...defaultOptions, ...options };\n    \n    this.recordedChunks = [];\n    this.mediaRecorder = new MediaRecorder(this.stream, finalOptions);\n    \n    this.mediaRecorder.ondataavailable = (event) => {\n      if (event.data.size > 0) {\n        this.recordedChunks.push(event.data);\n      }\n    };\n    \n    this.mediaRecorder.start();\n    \n    return new Promise((resolve) => {\n      this.mediaRecorder.onstop = () => {\n        const blob = new Blob(this.recordedChunks, { type: 'video/webm' });\n        resolve(blob);\n      };\n    });\n  }\n  \n  stopRecording() {\n    if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {\n      this.mediaRecorder.stop();\n    }\n  }\n  \n  capturePhoto(videoElement) {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    \n    canvas.width = videoElement.videoWidth;\n    canvas.height = videoElement.videoHeight;\n    \n    context.drawImage(videoElement, 0, 0);\n    \n    return new Promise((resolve) => {\n      canvas.toBlob((blob) => {\n        resolve(blob);\n      }, 'image/jpeg', 0.9);\n    });\n  }\n  \n  mergeConstraints(defaults, custom) {\n    const result = { ...defaults };\n    \n    if (custom.video) {\n      result.video = { ...defaults.video, ...custom.video };\n    }\n    \n    if (custom.audio) {\n      result.audio = typeof custom.audio === 'object' \n        ? { ...defaults.audio, ...custom.audio }\n        : custom.audio;\n    }\n    \n    return result;\n  }\n}\n\n// Usage\nconst cameraManager = new CameraManager();\n\nasync function initCamera() {\n  try {\n    // Get available devices\n    const devices = await cameraManager.getDevices();\n    console.log('Available cameras:', devices.videoInputs);\n    \n    // Start camera\n    const stream = await cameraManager.startCamera({\n      video: {\n        deviceId: devices.videoInputs[0]?.deviceId,\n        width: { ideal: 1280 },\n        height: { ideal: 720 }\n      }\n    });\n    \n    // Display in video element\n    const videoElement = document.getElementById('camera-preview');\n    videoElement.srcObject = stream;\n    \n    // Start recording\n    const recordingPromise = await cameraManager.startRecording();\n    \n    // Stop recording after 10 seconds\n    setTimeout(async () => {\n      cameraManager.stopRecording();\n      const videoBlob = await recordingPromise;\n      \n      // Download the recorded video\n      const url = URL.createObjectURL(videoBlob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = 'recorded-video.webm';\n      a.click();\n    }, 10000);\n    \n  } catch (error) {\n    console.error('Camera initialization failed:', error);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"intersection-observer",children:"Intersection Observer"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class IntersectionObserverManager {\n  constructor(callback, options = {}) {\n    const defaultOptions = {\n      root: null, // viewport\n      rootMargin: '0px',\n      threshold: 0.1\n    };\n    \n    this.options = { ...defaultOptions, ...options };\n    this.observer = new IntersectionObserver(callback, this.options);\n    this.observedElements = new Set();\n  }\n  \n  observe(element) {\n    this.observer.observe(element);\n    this.observedElements.add(element);\n  }\n  \n  unobserve(element) {\n    this.observer.unobserve(element);\n    this.observedElements.delete(element);\n  }\n  \n  disconnect() {\n    this.observer.disconnect();\n    this.observedElements.clear();\n  }\n}\n\n// Lazy loading images\nclass LazyImageLoader {\n  constructor() {\n    this.observer = new IntersectionObserverManager(\n      this.handleIntersection.bind(this),\n      {\n        rootMargin: '50px 0px', // Load 50px before entering viewport\n        threshold: 0\n      }\n    );\n  }\n  \n  handleIntersection(entries) {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        const img = entry.target;\n        this.loadImage(img);\n        this.observer.unobserve(img);\n      }\n    });\n  }\n  \n  loadImage(img) {\n    const src = img.dataset.src;\n    const srcset = img.dataset.srcset;\n    \n    if (src) {\n      img.src = src;\n    }\n    \n    if (srcset) {\n      img.srcset = srcset;\n    }\n    \n    img.classList.remove('lazy');\n    img.classList.add('loaded');\n    \n    img.onload = () => {\n      img.classList.add('fade-in');\n    };\n  }\n  \n  observeImages(selector = 'img[data-src]') {\n    const images = document.querySelectorAll(selector);\n    images.forEach(img => this.observer.observe(img));\n  }\n}\n\n// Infinite scroll\nclass InfiniteScroll {\n  constructor(callback, options = {}) {\n    this.callback = callback;\n    this.loading = false;\n    this.hasMore = true;\n    \n    this.sentinel = document.createElement('div');\n    this.sentinel.className = 'intersection-sentinel';\n    \n    this.observer = new IntersectionObserverManager(\n      this.handleIntersection.bind(this),\n      {\n        rootMargin: '100px 0px',\n        threshold: 0\n      }\n    );\n  }\n  \n  handleIntersection(entries) {\n    entries.forEach(entry => {\n      if (entry.isIntersecting && !this.loading && this.hasMore) {\n        this.loading = true;\n        this.callback().then((hasMore) => {\n          this.loading = false;\n          this.hasMore = hasMore;\n          \n          if (!hasMore) {\n            this.destroy();\n          }\n        });\n      }\n    });\n  }\n  \n  init(container) {\n    container.appendChild(this.sentinel);\n    this.observer.observe(this.sentinel);\n  }\n  \n  destroy() {\n    this.observer.disconnect();\n    if (this.sentinel.parentNode) {\n      this.sentinel.parentNode.removeChild(this.sentinel);\n    }\n  }\n}\n\n// Usage\nconst lazyLoader = new LazyImageLoader();\nlazyLoader.observeImages();\n\nconst infiniteScroll = new InfiniteScroll(async () => {\n  const response = await fetch(`/api/items?page=${currentPage++}`);\n  const items = await response.json();\n  \n  appendItemsToDOM(items);\n  \n  return items.length > 0; // Has more items\n});\n\ninfiniteScroll.init(document.getElementById('items-container'));\n"})}),"\n",(0,s.jsx)(n.h2,{id:"interview-questions",children:"Interview Questions"}),"\n",(0,s.jsx)(n.h3,{id:"1-what-are-web-workers-and-when-would-you-use-them",children:"1. What are Web Workers and when would you use them?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Answer:"}),"\nWeb Workers are a way to run JavaScript in the background, separate from the main UI thread. They enable parallel processing without blocking the UI."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Heavy computations (image processing, data analysis)"}),"\n",(0,s.jsx)(n.li,{children:"Background data sync"}),"\n",(0,s.jsx)(n.li,{children:"Real-time data processing"}),"\n",(0,s.jsx)(n.li,{children:"Cryptographic operations"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Non-blocking UI operations"}),"\n",(0,s.jsx)(n.li,{children:"True parallelism"}),"\n",(0,s.jsx)(n.li,{children:"Isolated execution context"}),"\n",(0,s.jsx)(n.li,{children:"Better performance for CPU-intensive tasks"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-explain-the-difference-between-service-workers-and-web-workers",children:"2. Explain the difference between Service Workers and Web Workers."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Answer:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Web Workers"}),": General-purpose background scripts for computations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Workers"}),": Specialized workers that act as a proxy between your app and the network"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Service Worker features:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Intercept network requests"}),"\n",(0,s.jsx)(n.li,{children:"Cache management"}),"\n",(0,s.jsx)(n.li,{children:"Push notifications"}),"\n",(0,s.jsx)(n.li,{children:"Background sync"}),"\n",(0,s.jsx)(n.li,{children:"Offline functionality"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-how-do-you-implement-offline-functionality-in-a-web-app",children:"3. How do you implement offline functionality in a web app?"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Answer:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Service Worker for caching\nself.addEventListener('fetch', (event) => {\n  if (event.request.method === 'GET') {\n    event.respondWith(\n      caches.match(event.request).then(response => {\n        return response || fetch(event.request).catch(() => {\n          // Return offline fallback\n          return caches.match('/offline.html');\n        });\n      })\n    );\n  }\n});\n\n// Background sync for failed requests\nself.addEventListener('sync', (event) => {\n  if (event.tag === 'background-sync') {\n    event.waitUntil(syncPendingRequests());\n  }\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-what-is-the-intersection-observer-api-and-its-benefits",children:"4. What is the Intersection Observer API and its benefits?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Answer:"}),"\nIntersection Observer provides an efficient way to observe changes in the intersection of a target element with an ancestor element or viewport."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Benefits:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Better performance than scroll events"}),"\n",(0,s.jsx)(n.li,{children:"Automatic cleanup"}),"\n",(0,s.jsx)(n.li,{children:"Configurable thresholds and margins"}),"\n",(0,s.jsx)(n.li,{children:"Passive observation"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Use cases:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Lazy loading"}),"\n",(0,s.jsx)(n.li,{children:"Infinite scroll"}),"\n",(0,s.jsx)(n.li,{children:"Analytics tracking"}),"\n",(0,s.jsx)(n.li,{children:"Animation triggers"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"5-how-do-you-handle-camera-and-media-access-in-web-applications",children:"5. How do you handle camera and media access in web applications?"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Answer:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"// Request camera access\nconst stream = await navigator.mediaDevices.getUserMedia({\n  video: { width: 1280, height: 720 },\n  audio: true\n});\n\n// Handle permissions\nnavigator.permissions.query({ name: 'camera' }).then(result => {\n  if (result.state === 'granted') {\n    // Access granted\n  } else if (result.state === 'prompt') {\n    // Will prompt user\n  } else {\n    // Access denied\n  }\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Security considerations:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"HTTPS required"}),"\n",(0,s.jsx)(n.li,{children:"User permission required"}),"\n",(0,s.jsx)(n.li,{children:"Clear user indication when recording"}),"\n",(0,s.jsx)(n.li,{children:"Proper cleanup of resources"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This comprehensive guide covers the essential browser APIs and modern web platform features needed for advanced frontend development and interviews."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);