"use strict";(self.webpackChunkfrontend_interview_guide=self.webpackChunkfrontend_interview_guide||[]).push([[5785],{7956:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=t(4848),a=t(8453);const o={},s="Internationalization (i18n) Interview Preparation",i={id:"frontend/internationalization/README",title:"Internationalization (i18n) Interview Preparation",description:"Core Concepts",source:"@site/docs/frontend/internationalization/README.md",sourceDirName:"frontend/internationalization",slug:"/frontend/internationalization/",permalink:"/interview/docs/frontend/internationalization/",draft:!1,unlisted:!1,editUrl:"https://github.com/Nhi4912/interview/tree/main/docs/frontend/internationalization/README.md",tags:[],version:"current",frontMatter:{},sidebar:"frontendSidebar",previous:{title:"Accessibility Interview Preparation",permalink:"/interview/docs/frontend/accessibility/"},next:{title:"Advanced Frontend Topics",permalink:"/interview/docs/frontend/advanced/"}},l={},c=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Internationalization Fundamentals",id:"internationalization-fundamentals",level:3},{value:"Key Components",id:"key-components",level:3},{value:"Advanced Topics",id:"advanced-topics",level:2},{value:"Modern i18n Features",id:"modern-i18n-features",level:3},{value:"Technical Implementation",id:"technical-implementation",level:3},{value:"Common Interview Questions &amp; Answers",id:"common-interview-questions--answers",level:2},{value:"i18n Questions",id:"i18n-questions",level:3},{value:"Advanced Interview Questions",id:"advanced-interview-questions",level:2},{value:"Practical Problems &amp; Solutions",id:"practical-problems--solutions",level:2},{value:"Problem 1: Implement Locale-Specific Number and Date Formatting",id:"problem-1-implement-locale-specific-number-and-date-formatting",level:3},{value:"Problem 2: Create a Dynamic Language Switcher",id:"problem-2-create-a-dynamic-language-switcher",level:3},{value:"i18n Best Practices",id:"i18n-best-practices",level:2},{value:"Translation Management",id:"translation-management",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Resources",id:"resources",level:2},{value:"Documentation",id:"documentation",level:3},{value:"Tools",id:"tools",level:3},{value:"Practice Platforms",id:"practice-platforms",level:3}];function d(n){const e={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"internationalization-i18n-interview-preparation",children:"Internationalization (i18n) Interview Preparation"}),"\n",(0,r.jsx)(e.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsx)(e.h3,{id:"internationalization-fundamentals",children:"Internationalization Fundamentals"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"i18n (Internationalization)"}),": Making applications ready for multiple languages"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"l10n (Localization)"}),": Adapting content for specific regions/cultures"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"RTL (Right-to-Left)"}),": Support for languages like Arabic, Hebrew, Persian"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Cultural Adaptation"}),": Date formats, number formats, currency, units"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Text Direction"}),": Handling bidirectional text and mixed content"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"key-components",children:"Key Components"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Translation Management"}),": Text extraction, translation, and management"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Formatting"}),": Dates, numbers, currency, pluralization"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Layout Adaptation"}),": RTL layouts, text overflow, font handling"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Cultural Considerations"}),": Colors, symbols, imagery, taboos"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Performance"}),": Lazy loading of translations, bundle optimization"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"advanced-topics",children:"Advanced Topics"}),"\n",(0,r.jsx)(e.h3,{id:"modern-i18n-features",children:"Modern i18n Features"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ICU MessageFormat"}),": Advanced pluralization and gender rules"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Dynamic Locale Switching"}),": Runtime language changes"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Fallback Chains"}),": Graceful degradation for missing translations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Context-Aware Translations"}),": Gender, number, and context-specific text"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Translation Memory"}),": Reuse and consistency across projects"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Bundle Splitting"}),": Code splitting by locale"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Server-Side Rendering"}),": SEO-friendly internationalized content"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"API Localization"}),": Backend support for multiple languages"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Database Localization"}),": Storing and retrieving localized content"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Caching Strategies"}),": Locale-specific caching"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"common-interview-questions--answers",children:"Common Interview Questions & Answers"}),"\n",(0,r.jsx)(e.h3,{id:"i18n-questions",children:"i18n Questions"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Q: What's the difference between i18n and l10n?"}),"\nA:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"i18n (Internationalization)"}),": Making software ready for multiple languages/regions"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"l10n (Localization)"}),": Adapting content for specific locales"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"i18n Example:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// Making code locale-aware\nconst dateFormatter = new Intl.DateTimeFormat(locale, {\n  year: "numeric",\n  month: "long",\n  day: "numeric",\n});\n\nconst numberFormatter = new Intl.NumberFormat(locale, {\n  style: "currency",\n  currency: currencyCode,\n});\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"l10n Example:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// Adapting content for specific locale\nconst translations = {\n  "en-US": {\n    greeting: "Hello",\n    dateFormat: "MM/DD/YYYY",\n    currency: "USD",\n  },\n  "ar-SA": {\n    greeting: "\u0645\u0631\u062d\u0628\u0627",\n    dateFormat: "DD/MM/YYYY",\n    currency: "SAR",\n  },\n};\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Q: How do you implement RTL support in a React application?"}),"\nA: Comprehensive RTL implementation:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// RTL support utilities\nclass RTLSupport {\n  constructor() {\n    this.rtlLanguages = ["ar", "he", "fa", "ur", "ps", "sd"];\n  }\n\n  isRTL(locale) {\n    return this.rtlLanguages.includes(locale.split("-")[0]);\n  }\n\n  setDocumentDirection(locale) {\n    const direction = this.isRTL(locale) ? "rtl" : "ltr";\n    document.documentElement.dir = direction;\n    document.documentElement.lang = locale;\n  }\n\n  getTextAlign(locale) {\n    return this.isRTL(locale) ? "right" : "left";\n  }\n\n  getFlexDirection(locale) {\n    return this.isRTL(locale) ? "row-reverse" : "row";\n  }\n\n  getMargin(locale, side) {\n    if (this.isRTL(locale)) {\n      return side === "left" ? "marginRight" : "marginLeft";\n    }\n    return side === "left" ? "marginLeft" : "marginRight";\n  }\n}\n\n// React component with RTL support\nfunction InternationalizedComponent({ locale, children }) {\n  const rtlSupport = new RTLSupport();\n  const isRTL = rtlSupport.isRTL(locale);\n\n  useEffect(() => {\n    rtlSupport.setDocumentDirection(locale);\n  }, [locale]);\n\n  return (\n    <div\n      className={`app ${isRTL ? "rtl" : "ltr"}`}\n      style={{\n        direction: isRTL ? "rtl" : "ltr",\n        textAlign: rtlSupport.getTextAlign(locale),\n      }}\n    >\n      {children}\n    </div>\n  );\n}\n\n// CSS for RTL support\nconst rtlStyles = `\n  .rtl {\n    direction: rtl;\n    text-align: right;\n  }\n\n  .rtl .flex-row {\n    flex-direction: row-reverse;\n  }\n\n  .rtl .margin-left {\n    margin-right: 0;\n    margin-left: auto;\n  }\n\n  .rtl .padding-left {\n    padding-right: 0;\n    padding-left: auto;\n  }\n\n  .rtl .border-left {\n    border-right: none;\n    border-left: 1px solid;\n  }\n\n  .rtl .float-left {\n    float: right;\n  }\n\n  .rtl .text-left {\n    text-align: right;\n  }\n`;\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Q: How do you handle pluralization in different languages?"}),"\nA: Advanced pluralization with ICU MessageFormat:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'class PluralizationManager {\n  constructor() {\n    this.pluralRules = {\n      en: (n) => (n === 1 ? "one" : "other"),\n      ar: (n) => {\n        if (n === 0) return "zero";\n        if (n === 1) return "one";\n        if (n === 2) return "two";\n        if (n % 100 >= 3 && n % 100 <= 10) return "few";\n        if (n % 100 >= 11) return "many";\n        return "other";\n      },\n      ru: (n) => {\n        const mod10 = n % 10;\n        const mod100 = n % 100;\n\n        if (mod10 === 1 && mod100 !== 11) return "one";\n        if ([2, 3, 4].includes(mod10) && ![12, 13, 14].includes(mod100))\n          return "few";\n        if (\n          mod10 === 0 ||\n          [5, 6, 7, 8, 9].includes(mod10) ||\n          [11, 12, 13, 14].includes(mod100)\n        )\n          return "many";\n        return "other";\n      },\n    };\n  }\n\n  getPluralForm(locale, count) {\n    const language = locale.split("-")[0];\n    const rule = this.pluralRules[language] || this.pluralRules.en;\n    return rule(count);\n  }\n\n  formatMessage(template, values, locale) {\n    return template.replace(/\\{(\\w+)\\}/g, (match, key) => {\n      if (key === "count") {\n        const count = values[key];\n        const pluralForm = this.getPluralForm(locale, count);\n        return this.getPluralizedText(values[`${key}_${pluralForm}`], count);\n      }\n      return values[key] || match;\n    });\n  }\n\n  getPluralizedText(text, count) {\n    return text.replace("{count}", count);\n  }\n}\n\n// Usage examples\nconst pluralManager = new PluralizationManager();\n\nconst messages = {\n  en: {\n    items: {\n      one: "{count} item",\n      other: "{count} items",\n    },\n    people: {\n      one: "{count} person",\n      other: "{count} people",\n    },\n  },\n  ar: {\n    items: {\n      zero: "\u0644\u0627 \u062a\u0648\u062c\u062f \u0639\u0646\u0627\u0635\u0631",\n      one: "\u0639\u0646\u0635\u0631 \u0648\u0627\u062d\u062f",\n      two: "\u0639\u0646\u0635\u0631\u0627\u0646",\n      few: "{count} \u0639\u0646\u0627\u0635\u0631",\n      many: "{count} \u0639\u0646\u0635\u0631\u0627\u064b",\n      other: "{count} \u0639\u0646\u0635\u0631",\n    },\n  },\n  ru: {\n    items: {\n      one: "{count} \u044d\u043b\u0435\u043c\u0435\u043d\u0442",\n      few: "{count} \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430",\n      many: "{count} \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432",\n      other: "{count} \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432",\n    },\n  },\n};\n\n// Format messages\nfunction formatPluralMessage(key, count, locale) {\n  const template = messages[locale][key];\n  const values = { count };\n\n  // Add plural forms to values\n  Object.keys(template).forEach((form) => {\n    values[`count_${form}`] = template[form];\n  });\n\n  return pluralManager.formatMessage(\n    `{count_${pluralManager.getPluralForm(locale, count)}}`,\n    values,\n    locale\n  );\n}\n\n// Examples\nconsole.log(formatPluralMessage("items", 1, "en")); // "1 item"\nconsole.log(formatPluralMessage("items", 5, "en")); // "5 items"\nconsole.log(formatPluralMessage("items", 0, "ar")); // "\u0644\u0627 \u062a\u0648\u062c\u062f \u0639\u0646\u0627\u0635\u0631"\nconsole.log(formatPluralMessage("items", 1, "ar")); // "\u0639\u0646\u0635\u0631 \u0648\u0627\u062d\u062f"\nconsole.log(formatPluralMessage("items", 2, "ar")); // "\u0639\u0646\u0635\u0631\u0627\u0646"\n'})}),"\n",(0,r.jsx)(e.h2,{id:"advanced-interview-questions",children:"Advanced Interview Questions"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Q: How would you implement a complete i18n system for a React application?"}),"\nA: Comprehensive i18n system implementation:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// i18n configuration and utilities\nclass I18nManager {\n  constructor(config = {}) {\n    this.defaultLocale = config.defaultLocale || "en";\n    this.supportedLocales = config.supportedLocales || ["en", "es", "fr", "ar"];\n    this.currentLocale = this.defaultLocale;\n    this.translations = new Map();\n    this.formatters = new Map();\n    this.listeners = new Set();\n\n    this.initializeFormatters();\n  }\n\n  initializeFormatters() {\n    this.supportedLocales.forEach((locale) => {\n      this.formatters.set(locale, {\n        date: new Intl.DateTimeFormat(locale, {\n          year: "numeric",\n          month: "long",\n          day: "numeric",\n        }),\n        number: new Intl.NumberFormat(locale),\n        currency: new Intl.NumberFormat(locale, {\n          style: "currency",\n          currency: this.getCurrencyForLocale(locale),\n        }),\n        relativeTime: new Intl.RelativeTimeFormat(locale, {\n          numeric: "auto",\n        }),\n      });\n    });\n  }\n\n  getCurrencyForLocale(locale) {\n    const currencyMap = {\n      en: "USD",\n      es: "EUR",\n      fr: "EUR",\n      ar: "SAR",\n      ja: "JPY",\n      zh: "CNY",\n    };\n    return currencyMap[locale] || "USD";\n  }\n\n  async loadTranslations(locale) {\n    if (this.translations.has(locale)) {\n      return this.translations.get(locale);\n    }\n\n    try {\n      // Dynamic import for code splitting\n      const translations = await import(`./locales/${locale}.js`);\n      this.translations.set(locale, translations.default);\n      return translations.default;\n    } catch (error) {\n      console.warn(`Failed to load translations for ${locale}:`, error);\n      return this.translations.get(this.defaultLocale) || {};\n    }\n  }\n\n  setLocale(locale) {\n    if (!this.supportedLocales.includes(locale)) {\n      console.warn(`Locale ${locale} is not supported`);\n      return;\n    }\n\n    this.currentLocale = locale;\n    this.setDocumentAttributes(locale);\n    this.notifyListeners();\n  }\n\n  setDocumentAttributes(locale) {\n    document.documentElement.lang = locale;\n    document.documentElement.dir = this.isRTL(locale) ? "rtl" : "ltr";\n  }\n\n  isRTL(locale) {\n    return ["ar", "he", "fa", "ur"].includes(locale);\n  }\n\n  t(key, params = {}) {\n    const translations = this.translations.get(this.currentLocale) || {};\n    let text = this.getNestedValue(translations, key) || key;\n\n    // Replace parameters\n    Object.keys(params).forEach((param) => {\n      text = text.replace(new RegExp(`{${param}}`, "g"), params[param]);\n    });\n\n    return text;\n  }\n\n  getNestedValue(obj, path) {\n    return path.split(".").reduce((current, key) => {\n      return current && current[key] !== undefined ? current[key] : null;\n    }, obj);\n  }\n\n  formatDate(date, options = {}) {\n    const formatter = this.formatters.get(this.currentLocale).date;\n    return formatter.format(date);\n  }\n\n  formatNumber(number, options = {}) {\n    const formatter = this.formatters.get(this.currentLocale).number;\n    return formatter.format(number);\n  }\n\n  formatCurrency(amount, currency = null) {\n    const formatter = this.formatters.get(this.currentLocale).currency;\n    if (currency) {\n      return new Intl.NumberFormat(this.currentLocale, {\n        style: "currency",\n        currency,\n      }).format(amount);\n    }\n    return formatter.format(amount);\n  }\n\n  formatRelativeTime(value, unit) {\n    const formatter = this.formatters.get(this.currentLocale).relativeTime;\n    return formatter.format(value, unit);\n  }\n\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  notifyListeners() {\n    this.listeners.forEach((listener) => listener(this.currentLocale));\n  }\n}\n\n// React hooks for i18n\nfunction useI18n() {\n  const [locale, setLocale] = useState(i18n.currentLocale);\n  const [translations, setTranslations] = useState({});\n\n  useEffect(() => {\n    const unsubscribe = i18n.subscribe(async (newLocale) => {\n      setLocale(newLocale);\n      const newTranslations = await i18n.loadTranslations(newLocale);\n      setTranslations(newTranslations);\n    });\n\n    // Load initial translations\n    i18n.loadTranslations(locale).then(setTranslations);\n\n    return unsubscribe;\n  }, []);\n\n  const t = useCallback((key, params) => i18n.t(key, params), [locale]);\n  const formatDate = useCallback(\n    (date, options) => i18n.formatDate(date, options),\n    [locale]\n  );\n  const formatNumber = useCallback(\n    (number, options) => i18n.formatNumber(number, options),\n    [locale]\n  );\n  const formatCurrency = useCallback(\n    (amount, currency) => i18n.formatCurrency(amount, currency),\n    [locale]\n  );\n\n  return {\n    locale,\n    setLocale: i18n.setLocale.bind(i18n),\n    t,\n    formatDate,\n    formatNumber,\n    formatCurrency,\n    isRTL: i18n.isRTL(locale),\n  };\n}\n\n// Translation component\nfunction Trans({ i18nKey, params, children }) {\n  const { t } = useI18n();\n\n  if (children) {\n    return <span dangerouslySetInnerHTML={{ __html: t(i18nKey, params) }} />;\n  }\n\n  return t(i18nKey, params);\n}\n\n// Usage in components\nfunction ProductCard({ product }) {\n  const { t, formatCurrency, formatDate, isRTL } = useI18n();\n\n  return (\n    <div className={`product-card ${isRTL ? "rtl" : "ltr"}`}>\n      <h3>{product.name}</h3>\n      <p className="price">{formatCurrency(product.price)}</p>\n      <p className="date">\n        <Trans\n          i18nKey="product.addedOn"\n          params={{ date: formatDate(product.addedDate) }}\n        />\n      </p>\n      <button>\n        <Trans i18nKey="product.addToCart" />\n      </button>\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Q: How do you handle dynamic content and user-generated text in multiple languages?"}),"\nA: Advanced dynamic content handling:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'class DynamicContentManager {\n  constructor() {\n    this.contentCache = new Map();\n    this.translationMemory = new Map();\n    this.userContent = new Map();\n  }\n\n  // Handle user-generated content with language detection\n  async processUserContent(content, userId) {\n    const detectedLanguage = await this.detectLanguage(content);\n    const processedContent = await this.processContent(\n      content,\n      detectedLanguage\n    );\n\n    this.userContent.set(userId, {\n      content: processedContent,\n      language: detectedLanguage,\n      timestamp: Date.now(),\n    });\n\n    return processedContent;\n  }\n\n  async detectLanguage(text) {\n    // Use a language detection library or API\n    const response = await fetch("/api/detect-language", {\n      method: "POST",\n      headers: { "Content-Type": "application/json" },\n      body: JSON.stringify({ text }),\n    });\n\n    const { language, confidence } = await response.json();\n    return confidence > 0.8 ? language : "en";\n  }\n\n  async processContent(content, sourceLanguage) {\n    // Handle mixed language content\n    const segments = this.segmentContent(content);\n    const processedSegments = [];\n\n    for (const segment of segments) {\n      const segmentLanguage = await this.detectLanguage(segment.text);\n\n      if (segmentLanguage !== sourceLanguage) {\n        // Translate segment to source language\n        const translated = await this.translateText(\n          segment.text,\n          segmentLanguage,\n          sourceLanguage\n        );\n        processedSegments.push({\n          ...segment,\n          text: translated,\n          originalText: segment.text,\n          originalLanguage: segmentLanguage,\n        });\n      } else {\n        processedSegments.push(segment);\n      }\n    }\n\n    return this.reconstructContent(processedSegments);\n  }\n\n  segmentContent(content) {\n    // Split content into segments (sentences, paragraphs, etc.)\n    const segments = [];\n    const sentences = content.split(/[.!?]+/).filter((s) => s.trim());\n\n    sentences.forEach((sentence, index) => {\n      segments.push({\n        id: index,\n        text: sentence.trim(),\n        type: "sentence",\n      });\n    });\n\n    return segments;\n  }\n\n  async translateText(text, fromLanguage, toLanguage) {\n    const cacheKey = `${text}_${fromLanguage}_${toLanguage}`;\n\n    if (this.translationMemory.has(cacheKey)) {\n      return this.translationMemory.get(cacheKey);\n    }\n\n    try {\n      const response = await fetch("/api/translate", {\n        method: "POST",\n        headers: { "Content-Type": "application/json" },\n        body: JSON.stringify({ text, from: fromLanguage, to: toLanguage }),\n      });\n\n      const { translation } = await response.json();\n      this.translationMemory.set(cacheKey, translation);\n\n      return translation;\n    } catch (error) {\n      console.error("Translation failed:", error);\n      return text; // Return original text if translation fails\n    }\n  }\n\n  reconstructContent(segments) {\n    return segments.map((segment) => segment.text).join(". ") + ".";\n  }\n\n  // Handle bidirectional text\n  processBidirectionalText(text, baseDirection = "ltr") {\n    const segments = this.splitBidirectionalText(text);\n    const processedSegments = [];\n\n    segments.forEach((segment) => {\n      const direction = this.getTextDirection(segment);\n\n      if (direction !== baseDirection) {\n        processedSegments.push({\n          text: segment,\n          direction,\n          needsEmbedding: true,\n        });\n      } else {\n        processedSegments.push({\n          text: segment,\n          direction,\n          needsEmbedding: false,\n        });\n      }\n    });\n\n    return this.renderBidirectionalText(processedSegments, baseDirection);\n  }\n\n  splitBidirectionalText(text) {\n    // Split text into segments based on language/script\n    const rtlRegex =\n      /[\\u0590-\\u05FF\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]/;\n    const segments = [];\n    let currentSegment = "";\n    let currentDirection = "ltr";\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const isRTL = rtlRegex.test(char);\n      const charDirection = isRTL ? "rtl" : "ltr";\n\n      if (charDirection !== currentDirection && currentSegment) {\n        segments.push(currentSegment);\n        currentSegment = "";\n        currentDirection = charDirection;\n      }\n\n      currentSegment += char;\n    }\n\n    if (currentSegment) {\n      segments.push(currentSegment);\n    }\n\n    return segments;\n  }\n\n  getTextDirection(text) {\n    const rtlRegex =\n      /[\\u0590-\\u05FF\\u0600-\\u06FF\\u0750-\\u077F\\u08A0-\\u08FF\\uFB50-\\uFDFF\\uFE70-\\uFEFF]/;\n    return rtlRegex.test(text) ? "rtl" : "ltr";\n  }\n\n  renderBidirectionalText(segments, baseDirection) {\n    return segments\n      .map((segment) => {\n        if (segment.needsEmbedding) {\n          return `<span dir="${segment.direction}">${segment.text}</span>`;\n        }\n        return segment.text;\n      })\n      .join("");\n  }\n\n  // Cache management\n  clearCache() {\n    this.contentCache.clear();\n    this.translationMemory.clear();\n  }\n\n  getCacheStats() {\n    return {\n      contentCacheSize: this.contentCache.size,\n      translationMemorySize: this.translationMemory.size,\n      userContentSize: this.userContent.size,\n    };\n  }\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"practical-problems--solutions",children:"Practical Problems & Solutions"}),"\n",(0,r.jsx)(e.h3,{id:"problem-1-implement-locale-specific-number-and-date-formatting",children:"Problem 1: Implement Locale-Specific Number and Date Formatting"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Challenge"}),": Create a comprehensive formatting system for different locales."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'class LocaleFormatter {\n  constructor() {\n    this.formatters = new Map();\n    this.initializeFormatters();\n  }\n\n  initializeFormatters() {\n    const locales = [\n      "en-US",\n      "en-GB",\n      "es-ES",\n      "fr-FR",\n      "de-DE",\n      "ja-JP",\n      "zh-CN",\n      "ar-SA",\n    ];\n\n    locales.forEach((locale) => {\n      this.formatters.set(locale, {\n        number: new Intl.NumberFormat(locale),\n        currency: new Intl.NumberFormat(locale, { style: "currency" }),\n        date: new Intl.DateTimeFormat(locale, {\n          year: "numeric",\n          month: "long",\n          day: "numeric",\n        }),\n        time: new Intl.DateTimeFormat(locale, {\n          hour: "2-digit",\n          minute: "2-digit",\n        }),\n        relative: new Intl.RelativeTimeFormat(locale, { numeric: "auto" }),\n      });\n    });\n  }\n\n  formatNumber(number, locale, options = {}) {\n    const formatter = this.formatters.get(locale)?.number;\n    if (!formatter) return number.toString();\n\n    if (\n      options.minimumFractionDigits !== undefined ||\n      options.maximumFractionDigits !== undefined\n    ) {\n      return new Intl.NumberFormat(locale, options).format(number);\n    }\n\n    return formatter.format(number);\n  }\n\n  formatCurrency(amount, locale, currency = null) {\n    if (currency) {\n      return new Intl.NumberFormat(locale, {\n        style: "currency",\n        currency,\n      }).format(amount);\n    }\n\n    const formatter = this.formatters.get(locale)?.currency;\n    return formatter ? formatter.format(amount) : amount.toString();\n  }\n\n  formatDate(date, locale, options = {}) {\n    const formatter = this.formatters.get(locale)?.date;\n    if (!formatter) return date.toLocaleDateString();\n\n    if (options.format) {\n      return new Intl.DateTimeFormat(locale, options).format(date);\n    }\n\n    return formatter.format(date);\n  }\n\n  formatRelativeTime(value, unit, locale) {\n    const formatter = this.formatters.get(locale)?.relative;\n    return formatter ? formatter.format(value, unit) : `${value} ${unit}`;\n  }\n\n  getLocaleInfo(locale) {\n    const formatter = this.formatters.get(locale);\n    if (!formatter) return null;\n\n    // Test formatting to determine locale characteristics\n    const testNumber = 1234.56;\n    const testDate = new Date();\n\n    return {\n      locale,\n      numberFormat: formatter.number.format(testNumber),\n      dateFormat: formatter.date.format(testDate),\n      currencyFormat: formatter.currency.format(testNumber),\n      isRTL: this.isRTL(locale),\n    };\n  }\n\n  isRTL(locale) {\n    return ["ar", "he", "fa", "ur"].includes(locale.split("-")[0]);\n  }\n\n  // Custom formatting for specific use cases\n  formatPhoneNumber(phone, locale) {\n    const phoneFormats = {\n      "en-US": (phone) => {\n        const cleaned = phone.replace(/\\D/g, "");\n        const match = cleaned.match(/^(\\d{3})(\\d{3})(\\d{4})$/);\n        return match ? `(${match[1]}) ${match[2]}-${match[3]}` : phone;\n      },\n      "en-GB": (phone) => {\n        const cleaned = phone.replace(/\\D/g, "");\n        const match = cleaned.match(/^(\\d{5})(\\d{6})$/);\n        return match ? `${match[1]} ${match[2]}` : phone;\n      },\n      "es-ES": (phone) => {\n        const cleaned = phone.replace(/\\D/g, "");\n        const match = cleaned.match(/^(\\d{3})(\\d{3})(\\d{3})$/);\n        return match ? `${match[1]} ${match[2]} ${match[3]}` : phone;\n      },\n    };\n\n    const formatter = phoneFormats[locale] || phoneFormats["en-US"];\n    return formatter(phone);\n  }\n\n  formatAddress(address, locale) {\n    const addressFormats = {\n      "en-US": (addr) =>\n        `${addr.street}, ${addr.city}, ${addr.state} ${addr.zip}`,\n      "en-GB": (addr) => `${addr.street}, ${addr.city}, ${addr.postcode}`,\n      "ja-JP": (addr) =>\n        `\u3012${addr.postcode} ${addr.prefecture}${addr.city}${addr.street}`,\n      "ar-SA": (addr) => `${addr.street}\u060c ${addr.city}\u060c ${addr.postcode}`,\n    };\n\n    const formatter = addressFormats[locale] || addressFormats["en-US"];\n    return formatter(address);\n  }\n}\n\n// Usage\nconst formatter = new LocaleFormatter();\n\n// Number formatting\nconsole.log(formatter.formatNumber(1234.56, "en-US")); // "1,234.56"\nconsole.log(formatter.formatNumber(1234.56, "de-DE")); // "1.234,56"\nconsole.log(formatter.formatNumber(1234.56, "ja-JP")); // "1,234.56"\n\n// Currency formatting\nconsole.log(formatter.formatCurrency(1234.56, "en-US")); // "$1,234.56"\nconsole.log(formatter.formatCurrency(1234.56, "de-DE")); // "1.234,56 \u20ac"\nconsole.log(formatter.formatCurrency(1234.56, "ja-JP")); // "\xa51,235"\n\n// Date formatting\nconst date = new Date("2023-12-25");\nconsole.log(formatter.formatDate(date, "en-US")); // "December 25, 2023"\nconsole.log(formatter.formatDate(date, "es-ES")); // "25 de diciembre de 2023"\nconsole.log(formatter.formatDate(date, "ja-JP")); // "2023\u5e7412\u670825\u65e5"\n'})}),"\n",(0,r.jsx)(e.h3,{id:"problem-2-create-a-dynamic-language-switcher",children:"Problem 2: Create a Dynamic Language Switcher"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Challenge"}),": Build a language switcher that handles locale changes and maintains user preferences."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'class LanguageSwitcher {\n  constructor() {\n    this.currentLocale = this.getStoredLocale() || "en";\n    this.supportedLocales = [\n      { code: "en", name: "English", flag: "\ud83c\uddfa\ud83c\uddf8" },\n      { code: "es", name: "Espa\xf1ol", flag: "\ud83c\uddea\ud83c\uddf8" },\n      { code: "fr", name: "Fran\xe7ais", flag: "\ud83c\uddeb\ud83c\uddf7" },\n      { code: "de", name: "Deutsch", flag: "\ud83c\udde9\ud83c\uddea" },\n      { code: "ja", name: "\u65e5\u672c\u8a9e", flag: "\ud83c\uddef\ud83c\uddf5" },\n      { code: "zh", name: "\u4e2d\u6587", flag: "\ud83c\udde8\ud83c\uddf3" },\n      { code: "ar", name: "\u0627\u0644\u0639\u0631\u0628\u064a\u0629", flag: "\ud83c\uddf8\ud83c\udde6" },\n    ];\n\n    this.listeners = new Set();\n    this.initializeSwitcher();\n  }\n\n  getStoredLocale() {\n    return (\n      localStorage.getItem("preferred-locale") ||\n      navigator.language.split("-")[0] ||\n      "en"\n    );\n  }\n\n  setLocale(locale) {\n    if (!this.supportedLocales.find((l) => l.code === locale)) {\n      console.warn(`Locale ${locale} is not supported`);\n      return;\n    }\n\n    this.currentLocale = locale;\n    localStorage.setItem("preferred-locale", locale);\n\n    // Update document attributes\n    document.documentElement.lang = locale;\n    document.documentElement.dir = this.isRTL(locale) ? "rtl" : "ltr";\n\n    // Notify listeners\n    this.notifyListeners();\n\n    // Reload translations\n    this.loadTranslations(locale);\n  }\n\n  isRTL(locale) {\n    return ["ar", "he", "fa", "ur"].includes(locale);\n  }\n\n  async loadTranslations(locale) {\n    try {\n      // Dynamic import for code splitting\n      const translations = await import(`./locales/${locale}.js`);\n\n      // Update i18n instance\n      if (window.i18n) {\n        window.i18n.setLocale(locale);\n        window.i18n.translations.set(locale, translations.default);\n      }\n\n      // Trigger re-render\n      this.notifyListeners();\n    } catch (error) {\n      console.error(`Failed to load translations for ${locale}:`, error);\n    }\n  }\n\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  notifyListeners() {\n    this.listeners.forEach((listener) => listener(this.currentLocale));\n  }\n\n  initializeSwitcher() {\n    this.setLocale(this.currentLocale);\n  }\n\n  getCurrentLocale() {\n    return this.currentLocale;\n  }\n\n  getSupportedLocales() {\n    return this.supportedLocales;\n  }\n\n  // React component for language switcher\n  renderSwitcher() {\n    return `\n      <div class="language-switcher">\n        <button class="current-locale" aria-haspopup="true" aria-expanded="false">\n          ${\n            this.supportedLocales.find((l) => l.code === this.currentLocale)\n              ?.flag\n          }\n          ${\n            this.supportedLocales.find((l) => l.code === this.currentLocale)\n              ?.name\n          }\n        </button>\n        <ul class="locale-dropdown" role="menu">\n          ${this.supportedLocales\n            .map(\n              (locale) => `\n            <li role="none">\n              <button \n                role="menuitem" \n                class="locale-option ${\n                  locale.code === this.currentLocale ? "active" : ""\n                }"\n                data-locale="${locale.code}"\n              >\n                ${locale.flag} ${locale.name}\n              </button>\n            </li>\n          `\n            )\n            .join("")}\n        </ul>\n      </div>\n    `;\n  }\n}\n\n// React component\nfunction LanguageSwitcherComponent() {\n  const [currentLocale, setCurrentLocale] = useState(\n    switcher.getCurrentLocale()\n  );\n  const [isOpen, setIsOpen] = useState(false);\n\n  useEffect(() => {\n    const unsubscribe = switcher.subscribe(setCurrentLocale);\n    return unsubscribe;\n  }, []);\n\n  const handleLocaleChange = (locale) => {\n    switcher.setLocale(locale);\n    setIsOpen(false);\n  };\n\n  const currentLocaleInfo = switcher.supportedLocales.find(\n    (l) => l.code === currentLocale\n  );\n\n  return (\n    <div className="language-switcher">\n      <button\n        className="current-locale"\n        onClick={() => setIsOpen(!isOpen)}\n        aria-haspopup="true"\n        aria-expanded={isOpen}\n      >\n        {currentLocaleInfo?.flag} {currentLocaleInfo?.name}\n      </button>\n\n      {isOpen && (\n        <ul className="locale-dropdown" role="menu">\n          {switcher.supportedLocales.map((locale) => (\n            <li key={locale.code} role="none">\n              <button\n                role="menuitem"\n                className={`locale-option ${\n                  locale.code === currentLocale ? "active" : ""\n                }`}\n                onClick={() => handleLocaleChange(locale.code)}\n              >\n                {locale.flag} {locale.name}\n              </button>\n            </li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"i18n-best-practices",children:"i18n Best Practices"}),"\n",(0,r.jsx)(e.h3,{id:"translation-management",children:"Translation Management"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'// Translation structure\nconst translations = {\n  en: {\n    common: {\n      save: "Save",\n      cancel: "Cancel",\n      delete: "Delete",\n      edit: "Edit",\n    },\n    errors: {\n      required: "This field is required",\n      invalid: "Invalid value",\n      network: "Network error occurred",\n    },\n    messages: {\n      saved: "Changes saved successfully",\n      deleted: "Item deleted successfully",\n    },\n  },\n  es: {\n    common: {\n      save: "Guardar",\n      cancel: "Cancelar",\n      delete: "Eliminar",\n      edit: "Editar",\n    },\n    errors: {\n      required: "Este campo es obligatorio",\n      invalid: "Valor inv\xe1lido",\n      network: "Error de red",\n    },\n    messages: {\n      saved: "Cambios guardados exitosamente",\n      deleted: "Elemento eliminado exitosamente",\n    },\n  },\n};\n\n// Translation key management\nconst TranslationKeys = {\n  COMMON: {\n    SAVE: "common.save",\n    CANCEL: "common.cancel",\n    DELETE: "common.delete",\n    EDIT: "common.edit",\n  },\n  ERRORS: {\n    REQUIRED: "errors.required",\n    INVALID: "errors.invalid",\n    NETWORK: "errors.network",\n  },\n  MESSAGES: {\n    SAVED: "messages.saved",\n    DELETED: "messages.deleted",\n  },\n};\n'})}),"\n",(0,r.jsx)(e.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// Lazy loading translations\nclass TranslationLoader {\n  constructor() {\n    this.loadedLocales = new Set();\n    this.loadingPromises = new Map();\n  }\n\n  async loadLocale(locale) {\n    if (this.loadedLocales.has(locale)) {\n      return;\n    }\n\n    if (this.loadingPromises.has(locale)) {\n      return this.loadingPromises.get(locale);\n    }\n\n    const loadPromise = this.loadLocaleFile(locale);\n    this.loadingPromises.set(locale, loadPromise);\n\n    try {\n      await loadPromise;\n      this.loadedLocales.add(locale);\n    } finally {\n      this.loadingPromises.delete(locale);\n    }\n  }\n\n  async loadLocaleFile(locale) {\n    const response = await fetch(`/locales/${locale}.json`);\n    const translations = await response.json();\n\n    // Store translations\n    window.i18n.translations.set(locale, translations);\n  }\n\n  preloadLocales(locales) {\n    return Promise.all(locales.map((locale) => this.loadLocale(locale)));\n  }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"resources",children:"Resources"}),"\n",(0,r.jsx)(e.h3,{id:"documentation",children:"Documentation"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl",children:"MDN Internationalization"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://formatjs.io/docs/intl-messageformat/",children:"ICU MessageFormat"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://formatjs.io/docs/react-intl/",children:"React Intl"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://www.i18next.com/",children:"i18next"})}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"tools",children:"Tools"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://formatjs.io/",children:"FormatJS"})," - Internationalization library"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://www.i18next.com/",children:"i18next"})," - Internationalization framework"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://lingui.js.org/",children:"Lingui"})," - Internationalization library"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://formatjs.io/docs/react-intl/",children:"React Intl"})," - React internationalization"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"practice-platforms",children:"Practice Platforms"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://github.com/i18next/i18next-http-backend",children:"i18n Testing"})," - Backend for i18next"]}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:"https://formatjs.io/docs/intl-messageformat/",children:"ICU MessageFormat Examples"})}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.a,{href:"https://rtlcss.com/",children:"RTL Testing"})," - RTL CSS testing"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.em,{children:"This guide covers essential internationalization concepts for frontend interviews, including practical problems and advanced techniques commonly asked at Big Tech companies."})})]})}function u(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>i});var r=t(6540);const a={},o=r.createContext(a);function s(n){const e=r.useContext(o);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),r.createElement(o.Provider,{value:e},n.children)}}}]);