<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/interview/_next/static/css/387024c6a2216908.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js"/><script src="/interview/_next/static/chunks/fd9d1056-6922f449a204c2cc.js" async=""></script><script src="/interview/_next/static/chunks/117-e7ecc085ce9cfab3.js" async=""></script><script src="/interview/_next/static/chunks/main-app-b06be5f3411c20c3.js" async=""></script><script src="/interview/_next/static/chunks/918-3273b83890f10546.js" async=""></script><script src="/interview/_next/static/chunks/972-011bba60ed155615.js" async=""></script><script src="/interview/_next/static/chunks/930-3262a6c9c5acace4.js" async=""></script><script src="/interview/_next/static/chunks/app/learn/%5Btopic%5D/page-b4f9b7b2865ef07e.js" async=""></script><script src="/interview/_next/static/chunks/710-dfaa11b4dff08f8e.js" async=""></script><script src="/interview/_next/static/chunks/233-3e0c1d820a17eca9.js" async=""></script><script src="/interview/_next/static/chunks/app/layout-333f4adcd11f8f39.js" async=""></script><title>Frontend Interview Prep 2025 - Big Tech Interview Guide</title><meta name="description" content="Comprehensive frontend interview preparation for Big Tech companies including React, TypeScript, algorithms, and system design."/><link rel="icon" href="/favicon.ico"/><meta name="theme-color" content="#1a1a1a"/><meta property="og:title" content="Frontend Interview Prep 2025"/><meta property="og:description" content="Complete guide for frontend engineers targeting Big Tech companies"/><meta property="og:type" content="website"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><meta name="next-size-adjust"/><script src="/interview/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script><style data-styled="" data-styled-version="6.1.19">*{margin:0;padding:0;box-sizing:border-box;}/*!sc*/
html{font-size:16px;line-height:1.5;scroll-behavior:smooth;}/*!sc*/
body{font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;font-size:1rem;line-height:1.5;color:#1e293b;background-color:#ffffff;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
h1,h2,h3,h4,h5,h6{font-weight:700;line-height:1.25;margin-bottom:0.5em;}/*!sc*/
h1{font-size:3rem;}/*!sc*/
@media (max-width: 768px){h1{font-size:2.25rem;}}/*!sc*/
h2{font-size:2.25rem;}/*!sc*/
@media (max-width: 768px){h2{font-size:1.875rem;}}/*!sc*/
h3{font-size:1.875rem;}/*!sc*/
@media (max-width: 768px){h3{font-size:1.5rem;}}/*!sc*/
h4{font-size:1.5rem;}/*!sc*/
@media (max-width: 768px){h4{font-size:1.25rem;}}/*!sc*/
h5{font-size:1.25rem;}/*!sc*/
h6{font-size:1.125rem;}/*!sc*/
p{margin-bottom:1rem;line-height:1.75;}/*!sc*/
a{color:#3b82f6;text-decoration:none;transition:color 0.15s ease;}/*!sc*/
a:hover{color:#2563eb;}/*!sc*/
a:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
button{cursor:pointer;border:none;background:none;font-family:inherit;font-size:inherit;}/*!sc*/
button:disabled{cursor:not-allowed;opacity:0.6;}/*!sc*/
button:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
input,textarea,select{font-family:inherit;font-size:inherit;}/*!sc*/
input:focus,textarea:focus,select:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
img{max-width:100%;height:auto;}/*!sc*/
ul,ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
li{margin-bottom:0.25rem;}/*!sc*/
blockquote{margin:1rem 0;padding:1rem;border-left:4px solid #3b82f6;background-color:#f1f5f9;font-style:italic;}/*!sc*/
code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;background-color:#f1f5f9;padding:0.2em 0.4em;border-radius:0.25rem;}/*!sc*/
pre{background-color:#f1f5f9;padding:1rem;border-radius:0.5rem;overflow-x:auto;margin-bottom:1rem;}/*!sc*/
pre code{background:none;padding:0;}/*!sc*/
table{width:100%;border-collapse:collapse;margin-bottom:1rem;}/*!sc*/
th,td{padding:0.75rem;text-align:left;border-bottom:1px solid #e2e8f0;}/*!sc*/
th{font-weight:600;background-color:#f1f5f9;}/*!sc*/
.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0;}/*!sc*/
.skip-link{position:absolute;top:-40px;left:6px;background:#3b82f6;color:white;padding:8px;text-decoration:none;border-radius:4px;z-index:100;}/*!sc*/
.skip-link:focus{top:6px;}/*!sc*/
::-webkit-scrollbar{width:8px;height:8px;}/*!sc*/
::-webkit-scrollbar-track{background:#f1f5f9;}/*!sc*/
::-webkit-scrollbar-thumb{background:#94a3b8;border-radius:4px;}/*!sc*/
::-webkit-scrollbar-thumb:hover{background:#64748b;}/*!sc*/
::selection{background:#3b82f6;color:white;}/*!sc*/
.focus-visible{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
.fade-in{opacity:0;animation:fadeIn 0.3s ease forwards;}/*!sc*/
.slide-up{transform:translateY(20px);opacity:0;animation:slideUp 0.3s ease forwards;}/*!sc*/
@keyframes fadeIn{to{opacity:1;}}/*!sc*/
@keyframes slideUp{to{transform:translateY(0);opacity:1;}}/*!sc*/
@media print{*{background:white!important;color:black!important;box-shadow:none!important;text-shadow:none!important;}a,a:visited{text-decoration:underline;}h1,h2,h3,h4,h5,h6{break-after:avoid;}pre,blockquote{border:1px solid #999;break-inside:avoid;}img{max-width:100%!important;}@page{margin:0.5in;}}/*!sc*/
data-styled.g1[id="sc-global-kxA-Ddz1"]{content:"sc-global-kxA-Ddz1,"}/*!sc*/
.wbMrm{position:fixed;top:0;width:100%;z-index:1020;background:transparent;backdrop-filter:blur(10px);border-bottom:1px solid transparent;transition:all 0.3s ease;}/*!sc*/
data-styled.g2[id="sc-bRKDuR"]{content:"wbMrm,"}/*!sc*/
.kDxBNU{max-width:1200px;margin:0 auto;padding:0 2rem;display:flex;align-items:center;justify-content:space-between;height:70px;}/*!sc*/
data-styled.g3[id="sc-hvigdm"]{content:"kDxBNU,"}/*!sc*/
.cvsJZg{display:flex;align-items:center;gap:0.5rem;font-size:1.5rem;font-weight:700;color:#3b82f6;text-decoration:none;cursor:pointer;}/*!sc*/
.cvsJZg:hover{color:#2563eb;}/*!sc*/
data-styled.g4[id="sc-fhHczv"]{content:"cvsJZg,"}/*!sc*/
.lfYVIv{display:flex;align-items:center;gap:2rem;}/*!sc*/
@media (max-width: 768px){.lfYVIv{display:none;}}/*!sc*/
data-styled.g5[id="sc-ggWZvA"]{content:"lfYVIv,"}/*!sc*/
.bhKRhV{color:#1e293b;font-weight:500;text-decoration:none;transition:color 0.15s ease;position:relative;}/*!sc*/
.bhKRhV:hover{color:#3b82f6;}/*!sc*/
.bhKRhV:after{content:'';position:absolute;bottom:-5px;left:0;width:0;height:2px;background:#3b82f6;transition:width 0.15s ease;}/*!sc*/
.bhKRhV:hover:after{width:100%;}/*!sc*/
data-styled.g6[id="sc-dTvVRJ"]{content:"bhKRhV,"}/*!sc*/
.gpUImn{display:none;background:none;border:none;color:#1e293b;cursor:pointer;padding:0.5rem;}/*!sc*/
@media (max-width: 768px){.gpUImn{display:block;}}/*!sc*/
data-styled.g7[id="sc-jwTyAe"]{content:"gpUImn,"}/*!sc*/
.hpKWkw{display:flex;align-items:center;gap:0.5rem;background:#f1f5f9;border:1px solid #e2e8f0;border-radius:0.5rem;padding:0.5rem 1rem;color:#64748b;font-size:0.9rem;transition:all 0.15s ease;}/*!sc*/
.hpKWkw:hover{background:#ffffff;border-color:#3b82f6;}/*!sc*/
data-styled.g11[id="sc-kNOymR"]{content:"hpKWkw,"}/*!sc*/
.cJzheU{background:#1e293b;color:white;padding:3rem 0 1rem;margin-top:auto;}/*!sc*/
data-styled.g12[id="sc-dYwGCk"]{content:"cJzheU,"}/*!sc*/
.hJUFeT{max-width:1200px;margin:0 auto;padding:0 2rem;}/*!sc*/
data-styled.g13[id="sc-lgpSej"]{content:"hJUFeT,"}/*!sc*/
.mSxwd{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:2rem;margin-bottom:2rem;}/*!sc*/
@media (max-width: 768px){.mSxwd{grid-template-columns:1fr 1fr;gap:1.5rem;}}/*!sc*/
@media (max-width: 480px){.mSxwd{grid-template-columns:1fr;}}/*!sc*/
data-styled.g14[id="sc-eqYatC"]{content:"mSxwd,"}/*!sc*/
.cmBIup h3{font-size:1.1rem;font-weight:600;margin-bottom:1rem;color:white;}/*!sc*/
.cmBIup ul{list-style:none;padding:0;margin:0;}/*!sc*/
.cmBIup li{margin-bottom:0.5rem;}/*!sc*/
.cmBIup a{color:rgba(255, 255, 255, 0.7);text-decoration:none;transition:color 0.15s ease;}/*!sc*/
.cmBIup a:hover{color:white;}/*!sc*/
data-styled.g15[id="sc-kcLKEh"]{content:"cmBIup,"}/*!sc*/
.bAsNIP{display:flex;align-items:center;gap:0.5rem;font-size:1.2rem;font-weight:700;margin-bottom:1rem;color:white;}/*!sc*/
data-styled.g16[id="sc-dntSTA"]{content:"bAsNIP,"}/*!sc*/
.gWXMDV{color:rgba(255, 255, 255, 0.7);line-height:1.6;margin-bottom:1rem;}/*!sc*/
data-styled.g17[id="sc-kvnevz"]{content:"gWXMDV,"}/*!sc*/
.jCoOHQ{display:flex;gap:1rem;}/*!sc*/
.jCoOHQ a{display:flex;align-items:center;justify-content:center;width:40px;height:40px;background:rgba(255, 255, 255, 0.1);border-radius:0.5rem;color:rgba(255, 255, 255, 0.7);transition:all 0.15s ease;}/*!sc*/
.jCoOHQ a:hover{background:rgba(255, 255, 255, 0.2);color:white;}/*!sc*/
data-styled.g18[id="sc-dFVmKS"]{content:"jCoOHQ,"}/*!sc*/
.crUaYh{border-top:1px solid rgba(255, 255, 255, 0.1);padding-top:2rem;display:flex;justify-content:space-between;align-items:center;}/*!sc*/
@media (max-width: 768px){.crUaYh{flex-direction:column;gap:1rem;text-align:center;}}/*!sc*/
data-styled.g19[id="sc-kCuUfV"]{content:"crUaYh,"}/*!sc*/
.esMlQF{color:rgba(255, 255, 255, 0.7);margin:0;font-size:0.9rem;}/*!sc*/
data-styled.g20[id="sc-dNdcvo"]{content:"esMlQF,"}/*!sc*/
.eHcrXx{display:flex;gap:2rem;}/*!sc*/
@media (max-width: 480px){.eHcrXx{flex-direction:column;gap:1rem;}}/*!sc*/
.eHcrXx a{color:rgba(255, 255, 255, 0.7);text-decoration:none;font-size:0.9rem;transition:color 0.15s ease;}/*!sc*/
.eHcrXx a:hover{color:white;}/*!sc*/
data-styled.g21[id="sc-fbQrwq"]{content:"eHcrXx,"}/*!sc*/
.FBMvQ{color:#1e293b;line-height:1.6;}/*!sc*/
.FBMvQ h1,.FBMvQ h2,.FBMvQ h3,.FBMvQ h4,.FBMvQ h5,.FBMvQ h6{color:#1e293b;margin-top:2rem;margin-bottom:1rem;font-weight:600;}/*!sc*/
.FBMvQ h1{font-size:2rem;border-bottom:2px solid #e2e8f0;padding-bottom:0.5rem;}/*!sc*/
.FBMvQ h2{font-size:1.5rem;border-bottom:1px solid #e2e8f0;padding-bottom:0.3rem;}/*!sc*/
.FBMvQ h3{font-size:1.25rem;}/*!sc*/
.FBMvQ h4{font-size:1.1rem;}/*!sc*/
.FBMvQ p{margin-bottom:1rem;color:#64748b;}/*!sc*/
.FBMvQ a{color:#3b82f6;text-decoration:none;}/*!sc*/
.FBMvQ a:hover{text-decoration:underline;}/*!sc*/
.FBMvQ ul,.FBMvQ ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
.FBMvQ ul li,.FBMvQ ol li{margin-bottom:0.5rem;color:#64748b;}/*!sc*/
.FBMvQ blockquote{border-left:4px solid #3b82f6;padding-left:1rem;margin:1rem 0;font-style:italic;color:#64748b;background:#f1f5f9;padding:1rem;border-radius:0.5rem;}/*!sc*/
.FBMvQ code{background:#f1f5f9;padding:0.2rem 0.4rem;border-radius:0.25rem;font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;color:#f59e0b;}/*!sc*/
.FBMvQ pre{background:#ffffff;border:1px solid #e2e8f0;border-radius:0.5rem;padding:1rem;margin:1rem 0;overflow-x:auto;}/*!sc*/
.FBMvQ pre code{background:none;padding:0;color:#1e293b;font-size:0.9rem;}/*!sc*/
.FBMvQ table{width:100%;border-collapse:collapse;margin:1rem 0;}/*!sc*/
.FBMvQ table th,.FBMvQ table td{border:1px solid #e2e8f0;padding:0.5rem;text-align:left;}/*!sc*/
.FBMvQ table th{background:#ffffff;font-weight:600;}/*!sc*/
.FBMvQ table tr:nth-child(even){background:#f1f5f9;}/*!sc*/
.FBMvQ hr{border:none;height:1px;background:#e2e8f0;margin:2rem 0;}/*!sc*/
.FBMvQ .highlight{background:#3b82f620;padding:0.2rem 0.4rem;border-radius:0.25rem;font-weight:600;}/*!sc*/
.FBMvQ .hljs{background:#ffffff;color:#1e293b;}/*!sc*/
.FBMvQ .hljs-keyword{color:#3b82f6;font-weight:600;}/*!sc*/
.FBMvQ .hljs-string{color:#10b981;}/*!sc*/
.FBMvQ .hljs-function{color:#f59e0b;}/*!sc*/
.FBMvQ .hljs-comment{color:#94a3b8;font-style:italic;}/*!sc*/
.FBMvQ .hljs-number{color:#f59e0b;}/*!sc*/
.FBMvQ .hljs-variable{color:#1e293b;}/*!sc*/
.FBMvQ .hljs-title{color:#f59e0b;font-weight:600;}/*!sc*/
data-styled.g22[id="sc-gGKoUb"]{content:"FBMvQ,"}/*!sc*/
</style></head><body class="__className_6eac61"><div style="min-height:100vh;display:flex;flex-direction:column"><nav class="sc-bRKDuR wbMrm"><div class="sc-hvigdm kDxBNU"><a href="/interview"><a class="sc-fhHczv cvsJZg"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</a></a><div class="sc-ggWZvA lfYVIv"><a href="/interview/problems"><a class="sc-dTvVRJ bhKRhV">Problems</a></a><a href="/interview/learn"><a class="sc-dTvVRJ bhKRhV">Learn</a></a><a href="/interview/study-guide"><a class="sc-dTvVRJ bhKRhV">Study Guide</a></a><a href="/interview/system-design"><a class="sc-dTvVRJ bhKRhV">System Design</a></a><a href="/interview/performance"><a class="sc-dTvVRJ bhKRhV">Performance</a></a><a href="/interview/accessibility"><a class="sc-dTvVRJ bhKRhV">Accessibility</a></a><a href="/interview/interview-tips"><a class="sc-dTvVRJ bhKRhV">Interview Tips</a></a><button class="sc-kNOymR hpKWkw"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search "><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg>Search</button></div><button class="sc-jwTyAe gpUImn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu "><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button></div></nav><main style="flex:1"><div class="max-w-6xl mx-auto px-8 py-24"><div class="flex items-center gap-4 mb-8"><a href="/interview/learn"><button class="flex items-center gap-2 bg-gray-100 border border-gray-300 text-gray-700 px-4 py-3 rounded-md font-medium hover:bg-gray-200 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left "><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg>Back to Learn</button></a></div><div class="bg-white border border-gray-200 rounded-lg p-8 mb-8"><div class="flex items-center justify-between mb-4"><h1 class="text-3xl font-bold text-gray-900">JavaScript Event Loop: Complete Deep Dive</h1><div class="flex gap-4"><button class="flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star "><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>Bookmark</button><button class="flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share2 "><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" x2="15.42" y1="13.51" y2="17.49"></line><line x1="15.41" x2="8.59" y1="6.51" y2="10.49"></line></svg>Share</button></div></div><div class="flex gap-8 mb-4"><div class="flex items-center gap-2 text-sm text-gray-600"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock "><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>2-3 hours</div><span class="px-3 py-1 rounded-full text-xs font-semibold text-white bg-yellow-500">Intermediate</span><span class="px-3 py-1 rounded-full text-xs font-semibold bg-blue-100 text-blue-700">General</span></div><p class="text-lg text-gray-700 leading-relaxed">The **Event Loop** is the fundamental mechanism that allows JavaScript to perform asynchronous operations despite being a single-threaded language. It&#x27;s the coordination system between the JavaScript ...</p></div><div class="grid grid-cols-1 lg:grid-cols-3 gap-8"><div class="lg:col-span-2"><div class="bg-white border border-gray-200 rounded-lg p-8"><div class="sc-gGKoUb FBMvQ"><h1 id="javascript-event-loop:-complete-deep-dive" node="[object Object]">JavaScript Event Loop: Complete Deep Dive</h1>
<h2 id="table-of-contents" node="[object Object]">Table of Contents</h2>
<ul>
<li><a href="#understanding-the-event-loop" node="[object Object]">Understanding the Event Loop</a></li>
<li><a href="#call-stack-fundamentals" node="[object Object]">Call Stack Fundamentals</a></li>
<li><a href="#web-apis-and-browser-environment" node="[object Object]">Web APIs and Browser Environment</a></li>
<li><a href="#task-queue-vs-microtask-queue" node="[object Object]">Task Queue vs Microtask Queue</a></li>
<li><a href="#event-loop-phases" node="[object Object]">Event Loop Phases</a></li>
<li><a href="#visual-diagrams" node="[object Object]">Visual Diagrams</a></li>
<li><a href="#common-misconceptions" node="[object Object]">Common Misconceptions</a></li>
<li><a href="#performance-implications" node="[object Object]">Performance Implications</a></li>
<li><a href="#interview-questions--answers" node="[object Object]">Interview Questions &amp; Answers</a></li>
<li><a href="#practical-examples" node="[object Object]">Practical Examples</a></li>
</ul>
<h2 id="understanding-the-event-loop" node="[object Object]">Understanding the Event Loop</h2>
<h3 id="what-is-the-event-loop?" node="[object Object]">What is the Event Loop?</h3>
<p>The <strong>Event Loop</strong> is the fundamental mechanism that allows JavaScript to perform asynchronous operations despite being a single-threaded language. It&#x27;s the coordination system between the JavaScript engine and the browser&#x27;s Web APIs.</p>
<h4>Key Concepts:</h4>
<p><strong>1. Single-Threaded Nature</strong></p>
<ul>
<li>JavaScript has only <strong>one call stack</strong></li>
<li>Only <strong>one thing can happen at a time</strong></li>
<li>But it can handle <strong>asynchronous operations</strong> through the event loop</li>
</ul>
<p><strong>2. Non-Blocking I/O</strong></p>
<ul>
<li>Long-running operations don&#x27;t freeze the UI</li>
<li>Callbacks are scheduled for later execution</li>
<li>Maintains responsive user interfaces</li>
</ul>
<p><strong>3. Concurrency Model</strong></p>
<ul>
<li>JavaScript achieves concurrency through the event loop</li>
<li>Multiple operations can be <strong>initiated</strong> simultaneously</li>
<li>But they&#x27;re <strong>executed</strong> one at a time</li>
</ul>
<h3 id="the-big-picture-architecture" node="[object Object]">The Big Picture Architecture</h3>
<pre><pre><code class="hljs undefined">┌─────────────────────────────────────────────────────┐
│                 BROWSER ENVIRONMENT                 │
├─────────────────────────────────────────────────────┤
│  JavaScript Engine (V8, SpiderMonkey, etc.)        │
│  ┌─────────────┐  ┌─────────────┐                  │
│  │    Heap     │  │ Call Stack  │                  │
│  │   Memory    │  │             │                  │
│  │ Allocation  │  │ Execution   │                  │
│  └─────────────┘  │ Context     │                  │
│                   └─────────────┘                  │
├─────────────────────────────────────────────────────┤
│                  WEB APIs                           │
│  DOM APIs │ HTTP │ Timers │ Geolocation │ etc.     │
├─────────────────────────────────────────────────────┤
│              TASK QUEUES                            │
│  ┌─────────────┐  ┌─────────────┐                  │
│  │  Callback   │  │ Microtask   │                  │
│  │   Queue     │  │   Queue     │                  │
│  │(Macrotasks) │  │(Promises)   │                  │
│  └─────────────┘  └─────────────┘                  │
└─────────────────────────────────────────────────────┘
              ↑
        EVENT LOOP
</code></pre></pre>
<h2 id="call-stack-fundamentals" node="[object Object]">Call Stack Fundamentals</h2>
<h3 id="how-the-call-stack-works" node="[object Object]">How the Call Stack Works</h3>
<p>The <strong>Call Stack</strong> is a LIFO (Last In, First Out) data structure that keeps track of function calls.</p>
<h4>Stack Operations:</h4>
<p><strong>1. Function Call (Push)</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;First function&quot;</span>);
  <span class="hljs-title function_">second</span>();
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Second function&quot;</span>);
  <span class="hljs-title function_">third</span>();
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">third</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Third function&quot;</span>);
}

<span class="hljs-title function_">first</span>();
</code></pre></pre>
<p><strong>Call Stack Visualization:</strong></p>
<pre><pre><code class="hljs undefined">Step 1: first() called
┌─────────────┐
│   first()   │
└─────────────┘

Step 2: second() called from first()
┌─────────────┐
│  second()   │
├─────────────┤
│   first()   │
└─────────────┘

Step 3: third() called from second()
┌─────────────┐
│   third()   │
├─────────────┤
│  second()   │
├─────────────┤
│   first()   │
└─────────────┘

Step 4: third() completes (Pop)
┌─────────────┐
│  second()   │
├─────────────┤
│   first()   │
└─────────────┘

Step 5: second() completes (Pop)
┌─────────────┐
│   first()   │
└─────────────┘

Step 6: first() completes (Pop)
┌─────────────┐
│    Empty    │
└─────────────┘
</code></pre></pre>
<h3 id="stack-overflow" node="[object Object]">Stack Overflow</h3>
<p>When the call stack exceeds its limit:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">recursiveFunction</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">recursiveFunction</span>(); <span class="hljs-comment">// Infinite recursion</span>
}

<span class="hljs-title function_">recursiveFunction</span>(); <span class="hljs-comment">// RangeError: Maximum call stack size exceeded</span>
</code></pre></pre>
<p><strong>Prevention Strategies:</strong></p>
<ul>
<li>Use iterative solutions when possible</li>
<li>Implement proper base cases in recursion</li>
<li>Use setTimeout for deep recursion to break stack</li>
</ul>
<h2 id="web-apis-and-browser-environment" node="[object Object]">Web APIs and Browser Environment</h2>
<h3 id="what-are-web-apis?" node="[object Object]">What are Web APIs?</h3>
<p>Web APIs are browser-provided interfaces that allow JavaScript to interact with browser features asynchronously.</p>
<h4>Common Web APIs:</h4>
<p><strong>1. Timer APIs</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// setTimeout - executes after delay</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Timer callback&quot;</span>), <span class="hljs-number">1000</span>);

<span class="hljs-comment">// setInterval - executes repeatedly</span>
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Interval callback&quot;</span>), <span class="hljs-number">1000</span>);

<span class="hljs-comment">// setImmediate (Node.js)</span>
<span class="hljs-title function_">setImmediate</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Immediate callback&quot;</span>));
</code></pre></pre>
<p><strong>2. DOM APIs</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Event listeners</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Click handled&quot;</span>);
});

<span class="hljs-comment">// DOM manipulation</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button clicked&quot;</span>);
};
</code></pre></pre>
<p><strong>3. Network APIs</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Fetch API</span>
<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/api/data&quot;</span>)
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> response.<span class="hljs-title function_">json</span>())
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data));

<span class="hljs-comment">// XMLHttpRequest</span>
<span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/api/data&quot;</span>);
xhr.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>);
xhr.<span class="hljs-title function_">send</span>();
</code></pre></pre>
<h3 id="how-web-apis-work" node="[object Object]">How Web APIs Work</h3>
<p>When you call a Web API:</p>
<ol>
<li><strong>Delegation</strong>: JavaScript delegates the operation to the browser</li>
<li><strong>Continuation</strong>: JavaScript continues executing other code</li>
<li><strong>Completion</strong>: Browser completes the operation</li>
<li><strong>Callback</strong>: Browser places callback in appropriate queue</li>
</ol>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Start&quot;</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Timer callback&quot;</span>);
}, <span class="hljs-number">0</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;End&quot;</span>);

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// Start</span>
<span class="hljs-comment">// End</span>
<span class="hljs-comment">// Timer callback</span>
</code></pre></pre>
<h2 id="task-queue-vs-microtask-queue" node="[object Object]">Task Queue vs Microtask Queue</h2>
<h3 id="understanding-queues" node="[object Object]">Understanding Queues</h3>
<p>The Event Loop manages two main types of queues with different priorities:</p>
<h4>1. Macrotask Queue (Task Queue)</h4>
<ul>
<li><strong>Lower priority</strong></li>
<li>Processed <strong>after</strong> microtasks</li>
<li><strong>Sources</strong>: setTimeout, setInterval, I/O operations, UI events</li>
</ul>
<h4>2. Microtask Queue</h4>
<ul>
<li><strong>Higher priority</strong></li>
<li>Processed <strong>before</strong> macrotasks</li>
<li><strong>Sources</strong>: Promises, queueMicrotask, MutationObserver</li>
</ul>
<h3 id="priority-system" node="[object Object]">Priority System</h3>
<pre><pre><code class="hljs undefined">Event Loop Priority (High to Low):
1. Call Stack (currently executing)
2. Microtask Queue (Promises, queueMicrotask)
3. Macrotask Queue (setTimeout, DOM events)
</code></pre></pre>
<h3 id="visual-representation" node="[object Object]">Visual Representation</h3>
<pre><pre><code class="hljs undefined">┌─────────────────────────────────────────────────────┐
│                EVENT LOOP CYCLE                     │
│                                                     │
│  1. Execute Call Stack to completion                │
│  2. Process ALL Microtasks                          │
│  3. Process ONE Macrotask                           │
│  4. Process ALL Microtasks (again)                  │
│  5. Render (if needed)                              │
│  6. Repeat                                          │
│                                                     │
└─────────────────────────────────────────────────────┘
</code></pre></pre>
<h3 id="detailed-example" node="[object Object]">Detailed Example</h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1: Start&quot;</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2: setTimeout&quot;</span>), <span class="hljs-number">0</span>);

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3: Promise 1&quot;</span>))
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;4: Promise 2&quot;</span>));

<span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;5: queueMicrotask&quot;</span>));

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;6: setTimeout 2&quot;</span>), <span class="hljs-number">0</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;7: End&quot;</span>);

<span class="hljs-comment">// Execution Order:</span>
<span class="hljs-comment">// 1: Start</span>
<span class="hljs-comment">// 7: End</span>
<span class="hljs-comment">// 3: Promise 1</span>
<span class="hljs-comment">// 5: queueMicrotask</span>
<span class="hljs-comment">// 4: Promise 2</span>
<span class="hljs-comment">// 2: setTimeout</span>
<span class="hljs-comment">// 6: setTimeout 2</span>
</code></pre></pre>
<p><strong>Step-by-Step Breakdown:</strong></p>
<pre><pre><code class="hljs undefined">Initial State:
Call Stack: [main()]
Microtask Queue: []
Macrotask Queue: []

After console.log(&#x27;1: Start&#x27;):
Call Stack: [main()]
Microtask Queue: []
Macrotask Queue: []
Output: &quot;1: Start&quot;

After setTimeout:
Call Stack: [main()]
Microtask Queue: []
Macrotask Queue: [setTimeout callback]

After Promise.resolve():
Call Stack: [main()]
Microtask Queue: [Promise callback]
Macrotask Queue: [setTimeout callback]

After queueMicrotask:
Call Stack: [main()]
Microtask Queue: [Promise callback, queueMicrotask callback]
Macrotask Queue: [setTimeout callback]

After second setTimeout:
Call Stack: [main()]
Microtask Queue: [Promise callback, queueMicrotask callback]
Macrotask Queue: [setTimeout callback, setTimeout callback 2]

After console.log(&#x27;7: End&#x27;):
Call Stack: [main()]
Microtask Queue: [Promise callback, queueMicrotask callback]
Macrotask Queue: [setTimeout callback, setTimeout callback 2]
Output: &quot;1: Start&quot;, &quot;7: End&quot;

Main function completes - Call Stack empty
Process Microtasks:
- Execute Promise callback → &quot;3: Promise 1&quot;
- Execute queueMicrotask callback → &quot;5: queueMicrotask&quot;
- Promise.then adds new microtask
- Execute Promise 2 callback → &quot;4: Promise 2&quot;

All Microtasks processed, process ONE Macrotask:
- Execute first setTimeout → &quot;2: setTimeout&quot;

Check for Microtasks (none), process next Macrotask:
- Execute second setTimeout → &quot;6: setTimeout 2&quot;
</code></pre></pre>
<h2 id="event-loop-phases" node="[object Object]">Event Loop Phases</h2>
<h3 id="detailed-event-loop-algorithm" node="[object Object]">Detailed Event Loop Algorithm</h3>
<p>The Event Loop operates in phases:</p>
<pre><pre><code class="hljs undefined">┌───────────────────────────┐
┌─&gt;│           timers          │  ← setTimeout, setInterval callbacks
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │  ← I/O callbacks (except close, timers, setImmediate)
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │  ← Internal use only
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │           poll            │  ← Fetch new I/O events; execute I/O callbacks
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │           check           │  ← setImmediate callbacks
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │  ← close event callbacks
   └───────────────────────────┘
</code></pre></pre>
<h3 id="browser-event-loop-vs-node.js" node="[object Object]">Browser Event Loop vs Node.js</h3>
<p><strong>Browser Event Loop:</strong></p>
<ul>
<li>Simpler model</li>
<li>Focuses on user interaction</li>
<li>Microtasks processed after each macrotask</li>
</ul>
<p><strong>Node.js Event Loop:</strong></p>
<ul>
<li>More complex with phases</li>
<li>Handles I/O efficiently</li>
<li>Different microtask timing</li>
</ul>
<h2 id="visual-diagrams" node="[object Object]">Visual Diagrams</h2>
<h3 id="complete-event-loop-flow" node="[object Object]">Complete Event Loop Flow</h3>
<pre><pre><code class="hljs undefined">┌─────────────────────────────────────────────────────────────────┐
│                        JAVASCRIPT RUNTIME                       │
│                                                                 │
│  ┌─────────────┐    ┌─────────────────────────────────────────┐ │
│  │    HEAP     │    │             CALL STACK                 │ │
│  │             │    │                                        │ │
│  │   Objects   │    │  ┌─────────────────────────────────┐   │ │
│  │  Memory     │    │  │        function()               │   │ │
│  │             │    │  └─────────────────────────────────┘   │ │
│  │             │    │  ┌─────────────────────────────────┐   │ │
│  │             │    │  │        function()               │   │ │
│  │             │    │  └─────────────────────────────────┘   │ │
│  │             │    │  ┌─────────────────────────────────┐   │ │
│  │             │    │  │         main()                  │   │ │
│  │             │    │  └─────────────────────────────────┘   │ │
│  └─────────────┘    └─────────────────────────────────────────┘ │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────┐
│                          WEB APIs                               │
│                                                                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐  │
│  │    DOM      │  │   Network   │  │        Timers           │  │
│  │   Events    │  │    APIs     │  │    setTimeout()         │  │
│  │             │  │   fetch()   │  │    setInterval()        │  │
│  └─────────────┘  └─────────────┘  └─────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────┐
│                        TASK QUEUES                             │
│                                                                 │
│  ┌─────────────────────────────┐  ┌─────────────────────────┐   │
│  │      MICROTASK QUEUE        │  │     MACROTASK QUEUE     │   │
│  │      (High Priority)        │  │     (Low Priority)      │   │
│  │                             │  │                         │   │
│  │  ┌─────────────────────┐    │  │  ┌─────────────────┐    │   │
│  │  │ Promise.then()      │    │  │  │ setTimeout()    │    │   │
│  │  └─────────────────────┘    │  │  └─────────────────┘    │   │
│  │  ┌─────────────────────┐    │  │  ┌─────────────────┐    │   │
│  │  │ queueMicrotask()    │    │  │  │ DOM Events      │    │   │
│  │  └─────────────────────┘    │  │  └─────────────────┘    │   │
│  │  ┌─────────────────────┐    │  │  ┌─────────────────┐    │   │
│  │  │ async/await         │    │  │  │ I/O Operations  │    │   │
│  │  └─────────────────────┘    │  │  └─────────────────┘    │   │
│  └─────────────────────────────┘  └─────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
                                   ▲
                                   │
                         ┌─────────────────┐
                         │   EVENT LOOP    │
                         │                 │
                         │  1. Check Stack │
                         │  2. Microtasks  │
                         │  3. Macrotasks  │
                         │  4. Render      │
                         │  5. Repeat      │
                         └─────────────────┘
</code></pre></pre>
<h3 id="promise-vs-settimeout-timing" node="[object Object]">Promise vs setTimeout Timing</h3>
<pre><pre><code class="hljs undefined">Timeline: Promise vs setTimeout Execution

Time: 0ms
┌─────────────────────────────────────────────────────────────┐
│ console.log(&#x27;start&#x27;)                                        │
│ setTimeout(() =&gt; console.log(&#x27;timeout&#x27;), 0)                │
│ Promise.resolve().then(() =&gt; console.log(&#x27;promise&#x27;))       │
│ console.log(&#x27;end&#x27;)                                          │
└─────────────────────────────────────────────────────────────┘

Call Stack:     [main]
Microtasks:     []
Macrotasks:     []
Output:         &quot;start&quot;

Time: 1ms
┌─────────────────────────────────────────────────────────────┐
│ setTimeout callback queued                                  │
└─────────────────────────────────────────────────────────────┘

Call Stack:     [main]
Microtasks:     []
Macrotasks:     [setTimeout callback]
Output:         &quot;start&quot;

Time: 2ms
┌─────────────────────────────────────────────────────────────┐
│ Promise callback queued                                     │
└─────────────────────────────────────────────────────────────┘

Call Stack:     [main]
Microtasks:     [Promise callback]
Macrotasks:     [setTimeout callback]
Output:         &quot;start&quot;

Time: 3ms
┌─────────────────────────────────────────────────────────────┐
│ console.log(&#x27;end&#x27;) executed                                 │
└─────────────────────────────────────────────────────────────┘

Call Stack:     [main]
Microtasks:     [Promise callback]
Macrotasks:     [setTimeout callback]
Output:         &quot;start&quot;, &quot;end&quot;

Time: 4ms - main() completes
┌─────────────────────────────────────────────────────────────┐
│ Call stack empty - Process microtasks first                │
└─────────────────────────────────────────────────────────────┘

Call Stack:     []
Microtasks:     [Promise callback] → Execute
Macrotasks:     [setTimeout callback]
Output:         &quot;start&quot;, &quot;end&quot;, &quot;promise&quot;

Time: 5ms
┌─────────────────────────────────────────────────────────────┐
│ All microtasks done - Process one macrotask                │
└─────────────────────────────────────────────────────────────┘

Call Stack:     []
Microtasks:     []
Macrotasks:     [setTimeout callback] → Execute
Output:         &quot;start&quot;, &quot;end&quot;, &quot;promise&quot;, &quot;timeout&quot;
</code></pre></pre>
<h2 id="common-misconceptions" node="[object Object]">Common Misconceptions</h2>
<h3 id="misconception-1:-&quot;settimeout(fn,-0)-executes-immediately&quot;" node="[object Object]">Misconception 1: &quot;setTimeout(fn, 0) executes immediately&quot;</h3>
<p><strong>Reality</strong>: setTimeout(fn, 0) schedules execution for the next event loop cycle.</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>), <span class="hljs-number">0</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>);

<span class="hljs-comment">// Output: 1, 3, 2 (not 1, 2, 3)</span>
</code></pre></pre>
<h3 id="misconception-2:-&quot;promises-are-synchronous&quot;" node="[object Object]">Misconception 2: &quot;Promises are synchronous&quot;</h3>
<p><strong>Reality</strong>: Promise callbacks are asynchronous microtasks.</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>);
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;2&quot;</span>));
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;3&quot;</span>);

<span class="hljs-comment">// Output: 1, 3, 2</span>
</code></pre></pre>
<h3 id="misconception-3:-&quot;all-async-operations-are-the-same-priority&quot;" node="[object Object]">Misconception 3: &quot;All async operations are the same priority&quot;</h3>
<p><strong>Reality</strong>: Microtasks have higher priority than macrotasks.</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>), <span class="hljs-number">0</span>);
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Promise&quot;</span>));
<span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;queueMicrotask&quot;</span>));

<span class="hljs-comment">// Output: Promise, queueMicrotask, setTimeout</span>
</code></pre></pre>
<h2 id="performance-implications" node="[object Object]">Performance Implications</h2>
<h3 id="blocking-the-event-loop" node="[object Object]">Blocking the Event Loop</h3>
<p><strong>Long-running synchronous operations block everything:</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// BAD: Blocks event loop</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">heavyComputation</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000000</span>; i++) {
    result += i;
  }
  <span class="hljs-keyword">return</span> result;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Start&quot;</span>);
<span class="hljs-title function_">heavyComputation</span>(); <span class="hljs-comment">// Blocks everything</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;End&quot;</span>);
</code></pre></pre>
<p><strong>Solution: Break work into chunks:</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// GOOD: Non-blocking approach</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">heavyComputationAsync</span>(<span class="hljs-params">start, end, chunkSize = <span class="hljs-number">1000000</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> current = start;

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">processChunk</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> chunkEnd = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(current + chunkSize, end);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = current; i &lt; chunkEnd; i++) {
        result += i;
      }

      current = chunkEnd;

      <span class="hljs-keyword">if</span> (current &lt; end) {
        <span class="hljs-built_in">setTimeout</span>(processChunk, <span class="hljs-number">0</span>); <span class="hljs-comment">// Yield control</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">resolve</span>(result);
      }
    }

    <span class="hljs-title function_">processChunk</span>();
  });
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Start&quot;</span>);
<span class="hljs-title function_">heavyComputationAsync</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000000000</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Result:&quot;</span>, result)
);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;End&quot;</span>);
<span class="hljs-comment">// Output: Start, End, Result: [number]</span>
</code></pre></pre>
<h3 id="microtask-queue-starvation" node="[object Object]">Microtask Queue Starvation</h3>
<p><strong>Problem</strong>: Too many microtasks can starve macrotasks:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// BAD: Infinite microtask loop</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">recursiveMicrotask</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(recursiveMicrotask);
}

<span class="hljs-title function_">recursiveMicrotask</span>(); <span class="hljs-comment">// Blocks all macrotasks!</span>
</code></pre></pre>
<p><strong>Solution</strong>: Use macrotasks for long-running operations:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// GOOD: Mix microtasks and macrotasks</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">balancedRecursion</span>(<span class="hljs-params">count = <span class="hljs-number">0</span></span>) {
  <span class="hljs-keyword">if</span> (count % <span class="hljs-number">100</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Use macrotask every 100 iterations</span>
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">balancedRecursion</span>(count + <span class="hljs-number">1</span>), <span class="hljs-number">0</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// Use microtask for most iterations</span>
    <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">balancedRecursion</span>(count + <span class="hljs-number">1</span>));
  }
}
</code></pre></pre>
<h2 id="interview-questions-&amp;-answers" node="[object Object]">Interview Questions &amp; Answers</h2>
<h3 id="q1:-what-will-this-code-output-and-why?" node="[object Object]">Q1: What will this code output and why?</h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;B&quot;</span>), <span class="hljs-number">0</span>);

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;C&quot;</span>);
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;D&quot;</span>), <span class="hljs-number">0</span>);
});

<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;E&quot;</span>));

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;F&quot;</span>);
</code></pre></pre>
<p><strong>Answer</strong>: A, F, C, E, B, D</p>
<p><strong>Explanation</strong>:</p>
<ol>
<li><strong>A</strong> - Synchronous console.log</li>
<li><strong>F</strong> - Synchronous console.log</li>
<li><strong>C</strong> - First Promise microtask (higher priority)</li>
<li><strong>E</strong> - Second Promise microtask</li>
<li><strong>B</strong> - First setTimeout macrotask</li>
<li><strong>D</strong> - Second setTimeout macrotask (queued from within Promise)</li>
</ol>
<h3 id="q2:-explain-the-difference-between-microtasks-and-macrotasks." node="[object Object]">Q2: Explain the difference between microtasks and macrotasks.</h3>
<p><strong>Answer</strong>:</p>
<p><strong>Microtasks</strong>:</p>
<ul>
<li>Higher priority in event loop</li>
<li>Processed completely before any macrotask</li>
<li>Sources: Promises, queueMicrotask, MutationObserver</li>
<li>Can starve macrotasks if not careful</li>
</ul>
<p><strong>Macrotasks</strong>:</p>
<ul>
<li>Lower priority in event loop</li>
<li>Only one processed per event loop cycle</li>
<li>Sources: setTimeout, setInterval, I/O, UI events</li>
<li>Allow other operations between executions</li>
</ul>
<h3 id="q3:-how-would-you-prevent-blocking-the-main-thread-during-heavy-computation?" node="[object Object]">Q3: How would you prevent blocking the main thread during heavy computation?</h3>
<p><strong>Answer</strong>:</p>
<p><strong>1. Web Workers</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;computation-worker.js&quot;</span>);
worker.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">data</span>: largeDataset });
worker.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Result:&quot;</span>, e.<span class="hljs-property">data</span>);

<span class="hljs-comment">// computation-worker.js</span>
self.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">heavyComputation</span>(e.<span class="hljs-property">data</span>);
  self.<span class="hljs-title function_">postMessage</span>(result);
};
</code></pre></pre>
<p><strong>2. Time-slicing</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">processLargeArray</span>(<span class="hljs-params">array, processor</span>) {
  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CHUNK_SIZE</span> = <span class="hljs-number">1000</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i += <span class="hljs-variable constant_">CHUNK_SIZE</span>) {
    <span class="hljs-keyword">const</span> chunk = array.<span class="hljs-title function_">slice</span>(i, i + <span class="hljs-variable constant_">CHUNK_SIZE</span>);
    chunk.<span class="hljs-title function_">forEach</span>(processor);

    <span class="hljs-comment">// Yield control every chunk</span>
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">0</span>));
  }
}
</code></pre></pre>
<p><strong>3. RequestIdleCallback</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">processWhenIdle</span>(<span class="hljs-params">tasks</span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">processTasks</span>(<span class="hljs-params">deadline</span>) {
    <span class="hljs-keyword">while</span> (deadline.<span class="hljs-title function_">timeRemaining</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> task = tasks.<span class="hljs-title function_">shift</span>();
      <span class="hljs-title function_">task</span>();
    }

    <span class="hljs-keyword">if</span> (tasks.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-title function_">requestIdleCallback</span>(processTasks);
    }
  }

  <span class="hljs-title function_">requestIdleCallback</span>(processTasks);
}
</code></pre></pre>
<h3 id="q4:-what&#x27;s-the-difference-between-settimeout(fn,-0)-and-queuemicrotask(fn)?" node="[object Object]">Q4: What&#x27;s the difference between setTimeout(fn, 0) and queueMicrotask(fn)?</h3>
<p><strong>Answer</strong>:</p>
<p><strong>setTimeout(fn, 0)</strong>:</p>
<ul>
<li>Macrotask - lower priority</li>
<li>Minimum delay of 4ms in browsers</li>
<li>Processed after current microtasks</li>
</ul>
<p><strong>queueMicrotask(fn)</strong>:</p>
<ul>
<li>Microtask - higher priority</li>
<li>No artificial delay</li>
<li>Processed before any macrotasks</li>
</ul>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;microtask&quot;</span>));
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;macrotask&quot;</span>), <span class="hljs-number">0</span>);
<span class="hljs-comment">// Output: microtask, macrotask</span>
</code></pre></pre>
<h2 id="practical-examples" node="[object Object]">Practical Examples</h2>
<h3 id="example-1:-building-a-non-blocking-renderer" node="[object Object]">Example 1: Building a Non-Blocking Renderer</h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NonBlockingRenderer</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderQueue</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">isRendering</span> = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">items</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderQueue</span>.<span class="hljs-title function_">push</span>(...items);

    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isRendering</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isRendering</span> = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processRenderQueue</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isRendering</span> = <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">processRenderQueue</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CHUNK_SIZE</span> = <span class="hljs-number">50</span>;

    <span class="hljs-keyword">while</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">renderQueue</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> chunk = <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderQueue</span>.<span class="hljs-title function_">splice</span>(<span class="hljs-number">0</span>, <span class="hljs-variable constant_">CHUNK_SIZE</span>);

      <span class="hljs-comment">// Render chunk synchronously</span>
      chunk.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">renderItem</span>(item));

      <span class="hljs-comment">// Yield control to prevent blocking</span>
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">yieldControl</span>();
    }
  }

  <span class="hljs-title function_">yieldControl</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">shouldYield</span>()) {
        <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">0</span>); <span class="hljs-comment">// Macrotask</span>
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">queueMicrotask</span>(resolve); <span class="hljs-comment">// Microtask</span>
      }
    });
  }

  <span class="hljs-title function_">shouldYield</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Yield if we&#x27;ve been running for too long</span>
    <span class="hljs-keyword">return</span> performance.<span class="hljs-title function_">now</span>() % <span class="hljs-number">16</span> &gt; <span class="hljs-number">5</span>; <span class="hljs-comment">// ~5ms threshold</span>
  }

  <span class="hljs-title function_">renderItem</span>(<span class="hljs-params">item</span>) {
    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);
    element.<span class="hljs-property">textContent</span> = item.<span class="hljs-property">text</span>;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(element);
  }
}
</code></pre></pre>
<h3 id="example-2:-promise-queue-with-concurrency-control" node="[object Object]">Example 2: Promise Queue with Concurrency Control</h3>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PromiseQueue</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">concurrency = <span class="hljs-number">1</span></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">concurrency</span> = concurrency;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span> = [];
  }

  <span class="hljs-title function_">add</span>(<span class="hljs-params">promiseFactory</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">push</span>({
        promiseFactory,
        resolve,
        reject,
      });

      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">process</span>();
    });
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span> &gt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">concurrency</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span>++;
    <span class="hljs-keyword">const</span> { promiseFactory, resolve, reject } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">queue</span>.<span class="hljs-title function_">shift</span>();

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">promiseFactory</span>();
      <span class="hljs-title function_">resolve</span>(result);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-title function_">reject</span>(error);
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">running</span>--;
      <span class="hljs-comment">// Process next item in next microtask</span>
      <span class="hljs-title function_">queueMicrotask</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">process</span>());
    }
  }
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">const</span> queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PromiseQueue</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// Max 3 concurrent operations</span>

<span class="hljs-comment">// Add multiple async operations</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
  queue
    .<span class="hljs-title function_">add</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/data/<span class="hljs-subst">${i}</span>`</span>))
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Completed <span class="hljs-subst">${i}</span>`</span>));
}
</code></pre></pre>
<p>{% endraw %}</p>
<h1 id="additional-advanced-interview-q&amp;a-and-visuals" node="[object Object]">Additional Advanced Interview Q&amp;A and Visuals</h1>
<h2 id="q:-what-is-the-output-of-the-following-code-and-why?" node="[object Object]">Q: What is the output of the following code and why?</h2>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;A&quot;</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;B&quot;</span>), <span class="hljs-number">0</span>);
(<span class="hljs-title function_">async</span> () =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;C&quot;</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-literal">null</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;D&quot;</span>);
})();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;E&quot;</span>);
</code></pre></pre>
<p><strong>Answer (English):</strong>
A, C, E, D, B</p>
<ul>
<li>Synchronous: A, C, E</li>
<li>Awaited code (D) is a microtask, runs after sync code</li>
<li>setTimeout (B) is a macrotask, runs after microtasks</li>
</ul>
<p><strong>Answer (Vietnamese):</strong>
A, C, E, D, B</p>
<ul>
<li>Lệnh đồng bộ: A, C, E</li>
<li>D (sau await) là microtask, chạy sau code đồng bộ</li>
<li>B (setTimeout) là macrotask, chạy sau microtask</li>
</ul>
<hr/>
<h2 id="q:-how-would-you-debug-a-ui-freeze-caused-by-a-long-running-synchronous-function?" node="[object Object]">Q: How would you debug a UI freeze caused by a long-running synchronous function?</h2>
<p><strong>Answer (English):</strong></p>
<ul>
<li>Use Chrome DevTools Performance tab to record and find long tasks</li>
<li>Refactor code to break work into smaller chunks (setTimeout, requestIdleCallback)</li>
<li>Move heavy computation to a Web Worker</li>
</ul>
<p><strong>Answer (Vietnamese):</strong></p>
<ul>
<li>Dùng Chrome DevTools Performance để tìm task dài</li>
<li>Chia nhỏ công việc bằng setTimeout, requestIdleCallback</li>
<li>Đưa xử lý nặng sang Web Worker</li>
</ul>
<hr/>
<h2 id="diagram:-event-loop-with-async/await-and-timers" node="[object Object]">Diagram: Event Loop with Async/Await and Timers</h2>
<pre><pre><code class="hljs hljs language-mermaid">sequenceDiagram
  participant Main
  participant Microtask
  participant Macrotask
  Main-&gt;&gt;Main: console.log(&#x27;A&#x27;)
  Main-&gt;&gt;Main: setTimeout(...)
  Main-&gt;&gt;Main: (async) console.log(&#x27;C&#x27;)
  Main-&gt;&gt;Microtask: await null (schedules D)
  Main-&gt;&gt;Main: console.log(&#x27;E&#x27;)
  Microtask-&gt;&gt;Main: console.log(&#x27;D&#x27;)
  Macrotask-&gt;&gt;Main: console.log(&#x27;B&#x27;)
</code></pre></pre>
<hr/>
<p>This comprehensive deep-dive covers the Event Loop from fundamental concepts to advanced implementation patterns, providing the theoretical knowledge and practical understanding needed for senior frontend engineering interviews.</p></div></div></div><div class="space-y-6"><div class="bg-white border border-gray-200 rounded-lg p-6"><h3 class="text-lg font-semibold text-gray-900 mb-4">Your Progress</h3><div class="w-full bg-gray-200 rounded-full h-2 mb-2"><div class="bg-blue-600 h-2 rounded-full" style="width:25%"></div></div><p class="text-sm text-gray-600">25% Complete</p></div></div></div></div></main><footer class="sc-dYwGCk cJzheU"><div class="sc-lgpSej hJUFeT"><div class="sc-eqYatC mSxwd"><div class="sc-kcLKEh cmBIup"><div class="sc-dntSTA bAsNIP"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</div><p class="sc-kvnevz gWXMDV">Comprehensive interview preparation for frontend engineers targeting Big Tech companies.</p><div class="sc-dFVmKS jCoOHQ"><a href="https://github.com" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github "><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><a href="https://twitter.com" aria-label="Twitter"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-twitter "><path d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"></path></svg></a><a href="https://linkedin.com" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-linkedin "><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect width="4" height="12" x="2" y="9"></rect><circle cx="4" cy="4" r="2"></circle></svg></a><a href="mailto:contact@example.com" aria-label="Email"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail "><rect width="20" height="16" x="2" y="4" rx="2"></rect><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path></svg></a></div></div><div class="sc-kcLKEh cmBIup"><h3>Study Materials</h3><ul><li><a href="/algorithms">Algorithms</a></li><li><a href="/react">React &amp; Frontend</a></li><li><a href="/system-design">System Design</a></li><li><a href="/typescript">TypeScript</a></li><li><a href="/performance">Performance</a></li></ul></div><div class="sc-kcLKEh cmBIup"><h3>Companies</h3><ul><li><a href="/google">Google</a></li><li><a href="/meta">Meta</a></li><li><a href="/amazon">Amazon</a></li><li><a href="/microsoft">Microsoft</a></li><li><a href="/apple">Apple</a></li></ul></div><div class="sc-kcLKEh cmBIup"><h3>Resources</h3><ul><li><a href="/interview-tips">Interview Tips</a></li><li><a href="/coding-challenges">Coding Challenges</a></li><li><a href="/mock-interviews">Mock Interviews</a></li><li><a href="/blog">Blog</a></li><li><a href="/faq">FAQ</a></li></ul></div></div><div class="sc-kCuUfV crUaYh"><p class="sc-dNdcvo esMlQF">© 2025 Frontend Interview Prep. All rights reserved.</p><div class="sc-fbQrwq eHcrXx"><a href="/privacy">Privacy Policy</a><a href="/terms">Terms of Service</a><a href="/contact">Contact</a></div></div></div></footer></div><script src="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/interview/_next/static/css/387024c6a2216908.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[2846,[],\"\"]\n5:I[2972,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"930\",\"static/chunks/930-3262a6c9c5acace4.js\",\"289\",\"static/chunks/app/learn/%5Btopic%5D/page-b4f9b7b2865ef07e.js\"],\"\"]\n6:I[5907,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"930\",\"static/chunks/930-3262a6c9c5acace4.js\",\"289\",\"static/chunks/app/learn/%5Btopic%5D/page-b4f9b7b2865ef07e.js\"],\"default\"]\n8:I[4707,[],\"\"]\na:I[6423,[],\"\"]\nb:I[2,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"710\",\"static/chunks/710-dfaa11b4dff08f8e.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"233\",\"static/chunks/233-3e0c1d820a17eca9.js\",\"185\",\"static/chunks/app/layout-333f4adcd11f8f39.js\"],\"default\",1]\nd:I[1060,[],\"\"]\n7:T7f5b,"])</script><script>self.__next_f.push([1,"# JavaScript Event Loop: Complete Deep Dive\n\n## Table of Contents\n\n- [Understanding the Event Loop](#understanding-the-event-loop)\n- [Call Stack Fundamentals](#call-stack-fundamentals)\n- [Web APIs and Browser Environment](#web-apis-and-browser-environment)\n- [Task Queue vs Microtask Queue](#task-queue-vs-microtask-queue)\n- [Event Loop Phases](#event-loop-phases)\n- [Visual Diagrams](#visual-diagrams)\n- [Common Misconceptions](#common-misconceptions)\n- [Performance Implications](#performance-implications)\n- [Interview Questions \u0026 Answers](#interview-questions--answers)\n- [Practical Examples](#practical-examples)\n\n## Understanding the Event Loop\n\n### What is the Event Loop?\n\nThe **Event Loop** is the fundamental mechanism that allows JavaScript to perform asynchronous operations despite being a single-threaded language. It's the coordination system between the JavaScript engine and the browser's Web APIs.\n\n#### Key Concepts:\n\n**1. Single-Threaded Nature**\n\n- JavaScript has only **one call stack**\n- Only **one thing can happen at a time**\n- But it can handle **asynchronous operations** through the event loop\n\n**2. Non-Blocking I/O**\n\n- Long-running operations don't freeze the UI\n- Callbacks are scheduled for later execution\n- Maintains responsive user interfaces\n\n**3. Concurrency Model**\n\n- JavaScript achieves concurrency through the event loop\n- Multiple operations can be **initiated** simultaneously\n- But they're **executed** one at a time\n\n### The Big Picture Architecture\n\n```\n┌─────────────────────────────────────────────────────┐\n│                 BROWSER ENVIRONMENT                 │\n├─────────────────────────────────────────────────────┤\n│  JavaScript Engine (V8, SpiderMonkey, etc.)        │\n│  ┌─────────────┐  ┌─────────────┐                  │\n│  │    Heap     │  │ Call Stack  │                  │\n│  │   Memory    │  │             │                  │\n│  │ Allocation  │  │ Execution   │                  │\n│  └─────────────┘  │ Context     │                  │\n│                   └─────────────┘                  │\n├─────────────────────────────────────────────────────┤\n│                  WEB APIs                           │\n│  DOM APIs │ HTTP │ Timers │ Geolocation │ etc.     │\n├─────────────────────────────────────────────────────┤\n│              TASK QUEUES                            │\n│  ┌─────────────┐  ┌─────────────┐                  │\n│  │  Callback   │  │ Microtask   │                  │\n│  │   Queue     │  │   Queue     │                  │\n│  │(Macrotasks) │  │(Promises)   │                  │\n│  └─────────────┘  └─────────────┘                  │\n└─────────────────────────────────────────────────────┘\n              ↑\n        EVENT LOOP\n```\n\n## Call Stack Fundamentals\n\n### How the Call Stack Works\n\nThe **Call Stack** is a LIFO (Last In, First Out) data structure that keeps track of function calls.\n\n#### Stack Operations:\n\n**1. Function Call (Push)**\n\n```javascript\nfunction first() {\n  console.log(\"First function\");\n  second();\n}\n\nfunction second() {\n  console.log(\"Second function\");\n  third();\n}\n\nfunction third() {\n  console.log(\"Third function\");\n}\n\nfirst();\n```\n\n**Call Stack Visualization:**\n\n```\nStep 1: first() called\n┌─────────────┐\n│   first()   │\n└─────────────┘\n\nStep 2: second() called from first()\n┌─────────────┐\n│  second()   │\n├─────────────┤\n│   first()   │\n└─────────────┘\n\nStep 3: third() called from second()\n┌─────────────┐\n│   third()   │\n├─────────────┤\n│  second()   │\n├─────────────┤\n│   first()   │\n└─────────────┘\n\nStep 4: third() completes (Pop)\n┌─────────────┐\n│  second()   │\n├─────────────┤\n│   first()   │\n└─────────────┘\n\nStep 5: second() completes (Pop)\n┌─────────────┐\n│   first()   │\n└─────────────┘\n\nStep 6: first() completes (Pop)\n┌─────────────┐\n│    Empty    │\n└─────────────┘\n```\n\n### Stack Overflow\n\nWhen the call stack exceeds its limit:\n\n```javascript\nfunction recursiveFunction() {\n  recursiveFunction(); // Infinite recursion\n}\n\nrecursiveFunction(); // RangeError: Maximum call stack size exceeded\n```\n\n**Prevention Strategies:**\n\n- Use iterative solutions when possible\n- Implement proper base cases in recursion\n- Use setTimeout for deep recursion to break stack\n\n## Web APIs and Browser Environment\n\n### What are Web APIs?\n\nWeb APIs are browser-provided interfaces that allow JavaScript to interact with browser features asynchronously.\n\n#### Common Web APIs:\n\n**1. Timer APIs**\n\n```javascript\n// setTimeout - executes after delay\nsetTimeout(() =\u003e console.log(\"Timer callback\"), 1000);\n\n// setInterval - executes repeatedly\nsetInterval(() =\u003e console.log(\"Interval callback\"), 1000);\n\n// setImmediate (Node.js)\nsetImmediate(() =\u003e console.log(\"Immediate callback\"));\n```\n\n**2. DOM APIs**\n\n```javascript\n// Event listeners\ndocument.addEventListener(\"click\", () =\u003e {\n  console.log(\"Click handled\");\n});\n\n// DOM manipulation\ndocument.getElementById(\"button\").onclick = () =\u003e {\n  console.log(\"Button clicked\");\n};\n```\n\n**3. Network APIs**\n\n```javascript\n// Fetch API\nfetch(\"/api/data\")\n  .then((response) =\u003e response.json())\n  .then((data) =\u003e console.log(data));\n\n// XMLHttpRequest\nconst xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"/api/data\");\nxhr.onload = () =\u003e console.log(xhr.responseText);\nxhr.send();\n```\n\n### How Web APIs Work\n\nWhen you call a Web API:\n\n1. **Delegation**: JavaScript delegates the operation to the browser\n2. **Continuation**: JavaScript continues executing other code\n3. **Completion**: Browser completes the operation\n4. **Callback**: Browser places callback in appropriate queue\n\n```javascript\nconsole.log(\"Start\");\n\nsetTimeout(() =\u003e {\n  console.log(\"Timer callback\");\n}, 0);\n\nconsole.log(\"End\");\n\n// Output:\n// Start\n// End\n// Timer callback\n```\n\n## Task Queue vs Microtask Queue\n\n### Understanding Queues\n\nThe Event Loop manages two main types of queues with different priorities:\n\n#### 1. Macrotask Queue (Task Queue)\n\n- **Lower priority**\n- Processed **after** microtasks\n- **Sources**: setTimeout, setInterval, I/O operations, UI events\n\n#### 2. Microtask Queue\n\n- **Higher priority**\n- Processed **before** macrotasks\n- **Sources**: Promises, queueMicrotask, MutationObserver\n\n### Priority System\n\n```\nEvent Loop Priority (High to Low):\n1. Call Stack (currently executing)\n2. Microtask Queue (Promises, queueMicrotask)\n3. Macrotask Queue (setTimeout, DOM events)\n```\n\n### Visual Representation\n\n```\n┌─────────────────────────────────────────────────────┐\n│                EVENT LOOP CYCLE                     │\n│                                                     │\n│  1. Execute Call Stack to completion                │\n│  2. Process ALL Microtasks                          │\n│  3. Process ONE Macrotask                           │\n│  4. Process ALL Microtasks (again)                  │\n│  5. Render (if needed)                              │\n│  6. Repeat                                          │\n│                                                     │\n└─────────────────────────────────────────────────────┘\n```\n\n### Detailed Example\n\n```javascript\nconsole.log(\"1: Start\");\n\nsetTimeout(() =\u003e console.log(\"2: setTimeout\"), 0);\n\nPromise.resolve()\n  .then(() =\u003e console.log(\"3: Promise 1\"))\n  .then(() =\u003e console.log(\"4: Promise 2\"));\n\nqueueMicrotask(() =\u003e console.log(\"5: queueMicrotask\"));\n\nsetTimeout(() =\u003e console.log(\"6: setTimeout 2\"), 0);\n\nconsole.log(\"7: End\");\n\n// Execution Order:\n// 1: Start\n// 7: End\n// 3: Promise 1\n// 5: queueMicrotask\n// 4: Promise 2\n// 2: setTimeout\n// 6: setTimeout 2\n```\n\n**Step-by-Step Breakdown:**\n\n```\nInitial State:\nCall Stack: [main()]\nMicrotask Queue: []\nMacrotask Queue: []\n\nAfter console.log('1: Start'):\nCall Stack: [main()]\nMicrotask Queue: []\nMacrotask Queue: []\nOutput: \"1: Start\"\n\nAfter setTimeout:\nCall Stack: [main()]\nMicrotask Queue: []\nMacrotask Queue: [setTimeout callback]\n\nAfter Promise.resolve():\nCall Stack: [main()]\nMicrotask Queue: [Promise callback]\nMacrotask Queue: [setTimeout callback]\n\nAfter queueMicrotask:\nCall Stack: [main()]\nMicrotask Queue: [Promise callback, queueMicrotask callback]\nMacrotask Queue: [setTimeout callback]\n\nAfter second setTimeout:\nCall Stack: [main()]\nMicrotask Queue: [Promise callback, queueMicrotask callback]\nMacrotask Queue: [setTimeout callback, setTimeout callback 2]\n\nAfter console.log('7: End'):\nCall Stack: [main()]\nMicrotask Queue: [Promise callback, queueMicrotask callback]\nMacrotask Queue: [setTimeout callback, setTimeout callback 2]\nOutput: \"1: Start\", \"7: End\"\n\nMain function completes - Call Stack empty\nProcess Microtasks:\n- Execute Promise callback → \"3: Promise 1\"\n- Execute queueMicrotask callback → \"5: queueMicrotask\"\n- Promise.then adds new microtask\n- Execute Promise 2 callback → \"4: Promise 2\"\n\nAll Microtasks processed, process ONE Macrotask:\n- Execute first setTimeout → \"2: setTimeout\"\n\nCheck for Microtasks (none), process next Macrotask:\n- Execute second setTimeout → \"6: setTimeout 2\"\n```\n\n## Event Loop Phases\n\n### Detailed Event Loop Algorithm\n\nThe Event Loop operates in phases:\n\n```\n┌───────────────────────────┐\n┌─\u003e│           timers          │  ← setTimeout, setInterval callbacks\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │  ← I/O callbacks (except close, timers, setImmediate)\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │  ← Internal use only\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │           poll            │  ← Fetch new I/O events; execute I/O callbacks\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │           check           │  ← setImmediate callbacks\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │  ← close event callbacks\n   └───────────────────────────┘\n```\n\n### Browser Event Loop vs Node.js\n\n**Browser Event Loop:**\n\n- Simpler model\n- Focuses on user interaction\n- Microtasks processed after each macrotask\n\n**Node.js Event Loop:**\n\n- More complex with phases\n- Handles I/O efficiently\n- Different microtask timing\n\n## Visual Diagrams\n\n### Complete Event Loop Flow\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                        JAVASCRIPT RUNTIME                       │\n│                                                                 │\n│  ┌─────────────┐    ┌─────────────────────────────────────────┐ │\n│  │    HEAP     │    │             CALL STACK                 │ │\n│  │             │    │                                        │ │\n│  │   Objects   │    │  ┌─────────────────────────────────┐   │ │\n│  │  Memory     │    │  │        function()               │   │ │\n│  │             │    │  └─────────────────────────────────┘   │ │\n│  │             │    │  ┌─────────────────────────────────┐   │ │\n│  │             │    │  │        function()               │   │ │\n│  │             │    │  └─────────────────────────────────┘   │ │\n│  │             │    │  ┌─────────────────────────────────┐   │ │\n│  │             │    │  │         main()                  │   │ │\n│  │             │    │  └─────────────────────────────────┘   │ │\n│  └─────────────┘    └─────────────────────────────────────────┘ │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘\n                                   │\n                                   ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                          WEB APIs                               │\n│                                                                 │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐  │\n│  │    DOM      │  │   Network   │  │        Timers           │  │\n│  │   Events    │  │    APIs     │  │    setTimeout()         │  │\n│  │             │  │   fetch()   │  │    setInterval()        │  │\n│  └─────────────┘  └─────────────┘  └─────────────────────────┘  │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘\n                                   │\n                                   ▼\n┌─────────────────────────────────────────────────────────────────┐\n│                        TASK QUEUES                             │\n│                                                                 │\n│  ┌─────────────────────────────┐  ┌─────────────────────────┐   │\n│  │      MICROTASK QUEUE        │  │     MACROTASK QUEUE     │   │\n│  │      (High Priority)        │  │     (Low Priority)      │   │\n│  │                             │  │                         │   │\n│  │  ┌─────────────────────┐    │  │  ┌─────────────────┐    │   │\n│  │  │ Promise.then()      │    │  │  │ setTimeout()    │    │   │\n│  │  └─────────────────────┘    │  │  └─────────────────┘    │   │\n│  │  ┌─────────────────────┐    │  │  ┌─────────────────┐    │   │\n│  │  │ queueMicrotask()    │    │  │  │ DOM Events      │    │   │\n│  │  └─────────────────────┘    │  │  └─────────────────┘    │   │\n│  │  ┌─────────────────────┐    │  │  ┌─────────────────┐    │   │\n│  │  │ async/await         │    │  │  │ I/O Operations  │    │   │\n│  │  └─────────────────────┘    │  │  └─────────────────┘    │   │\n│  └─────────────────────────────┘  └─────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────┘\n                                   ▲\n                                   │\n                         ┌─────────────────┐\n                         │   EVENT LOOP    │\n                         │                 │\n                         │  1. Check Stack │\n                         │  2. Microtasks  │\n                         │  3. Macrotasks  │\n                         │  4. Render      │\n                         │  5. Repeat      │\n                         └─────────────────┘\n```\n\n### Promise vs setTimeout Timing\n\n```\nTimeline: Promise vs setTimeout Execution\n\nTime: 0ms\n┌─────────────────────────────────────────────────────────────┐\n│ console.log('start')                                        │\n│ setTimeout(() =\u003e console.log('timeout'), 0)                │\n│ Promise.resolve().then(() =\u003e console.log('promise'))       │\n│ console.log('end')                                          │\n└─────────────────────────────────────────────────────────────┘\n\nCall Stack:     [main]\nMicrotasks:     []\nMacrotasks:     []\nOutput:         \"start\"\n\nTime: 1ms\n┌─────────────────────────────────────────────────────────────┐\n│ setTimeout callback queued                                  │\n└─────────────────────────────────────────────────────────────┘\n\nCall Stack:     [main]\nMicrotasks:     []\nMacrotasks:     [setTimeout callback]\nOutput:         \"start\"\n\nTime: 2ms\n┌─────────────────────────────────────────────────────────────┐\n│ Promise callback queued                                     │\n└─────────────────────────────────────────────────────────────┘\n\nCall Stack:     [main]\nMicrotasks:     [Promise callback]\nMacrotasks:     [setTimeout callback]\nOutput:         \"start\"\n\nTime: 3ms\n┌─────────────────────────────────────────────────────────────┐\n│ console.log('end') executed                                 │\n└─────────────────────────────────────────────────────────────┘\n\nCall Stack:     [main]\nMicrotasks:     [Promise callback]\nMacrotasks:     [setTimeout callback]\nOutput:         \"start\", \"end\"\n\nTime: 4ms - main() completes\n┌─────────────────────────────────────────────────────────────┐\n│ Call stack empty - Process microtasks first                │\n└─────────────────────────────────────────────────────────────┘\n\nCall Stack:     []\nMicrotasks:     [Promise callback] → Execute\nMacrotasks:     [setTimeout callback]\nOutput:         \"start\", \"end\", \"promise\"\n\nTime: 5ms\n┌─────────────────────────────────────────────────────────────┐\n│ All microtasks done - Process one macrotask                │\n└─────────────────────────────────────────────────────────────┘\n\nCall Stack:     []\nMicrotasks:     []\nMacrotasks:     [setTimeout callback] → Execute\nOutput:         \"start\", \"end\", \"promise\", \"timeout\"\n```\n\n## Common Misconceptions\n\n### Misconception 1: \"setTimeout(fn, 0) executes immediately\"\n\n**Reality**: setTimeout(fn, 0) schedules execution for the next event loop cycle.\n\n```javascript\nconsole.log(\"1\");\nsetTimeout(() =\u003e console.log(\"2\"), 0);\nconsole.log(\"3\");\n\n// Output: 1, 3, 2 (not 1, 2, 3)\n```\n\n### Misconception 2: \"Promises are synchronous\"\n\n**Reality**: Promise callbacks are asynchronous microtasks.\n\n```javascript\nconsole.log(\"1\");\nPromise.resolve().then(() =\u003e console.log(\"2\"));\nconsole.log(\"3\");\n\n// Output: 1, 3, 2\n```\n\n### Misconception 3: \"All async operations are the same priority\"\n\n**Reality**: Microtasks have higher priority than macrotasks.\n\n```javascript\nsetTimeout(() =\u003e console.log(\"setTimeout\"), 0);\nPromise.resolve().then(() =\u003e console.log(\"Promise\"));\nqueueMicrotask(() =\u003e console.log(\"queueMicrotask\"));\n\n// Output: Promise, queueMicrotask, setTimeout\n```\n\n## Performance Implications\n\n### Blocking the Event Loop\n\n**Long-running synchronous operations block everything:**\n\n```javascript\n// BAD: Blocks event loop\nfunction heavyComputation() {\n  let result = 0;\n  for (let i = 0; i \u003c 1000000000; i++) {\n    result += i;\n  }\n  return result;\n}\n\nconsole.log(\"Start\");\nheavyComputation(); // Blocks everything\nconsole.log(\"End\");\n```\n\n**Solution: Break work into chunks:**\n\n```javascript\n// GOOD: Non-blocking approach\nfunction heavyComputationAsync(start, end, chunkSize = 1000000) {\n  return new Promise((resolve) =\u003e {\n    let result = 0;\n    let current = start;\n\n    function processChunk() {\n      const chunkEnd = Math.min(current + chunkSize, end);\n\n      for (let i = current; i \u003c chunkEnd; i++) {\n        result += i;\n      }\n\n      current = chunkEnd;\n\n      if (current \u003c end) {\n        setTimeout(processChunk, 0); // Yield control\n      } else {\n        resolve(result);\n      }\n    }\n\n    processChunk();\n  });\n}\n\nconsole.log(\"Start\");\nheavyComputationAsync(0, 1000000000).then((result) =\u003e\n  console.log(\"Result:\", result)\n);\nconsole.log(\"End\");\n// Output: Start, End, Result: [number]\n```\n\n### Microtask Queue Starvation\n\n**Problem**: Too many microtasks can starve macrotasks:\n\n```javascript\n// BAD: Infinite microtask loop\nfunction recursiveMicrotask() {\n  Promise.resolve().then(recursiveMicrotask);\n}\n\nrecursiveMicrotask(); // Blocks all macrotasks!\n```\n\n**Solution**: Use macrotasks for long-running operations:\n\n```javascript\n// GOOD: Mix microtasks and macrotasks\nfunction balancedRecursion(count = 0) {\n  if (count % 100 === 0) {\n    // Use macrotask every 100 iterations\n    setTimeout(() =\u003e balancedRecursion(count + 1), 0);\n  } else {\n    // Use microtask for most iterations\n    Promise.resolve().then(() =\u003e balancedRecursion(count + 1));\n  }\n}\n```\n\n## Interview Questions \u0026 Answers\n\n### Q1: What will this code output and why?\n\n```javascript\nconsole.log(\"A\");\n\nsetTimeout(() =\u003e console.log(\"B\"), 0);\n\nPromise.resolve().then(() =\u003e {\n  console.log(\"C\");\n  setTimeout(() =\u003e console.log(\"D\"), 0);\n});\n\nPromise.resolve().then(() =\u003e console.log(\"E\"));\n\nconsole.log(\"F\");\n```\n\n**Answer**: A, F, C, E, B, D\n\n**Explanation**:\n\n1. **A** - Synchronous console.log\n2. **F** - Synchronous console.log\n3. **C** - First Promise microtask (higher priority)\n4. **E** - Second Promise microtask\n5. **B** - First setTimeout macrotask\n6. **D** - Second setTimeout macrotask (queued from within Promise)\n\n### Q2: Explain the difference between microtasks and macrotasks.\n\n**Answer**:\n\n**Microtasks**:\n\n- Higher priority in event loop\n- Processed completely before any macrotask\n- Sources: Promises, queueMicrotask, MutationObserver\n- Can starve macrotasks if not careful\n\n**Macrotasks**:\n\n- Lower priority in event loop\n- Only one processed per event loop cycle\n- Sources: setTimeout, setInterval, I/O, UI events\n- Allow other operations between executions\n\n### Q3: How would you prevent blocking the main thread during heavy computation?\n\n**Answer**:\n\n**1. Web Workers**:\n\n```javascript\n// main.js\nconst worker = new Worker(\"computation-worker.js\");\nworker.postMessage({ data: largeDataset });\nworker.onmessage = (e) =\u003e console.log(\"Result:\", e.data);\n\n// computation-worker.js\nself.onmessage = function (e) {\n  const result = heavyComputation(e.data);\n  self.postMessage(result);\n};\n```\n\n**2. Time-slicing**:\n\n```javascript\nasync function processLargeArray(array, processor) {\n  const CHUNK_SIZE = 1000;\n\n  for (let i = 0; i \u003c array.length; i += CHUNK_SIZE) {\n    const chunk = array.slice(i, i + CHUNK_SIZE);\n    chunk.forEach(processor);\n\n    // Yield control every chunk\n    await new Promise((resolve) =\u003e setTimeout(resolve, 0));\n  }\n}\n```\n\n**3. RequestIdleCallback**:\n\n```javascript\nfunction processWhenIdle(tasks) {\n  function processTasks(deadline) {\n    while (deadline.timeRemaining() \u003e 0 \u0026\u0026 tasks.length \u003e 0) {\n      const task = tasks.shift();\n      task();\n    }\n\n    if (tasks.length \u003e 0) {\n      requestIdleCallback(processTasks);\n    }\n  }\n\n  requestIdleCallback(processTasks);\n}\n```\n\n### Q4: What's the difference between setTimeout(fn, 0) and queueMicrotask(fn)?\n\n**Answer**:\n\n**setTimeout(fn, 0)**:\n\n- Macrotask - lower priority\n- Minimum delay of 4ms in browsers\n- Processed after current microtasks\n\n**queueMicrotask(fn)**:\n\n- Microtask - higher priority\n- No artificial delay\n- Processed before any macrotasks\n\n```javascript\nqueueMicrotask(() =\u003e console.log(\"microtask\"));\nsetTimeout(() =\u003e console.log(\"macrotask\"), 0);\n// Output: microtask, macrotask\n```\n\n## Practical Examples\n\n### Example 1: Building a Non-Blocking Renderer\n\n```javascript\nclass NonBlockingRenderer {\n  constructor() {\n    this.renderQueue = [];\n    this.isRendering = false;\n  }\n\n  async render(items) {\n    this.renderQueue.push(...items);\n\n    if (!this.isRendering) {\n      this.isRendering = true;\n      await this.processRenderQueue();\n      this.isRendering = false;\n    }\n  }\n\n  async processRenderQueue() {\n    const CHUNK_SIZE = 50;\n\n    while (this.renderQueue.length \u003e 0) {\n      const chunk = this.renderQueue.splice(0, CHUNK_SIZE);\n\n      // Render chunk synchronously\n      chunk.forEach((item) =\u003e this.renderItem(item));\n\n      // Yield control to prevent blocking\n      await this.yieldControl();\n    }\n  }\n\n  yieldControl() {\n    return new Promise((resolve) =\u003e {\n      if (this.shouldYield()) {\n        setTimeout(resolve, 0); // Macrotask\n      } else {\n        queueMicrotask(resolve); // Microtask\n      }\n    });\n  }\n\n  shouldYield() {\n    // Yield if we've been running for too long\n    return performance.now() % 16 \u003e 5; // ~5ms threshold\n  }\n\n  renderItem(item) {\n    const element = document.createElement(\"div\");\n    element.textContent = item.text;\n    document.body.appendChild(element);\n  }\n}\n```\n\n### Example 2: Promise Queue with Concurrency Control\n\n{% raw %}\n```javascript\nclass PromiseQueue {\n  constructor(concurrency = 1) {\n    this.concurrency = concurrency;\n    this.running = 0;\n    this.queue = [];\n  }\n\n  add(promiseFactory) {\n    return new Promise((resolve, reject) =\u003e {\n      this.queue.push({\n        promiseFactory,\n        resolve,\n        reject,\n      });\n\n      this.process();\n    });\n  }\n\n  async process() {\n    if (this.running \u003e= this.concurrency || this.queue.length === 0) {\n      return;\n    }\n\n    this.running++;\n    const { promiseFactory, resolve, reject } = this.queue.shift();\n\n    try {\n      const result = await promiseFactory();\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    } finally {\n      this.running--;\n      // Process next item in next microtask\n      queueMicrotask(() =\u003e this.process());\n    }\n  }\n}\n\n// Usage\nconst queue = new PromiseQueue(3); // Max 3 concurrent operations\n\n// Add multiple async operations\nfor (let i = 0; i \u003c 10; i++) {\n  queue\n    .add(() =\u003e fetch(`/api/data/${i}`))\n    .then((response) =\u003e console.log(`Completed ${i}`));\n}\n```\n{% endraw %}\n\n# Additional Advanced Interview Q\u0026A and Visuals\n\n## Q: What is the output of the following code and why?\n\n```javascript\nconsole.log(\"A\");\nsetTimeout(() =\u003e console.log(\"B\"), 0);\n(async () =\u003e {\n  console.log(\"C\");\n  await null;\n  console.log(\"D\");\n})();\nconsole.log(\"E\");\n```\n\n**Answer (English):**\nA, C, E, D, B\n\n- Synchronous: A, C, E\n- Awaited code (D) is a microtask, runs after sync code\n- setTimeout (B) is a macrotask, runs after microtasks\n\n**Answer (Vietnamese):**\nA, C, E, D, B\n\n- Lệnh đồng bộ: A, C, E\n- D (sau await) là microtask, chạy sau code đồng bộ\n- B (setTimeout) là macrotask, chạy sau microtask\n\n---\n\n## Q: How would you debug a UI freeze caused by a long-running synchronous function?\n\n**Answer (English):**\n\n- Use Chrome DevTools Performance tab to record and find long tasks\n- Refactor code to break work into smaller chunks (setTimeout, requestIdleCallback)\n- Move heavy computation to a Web Worker\n\n**Answer (Vietnamese):**\n\n- Dùng Chrome DevTools Performance để tìm task dài\n- Chia nhỏ công việc bằng setTimeout, requestIdleCallback\n- Đưa xử lý nặng sang Web Worker\n\n---\n\n## Diagram: Event Loop with Async/Await and Timers\n\n```mermaid\nsequenceDiagram\n  participant Main\n  participant Microtask\n  participant Macrotask\n  Main-\u003e\u003eMain: console.log('A')\n  Main-\u003e\u003eMain: setTimeout(...)\n  Main-\u003e\u003eMain: (async) console.log('C')\n  Main-\u003e\u003eMicrotask: await null (schedules D)\n  Main-\u003e\u003eMain: console.log('E')\n  Microtask-\u003e\u003eMain: console.log('D')\n  Macrotask-\u003e\u003eMain: console.log('B')\n```\n\n---\n\nThis comprehensive deep-dive covers the Event Loop from fundamental concepts to advanced implementation patterns, providing the theoretical knowledge and practical understanding needed for senior frontend engineering interviews.\n"])</script><script>self.__next_f.push([1,"9:[\"topic\",\"fundamentals-event-loop-deep-dive\",\"d\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L3\",null,{\"buildId\":\"fjDGwqtt1UnBZeA2uH4xO\",\"assetPrefix\":\"/interview\",\"urlParts\":[\"\",\"learn\",\"fundamentals-event-loop-deep-dive\"],\"initialTree\":[\"\",{\"children\":[\"learn\",{\"children\":[[\"topic\",\"fundamentals-event-loop-deep-dive\",\"d\"],{\"children\":[\"__PAGE__?{\\\"topic\\\":\\\"fundamentals-event-loop-deep-dive\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"learn\",{\"children\":[[\"topic\",\"fundamentals-event-loop-deep-dive\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",[\"$\",\"div\",null,{\"className\":\"max-w-6xl mx-auto px-8 py-24\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-4 mb-8\",\"children\":[\"$\",\"$L5\",null,{\"href\":\"/learn\",\"children\":[\"$\",\"button\",null,{\"className\":\"flex items-center gap-2 bg-gray-100 border border-gray-300 text-gray-700 px-4 py-3 rounded-md font-medium hover:bg-gray-200 transition-colors\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-arrow-left \",\"children\":[[\"$\",\"path\",\"1l729n\",{\"d\":\"m12 19-7-7 7-7\"}],[\"$\",\"path\",\"x3x0zl\",{\"d\":\"M19 12H5\"}],\"$undefined\"]}],\"Back to Learn\"]}]}]}],[\"$\",\"div\",null,{\"className\":\"bg-white border border-gray-200 rounded-lg p-8 mb-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between mb-4\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-bold text-gray-900\",\"children\":\"JavaScript Event Loop: Complete Deep Dive\"}],[\"$\",\"div\",null,{\"className\":\"flex gap-4\",\"children\":[[\"$\",\"button\",null,{\"className\":\"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-star \",\"children\":[[\"$\",\"polygon\",\"8f66p6\",{\"points\":\"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2\"}],\"$undefined\"]}],\"Bookmark\"]}],[\"$\",\"button\",null,{\"className\":\"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-share2 \",\"children\":[[\"$\",\"circle\",\"gq8acd\",{\"cx\":\"18\",\"cy\":\"5\",\"r\":\"3\"}],[\"$\",\"circle\",\"w7nqdw\",{\"cx\":\"6\",\"cy\":\"12\",\"r\":\"3\"}],[\"$\",\"circle\",\"1xt0gg\",{\"cx\":\"18\",\"cy\":\"19\",\"r\":\"3\"}],[\"$\",\"line\",\"47mynk\",{\"x1\":\"8.59\",\"x2\":\"15.42\",\"y1\":\"13.51\",\"y2\":\"17.49\"}],[\"$\",\"line\",\"1n3mei\",{\"x1\":\"15.41\",\"x2\":\"8.59\",\"y1\":\"6.51\",\"y2\":\"10.49\"}],\"$undefined\"]}],\"Share\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"flex gap-8 mb-4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-2 text-sm text-gray-600\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-clock \",\"children\":[[\"$\",\"circle\",\"1mglay\",{\"cx\":\"12\",\"cy\":\"12\",\"r\":\"10\"}],[\"$\",\"polyline\",\"68esgv\",{\"points\":\"12 6 12 12 16 14\"}],\"$undefined\"]}],\"2-3 hours\"]}],[\"$\",\"span\",null,{\"className\":\"px-3 py-1 rounded-full text-xs font-semibold text-white bg-yellow-500\",\"children\":\"Intermediate\"}],[\"$\",\"span\",null,{\"className\":\"px-3 py-1 rounded-full text-xs font-semibold bg-blue-100 text-blue-700\",\"children\":\"General\"}]]}],false,[\"$\",\"p\",null,{\"className\":\"text-lg text-gray-700 leading-relaxed\",\"children\":\"The **Event Loop** is the fundamental mechanism that allows JavaScript to perform asynchronous operations despite being a single-threaded language. It's the coordination system between the JavaScript ...\"}]]}],[\"$\",\"div\",null,{\"className\":\"grid grid-cols-1 lg:grid-cols-3 gap-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"lg:col-span-2\",\"children\":[\"$\",\"div\",null,{\"className\":\"bg-white border border-gray-200 rounded-lg p-8\",\"children\":[\"$\",\"$L6\",null,{\"content\":\"$7\"}]}]}],[\"$\",\"div\",null,{\"className\":\"space-y-6\",\"children\":[[\"$\",\"div\",null,{\"className\":\"bg-white border border-gray-200 rounded-lg p-6\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-lg font-semibold text-gray-900 mb-4\",\"children\":\"Your Progress\"}],[\"$\",\"div\",null,{\"className\":\"w-full bg-gray-200 rounded-full h-2 mb-2\",\"children\":[\"$\",\"div\",null,{\"className\":\"bg-blue-600 h-2 rounded-full\",\"style\":{\"width\":\"25%\"}}]}],[\"$\",\"p\",null,{\"className\":\"text-sm text-gray-600\",\"children\":\"25% Complete\"}]]}],false]}]]}]]}],null],null],null]},[null,[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"learn\",\"children\",\"$9\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"learn\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/interview/_next/static/css/387024c6a2216908.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}],\"params\":{}}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"2\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>