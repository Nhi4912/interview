<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/interview/_next/static/css/387024c6a2216908.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js"/><script src="/interview/_next/static/chunks/fd9d1056-6922f449a204c2cc.js" async=""></script><script src="/interview/_next/static/chunks/117-e7ecc085ce9cfab3.js" async=""></script><script src="/interview/_next/static/chunks/main-app-b06be5f3411c20c3.js" async=""></script><script src="/interview/_next/static/chunks/918-3273b83890f10546.js" async=""></script><script src="/interview/_next/static/chunks/972-011bba60ed155615.js" async=""></script><script src="/interview/_next/static/chunks/930-3262a6c9c5acace4.js" async=""></script><script src="/interview/_next/static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js" async=""></script><script src="/interview/_next/static/chunks/710-dfaa11b4dff08f8e.js" async=""></script><script src="/interview/_next/static/chunks/233-3e0c1d820a17eca9.js" async=""></script><script src="/interview/_next/static/chunks/app/layout-333f4adcd11f8f39.js" async=""></script><title>Frontend Interview Prep 2025 - Big Tech Interview Guide</title><meta name="description" content="Comprehensive frontend interview preparation for Big Tech companies including React, TypeScript, algorithms, and system design."/><link rel="icon" href="/favicon.ico"/><meta name="theme-color" content="#1a1a1a"/><meta property="og:title" content="Frontend Interview Prep 2025"/><meta property="og:description" content="Complete guide for frontend engineers targeting Big Tech companies"/><meta property="og:type" content="website"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><meta name="next-size-adjust"/><script src="/interview/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script><style data-styled="" data-styled-version="6.1.19">*{margin:0;padding:0;box-sizing:border-box;}/*!sc*/
html{font-size:16px;line-height:1.5;scroll-behavior:smooth;}/*!sc*/
body{font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;font-size:1rem;line-height:1.5;color:#1e293b;background-color:#ffffff;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
h1,h2,h3,h4,h5,h6{font-weight:700;line-height:1.25;margin-bottom:0.5em;}/*!sc*/
h1{font-size:3rem;}/*!sc*/
@media (max-width: 768px){h1{font-size:2.25rem;}}/*!sc*/
h2{font-size:2.25rem;}/*!sc*/
@media (max-width: 768px){h2{font-size:1.875rem;}}/*!sc*/
h3{font-size:1.875rem;}/*!sc*/
@media (max-width: 768px){h3{font-size:1.5rem;}}/*!sc*/
h4{font-size:1.5rem;}/*!sc*/
@media (max-width: 768px){h4{font-size:1.25rem;}}/*!sc*/
h5{font-size:1.25rem;}/*!sc*/
h6{font-size:1.125rem;}/*!sc*/
p{margin-bottom:1rem;line-height:1.75;}/*!sc*/
a{color:#3b82f6;text-decoration:none;transition:color 0.15s ease;}/*!sc*/
a:hover{color:#2563eb;}/*!sc*/
a:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
button{cursor:pointer;border:none;background:none;font-family:inherit;font-size:inherit;}/*!sc*/
button:disabled{cursor:not-allowed;opacity:0.6;}/*!sc*/
button:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
input,textarea,select{font-family:inherit;font-size:inherit;}/*!sc*/
input:focus,textarea:focus,select:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
img{max-width:100%;height:auto;}/*!sc*/
ul,ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
li{margin-bottom:0.25rem;}/*!sc*/
blockquote{margin:1rem 0;padding:1rem;border-left:4px solid #3b82f6;background-color:#f1f5f9;font-style:italic;}/*!sc*/
code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;background-color:#f1f5f9;padding:0.2em 0.4em;border-radius:0.25rem;}/*!sc*/
pre{background-color:#f1f5f9;padding:1rem;border-radius:0.5rem;overflow-x:auto;margin-bottom:1rem;}/*!sc*/
pre code{background:none;padding:0;}/*!sc*/
table{width:100%;border-collapse:collapse;margin-bottom:1rem;}/*!sc*/
th,td{padding:0.75rem;text-align:left;border-bottom:1px solid #e2e8f0;}/*!sc*/
th{font-weight:600;background-color:#f1f5f9;}/*!sc*/
.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0;}/*!sc*/
.skip-link{position:absolute;top:-40px;left:6px;background:#3b82f6;color:white;padding:8px;text-decoration:none;border-radius:4px;z-index:100;}/*!sc*/
.skip-link:focus{top:6px;}/*!sc*/
::-webkit-scrollbar{width:8px;height:8px;}/*!sc*/
::-webkit-scrollbar-track{background:#f1f5f9;}/*!sc*/
::-webkit-scrollbar-thumb{background:#94a3b8;border-radius:4px;}/*!sc*/
::-webkit-scrollbar-thumb:hover{background:#64748b;}/*!sc*/
::selection{background:#3b82f6;color:white;}/*!sc*/
.focus-visible{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
.fade-in{opacity:0;animation:fadeIn 0.3s ease forwards;}/*!sc*/
.slide-up{transform:translateY(20px);opacity:0;animation:slideUp 0.3s ease forwards;}/*!sc*/
@keyframes fadeIn{to{opacity:1;}}/*!sc*/
@keyframes slideUp{to{transform:translateY(0);opacity:1;}}/*!sc*/
@media print{*{background:white!important;color:black!important;box-shadow:none!important;text-shadow:none!important;}a,a:visited{text-decoration:underline;}h1,h2,h3,h4,h5,h6{break-after:avoid;}pre,blockquote{border:1px solid #999;break-inside:avoid;}img{max-width:100%!important;}@page{margin:0.5in;}}/*!sc*/
data-styled.g1[id="sc-global-kxA-Ddz1"]{content:"sc-global-kxA-Ddz1,"}/*!sc*/
.wbMrm{position:fixed;top:0;width:100%;z-index:1020;background:transparent;backdrop-filter:blur(10px);border-bottom:1px solid transparent;transition:all 0.3s ease;}/*!sc*/
data-styled.g2[id="sc-bRKDuR"]{content:"wbMrm,"}/*!sc*/
.kDxBNU{max-width:1200px;margin:0 auto;padding:0 2rem;display:flex;align-items:center;justify-content:space-between;height:70px;}/*!sc*/
data-styled.g3[id="sc-hvigdm"]{content:"kDxBNU,"}/*!sc*/
.cvsJZg{display:flex;align-items:center;gap:0.5rem;font-size:1.5rem;font-weight:700;color:#3b82f6;text-decoration:none;cursor:pointer;}/*!sc*/
.cvsJZg:hover{color:#2563eb;}/*!sc*/
data-styled.g4[id="sc-fhHczv"]{content:"cvsJZg,"}/*!sc*/
.lfYVIv{display:flex;align-items:center;gap:2rem;}/*!sc*/
@media (max-width: 768px){.lfYVIv{display:none;}}/*!sc*/
data-styled.g5[id="sc-ggWZvA"]{content:"lfYVIv,"}/*!sc*/
.bhKRhV{color:#1e293b;font-weight:500;text-decoration:none;transition:color 0.15s ease;position:relative;}/*!sc*/
.bhKRhV:hover{color:#3b82f6;}/*!sc*/
.bhKRhV:after{content:'';position:absolute;bottom:-5px;left:0;width:0;height:2px;background:#3b82f6;transition:width 0.15s ease;}/*!sc*/
.bhKRhV:hover:after{width:100%;}/*!sc*/
data-styled.g6[id="sc-dTvVRJ"]{content:"bhKRhV,"}/*!sc*/
.gpUImn{display:none;background:none;border:none;color:#1e293b;cursor:pointer;padding:0.5rem;}/*!sc*/
@media (max-width: 768px){.gpUImn{display:block;}}/*!sc*/
data-styled.g7[id="sc-jwTyAe"]{content:"gpUImn,"}/*!sc*/
.hpKWkw{display:flex;align-items:center;gap:0.5rem;background:#f1f5f9;border:1px solid #e2e8f0;border-radius:0.5rem;padding:0.5rem 1rem;color:#64748b;font-size:0.9rem;transition:all 0.15s ease;}/*!sc*/
.hpKWkw:hover{background:#ffffff;border-color:#3b82f6;}/*!sc*/
data-styled.g11[id="sc-kNOymR"]{content:"hpKWkw,"}/*!sc*/
.cJzheU{background:#1e293b;color:white;padding:3rem 0 1rem;margin-top:auto;}/*!sc*/
data-styled.g12[id="sc-dYwGCk"]{content:"cJzheU,"}/*!sc*/
.hJUFeT{max-width:1200px;margin:0 auto;padding:0 2rem;}/*!sc*/
data-styled.g13[id="sc-lgpSej"]{content:"hJUFeT,"}/*!sc*/
.mSxwd{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:2rem;margin-bottom:2rem;}/*!sc*/
@media (max-width: 768px){.mSxwd{grid-template-columns:1fr 1fr;gap:1.5rem;}}/*!sc*/
@media (max-width: 480px){.mSxwd{grid-template-columns:1fr;}}/*!sc*/
data-styled.g14[id="sc-eqYatC"]{content:"mSxwd,"}/*!sc*/
.cmBIup h3{font-size:1.1rem;font-weight:600;margin-bottom:1rem;color:white;}/*!sc*/
.cmBIup ul{list-style:none;padding:0;margin:0;}/*!sc*/
.cmBIup li{margin-bottom:0.5rem;}/*!sc*/
.cmBIup a{color:rgba(255, 255, 255, 0.7);text-decoration:none;transition:color 0.15s ease;}/*!sc*/
.cmBIup a:hover{color:white;}/*!sc*/
data-styled.g15[id="sc-kcLKEh"]{content:"cmBIup,"}/*!sc*/
.bAsNIP{display:flex;align-items:center;gap:0.5rem;font-size:1.2rem;font-weight:700;margin-bottom:1rem;color:white;}/*!sc*/
data-styled.g16[id="sc-dntSTA"]{content:"bAsNIP,"}/*!sc*/
.gWXMDV{color:rgba(255, 255, 255, 0.7);line-height:1.6;margin-bottom:1rem;}/*!sc*/
data-styled.g17[id="sc-kvnevz"]{content:"gWXMDV,"}/*!sc*/
.jCoOHQ{display:flex;gap:1rem;}/*!sc*/
.jCoOHQ a{display:flex;align-items:center;justify-content:center;width:40px;height:40px;background:rgba(255, 255, 255, 0.1);border-radius:0.5rem;color:rgba(255, 255, 255, 0.7);transition:all 0.15s ease;}/*!sc*/
.jCoOHQ a:hover{background:rgba(255, 255, 255, 0.2);color:white;}/*!sc*/
data-styled.g18[id="sc-dFVmKS"]{content:"jCoOHQ,"}/*!sc*/
.crUaYh{border-top:1px solid rgba(255, 255, 255, 0.1);padding-top:2rem;display:flex;justify-content:space-between;align-items:center;}/*!sc*/
@media (max-width: 768px){.crUaYh{flex-direction:column;gap:1rem;text-align:center;}}/*!sc*/
data-styled.g19[id="sc-kCuUfV"]{content:"crUaYh,"}/*!sc*/
.esMlQF{color:rgba(255, 255, 255, 0.7);margin:0;font-size:0.9rem;}/*!sc*/
data-styled.g20[id="sc-dNdcvo"]{content:"esMlQF,"}/*!sc*/
.eHcrXx{display:flex;gap:2rem;}/*!sc*/
@media (max-width: 480px){.eHcrXx{flex-direction:column;gap:1rem;}}/*!sc*/
.eHcrXx a{color:rgba(255, 255, 255, 0.7);text-decoration:none;font-size:0.9rem;transition:color 0.15s ease;}/*!sc*/
.eHcrXx a:hover{color:white;}/*!sc*/
data-styled.g21[id="sc-fbQrwq"]{content:"eHcrXx,"}/*!sc*/
.dAQFGp{color:#1e293b;line-height:1.6;}/*!sc*/
.dAQFGp h1,.dAQFGp h2,.dAQFGp h3,.dAQFGp h4,.dAQFGp h5,.dAQFGp h6{color:#1e293b;margin-top:2rem;margin-bottom:1rem;font-weight:600;}/*!sc*/
.dAQFGp h1{font-size:2rem;border-bottom:2px solid #e2e8f0;padding-bottom:0.5rem;}/*!sc*/
.dAQFGp h2{font-size:1.5rem;border-bottom:1px solid #e2e8f0;padding-bottom:0.3rem;}/*!sc*/
.dAQFGp h3{font-size:1.25rem;}/*!sc*/
.dAQFGp h4{font-size:1.1rem;}/*!sc*/
.dAQFGp p{margin-bottom:1rem;color:#64748b;}/*!sc*/
.dAQFGp a{color:#3b82f6;text-decoration:none;}/*!sc*/
.dAQFGp a:hover{text-decoration:underline;}/*!sc*/
.dAQFGp ul,.dAQFGp ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
.dAQFGp ul li,.dAQFGp ol li{margin-bottom:0.5rem;color:#64748b;}/*!sc*/
.dAQFGp blockquote{border-left:4px solid #3b82f6;padding-left:1rem;margin:1rem 0;font-style:italic;color:#64748b;background:#f1f5f9;padding:1rem;border-radius:0.5rem;}/*!sc*/
.dAQFGp code{background:#f1f5f9;padding:0.2rem 0.4rem;border-radius:0.25rem;font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;color:#f59e0b;}/*!sc*/
.dAQFGp pre{background:#ffffff;border:1px solid #e2e8f0;border-radius:0.5rem;padding:1rem;margin:1rem 0;overflow-x:auto;}/*!sc*/
.dAQFGp pre code{background:none;padding:0;color:#1e293b;font-size:0.9rem;}/*!sc*/
.dAQFGp table{width:100%;border-collapse:collapse;margin:1rem 0;}/*!sc*/
.dAQFGp table th,.dAQFGp table td{border:1px solid #e2e8f0;padding:0.5rem;text-align:left;}/*!sc*/
.dAQFGp table th{background:#ffffff;font-weight:600;}/*!sc*/
.dAQFGp table tr:nth-child(even){background:#f1f5f9;}/*!sc*/
.dAQFGp hr{border:none;height:1px;background:#e2e8f0;margin:2rem 0;}/*!sc*/
.dAQFGp .highlight{background:#3b82f620;padding:0.2rem 0.4rem;border-radius:0.25rem;font-weight:600;}/*!sc*/
.dAQFGp .hljs{background:#ffffff;color:#1e293b;}/*!sc*/
.dAQFGp .hljs-keyword{color:#3b82f6;font-weight:600;}/*!sc*/
.dAQFGp .hljs-string{color:#10b981;}/*!sc*/
.dAQFGp .hljs-function{color:#f59e0b;}/*!sc*/
.dAQFGp .hljs-comment{color:#94a3b8;font-style:italic;}/*!sc*/
.dAQFGp .hljs-number{color:#f59e0b;}/*!sc*/
.dAQFGp .hljs-variable{color:#1e293b;}/*!sc*/
.dAQFGp .hljs-title{color:#f59e0b;font-weight:600;}/*!sc*/
data-styled.g22[id="sc-gGKoUb"]{content:"dAQFGp,"}/*!sc*/
</style></head><body class="__className_6eac61"><div style="min-height:100vh;display:flex;flex-direction:column"><nav class="sc-bRKDuR wbMrm"><div class="sc-hvigdm kDxBNU"><a href="/interview"><a class="sc-fhHczv cvsJZg"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</a></a><div class="sc-ggWZvA lfYVIv"><a href="/interview/problems"><a class="sc-dTvVRJ bhKRhV">Problems</a></a><a href="/interview/learn"><a class="sc-dTvVRJ bhKRhV">Learn</a></a><a href="/interview/study-guide"><a class="sc-dTvVRJ bhKRhV">Study Guide</a></a><a href="/interview/system-design"><a class="sc-dTvVRJ bhKRhV">System Design</a></a><a href="/interview/performance"><a class="sc-dTvVRJ bhKRhV">Performance</a></a><a href="/interview/accessibility"><a class="sc-dTvVRJ bhKRhV">Accessibility</a></a><a href="/interview/interview-tips"><a class="sc-dTvVRJ bhKRhV">Interview Tips</a></a><button class="sc-kNOymR hpKWkw"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search "><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg>Search</button></div><button class="sc-jwTyAe gpUImn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu "><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button></div></nav><main style="flex:1"><div class="max-w-6xl mx-auto px-8 py-24"><div class="flex items-center gap-4 mb-8"><a href="/interview/learn"><button class="flex items-center gap-2 bg-gray-100 border border-gray-300 text-gray-700 px-4 py-3 rounded-md font-medium hover:bg-gray-200 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left "><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg>Back to Learn</button></a></div><div class="bg-white border border-gray-200 rounded-lg p-8 mb-8"><div class="flex items-center justify-between mb-4"><h1 class="text-3xl font-bold text-gray-900">LRU Cache</h1><div class="flex gap-4"><button class="flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star "><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>Bookmark</button><button class="flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share2 "><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" x2="15.42" y1="13.51" y2="17.49"></line><line x1="15.41" x2="8.59" y1="6.51" y2="10.49"></line></svg>Share</button></div></div><div class="flex gap-8 mb-4"><div class="flex items-center gap-2 text-sm text-gray-600"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock "><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>2-3 hours</div><span class="px-3 py-1 rounded-full text-xs font-semibold text-white bg-red-500">Easy</span><span class="px-3 py-1 rounded-full text-xs font-semibold bg-blue-100 text-blue-700">Others</span></div><div class="flex flex-wrap gap-2 mb-4"><span class="bg-gray-100 text-gray-600 px-3 py-1 rounded-md text-xs font-medium">Others</span><span class="bg-gray-100 text-gray-600 px-3 py-1 rounded-md text-xs font-medium">Hash Table</span></div><p class="text-lg text-gray-700 leading-relaxed"> *  * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  *  * Implement the LRUCache class:  * - LRUCache(int capacity) Initialize the LRU cache with positive ...</p></div><div class="grid grid-cols-1 lg:grid-cols-3 gap-8"><div class="lg:col-span-2"><div class="bg-white border border-gray-200 rounded-lg p-8"><div class="sc-gGKoUb dAQFGp"><h1 id="lru-cache" node="[object Object]">LRU Cache</h1>
<h2 id="problem-description" node="[object Object]">Problem Description</h2>
<ul>
<li>
<ul>
<li>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  *  * Implement the LRUCache class:  * - LRUCache(int capacity) Initialize the LRU cache with positive size capacity.</li>
</ul>
</li>
</ul>
<h2 id="solutions" node="[object Object]">Solutions</h2>
<p>{% raw %}
/**</p>
<ul>
<li>LRU Cache</li>
<li></li>
<li>Problem: <a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener noreferrer" node="[object Object]">https://leetcode.com/problems/lru-cache/</a></li>
<li></li>
<li>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</li>
<li></li>
<li>Implement the LRUCache class:</li>
<li>
<ul>
<li>LRUCache(int capacity) Initialize the LRU cache with positive size capacity.</li>
</ul>
</li>
<li>
<ul>
<li>int get(int key) Return the value of the key if the key exists, otherwise return -1.</li>
</ul>
</li>
<li>
<ul>
<li>void put(int key, int value) Update the value of the key if the key exists. Otherwise,</li>
</ul>
</li>
<li>add the key-value pair to the cache. If the number of keys exceeds the capacity from</li>
<li>this operation, evict the least recently used key.</li>
<li></li>
<li>The functions get and put must each run in O(1) average time complexity.</li>
<li></li>
<li>Example 1:</li>
<li>Input:</li>
<li>[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</li>
<li>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</li>
<li>Output: [null, null, null, 1, null, -1, null, -1, 3, 4]</li>
<li></li>
<li>Explanation:</li>
<li>LRUCache lRUCache = new LRUCache(2);</li>
<li>lRUCache.put(1, 1); // cache is {1=1}</li>
<li>lRUCache.put(2, 2); // cache is {1=1, 2=2}</li>
<li>lRUCache.get(1);    // return 1</li>
<li>lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}</li>
<li>lRUCache.get(2);    // returns -1 (not found)</li>
<li>lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}</li>
<li>lRUCache.get(1);    // return -1 (not found)</li>
<li>lRUCache.get(3);    // return 3</li>
<li>lRUCache.get(4);    // return 4</li>
<li></li>
<li>Constraints:</li>
<li>
<ul>
<li>1 &lt;= capacity &lt;= 3000</li>
</ul>
</li>
<li>
<ul>
<li>0 &lt;= key &lt;= 10^4</li>
</ul>
</li>
<li>
<ul>
<li>0 &lt;= value &lt;= 10^5</li>
</ul>
</li>
<li>
<ul>
<li>At most 2 * 10^5 calls will be made to get and put.</li>
</ul>
</li>
<li></li>
<li>Solution Approaches:</li>
<li>
<ol>
<li>HashMap + Doubly Linked List</li>
</ol>
</li>
<li>
<ol start="2">
<li>Using Map (built-in LRU behavior in some languages)</li>
</ol>
</li>
<li>
<ol start="3">
<li>Array-based implementation (for small capacity)</li>
</ol>
</li>
<li>
<ol start="4">
<li>With eviction statistics</li>
</ol>
</li>
<li></li>
<li>Time Complexity: O(1) for get and put operations</li>
<li>Space Complexity: O(capacity)
*/</li>
</ul>
<p>/**</p>
<ul>
<li>Doubly Linked List Node
*/
class ListNode {
key: number;
value: number;
prev: ListNode | null;
next: ListNode | null;</li>
</ul>
<p>constructor(key: number, value: number) {
this.key = key;
this.value = value;
this.prev = null;
this.next = null;
}
}</p>
<p>/**</p>
<ul>
<li>LRU Cache - HashMap + Doubly Linked List Implementation</li>
<li></li>
<li>LRU Cache - Triển khai HashMap + Doubly Linked List</li>
<li></li>
<li>This approach uses a HashMap for O(1) lookups and a doubly linked list</li>
<li>to maintain the order of recently used items
*/
class LRUCache {
private capacity: number;
private cache: Map&lt;number, ListNode&gt;;
private head: ListNode;
private tail: ListNode;</li>
</ul>
<p>constructor(capacity: number) {
this.capacity = capacity;
this.cache = new Map();</p>
<pre><pre><code class="hljs undefined">// Initialize dummy head and tail nodes
this.head = new ListNode(0, 0);
this.tail = new ListNode(0, 0);
this.head.next = this.tail;
this.tail.prev = this.head;
</code></pre></pre>
<p>}</p>
<p>/**</p>
<ul>
<li>Get value by key</li>
<li>Lấy giá trị theo khóa
*/
get(key: number): number {
const node = this.cache.get(key);</li>
</ul>
<pre><pre><code class="hljs undefined">if (!node) {
</code></pre></pre>
<pre><pre><code class="hljs undefined">  return -1;
}

// Move to front (most recently used)
this.moveToFront(node);

return node.value;
</code></pre></pre>
<p>}</p>
<p>/**</p>
<ul>
<li>Put key-value pair</li>
<li>Đặt cặp khóa-giá trị
*/
put(key: number, value: number): void {
const existingNode = this.cache.get(key);</li>
</ul>
<pre><pre><code class="hljs undefined">if (existingNode) {
</code></pre></pre>
<pre><pre><code class="hljs undefined">  // Update existing node
  existingNode.value = value;
  this.moveToFront(existingNode);
} else {
  // Create new node
  const newNode = new ListNode(key, value);
  this.cache.set(key, newNode);
  this.addToFront(newNode);

  // Check capacity and evict if necessary
  if (this.cache.size &gt; this.capacity) {
    this.evictLRU();
  }
}
</code></pre></pre>
<p>}</p>
<p>/**</p>
<ul>
<li>Move node to front of list (most recently used)</li>
<li>Di chuyển node lên đầu danh sách (sử dụng gần đây nhất)
*/
private moveToFront(node: ListNode): void {
// Remove from current position
this.removeNode(node);
// Add to front
this.addToFront(node);
}</li>
</ul>
<p>/**</p>
<ul>
<li>Add node to front of list</li>
<li>Thêm node vào đầu danh sách
*/
private addToFront(node: ListNode): void {
node.prev = this.head;
node.next = this.head.next;
this.head.next!.prev = node;
this.head.next = node;
}</li>
</ul>
<p>/**</p>
<ul>
<li>Remove node from list</li>
<li>Xóa node khỏi danh sách
*/
private removeNode(node: ListNode): void {
node.prev!.next = node.next;
node.next!.prev = node.prev;
}</li>
</ul>
<p>/**</p>
<ul>
<li>Evict least recently used item</li>
<li>Loại bỏ phần tử ít được sử dụng nhất
*/
private evictLRU(): void {
const lruNode = this.tail.prev!;
this.removeNode(lruNode);
this.cache.delete(lruNode.key);
}</li>
</ul>
<p>/**</p>
<ul>
<li>Get current size of cache</li>
<li>Lấy kích thước hiện tại của cache
*/
size(): number {
return this.cache.size;
}</li>
</ul>
<p>/**</p>
<ul>
<li>Check if cache is full</li>
<li>Kiểm tra xem cache có đầy không
*/
isFull(): boolean {
return this.cache.size &gt;= this.capacity;
}</li>
</ul>
<p>/**</p>
<ul>
<li>Get all keys in order of usage (most recent first)</li>
<li>Lấy tất cả khóa theo thứ tự sử dụng (gần đây nhất trước)
*/
getKeysInOrder(): number[] {
const keys: number[] = [];
let current = this.head.next;</li>
</ul>
<pre><pre><code class="hljs undefined">while (current &amp;&amp; current !== this.tail) {
</code></pre></pre>
<pre><pre><code class="hljs undefined">  keys.push(current.key);
  current = current.next;
}

return keys;
</code></pre></pre>
<p>}</p>
<p>/**</p>
<ul>
<li>Get cache statistics</li>
<li>Lấy thống kê cache
*/
getStats(): { size: number; capacity: number; usage: number } {
return {
size: this.cache.size,
capacity: this.capacity,
usage: (this.cache.size / this.capacity) * 100,
};
}
}</li>
</ul>
<p>/**</p>
<ul>
<li>Alternative Implementation: Using Map (built-in LRU behavior)</li>
<li></li>
<li>Triển khai thay thế: Sử dụng Map (hành vi LRU có sẵn)
*/
class LRUCacheMap {
private capacity: number;
private cache: Map&lt;number, number&gt;;</li>
</ul>
<p>constructor(capacity: number) {
this.capacity = capacity;
this.cache = new Map();
}</p>
<p>get(key: number): number {
if (!this.cache.has(key)) {
return -1;
}</p>
<pre><pre><code class="hljs undefined">// Move to end (most recently used)
const value = this.cache.get(key)!;
this.cache.delete(key);
this.cache.set(key, value);

return value;
</code></pre></pre>
<p>}</p>
<p>put(key: number, value: number): void {
if (this.cache.has(key)) {
this.cache.delete(key);
} else if (this.cache.size &gt;= this.capacity) {
// Remove least recently used (first key)
const firstKey = this.cache.keys().next().value;
this.cache.delete(firstKey);
}</p>
<pre><pre><code class="hljs undefined">this.cache.set(key, value);
</code></pre></pre>
<p>}</p>
<p>size(): number {
return this.cache.size;
}</p>
<p>isFull(): boolean {
return this.cache.size &gt;= this.capacity;
}
}</p>
<p>/**</p>
<ul>
<li>Implementation with Eviction Statistics</li>
<li></li>
<li>Triển khai với thống kê loại bỏ
*/
class LRUCacheWithStats extends LRUCache {
private evictionCount: number;
private hitCount: number;
private missCount: number;
private evictionHistory: Array&lt;{ key: number; timestamp: number }&gt;;</li>
</ul>
<p>constructor(capacity: number) {
super(capacity);
this.evictionCount = 0;
this.hitCount = 0;
this.missCount = 0;
this.evictionHistory = [];
}</p>
<p>get(key: number): number {
const result = super.get(key);</p>
<pre><pre><code class="hljs undefined">if (result === -1) {
  this.missCount++;
} else {
  this.hitCount++;
}

return result;
</code></pre></pre>
<p>}</p>
<p>put(key: number, value: number): void {
const wasFull = this.isFull();
const hadKey = this.get(key) !== -1;</p>
<pre><pre><code class="hljs undefined">super.put(key, value);

// Track eviction if cache was full and we added a new key
if (wasFull &amp;&amp; !hadKey) {
  this.evictionCount++;
  this.evictionHistory.push({ key, timestamp: Date.now() });
}
</code></pre></pre>
<p>}</p>
<p>/**</p>
<ul>
<li>Get cache performance statistics</li>
<li>Lấy thống kê hiệu suất cache
*/
getPerformanceStats(): {
hitCount: number;
missCount: number;
hitRate: number;
evictionCount: number;
evictionHistory: Array&lt;{ key: number; timestamp: number }&gt;;
} {
const totalRequests = this.hitCount + this.missCount;
const hitRate =
totalRequests &gt; 0 ? (this.hitCount / totalRequests) * 100 : 0;</li>
</ul>
<pre><pre><code class="hljs undefined">return {
</code></pre></pre>
<pre><pre><code class="hljs undefined">  hitCount: this.hitCount,
  missCount: this.missCount,
  hitRate,
  evictionCount: this.evictionCount,
  evictionHistory: [...this.evictionHistory],
};
</code></pre></pre>
<p>}</p>
<p>/**</p>
<ul>
<li>Clear performance statistics</li>
<li>Xóa thống kê hiệu suất
*/
clearStats(): void {
this.evictionCount = 0;
this.hitCount = 0;
this.missCount = 0;
this.evictionHistory = [];
}
}</li>
</ul>
<p>/**</p>
<ul>
<li>Implementation with TTL (Time To Live)</li>
<li></li>
<li>Triển khai với TTL (Thời gian sống)
*/
class LRUCacheWithTTL extends LRUCache {
private ttl: number; // Time to live in milliseconds
private timestamps: Map&lt;number, number&gt;;</li>
</ul>
<p>constructor(capacity: number, ttl: number = 60000) {
// Default 1 minute
super(capacity);
this.ttl = ttl;
this.timestamps = new Map();
}</p>
<p>get(key: number): number {
const timestamp = this.timestamps.get(key);</p>
<pre><pre><code class="hljs undefined">if (timestamp &amp;&amp; Date.now() - timestamp &gt; this.ttl) {
  // Key has expired, remove it
  this.timestamps.delete(key);
  return -1;
}

const result = super.get(key);

if (result !== -1) {
  // Update timestamp
  this.timestamps.set(key, Date.now());
}

return result;
</code></pre></pre>
<p>}</p>
<p>put(key: number, value: number): void {
super.put(key, value);
this.timestamps.set(key, Date.now());
}</p>
<p>/**</p>
<ul>
<li>Clean up expired entries</li>
<li>Dọn dẹp các mục đã hết hạn
*/
cleanup(): number {
const now = Date.now();
let cleanedCount = 0;</li>
</ul>
<pre><pre><code class="hljs undefined">for (const [key, timestamp] of this.timestamps.entries()) {
</code></pre></pre>
<pre><pre><code class="hljs undefined">  if (now - timestamp &gt; this.ttl) {
    this.timestamps.delete(key);
    cleanedCount++;
  }
}

return cleanedCount;
</code></pre></pre>
<p>}</p>
<p>/**</p>
<ul>
<li>Get TTL statistics</li>
<li>Lấy thống kê TTL
*/
getTTLStats(): {
ttl: number;
activeEntries: number;
expiredEntries: number;
} {
const now = Date.now();
let expiredCount = 0;</li>
</ul>
<pre><pre><code class="hljs undefined">for (const timestamp of this.timestamps.values()) {
</code></pre></pre>
<pre><pre><code class="hljs undefined">  if (now - timestamp &gt; this.ttl) {
    expiredCount++;
  }
}

return {
  ttl: this.ttl,
  activeEntries: this.timestamps.size - expiredCount,
  expiredEntries: expiredCount,
};
</code></pre></pre>
<p>}
}</p>
<p>/**</p>
<ul>
<li>Performance Comparison Function</li>
<li></li>
<li>Hàm so sánh hiệu suất các phương pháp
*/
function compareLRUImplementations(
operations: Array&lt;{ type: &quot;get&quot; | &quot;put&quot;; key: number; value?: number }&gt;
): void {
console.log(
&quot;LRU Cache Implementation Performance Comparison / So sánh hiệu suất triển khai LRU Cache&quot;
);
console.log(&quot;=&quot;.repeat(80));</li>
</ul>
<p>const implementations = [
{ name: &quot;Doubly Linked List&quot;, cache: new LRUCache(100) },
{ name: &quot;Map-based&quot;, cache: new LRUCacheMap(100) },
];</p>
<p>for (const impl of implementations) {
console.log(<pre><code class="hljs undefined">\nTesting ${impl.name}:</code></pre>);</p>
<pre><pre><code class="hljs undefined">const start = performance.now();

for (const op of operations) {
  switch (op.type) {
    case &quot;get&quot;:
      impl.cache.get(op.key);
      break;
    case &quot;put&quot;:
      impl.cache.put(op.key, op.value!);
      break;
  }
}

const end = performance.now();
console.log(`  Time: ${(end - start).toFixed(4)}ms`);
console.log(`  Final size: ${impl.cache.size()}`);
</code></pre></pre>
<p>}
}</p>
<p>/**</p>
<ul>
<li>Test Cases</li>
<li></li>
<li>Các trường hợp kiểm thử
*/
function runTests(): void {
console.log(&quot;LRU Cache Tests / Kiểm thử LRU Cache&quot;);
console.log(&quot;=&quot;.repeat(50));</li>
</ul>
<p>// Test 1: Basic operations
console.log(&quot;\nTest 1: Basic operations / Các thao tác cơ bản&quot;);
const cache1 = new LRUCache(2);
cache1.put(1, 1);
cache1.put(2, 2);
console.log(<pre><code class="hljs undefined">get(1): ${cache1.get(1)}</code></pre>); // Expected: 1
cache1.put(3, 3);
console.log(<pre><code class="hljs undefined">get(2): ${cache1.get(2)}</code></pre>); // Expected: -1
cache1.put(4, 4);
console.log(<pre><code class="hljs undefined">get(1): ${cache1.get(1)}</code></pre>); // Expected: -1
console.log(<pre><code class="hljs undefined">get(3): ${cache1.get(3)}</code></pre>); // Expected: 3
console.log(<pre><code class="hljs undefined">get(4): ${cache1.get(4)}</code></pre>); // Expected: 4</p>
<p>// Test 2: Performance tracking
console.log(&quot;\nTest 2: Performance tracking / Theo dõi hiệu suất&quot;);
const perfCache = new LRUCacheWithStats(3);</p>
<p>perfCache.put(1, 1);
perfCache.put(2, 2);
perfCache.put(3, 3);
perfCache.get(1); // Hit
perfCache.get(4); // Miss
perfCache.put(4, 4); // Evicts 2
perfCache.get(2); // Miss (evicted)</p>
<p>const stats = perfCache.getPerformanceStats();
console.log(<pre><code class="hljs undefined">Hit count: ${stats.hitCount}</code></pre>);
console.log(<pre><code class="hljs undefined">Miss count: ${stats.missCount}</code></pre>);
console.log(<pre><code class="hljs undefined">Hit rate: ${stats.hitRate.toFixed(2)}%</code></pre>);
console.log(<pre><code class="hljs undefined">Eviction count: ${stats.evictionCount}</code></pre>);</p>
<p>// Test 3: TTL cache
console.log(&quot;\nTest 3: TTL cache / Cache với TTL&quot;);
const ttlCache = new LRUCacheWithTTL(3, 1000); // 1 second TTL</p>
<p>ttlCache.put(1, 1);
ttlCache.put(2, 2);
console.log(<pre><code class="hljs undefined">get(1): ${ttlCache.get(1)}</code></pre>); // Expected: 1</p>
<p>// Wait for TTL to expire (simulate)
setTimeout(() =&gt; {
console.log(<pre><code class="hljs undefined">get(1) after TTL: ${ttlCache.get(1)}</code></pre>); // Expected: -1
console.log(<pre><code class="hljs undefined">TTL stats: ${JSON.stringify(ttlCache.getTTLStats())}</code></pre>);
}, 1100);</p>
<p>// Test 4: Cache statistics
console.log(&quot;\nTest 4: Cache statistics / Thống kê cache&quot;);
const statCache = new LRUCache(5);</p>
<p>for (let i = 1; i &lt;= 7; i++) {
statCache.put(i, i * 10);
}</p>
<p>console.log(<pre><code class="hljs undefined">Size: ${statCache.size()}</code></pre>);
console.log(<pre><code class="hljs undefined">Is full: ${statCache.isFull()}</code></pre>);
console.log(<pre><code class="hljs undefined">Keys in order: [${statCache.getKeysInOrder().join(&quot;, &quot;)}]</code></pre>);
console.log(<pre><code class="hljs undefined">Stats: ${JSON.stringify(statCache.getStats())}</code></pre>);</p>
<p>// Test 5: Performance comparison
console.log(&quot;\nTest 5: Performance comparison / So sánh hiệu suất&quot;);
const testOperations = [
{ type: &quot;put&quot; as const, key: 1, value: 1 },
{ type: &quot;put&quot; as const, key: 2, value: 2 },
{ type: &quot;get&quot; as const, key: 1 },
{ type: &quot;put&quot; as const, key: 3, value: 3 },
{ type: &quot;get&quot; as const, key: 2 },
{ type: &quot;put&quot; as const, key: 4, value: 4 },
{ type: &quot;get&quot; as const, key: 1 },
{ type: &quot;get&quot; as const, key: 3 },
{ type: &quot;get&quot; as const, key: 4 },
];</p>
<p>compareLRUImplementations(testOperations);
}</p>
<p>// Uncomment to run tests
// runTests();</p>
<p>export {
LRUCache,
LRUCacheMap,
LRUCacheWithStats,
LRUCacheWithTTL,
ListNode,
compareLRUImplementations,
runTests,
};
{% endraw %}</p></div></div></div><div class="space-y-6"><div class="bg-white border border-gray-200 rounded-lg p-6"><h3 class="text-lg font-semibold text-gray-900 mb-4">Your Progress</h3><div class="w-full bg-gray-200 rounded-full h-2 mb-2"><div class="bg-blue-600 h-2 rounded-full" style="width:25%"></div></div><p class="text-sm text-gray-600">25% Complete</p></div></div></div></div></main><footer class="sc-dYwGCk cJzheU"><div class="sc-lgpSej hJUFeT"><div class="sc-eqYatC mSxwd"><div class="sc-kcLKEh cmBIup"><div class="sc-dntSTA bAsNIP"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</div><p class="sc-kvnevz gWXMDV">Comprehensive interview preparation for frontend engineers targeting Big Tech companies.</p><div class="sc-dFVmKS jCoOHQ"><a href="https://github.com" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github "><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><a href="https://twitter.com" aria-label="Twitter"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-twitter "><path d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"></path></svg></a><a href="https://linkedin.com" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-linkedin "><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect width="4" height="12" x="2" y="9"></rect><circle cx="4" cy="4" r="2"></circle></svg></a><a href="mailto:contact@example.com" aria-label="Email"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail "><rect width="20" height="16" x="2" y="4" rx="2"></rect><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path></svg></a></div></div><div class="sc-kcLKEh cmBIup"><h3>Study Materials</h3><ul><li><a href="/algorithms">Algorithms</a></li><li><a href="/react">React &amp; Frontend</a></li><li><a href="/system-design">System Design</a></li><li><a href="/typescript">TypeScript</a></li><li><a href="/performance">Performance</a></li></ul></div><div class="sc-kcLKEh cmBIup"><h3>Companies</h3><ul><li><a href="/google">Google</a></li><li><a href="/meta">Meta</a></li><li><a href="/amazon">Amazon</a></li><li><a href="/microsoft">Microsoft</a></li><li><a href="/apple">Apple</a></li></ul></div><div class="sc-kcLKEh cmBIup"><h3>Resources</h3><ul><li><a href="/interview-tips">Interview Tips</a></li><li><a href="/coding-challenges">Coding Challenges</a></li><li><a href="/mock-interviews">Mock Interviews</a></li><li><a href="/blog">Blog</a></li><li><a href="/faq">FAQ</a></li></ul></div></div><div class="sc-kCuUfV crUaYh"><p class="sc-dNdcvo esMlQF">© 2025 Frontend Interview Prep. All rights reserved.</p><div class="sc-fbQrwq eHcrXx"><a href="/privacy">Privacy Policy</a><a href="/terms">Terms of Service</a><a href="/contact">Contact</a></div></div></div></footer></div><script src="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/interview/_next/static/css/387024c6a2216908.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[2846,[],\"\"]\n5:I[2972,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"930\",\"static/chunks/930-3262a6c9c5acace4.js\",\"289\",\"static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js\"],\"\"]\n6:I[5907,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"930\",\"static/chunks/930-3262a6c9c5acace4.js\",\"289\",\"static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js\"],\"default\"]\n8:I[4707,[],\"\"]\na:I[6423,[],\"\"]\nb:I[2,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"710\",\"static/chunks/710-dfaa11b4dff08f8e.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"233\",\"static/chunks/233-3e0c1d820a17eca9.js\",\"185\",\"static/chunks/app/layout-333f4adcd11f8f39.js\"],\"default\",1]\nd:I[1060,[],\"\"]\n7:T38d6,"])</script><script>self.__next_f.push([1,"\n# LRU Cache\n\n\n\n## Problem Description\n\n *  * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  *  * Implement the LRUCache class:  * - LRUCache(int capacity) Initialize the LRU cache with positive size capacity. \n\n## Solutions\n\n{% raw %}\n/**\n * LRU Cache\n *\n * Problem: https://leetcode.com/problems/lru-cache/\n *\n * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n *\n * Implement the LRUCache class:\n * - LRUCache(int capacity) Initialize the LRU cache with positive size capacity.\n * - int get(int key) Return the value of the key if the key exists, otherwise return -1.\n * - void put(int key, int value) Update the value of the key if the key exists. Otherwise,\n *   add the key-value pair to the cache. If the number of keys exceeds the capacity from\n *   this operation, evict the least recently used key.\n *\n * The functions get and put must each run in O(1) average time complexity.\n *\n * Example 1:\n * Input:\n * [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n * [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n * Output: [null, null, null, 1, null, -1, null, -1, 3, 4]\n *\n * Explanation:\n * LRUCache lRUCache = new LRUCache(2);\n * lRUCache.put(1, 1); // cache is {1=1}\n * lRUCache.put(2, 2); // cache is {1=1, 2=2}\n * lRUCache.get(1);    // return 1\n * lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\n * lRUCache.get(2);    // returns -1 (not found)\n * lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\n * lRUCache.get(1);    // return -1 (not found)\n * lRUCache.get(3);    // return 3\n * lRUCache.get(4);    // return 4\n *\n * Constraints:\n * - 1 \u003c= capacity \u003c= 3000\n * - 0 \u003c= key \u003c= 10^4\n * - 0 \u003c= value \u003c= 10^5\n * - At most 2 * 10^5 calls will be made to get and put.\n *\n * Solution Approaches:\n * 1. HashMap + Doubly Linked List\n * 2. Using Map (built-in LRU behavior in some languages)\n * 3. Array-based implementation (for small capacity)\n * 4. With eviction statistics\n *\n * Time Complexity: O(1) for get and put operations\n * Space Complexity: O(capacity)\n */\n\n/**\n * Doubly Linked List Node\n */\nclass ListNode {\n  key: number;\n  value: number;\n  prev: ListNode | null;\n  next: ListNode | null;\n\n  constructor(key: number, value: number) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\n\n/**\n * LRU Cache - HashMap + Doubly Linked List Implementation\n *\n * LRU Cache - Triển khai HashMap + Doubly Linked List\n *\n * This approach uses a HashMap for O(1) lookups and a doubly linked list\n * to maintain the order of recently used items\n */\nclass LRUCache {\n  private capacity: number;\n  private cache: Map\u003cnumber, ListNode\u003e;\n  private head: ListNode;\n  private tail: ListNode;\n\n  constructor(capacity: number) {\n    this.capacity = capacity;\n    this.cache = new Map();\n\n    // Initialize dummy head and tail nodes\n    this.head = new ListNode(0, 0);\n    this.tail = new ListNode(0, 0);\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n\n  /**\n   * Get value by key\n   * Lấy giá trị theo khóa\n   */\n  get(key: number): number {\n    const node = this.cache.get(key);\n\n    if (!node) {\n      return -1;\n    }\n\n    // Move to front (most recently used)\n    this.moveToFront(node);\n\n    return node.value;\n  }\n\n  /**\n   * Put key-value pair\n   * Đặt cặp khóa-giá trị\n   */\n  put(key: number, value: number): void {\n    const existingNode = this.cache.get(key);\n\n    if (existingNode) {\n      // Update existing node\n      existingNode.value = value;\n      this.moveToFront(existingNode);\n    } else {\n      // Create new node\n      const newNode = new ListNode(key, value);\n      this.cache.set(key, newNode);\n      this.addToFront(newNode);\n\n      // Check capacity and evict if necessary\n      if (this.cache.size \u003e this.capacity) {\n        this.evictLRU();\n      }\n    }\n  }\n\n  /**\n   * Move node to front of list (most recently used)\n   * Di chuyển node lên đầu danh sách (sử dụng gần đây nhất)\n   */\n  private moveToFront(node: ListNode): void {\n    // Remove from current position\n    this.removeNode(node);\n    // Add to front\n    this.addToFront(node);\n  }\n\n  /**\n   * Add node to front of list\n   * Thêm node vào đầu danh sách\n   */\n  private addToFront(node: ListNode): void {\n    node.prev = this.head;\n    node.next = this.head.next;\n    this.head.next!.prev = node;\n    this.head.next = node;\n  }\n\n  /**\n   * Remove node from list\n   * Xóa node khỏi danh sách\n   */\n  private removeNode(node: ListNode): void {\n    node.prev!.next = node.next;\n    node.next!.prev = node.prev;\n  }\n\n  /**\n   * Evict least recently used item\n   * Loại bỏ phần tử ít được sử dụng nhất\n   */\n  private evictLRU(): void {\n    const lruNode = this.tail.prev!;\n    this.removeNode(lruNode);\n    this.cache.delete(lruNode.key);\n  }\n\n  /**\n   * Get current size of cache\n   * Lấy kích thước hiện tại của cache\n   */\n  size(): number {\n    return this.cache.size;\n  }\n\n  /**\n   * Check if cache is full\n   * Kiểm tra xem cache có đầy không\n   */\n  isFull(): boolean {\n    return this.cache.size \u003e= this.capacity;\n  }\n\n  /**\n   * Get all keys in order of usage (most recent first)\n   * Lấy tất cả khóa theo thứ tự sử dụng (gần đây nhất trước)\n   */\n  getKeysInOrder(): number[] {\n    const keys: number[] = [];\n    let current = this.head.next;\n\n    while (current \u0026\u0026 current !== this.tail) {\n      keys.push(current.key);\n      current = current.next;\n    }\n\n    return keys;\n  }\n\n  /**\n   * Get cache statistics\n   * Lấy thống kê cache\n   */\n  getStats(): { size: number; capacity: number; usage: number } {\n    return {\n      size: this.cache.size,\n      capacity: this.capacity,\n      usage: (this.cache.size / this.capacity) * 100,\n    };\n  }\n}\n\n/**\n * Alternative Implementation: Using Map (built-in LRU behavior)\n *\n * Triển khai thay thế: Sử dụng Map (hành vi LRU có sẵn)\n */\nclass LRUCacheMap {\n  private capacity: number;\n  private cache: Map\u003cnumber, number\u003e;\n\n  constructor(capacity: number) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n\n  get(key: number): number {\n    if (!this.cache.has(key)) {\n      return -1;\n    }\n\n    // Move to end (most recently used)\n    const value = this.cache.get(key)!;\n    this.cache.delete(key);\n    this.cache.set(key, value);\n\n    return value;\n  }\n\n  put(key: number, value: number): void {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size \u003e= this.capacity) {\n      // Remove least recently used (first key)\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n\n    this.cache.set(key, value);\n  }\n\n  size(): number {\n    return this.cache.size;\n  }\n\n  isFull(): boolean {\n    return this.cache.size \u003e= this.capacity;\n  }\n}\n\n/**\n * Implementation with Eviction Statistics\n *\n * Triển khai với thống kê loại bỏ\n */\nclass LRUCacheWithStats extends LRUCache {\n  private evictionCount: number;\n  private hitCount: number;\n  private missCount: number;\n  private evictionHistory: Array\u003c{ key: number; timestamp: number }\u003e;\n\n  constructor(capacity: number) {\n    super(capacity);\n    this.evictionCount = 0;\n    this.hitCount = 0;\n    this.missCount = 0;\n    this.evictionHistory = [];\n  }\n\n  get(key: number): number {\n    const result = super.get(key);\n\n    if (result === -1) {\n      this.missCount++;\n    } else {\n      this.hitCount++;\n    }\n\n    return result;\n  }\n\n  put(key: number, value: number): void {\n    const wasFull = this.isFull();\n    const hadKey = this.get(key) !== -1;\n\n    super.put(key, value);\n\n    // Track eviction if cache was full and we added a new key\n    if (wasFull \u0026\u0026 !hadKey) {\n      this.evictionCount++;\n      this.evictionHistory.push({ key, timestamp: Date.now() });\n    }\n  }\n\n  /**\n   * Get cache performance statistics\n   * Lấy thống kê hiệu suất cache\n   */\n  getPerformanceStats(): {\n    hitCount: number;\n    missCount: number;\n    hitRate: number;\n    evictionCount: number;\n    evictionHistory: Array\u003c{ key: number; timestamp: number }\u003e;\n  } {\n    const totalRequests = this.hitCount + this.missCount;\n    const hitRate =\n      totalRequests \u003e 0 ? (this.hitCount / totalRequests) * 100 : 0;\n\n    return {\n      hitCount: this.hitCount,\n      missCount: this.missCount,\n      hitRate,\n      evictionCount: this.evictionCount,\n      evictionHistory: [...this.evictionHistory],\n    };\n  }\n\n  /**\n   * Clear performance statistics\n   * Xóa thống kê hiệu suất\n   */\n  clearStats(): void {\n    this.evictionCount = 0;\n    this.hitCount = 0;\n    this.missCount = 0;\n    this.evictionHistory = [];\n  }\n}\n\n/**\n * Implementation with TTL (Time To Live)\n *\n * Triển khai với TTL (Thời gian sống)\n */\nclass LRUCacheWithTTL extends LRUCache {\n  private ttl: number; // Time to live in milliseconds\n  private timestamps: Map\u003cnumber, number\u003e;\n\n  constructor(capacity: number, ttl: number = 60000) {\n    // Default 1 minute\n    super(capacity);\n    this.ttl = ttl;\n    this.timestamps = new Map();\n  }\n\n  get(key: number): number {\n    const timestamp = this.timestamps.get(key);\n\n    if (timestamp \u0026\u0026 Date.now() - timestamp \u003e this.ttl) {\n      // Key has expired, remove it\n      this.timestamps.delete(key);\n      return -1;\n    }\n\n    const result = super.get(key);\n\n    if (result !== -1) {\n      // Update timestamp\n      this.timestamps.set(key, Date.now());\n    }\n\n    return result;\n  }\n\n  put(key: number, value: number): void {\n    super.put(key, value);\n    this.timestamps.set(key, Date.now());\n  }\n\n  /**\n   * Clean up expired entries\n   * Dọn dẹp các mục đã hết hạn\n   */\n  cleanup(): number {\n    const now = Date.now();\n    let cleanedCount = 0;\n\n    for (const [key, timestamp] of this.timestamps.entries()) {\n      if (now - timestamp \u003e this.ttl) {\n        this.timestamps.delete(key);\n        cleanedCount++;\n      }\n    }\n\n    return cleanedCount;\n  }\n\n  /**\n   * Get TTL statistics\n   * Lấy thống kê TTL\n   */\n  getTTLStats(): {\n    ttl: number;\n    activeEntries: number;\n    expiredEntries: number;\n  } {\n    const now = Date.now();\n    let expiredCount = 0;\n\n    for (const timestamp of this.timestamps.values()) {\n      if (now - timestamp \u003e this.ttl) {\n        expiredCount++;\n      }\n    }\n\n    return {\n      ttl: this.ttl,\n      activeEntries: this.timestamps.size - expiredCount,\n      expiredEntries: expiredCount,\n    };\n  }\n}\n\n/**\n * Performance Comparison Function\n *\n * Hàm so sánh hiệu suất các phương pháp\n */\nfunction compareLRUImplementations(\n  operations: Array\u003c{ type: \"get\" | \"put\"; key: number; value?: number }\u003e\n): void {\n  console.log(\n    \"LRU Cache Implementation Performance Comparison / So sánh hiệu suất triển khai LRU Cache\"\n  );\n  console.log(\"=\".repeat(80));\n\n  const implementations = [\n    { name: \"Doubly Linked List\", cache: new LRUCache(100) },\n    { name: \"Map-based\", cache: new LRUCacheMap(100) },\n  ];\n\n  for (const impl of implementations) {\n    console.log(`\\nTesting ${impl.name}:`);\n\n    const start = performance.now();\n\n    for (const op of operations) {\n      switch (op.type) {\n        case \"get\":\n          impl.cache.get(op.key);\n          break;\n        case \"put\":\n          impl.cache.put(op.key, op.value!);\n          break;\n      }\n    }\n\n    const end = performance.now();\n    console.log(`  Time: ${(end - start).toFixed(4)}ms`);\n    console.log(`  Final size: ${impl.cache.size()}`);\n  }\n}\n\n/**\n * Test Cases\n *\n * Các trường hợp kiểm thử\n */\nfunction runTests(): void {\n  console.log(\"LRU Cache Tests / Kiểm thử LRU Cache\");\n  console.log(\"=\".repeat(50));\n\n  // Test 1: Basic operations\n  console.log(\"\\nTest 1: Basic operations / Các thao tác cơ bản\");\n  const cache1 = new LRUCache(2);\n  cache1.put(1, 1);\n  cache1.put(2, 2);\n  console.log(`get(1): ${cache1.get(1)}`); // Expected: 1\n  cache1.put(3, 3);\n  console.log(`get(2): ${cache1.get(2)}`); // Expected: -1\n  cache1.put(4, 4);\n  console.log(`get(1): ${cache1.get(1)}`); // Expected: -1\n  console.log(`get(3): ${cache1.get(3)}`); // Expected: 3\n  console.log(`get(4): ${cache1.get(4)}`); // Expected: 4\n\n  // Test 2: Performance tracking\n  console.log(\"\\nTest 2: Performance tracking / Theo dõi hiệu suất\");\n  const perfCache = new LRUCacheWithStats(3);\n\n  perfCache.put(1, 1);\n  perfCache.put(2, 2);\n  perfCache.put(3, 3);\n  perfCache.get(1); // Hit\n  perfCache.get(4); // Miss\n  perfCache.put(4, 4); // Evicts 2\n  perfCache.get(2); // Miss (evicted)\n\n  const stats = perfCache.getPerformanceStats();\n  console.log(`Hit count: ${stats.hitCount}`);\n  console.log(`Miss count: ${stats.missCount}`);\n  console.log(`Hit rate: ${stats.hitRate.toFixed(2)}%`);\n  console.log(`Eviction count: ${stats.evictionCount}`);\n\n  // Test 3: TTL cache\n  console.log(\"\\nTest 3: TTL cache / Cache với TTL\");\n  const ttlCache = new LRUCacheWithTTL(3, 1000); // 1 second TTL\n\n  ttlCache.put(1, 1);\n  ttlCache.put(2, 2);\n  console.log(`get(1): ${ttlCache.get(1)}`); // Expected: 1\n\n  // Wait for TTL to expire (simulate)\n  setTimeout(() =\u003e {\n    console.log(`get(1) after TTL: ${ttlCache.get(1)}`); // Expected: -1\n    console.log(`TTL stats: ${JSON.stringify(ttlCache.getTTLStats())}`);\n  }, 1100);\n\n  // Test 4: Cache statistics\n  console.log(\"\\nTest 4: Cache statistics / Thống kê cache\");\n  const statCache = new LRUCache(5);\n\n  for (let i = 1; i \u003c= 7; i++) {\n    statCache.put(i, i * 10);\n  }\n\n  console.log(`Size: ${statCache.size()}`);\n  console.log(`Is full: ${statCache.isFull()}`);\n  console.log(`Keys in order: [${statCache.getKeysInOrder().join(\", \")}]`);\n  console.log(`Stats: ${JSON.stringify(statCache.getStats())}`);\n\n  // Test 5: Performance comparison\n  console.log(\"\\nTest 5: Performance comparison / So sánh hiệu suất\");\n  const testOperations = [\n    { type: \"put\" as const, key: 1, value: 1 },\n    { type: \"put\" as const, key: 2, value: 2 },\n    { type: \"get\" as const, key: 1 },\n    { type: \"put\" as const, key: 3, value: 3 },\n    { type: \"get\" as const, key: 2 },\n    { type: \"put\" as const, key: 4, value: 4 },\n    { type: \"get\" as const, key: 1 },\n    { type: \"get\" as const, key: 3 },\n    { type: \"get\" as const, key: 4 },\n  ];\n\n  compareLRUImplementations(testOperations);\n}\n\n// Uncomment to run tests\n// runTests();\n\nexport {\n  LRUCache,\n  LRUCacheMap,\n  LRUCacheWithStats,\n  LRUCacheWithTTL,\n  ListNode,\n  compareLRUImplementations,\n  runTests,\n};\n{% endraw %}\n"])</script><script>self.__next_f.push([1,"9:[\"topic\",\"others-problems-06-lru-cache\",\"d\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L3\",null,{\"buildId\":\"2NmUhWiPdVVBzVtDZlggk\",\"assetPrefix\":\"/interview\",\"urlParts\":[\"\",\"learn\",\"others-problems-06-lru-cache\"],\"initialTree\":[\"\",{\"children\":[\"learn\",{\"children\":[[\"topic\",\"others-problems-06-lru-cache\",\"d\"],{\"children\":[\"__PAGE__?{\\\"topic\\\":\\\"others-problems-06-lru-cache\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"learn\",{\"children\":[[\"topic\",\"others-problems-06-lru-cache\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",[\"$\",\"div\",null,{\"className\":\"max-w-6xl mx-auto px-8 py-24\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-4 mb-8\",\"children\":[\"$\",\"$L5\",null,{\"href\":\"/learn\",\"children\":[\"$\",\"button\",null,{\"className\":\"flex items-center gap-2 bg-gray-100 border border-gray-300 text-gray-700 px-4 py-3 rounded-md font-medium hover:bg-gray-200 transition-colors\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-arrow-left \",\"children\":[[\"$\",\"path\",\"1l729n\",{\"d\":\"m12 19-7-7 7-7\"}],[\"$\",\"path\",\"x3x0zl\",{\"d\":\"M19 12H5\"}],\"$undefined\"]}],\"Back to Learn\"]}]}]}],[\"$\",\"div\",null,{\"className\":\"bg-white border border-gray-200 rounded-lg p-8 mb-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between mb-4\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-bold text-gray-900\",\"children\":\"LRU Cache\"}],[\"$\",\"div\",null,{\"className\":\"flex gap-4\",\"children\":[[\"$\",\"button\",null,{\"className\":\"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-star \",\"children\":[[\"$\",\"polygon\",\"8f66p6\",{\"points\":\"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2\"}],\"$undefined\"]}],\"Bookmark\"]}],[\"$\",\"button\",null,{\"className\":\"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-share2 \",\"children\":[[\"$\",\"circle\",\"gq8acd\",{\"cx\":\"18\",\"cy\":\"5\",\"r\":\"3\"}],[\"$\",\"circle\",\"w7nqdw\",{\"cx\":\"6\",\"cy\":\"12\",\"r\":\"3\"}],[\"$\",\"circle\",\"1xt0gg\",{\"cx\":\"18\",\"cy\":\"19\",\"r\":\"3\"}],[\"$\",\"line\",\"47mynk\",{\"x1\":\"8.59\",\"x2\":\"15.42\",\"y1\":\"13.51\",\"y2\":\"17.49\"}],[\"$\",\"line\",\"1n3mei\",{\"x1\":\"15.41\",\"x2\":\"8.59\",\"y1\":\"6.51\",\"y2\":\"10.49\"}],\"$undefined\"]}],\"Share\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"flex gap-8 mb-4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-2 text-sm text-gray-600\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-clock \",\"children\":[[\"$\",\"circle\",\"1mglay\",{\"cx\":\"12\",\"cy\":\"12\",\"r\":\"10\"}],[\"$\",\"polyline\",\"68esgv\",{\"points\":\"12 6 12 12 16 14\"}],\"$undefined\"]}],\"2-3 hours\"]}],[\"$\",\"span\",null,{\"className\":\"px-3 py-1 rounded-full text-xs font-semibold text-white bg-red-500\",\"children\":\"Easy\"}],[\"$\",\"span\",null,{\"className\":\"px-3 py-1 rounded-full text-xs font-semibold bg-blue-100 text-blue-700\",\"children\":\"Others\"}]]}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-2 mb-4\",\"children\":[[\"$\",\"span\",\"0\",{\"className\":\"bg-gray-100 text-gray-600 px-3 py-1 rounded-md text-xs font-medium\",\"children\":\"Others\"}],[\"$\",\"span\",\"1\",{\"className\":\"bg-gray-100 text-gray-600 px-3 py-1 rounded-md text-xs font-medium\",\"children\":\"Hash Table\"}]]}],[\"$\",\"p\",null,{\"className\":\"text-lg text-gray-700 leading-relaxed\",\"children\":\" *  * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  *  * Implement the LRUCache class:  * - LRUCache(int capacity) Initialize the LRU cache with positive ...\"}]]}],[\"$\",\"div\",null,{\"className\":\"grid grid-cols-1 lg:grid-cols-3 gap-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"lg:col-span-2\",\"children\":[\"$\",\"div\",null,{\"className\":\"bg-white border border-gray-200 rounded-lg p-8\",\"children\":[\"$\",\"$L6\",null,{\"content\":\"$7\"}]}]}],[\"$\",\"div\",null,{\"className\":\"space-y-6\",\"children\":[[\"$\",\"div\",null,{\"className\":\"bg-white border border-gray-200 rounded-lg p-6\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-lg font-semibold text-gray-900 mb-4\",\"children\":\"Your Progress\"}],[\"$\",\"div\",null,{\"className\":\"w-full bg-gray-200 rounded-full h-2 mb-2\",\"children\":[\"$\",\"div\",null,{\"className\":\"bg-blue-600 h-2 rounded-full\",\"style\":{\"width\":\"25%\"}}]}],[\"$\",\"p\",null,{\"className\":\"text-sm text-gray-600\",\"children\":\"25% Complete\"}]]}],false]}]]}]]}],null],null],null]},[null,[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"learn\",\"children\",\"$9\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"learn\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/interview/_next/static/css/387024c6a2216908.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}],\"params\":{}}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"2\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>