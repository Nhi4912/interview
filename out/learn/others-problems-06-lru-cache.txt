2:I[2972,["918","static/chunks/918-3273b83890f10546.js","972","static/chunks/972-011bba60ed155615.js","930","static/chunks/930-3262a6c9c5acace4.js","289","static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js"],""]
3:I[5907,["918","static/chunks/918-3273b83890f10546.js","972","static/chunks/972-011bba60ed155615.js","930","static/chunks/930-3262a6c9c5acace4.js","289","static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js"],"default"]
5:I[4707,[],""]
7:I[6423,[],""]
8:I[2,["918","static/chunks/918-3273b83890f10546.js","710","static/chunks/710-dfaa11b4dff08f8e.js","972","static/chunks/972-011bba60ed155615.js","233","static/chunks/233-3e0c1d820a17eca9.js","185","static/chunks/app/layout-333f4adcd11f8f39.js"],"default",1]
4:T38d6,
# LRU Cache



## Problem Description

 *  * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  *  * Implement the LRUCache class:  * - LRUCache(int capacity) Initialize the LRU cache with positive size capacity. 

## Solutions

{% raw %}
/**
 * LRU Cache
 *
 * Problem: https://leetcode.com/problems/lru-cache/
 *
 * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
 *
 * Implement the LRUCache class:
 * - LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
 * - int get(int key) Return the value of the key if the key exists, otherwise return -1.
 * - void put(int key, int value) Update the value of the key if the key exists. Otherwise,
 *   add the key-value pair to the cache. If the number of keys exceeds the capacity from
 *   this operation, evict the least recently used key.
 *
 * The functions get and put must each run in O(1) average time complexity.
 *
 * Example 1:
 * Input:
 * ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
 * [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
 * Output: [null, null, null, 1, null, -1, null, -1, 3, 4]
 *
 * Explanation:
 * LRUCache lRUCache = new LRUCache(2);
 * lRUCache.put(1, 1); // cache is {1=1}
 * lRUCache.put(2, 2); // cache is {1=1, 2=2}
 * lRUCache.get(1);    // return 1
 * lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
 * lRUCache.get(2);    // returns -1 (not found)
 * lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
 * lRUCache.get(1);    // return -1 (not found)
 * lRUCache.get(3);    // return 3
 * lRUCache.get(4);    // return 4
 *
 * Constraints:
 * - 1 <= capacity <= 3000
 * - 0 <= key <= 10^4
 * - 0 <= value <= 10^5
 * - At most 2 * 10^5 calls will be made to get and put.
 *
 * Solution Approaches:
 * 1. HashMap + Doubly Linked List
 * 2. Using Map (built-in LRU behavior in some languages)
 * 3. Array-based implementation (for small capacity)
 * 4. With eviction statistics
 *
 * Time Complexity: O(1) for get and put operations
 * Space Complexity: O(capacity)
 */

/**
 * Doubly Linked List Node
 */
class ListNode {
  key: number;
  value: number;
  prev: ListNode | null;
  next: ListNode | null;

  constructor(key: number, value: number) {
    this.key = key;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
}

/**
 * LRU Cache - HashMap + Doubly Linked List Implementation
 *
 * LRU Cache - Triển khai HashMap + Doubly Linked List
 *
 * This approach uses a HashMap for O(1) lookups and a doubly linked list
 * to maintain the order of recently used items
 */
class LRUCache {
  private capacity: number;
  private cache: Map<number, ListNode>;
  private head: ListNode;
  private tail: ListNode;

  constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();

    // Initialize dummy head and tail nodes
    this.head = new ListNode(0, 0);
    this.tail = new ListNode(0, 0);
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }

  /**
   * Get value by key
   * Lấy giá trị theo khóa
   */
  get(key: number): number {
    const node = this.cache.get(key);

    if (!node) {
      return -1;
    }

    // Move to front (most recently used)
    this.moveToFront(node);

    return node.value;
  }

  /**
   * Put key-value pair
   * Đặt cặp khóa-giá trị
   */
  put(key: number, value: number): void {
    const existingNode = this.cache.get(key);

    if (existingNode) {
      // Update existing node
      existingNode.value = value;
      this.moveToFront(existingNode);
    } else {
      // Create new node
      const newNode = new ListNode(key, value);
      this.cache.set(key, newNode);
      this.addToFront(newNode);

      // Check capacity and evict if necessary
      if (this.cache.size > this.capacity) {
        this.evictLRU();
      }
    }
  }

  /**
   * Move node to front of list (most recently used)
   * Di chuyển node lên đầu danh sách (sử dụng gần đây nhất)
   */
  private moveToFront(node: ListNode): void {
    // Remove from current position
    this.removeNode(node);
    // Add to front
    this.addToFront(node);
  }

  /**
   * Add node to front of list
   * Thêm node vào đầu danh sách
   */
  private addToFront(node: ListNode): void {
    node.prev = this.head;
    node.next = this.head.next;
    this.head.next!.prev = node;
    this.head.next = node;
  }

  /**
   * Remove node from list
   * Xóa node khỏi danh sách
   */
  private removeNode(node: ListNode): void {
    node.prev!.next = node.next;
    node.next!.prev = node.prev;
  }

  /**
   * Evict least recently used item
   * Loại bỏ phần tử ít được sử dụng nhất
   */
  private evictLRU(): void {
    const lruNode = this.tail.prev!;
    this.removeNode(lruNode);
    this.cache.delete(lruNode.key);
  }

  /**
   * Get current size of cache
   * Lấy kích thước hiện tại của cache
   */
  size(): number {
    return this.cache.size;
  }

  /**
   * Check if cache is full
   * Kiểm tra xem cache có đầy không
   */
  isFull(): boolean {
    return this.cache.size >= this.capacity;
  }

  /**
   * Get all keys in order of usage (most recent first)
   * Lấy tất cả khóa theo thứ tự sử dụng (gần đây nhất trước)
   */
  getKeysInOrder(): number[] {
    const keys: number[] = [];
    let current = this.head.next;

    while (current && current !== this.tail) {
      keys.push(current.key);
      current = current.next;
    }

    return keys;
  }

  /**
   * Get cache statistics
   * Lấy thống kê cache
   */
  getStats(): { size: number; capacity: number; usage: number } {
    return {
      size: this.cache.size,
      capacity: this.capacity,
      usage: (this.cache.size / this.capacity) * 100,
    };
  }
}

/**
 * Alternative Implementation: Using Map (built-in LRU behavior)
 *
 * Triển khai thay thế: Sử dụng Map (hành vi LRU có sẵn)
 */
class LRUCacheMap {
  private capacity: number;
  private cache: Map<number, number>;

  constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key: number): number {
    if (!this.cache.has(key)) {
      return -1;
    }

    // Move to end (most recently used)
    const value = this.cache.get(key)!;
    this.cache.delete(key);
    this.cache.set(key, value);

    return value;
  }

  put(key: number, value: number): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // Remove least recently used (first key)
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    this.cache.set(key, value);
  }

  size(): number {
    return this.cache.size;
  }

  isFull(): boolean {
    return this.cache.size >= this.capacity;
  }
}

/**
 * Implementation with Eviction Statistics
 *
 * Triển khai với thống kê loại bỏ
 */
class LRUCacheWithStats extends LRUCache {
  private evictionCount: number;
  private hitCount: number;
  private missCount: number;
  private evictionHistory: Array<{ key: number; timestamp: number }>;

  constructor(capacity: number) {
    super(capacity);
    this.evictionCount = 0;
    this.hitCount = 0;
    this.missCount = 0;
    this.evictionHistory = [];
  }

  get(key: number): number {
    const result = super.get(key);

    if (result === -1) {
      this.missCount++;
    } else {
      this.hitCount++;
    }

    return result;
  }

  put(key: number, value: number): void {
    const wasFull = this.isFull();
    const hadKey = this.get(key) !== -1;

    super.put(key, value);

    // Track eviction if cache was full and we added a new key
    if (wasFull && !hadKey) {
      this.evictionCount++;
      this.evictionHistory.push({ key, timestamp: Date.now() });
    }
  }

  /**
   * Get cache performance statistics
   * Lấy thống kê hiệu suất cache
   */
  getPerformanceStats(): {
    hitCount: number;
    missCount: number;
    hitRate: number;
    evictionCount: number;
    evictionHistory: Array<{ key: number; timestamp: number }>;
  } {
    const totalRequests = this.hitCount + this.missCount;
    const hitRate =
      totalRequests > 0 ? (this.hitCount / totalRequests) * 100 : 0;

    return {
      hitCount: this.hitCount,
      missCount: this.missCount,
      hitRate,
      evictionCount: this.evictionCount,
      evictionHistory: [...this.evictionHistory],
    };
  }

  /**
   * Clear performance statistics
   * Xóa thống kê hiệu suất
   */
  clearStats(): void {
    this.evictionCount = 0;
    this.hitCount = 0;
    this.missCount = 0;
    this.evictionHistory = [];
  }
}

/**
 * Implementation with TTL (Time To Live)
 *
 * Triển khai với TTL (Thời gian sống)
 */
class LRUCacheWithTTL extends LRUCache {
  private ttl: number; // Time to live in milliseconds
  private timestamps: Map<number, number>;

  constructor(capacity: number, ttl: number = 60000) {
    // Default 1 minute
    super(capacity);
    this.ttl = ttl;
    this.timestamps = new Map();
  }

  get(key: number): number {
    const timestamp = this.timestamps.get(key);

    if (timestamp && Date.now() - timestamp > this.ttl) {
      // Key has expired, remove it
      this.timestamps.delete(key);
      return -1;
    }

    const result = super.get(key);

    if (result !== -1) {
      // Update timestamp
      this.timestamps.set(key, Date.now());
    }

    return result;
  }

  put(key: number, value: number): void {
    super.put(key, value);
    this.timestamps.set(key, Date.now());
  }

  /**
   * Clean up expired entries
   * Dọn dẹp các mục đã hết hạn
   */
  cleanup(): number {
    const now = Date.now();
    let cleanedCount = 0;

    for (const [key, timestamp] of this.timestamps.entries()) {
      if (now - timestamp > this.ttl) {
        this.timestamps.delete(key);
        cleanedCount++;
      }
    }

    return cleanedCount;
  }

  /**
   * Get TTL statistics
   * Lấy thống kê TTL
   */
  getTTLStats(): {
    ttl: number;
    activeEntries: number;
    expiredEntries: number;
  } {
    const now = Date.now();
    let expiredCount = 0;

    for (const timestamp of this.timestamps.values()) {
      if (now - timestamp > this.ttl) {
        expiredCount++;
      }
    }

    return {
      ttl: this.ttl,
      activeEntries: this.timestamps.size - expiredCount,
      expiredEntries: expiredCount,
    };
  }
}

/**
 * Performance Comparison Function
 *
 * Hàm so sánh hiệu suất các phương pháp
 */
function compareLRUImplementations(
  operations: Array<{ type: "get" | "put"; key: number; value?: number }>
): void {
  console.log(
    "LRU Cache Implementation Performance Comparison / So sánh hiệu suất triển khai LRU Cache"
  );
  console.log("=".repeat(80));

  const implementations = [
    { name: "Doubly Linked List", cache: new LRUCache(100) },
    { name: "Map-based", cache: new LRUCacheMap(100) },
  ];

  for (const impl of implementations) {
    console.log(`\nTesting ${impl.name}:`);

    const start = performance.now();

    for (const op of operations) {
      switch (op.type) {
        case "get":
          impl.cache.get(op.key);
          break;
        case "put":
          impl.cache.put(op.key, op.value!);
          break;
      }
    }

    const end = performance.now();
    console.log(`  Time: ${(end - start).toFixed(4)}ms`);
    console.log(`  Final size: ${impl.cache.size()}`);
  }
}

/**
 * Test Cases
 *
 * Các trường hợp kiểm thử
 */
function runTests(): void {
  console.log("LRU Cache Tests / Kiểm thử LRU Cache");
  console.log("=".repeat(50));

  // Test 1: Basic operations
  console.log("\nTest 1: Basic operations / Các thao tác cơ bản");
  const cache1 = new LRUCache(2);
  cache1.put(1, 1);
  cache1.put(2, 2);
  console.log(`get(1): ${cache1.get(1)}`); // Expected: 1
  cache1.put(3, 3);
  console.log(`get(2): ${cache1.get(2)}`); // Expected: -1
  cache1.put(4, 4);
  console.log(`get(1): ${cache1.get(1)}`); // Expected: -1
  console.log(`get(3): ${cache1.get(3)}`); // Expected: 3
  console.log(`get(4): ${cache1.get(4)}`); // Expected: 4

  // Test 2: Performance tracking
  console.log("\nTest 2: Performance tracking / Theo dõi hiệu suất");
  const perfCache = new LRUCacheWithStats(3);

  perfCache.put(1, 1);
  perfCache.put(2, 2);
  perfCache.put(3, 3);
  perfCache.get(1); // Hit
  perfCache.get(4); // Miss
  perfCache.put(4, 4); // Evicts 2
  perfCache.get(2); // Miss (evicted)

  const stats = perfCache.getPerformanceStats();
  console.log(`Hit count: ${stats.hitCount}`);
  console.log(`Miss count: ${stats.missCount}`);
  console.log(`Hit rate: ${stats.hitRate.toFixed(2)}%`);
  console.log(`Eviction count: ${stats.evictionCount}`);

  // Test 3: TTL cache
  console.log("\nTest 3: TTL cache / Cache với TTL");
  const ttlCache = new LRUCacheWithTTL(3, 1000); // 1 second TTL

  ttlCache.put(1, 1);
  ttlCache.put(2, 2);
  console.log(`get(1): ${ttlCache.get(1)}`); // Expected: 1

  // Wait for TTL to expire (simulate)
  setTimeout(() => {
    console.log(`get(1) after TTL: ${ttlCache.get(1)}`); // Expected: -1
    console.log(`TTL stats: ${JSON.stringify(ttlCache.getTTLStats())}`);
  }, 1100);

  // Test 4: Cache statistics
  console.log("\nTest 4: Cache statistics / Thống kê cache");
  const statCache = new LRUCache(5);

  for (let i = 1; i <= 7; i++) {
    statCache.put(i, i * 10);
  }

  console.log(`Size: ${statCache.size()}`);
  console.log(`Is full: ${statCache.isFull()}`);
  console.log(`Keys in order: [${statCache.getKeysInOrder().join(", ")}]`);
  console.log(`Stats: ${JSON.stringify(statCache.getStats())}`);

  // Test 5: Performance comparison
  console.log("\nTest 5: Performance comparison / So sánh hiệu suất");
  const testOperations = [
    { type: "put" as const, key: 1, value: 1 },
    { type: "put" as const, key: 2, value: 2 },
    { type: "get" as const, key: 1 },
    { type: "put" as const, key: 3, value: 3 },
    { type: "get" as const, key: 2 },
    { type: "put" as const, key: 4, value: 4 },
    { type: "get" as const, key: 1 },
    { type: "get" as const, key: 3 },
    { type: "get" as const, key: 4 },
  ];

  compareLRUImplementations(testOperations);
}

// Uncomment to run tests
// runTests();

export {
  LRUCache,
  LRUCacheMap,
  LRUCacheWithStats,
  LRUCacheWithTTL,
  ListNode,
  compareLRUImplementations,
  runTests,
};
{% endraw %}
6:["topic","others-problems-06-lru-cache","d"]
0:["RvGUJ9M6JplVqkHeE7DSv",[[["",{"children":["learn",{"children":[["topic","others-problems-06-lru-cache","d"],{"children":["__PAGE__?{\"topic\":\"others-problems-06-lru-cache\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["learn",{"children":[["topic","others-problems-06-lru-cache","d"],{"children":["__PAGE__",{},[["$L1",["$","div",null,{"className":"max-w-6xl mx-auto px-8 py-24","children":[["$","div",null,{"className":"flex items-center gap-4 mb-8","children":["$","$L2",null,{"href":"/learn","children":["$","button",null,{"className":"flex items-center gap-2 bg-gray-100 border border-gray-300 text-gray-700 px-4 py-3 rounded-md font-medium hover:bg-gray-200 transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left ","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"Back to Learn"]}]}]}],["$","div",null,{"className":"bg-white border border-gray-200 rounded-lg p-8 mb-8","children":[["$","div",null,{"className":"flex items-center justify-between mb-4","children":[["$","h1",null,{"className":"text-3xl font-bold text-gray-900","children":"LRU Cache"}],["$","div",null,{"className":"flex gap-4","children":[["$","button",null,{"className":"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-star ","children":[["$","polygon","8f66p6",{"points":"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"}],"$undefined"]}],"Bookmark"]}],["$","button",null,{"className":"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-share2 ","children":[["$","circle","gq8acd",{"cx":"18","cy":"5","r":"3"}],["$","circle","w7nqdw",{"cx":"6","cy":"12","r":"3"}],["$","circle","1xt0gg",{"cx":"18","cy":"19","r":"3"}],["$","line","47mynk",{"x1":"8.59","x2":"15.42","y1":"13.51","y2":"17.49"}],["$","line","1n3mei",{"x1":"15.41","x2":"8.59","y1":"6.51","y2":"10.49"}],"$undefined"]}],"Share"]}]]}]]}],["$","div",null,{"className":"flex gap-8 mb-4","children":[["$","div",null,{"className":"flex items-center gap-2 text-sm text-gray-600","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock ","children":[["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],["$","polyline","68esgv",{"points":"12 6 12 12 16 14"}],"$undefined"]}],"2-3 hours"]}],["$","span",null,{"className":"px-3 py-1 rounded-full text-xs font-semibold text-white bg-red-500","children":"Easy"}],["$","span",null,{"className":"px-3 py-1 rounded-full text-xs font-semibold bg-blue-100 text-blue-700","children":"Others"}]]}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-4","children":[["$","span","0",{"className":"bg-gray-100 text-gray-600 px-3 py-1 rounded-md text-xs font-medium","children":"Others"}],["$","span","1",{"className":"bg-gray-100 text-gray-600 px-3 py-1 rounded-md text-xs font-medium","children":"Hash Table"}]]}],["$","p",null,{"className":"text-lg text-gray-700 leading-relaxed","children":" *  * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  *  * Implement the LRUCache class:  * - LRUCache(int capacity) Initialize the LRU cache with positive ..."}]]}],["$","div",null,{"className":"grid grid-cols-1 lg:grid-cols-3 gap-8","children":[["$","div",null,{"className":"lg:col-span-2","children":["$","div",null,{"className":"bg-white border border-gray-200 rounded-lg p-8","children":["$","$L3",null,{"content":"$4"}]}]}],["$","div",null,{"className":"space-y-6","children":[["$","div",null,{"className":"bg-white border border-gray-200 rounded-lg p-6","children":[["$","h3",null,{"className":"text-lg font-semibold text-gray-900 mb-4","children":"Your Progress"}],["$","div",null,{"className":"w-full bg-gray-200 rounded-full h-2 mb-2","children":["$","div",null,{"className":"bg-blue-600 h-2 rounded-full","style":{"width":"25%"}}]}],["$","p",null,{"className":"text-sm text-gray-600","children":"25% Complete"}]]}],false]}]]}]]}],null],null],null]},[null,["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","learn","children","$6","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","learn","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/interview/_next/static/css/387024c6a2216908.css","precedence":"next","crossOrigin":"$undefined"}]],["$","$L8",null,{"children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}],"params":{}}]],null],null],["$L9",null]]]]
9:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","meta","2",{"name":"next-size-adjust"}]]
1:null
