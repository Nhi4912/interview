2:I[2972,["918","static/chunks/918-3273b83890f10546.js","972","static/chunks/972-011bba60ed155615.js","930","static/chunks/930-3262a6c9c5acace4.js","289","static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js"],""]
3:I[5907,["918","static/chunks/918-3273b83890f10546.js","972","static/chunks/972-011bba60ed155615.js","930","static/chunks/930-3262a6c9c5acace4.js","289","static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js"],"default"]
5:I[4707,[],""]
7:I[6423,[],""]
8:I[2,["918","static/chunks/918-3273b83890f10546.js","710","static/chunks/710-dfaa11b4dff08f8e.js","972","static/chunks/972-011bba60ed155615.js","233","static/chunks/233-3e0c1d820a17eca9.js","185","static/chunks/app/layout-333f4adcd11f8f39.js"],"default",1]
4:T60d6,# State Management for Frontend Interviews

**Quản lý trạng thái cho phỏng vấn Frontend**

## 1. Why State Management?

- **Local state:** useState, useReducer, component state.
- **Global state:** Shared across app (user, theme, cart).
- **Server state:** Data from API, cache, sync.

## 2. Tools & Libraries

- **Redux:** Predictable, single source, middleware (thunk, saga), devtools.
- **Context API:** Lightweight, for small/medium apps, avoid prop drilling.
- **MobX:** Observable, reactive, less boilerplate.
- **Zustand:** Minimal, hooks-based, scalable.
- **Recoil:** Atom/selectors, async, React integration.
- **Jotai, XState, Akita:** Other options.

## 3. Patterns

- **Lifting state up:** Move state to common ancestor.
- **Derived state:** Compute from other state, avoid duplication.
- **Selector functions:** Memoize, reselect.
- **Normalized state:** Store by ID, avoid deep nesting.

## 4. Best Practices

- **Keep state minimal:** Only what you need.
- **Avoid prop drilling:** Use context or global store.
- **Immutable updates:** Spread/rest, immer.
- **Testing:** Mock store, test reducers/selectors.
- **Performance:** Avoid unnecessary re-renders, use memoization.

## 5. Interview Questions

- When to use Redux vs Context?
- How to handle async state (API calls)?
- How to avoid prop drilling?
- How to test state logic?

## 6. Resources

- [Redux Docs](https://redux.js.org/)
- [MobX Docs](https://mobx.js.org/)
- [Zustand](https://docs.pmnd.rs/zustand/getting-started/introduction)
- [Recoil](https://recoiljs.org/)

# State Management Interview Preparation

## Core Concepts

### State Management Fundamentals

- **Local State**: Component-level state (useState, useReducer)
- **Global State**: Application-wide state shared across components
- **Server State**: Data fetched from APIs and cached
- **Form State**: User input and form validation state
- **UI State**: Loading, error, modal, navigation states

### State Management Patterns

- **Flux Architecture**: Unidirectional data flow
- **Redux Pattern**: Predictable state container
- **Context API**: React's built-in state sharing
- **Atomic State**: Small, focused state pieces
- **Event Sourcing**: State as sequence of events

## Advanced Topics

### Modern State Management

- **Redux Toolkit**: Simplified Redux with RTK Query
- **Zustand**: Lightweight state management
- **Jotai**: Atomic state management
- **Recoil**: Facebook's experimental state management
- **XState**: State machines and statecharts

### State Synchronization

- **Optimistic Updates**: Update UI before server confirmation
- **Pessimistic Updates**: Wait for server response
- **Real-time Sync**: WebSocket state synchronization
- **Offline Support**: Local state with sync when online
- **Conflict Resolution**: Handling concurrent updates

## Common Interview Questions & Answers

### State Management Questions

**Q: When would you use Redux vs Context API vs local state?**
A:

- **Local State**: Component-specific data, form inputs, UI toggles
- **Context API**: Theme, authentication, user preferences, simple global state
- **Redux**: Complex application state, multiple data sources, debugging needs

**Q: Explain the Redux flow and its three principles.**
A: Redux follows unidirectional data flow:

1. **Store**: Single source of truth
2. **Actions**: Plain objects describing what happened
3. **Reducers**: Pure functions that update state

**Three Principles**:

- Single source of truth
- State is read-only
- Changes made with pure functions

**Q: What are the benefits and drawbacks of Redux?**
A:
**Benefits**:

- Predictable state updates
- Great debugging with DevTools
- Middleware ecosystem
- Time-travel debugging

**Drawbacks**:

- Boilerplate code
- Learning curve
- Overkill for simple apps
- Performance overhead

### Advanced Questions

**Q: How would you implement optimistic updates in a state management system?**
A: Optimistic updates modify UI immediately, then sync with server:

```javascript
// Redux Toolkit example
const userSlice = createSlice({
  name: "user",
  initialState: { users: [], loading: false },
  reducers: {
    addUserOptimistic: (state, action) => {
      state.users.push({ ...action.payload, id: "temp-" + Date.now() });
    },
    addUserSuccess: (state, action) => {
      const index = state.users.findIndex((u) => u.id.startsWith("temp-"));
      if (index !== -1) {
        state.users[index] = action.payload;
      }
    },
    addUserFailure: (state, action) => {
      state.users = state.users.filter((u) => !u.id.startsWith("temp-"));
    },
  },
});

// Usage
const addUser = (userData) => async (dispatch) => {
  // Optimistic update
  dispatch(addUserOptimistic(userData));

  try {
    const response = await api.createUser(userData);
    dispatch(addUserSuccess(response.data));
  } catch (error) {
    dispatch(addUserFailure(error));
  }
};
```

**Q: How would you implement real-time state synchronization?**
A: Using WebSockets with state management:

```javascript
class RealTimeStateManager {
  constructor(store) {
    this.store = store;
    this.socket = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
  }

  connect(url) {
    this.socket = new WebSocket(url);

    this.socket.onopen = () => {
      console.log("WebSocket connected");
      this.reconnectAttempts = 0;
    };

    this.socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleMessage(data);
    };

    this.socket.onclose = () => {
      console.log("WebSocket disconnected");
      this.scheduleReconnect();
    };
  }

  handleMessage(data) {
    switch (data.type) {
      case "USER_UPDATED":
        this.store.dispatch(updateUser(data.payload));
        break;
      case "MESSAGE_RECEIVED":
        this.store.dispatch(addMessage(data.payload));
        break;
      case "STATUS_CHANGED":
        this.store.dispatch(updateUserStatus(data.payload));
        break;
    }
  }

  sendMessage(type, payload) {
    if (this.socket?.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify({ type, payload }));
    }
  }

  scheduleReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      const delay = Math.pow(2, this.reconnectAttempts) * 1000;

      setTimeout(() => {
        this.connect(this.socket.url);
      }, delay);
    }
  }
}

// Usage
const realTimeManager = new RealTimeStateManager(store);
realTimeManager.connect("wss://api.example.com/ws");
```

## Practical Problems & Solutions

### Problem 1: Implement a Custom State Management Library

**Challenge**: Create a lightweight state management library similar to Zustand.

```javascript
class SimpleStore {
  constructor(initialState = {}) {
    this.state = initialState;
    this.listeners = new Set();
    this.middleware = [];
  }

  getState() {
    return this.state;
  }

  setState(partial) {
    const prevState = { ...this.state };
    this.state = { ...this.state, ...partial };

    // Run middleware
    this.middleware.forEach((middleware) => {
      middleware(prevState, this.state);
    });

    // Notify listeners
    this.listeners.forEach((listener) => listener(this.state, prevState));
  }

  subscribe(listener) {
    this.listeners.add(listener);

    return () => {
      this.listeners.delete(listener);
    };
  }

  useMiddleware(middleware) {
    this.middleware.push(middleware);
  }

  // Action creators
  createAction(type, payload) {
    return { type, payload, timestamp: Date.now() };
  }

  dispatch(action) {
    // Log action for debugging
    console.log("Action:", action);

    // Update state based on action
    switch (action.type) {
      case "INCREMENT":
        this.setState({ count: this.state.count + 1 });
        break;
      case "SET_USER":
        this.setState({ user: action.payload });
        break;
      case "ADD_TODO":
        this.setState({
          todos: [...this.state.todos, action.payload],
        });
        break;
      default:
        console.warn("Unknown action type:", action.type);
    }
  }
}

// React hook for using the store
function useStore(store, selector) {
  const [state, setState] = React.useState(() => selector(store.getState()));

  React.useEffect(() => {
    const unsubscribe = store.subscribe((newState) => {
      const newSelectedState = selector(newState);
      setState(newSelectedState);
    });

    return unsubscribe;
  }, [store, selector]);

  return state;
}

// Usage
const store = new SimpleStore({
  count: 0,
  user: null,
  todos: [],
});

// Add logging middleware
store.useMiddleware((prevState, newState) => {
  console.log("State changed:", { prevState, newState });
});

// React component
function Counter() {
  const count = useStore(store, (state) => state.count);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => store.dispatch({ type: "INCREMENT" })}>
        Increment
      </button>
    </div>
  );
}
```

### Problem 2: Create a Form State Manager

**Challenge**: Build a comprehensive form state management system with validation and error handling.

```javascript
class FormStateManager {
  constructor(initialValues = {}, validationSchema = {}) {
    this.initialValues = initialValues;
    this.validationSchema = validationSchema;
    this.state = {
      values: { ...initialValues },
      errors: {},
      touched: {},
      isValid: true,
      isDirty: false,
      isSubmitting: false,
    };
    this.listeners = new Set();
  }

  getFieldValue(name) {
    return this.state.values[name];
  }

  setFieldValue(name, value) {
    const newValues = { ...this.state.values, [name]: value };
    const newErrors = this.validateField(name, value);
    const newTouched = { ...this.state.touched, [name]: true };

    this.setState({
      values: newValues,
      errors: { ...this.state.errors, [name]: newErrors[name] },
      touched: newTouched,
      isDirty: true,
      isValid: this.validateForm(newValues),
    });
  }

  setFieldError(name, error) {
    this.setState({
      errors: { ...this.state.errors, [name]: error },
      isValid: this.validateForm(this.state.values),
    });
  }

  validateField(name, value) {
    const fieldSchema = this.validationSchema[name];
    if (!fieldSchema) return {};

    const errors = {};

    // Required validation
    if (fieldSchema.required && (!value || value.trim() === "")) {
      errors[name] = fieldSchema.required;
    }

    // Pattern validation
    if (fieldSchema.pattern && value && !fieldSchema.pattern.test(value)) {
      errors[name] = fieldSchema.patternMessage || "Invalid format";
    }

    // Custom validation
    if (fieldSchema.validate) {
      const customError = fieldSchema.validate(value, this.state.values);
      if (customError) {
        errors[name] = customError;
      }
    }

    return errors;
  }

  validateForm(values) {
    const errors = {};

    Object.keys(this.validationSchema).forEach((fieldName) => {
      const fieldErrors = this.validateField(fieldName, values[fieldName]);
      Object.assign(errors, fieldErrors);
    });

    return Object.keys(errors).length === 0;
  }

  handleSubmit(onSubmit) {
    return async (event) => {
      event?.preventDefault();

      if (!this.state.isValid) {
        // Mark all fields as touched to show errors
        const touched = {};
        Object.keys(this.validationSchema).forEach((key) => {
          touched[key] = true;
        });

        this.setState({ touched });
        return;
      }

      this.setState({ isSubmitting: true });

      try {
        await onSubmit(this.state.values);
        this.setState({ isSubmitting: false });
      } catch (error) {
        this.setState({
          isSubmitting: false,
          errors: { submit: error.message },
        });
      }
    };
  }

  reset() {
    this.setState({
      values: { ...this.initialValues },
      errors: {},
      touched: {},
      isValid: true,
      isDirty: false,
      isSubmitting: false,
    });
  }

  setState(partial) {
    this.state = { ...this.state, ...partial };
    this.listeners.forEach((listener) => listener(this.state));
  }

  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
}

// React hook for form state
function useFormState(formManager) {
  const [state, setState] = React.useState(formManager.state);

  React.useEffect(() => {
    return formManager.subscribe(setState);
  }, [formManager]);

  return {
    ...state,
    setFieldValue: formManager.setFieldValue.bind(formManager),
    setFieldError: formManager.setFieldError.bind(formManager),
    handleSubmit: formManager.handleSubmit.bind(formManager),
    reset: formManager.reset.bind(formManager),
  };
}

// Usage
const validationSchema = {
  email: {
    required: "Email is required",
    pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
    patternMessage: "Invalid email format",
  },
  password: {
    required: "Password is required",
    validate: (value) => {
      if (value.length < 8) {
        return "Password must be at least 8 characters";
      }
      return null;
    },
  },
};

const formManager = new FormStateManager(
  { email: "", password: "" },
  validationSchema
);

function LoginForm() {
  const {
    values,
    errors,
    touched,
    isValid,
    isSubmitting,
    setFieldValue,
    handleSubmit,
  } = useFormState(formManager);

  const onSubmit = async (values) => {
    const response = await fetch("/api/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(values),
    });

    if (!response.ok) {
      throw new Error("Login failed");
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input
          type="email"
          value={values.email}
          onChange={(e) => setFieldValue("email", e.target.value)}
          placeholder="Email"
        />
        {touched.email && errors.email && (
          <span className="error">{errors.email}</span>
        )}
      </div>

      <div>
        <input
          type="password"
          value={values.password}
          onChange={(e) => setFieldValue("password", e.target.value)}
          placeholder="Password"
        />
        {touched.password && errors.password && (
          <span className="error">{errors.password}</span>
        )}
      </div>

      <button type="submit" disabled={!isValid || isSubmitting}>
        {isSubmitting ? "Logging in..." : "Login"}
      </button>
    </form>
  );
}
```

### Problem 3: Implement Redux with Middleware

**Challenge**: Create a Redux-like state management system with middleware support.

```javascript
// Action types
const ActionTypes = {
  INIT: "@@redux/INIT",
};

// Create store
function createStore(reducer, initialState, enhancer) {
  if (typeof enhancer === "function") {
    return enhancer(createStore)(reducer, initialState);
  }

  let state = initialState;
  let listeners = [];
  let isDispatching = false;

  function getState() {
    if (isDispatching) {
      throw new Error("Cannot call getState while dispatching");
    }
    return state;
  }

  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error("Listener must be a function");
    }

    let isSubscribed = true;
    listeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) return;

      isSubscribed = false;
      const index = listeners.indexOf(listener);
      listeners.splice(index, 1);
    };
  }

  function dispatch(action) {
    if (!action || typeof action.type === "undefined") {
      throw new Error("Actions must have a type property");
    }

    if (isDispatching) {
      throw new Error("Reducers may not dispatch actions");
    }

    try {
      isDispatching = true;
      state = reducer(state, action);
    } finally {
      isDispatching = false;
    }

    listeners.forEach((listener) => listener());
    return action;
  }

  // Initialize store
  dispatch({ type: ActionTypes.INIT });

  return {
    getState,
    subscribe,
    dispatch,
  };
}

// Apply middleware
function applyMiddleware(...middlewares) {
  return (createStore) => (reducer, initialState) => {
    const store = createStore(reducer, initialState);
    let dispatch = store.dispatch;

    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action) => dispatch(action),
    };

    const chain = middlewares.map((middleware) => middleware(middlewareAPI));
    dispatch = compose(...chain)(store.dispatch);

    return {
      ...store,
      dispatch,
    };
  };
}

// Compose functions
function compose(...funcs) {
  if (funcs.length === 0) {
    return (arg) => arg;
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(
    (a, b) =>
      (...args) =>
        a(b(...args))
  );
}

// Logger middleware
function logger(middlewareAPI) {
  return (next) => (action) => {
    console.group(action.type);
    console.log("Previous State:", middlewareAPI.getState());
    console.log("Action:", action);

    const result = next(action);

    console.log("Next State:", middlewareAPI.getState());
    console.groupEnd();

    return result;
  };
}

// Thunk middleware
function thunk(middlewareAPI) {
  return (next) => (action) => {
    if (typeof action === "function") {
      return action(middlewareAPI.dispatch, middlewareAPI.getState);
    }
    return next(action);
  };
}

// Example reducer
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case "INCREMENT":
      return { ...state, count: state.count + 1 };
    case "DECREMENT":
      return { ...state, count: state.count - 1 };
    case "SET_COUNT":
      return { ...state, count: action.payload };
    default:
      return state;
  }
}

// Action creators
const increment = () => ({ type: "INCREMENT" });
const decrement = () => ({ type: "DECREMENT" });
const setCount = (count) => ({ type: "SET_COUNT", payload: count });

// Async action creator
const incrementAsync = () => (dispatch, getState) => {
  setTimeout(() => {
    dispatch(increment());
  }, 1000);
};

// Create store with middleware
const store = createStore(
  counterReducer,
  { count: 0 },
  applyMiddleware(logger, thunk)
);

// Usage
store.subscribe(() => {
  console.log("State:", store.getState());
});

store.dispatch(increment()); // 1
store.dispatch(incrementAsync()); // 2 (after 1 second)
store.dispatch(setCount(10)); // 10
```

### Problem 4: Create a State Persistence System

**Challenge**: Implement a system to persist and rehydrate state across browser sessions.

```javascript
class StatePersistence {
  constructor(storage = localStorage, key = "app-state") {
    this.storage = storage;
    this.key = key;
    this.subscribers = new Set();
  }

  save(state, options = {}) {
    const {
      includeKeys = null,
      excludeKeys = null,
      transform = null,
    } = options;

    let stateToSave = state;

    // Filter keys
    if (includeKeys) {
      stateToSave = Object.keys(state)
        .filter((key) => includeKeys.includes(key))
        .reduce((obj, key) => {
          obj[key] = state[key];
          return obj;
        }, {});
    }

    if (excludeKeys) {
      stateToSave = Object.keys(state)
        .filter((key) => !excludeKeys.includes(key))
        .reduce((obj, key) => {
          obj[key] = state[key];
          return obj;
        }, {});
    }

    // Transform state
    if (transform) {
      stateToSave = transform(stateToSave);
    }

    try {
      const serialized = JSON.stringify(stateToSave);
      this.storage.setItem(this.key, serialized);
      this.notifySubscribers("saved", stateToSave);
    } catch (error) {
      console.error("Failed to save state:", error);
      this.notifySubscribers("error", error);
    }
  }

  load(options = {}) {
    const { transform = null, defaultValue = {} } = options;

    try {
      const serialized = this.storage.getItem(this.key);
      if (!serialized) {
        return defaultValue;
      }

      let state = JSON.parse(serialized);

      // Transform state
      if (transform) {
        state = transform(state);
      }

      this.notifySubscribers("loaded", state);
      return state;
    } catch (error) {
      console.error("Failed to load state:", error);
      this.notifySubscribers("error", error);
      return defaultValue;
    }
  }

  clear() {
    try {
      this.storage.removeItem(this.key);
      this.notifySubscribers("cleared");
    } catch (error) {
      console.error("Failed to clear state:", error);
      this.notifySubscribers("error", error);
    }
  }

  subscribe(callback) {
    this.subscribers.add(callback);
    return () => this.subscribers.delete(callback);
  }

  notifySubscribers(event, data) {
    this.subscribers.forEach((callback) => {
      try {
        callback(event, data);
      } catch (error) {
        console.error("Subscriber error:", error);
      }
    });
  }
}

// Enhanced store with persistence
function createPersistentStore(reducer, initialState, options = {}) {
  const {
    storage = localStorage,
    key = "app-state",
    includeKeys = null,
    excludeKeys = null,
    transform = null,
  } = options;

  const persistence = new StatePersistence(storage, key);

  // Load initial state from storage
  const savedState = persistence.load({
    transform,
    defaultValue: initialState,
  });
  const store = createStore(reducer, savedState);

  // Subscribe to state changes and save
  store.subscribe(() => {
    const currentState = store.getState();
    persistence.save(currentState, { includeKeys, excludeKeys, transform });
  });

  // Add persistence methods to store
  store.persist = {
    clear: () => persistence.clear(),
    on: (event, callback) => persistence.subscribe(callback),
  };

  return store;
}

// Usage
const counterReducer = (state = { count: 0, lastUpdated: null }, action) => {
  switch (action.type) {
    case "INCREMENT":
      return {
        ...state,
        count: state.count + 1,
        lastUpdated: new Date().toISOString(),
      };
    case "DECREMENT":
      return {
        ...state,
        count: state.count - 1,
        lastUpdated: new Date().toISOString(),
      };
    default:
      return state;
  }
};

// Create persistent store
const store = createPersistentStore(
  counterReducer,
  { count: 0, lastUpdated: null },
  {
    key: "counter-state",
    includeKeys: ["count"], // Only persist count
    transform: (state) => ({
      ...state,
      version: "1.0", // Add version for migration
    }),
  }
);

// Listen to persistence events
store.persist.on("saved", (state) => {
  console.log("State saved:", state);
});

store.persist.on("loaded", (state) => {
  console.log("State loaded:", state);
});

store.persist.on("error", (error) => {
  console.error("Persistence error:", error);
});

// Use the store
store.dispatch({ type: "INCREMENT" });
// State will be automatically saved to localStorage

// Clear persisted state
// store.persist.clear();
```

## Best Practices

### State Structure

- Normalize complex data structures
- Keep state flat and avoid nesting
- Separate UI state from business logic
- Use selectors for derived state
- Implement proper error boundaries

### Performance Optimization

- Use React.memo for expensive components
- Implement proper memoization with useMemo/useCallback
- Avoid unnecessary re-renders
- Use React DevTools Profiler
- Implement code splitting for large state

### Testing

- Test reducers as pure functions
- Mock external dependencies
- Test async actions with proper setup/teardown
- Use snapshot testing for UI components
- Implement integration tests for state flows

## Resources

### Documentation

- [Redux Documentation](https://redux.js.org/)
- [Redux Toolkit](https://redux-toolkit.js.org/)
- [React Context API](https://reactjs.org/docs/context.html)
- [Zustand](https://github.com/pmndrs/zustand)

### Tools

- [Redux DevTools](https://github.com/reduxjs/redux-devtools)
- [React DevTools](https://reactjs.org/blog/2019/08/15/new-react-devtools.html)
- [Immer](https://immerjs.github.io/immer/) - Immutable updates
- [Reselect](https://github.com/reduxjs/reselect) - Memoized selectors

### Practice Platforms

- [Redux Toolkit Examples](https://redux-toolkit.js.org/introduction/quick-start)
- [React State Management Patterns](https://kentcdodds.com/blog/application-state-management-with-react)
- [State Management Best Practices](https://redux.js.org/style-guide/)

---

_This guide covers essential state management concepts for frontend interviews, including practical problems and advanced techniques commonly asked at Big Tech companies._
6:["topic","system-design-state-management","d"]
0:["RvGUJ9M6JplVqkHeE7DSv",[[["",{"children":["learn",{"children":[["topic","system-design-state-management","d"],{"children":["__PAGE__?{\"topic\":\"system-design-state-management\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["learn",{"children":[["topic","system-design-state-management","d"],{"children":["__PAGE__",{},[["$L1",["$","div",null,{"className":"max-w-6xl mx-auto px-8 py-24","children":[["$","div",null,{"className":"flex items-center gap-4 mb-8","children":["$","$L2",null,{"href":"/learn","children":["$","button",null,{"className":"flex items-center gap-2 bg-gray-100 border border-gray-300 text-gray-700 px-4 py-3 rounded-md font-medium hover:bg-gray-200 transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left ","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"Back to Learn"]}]}]}],["$","div",null,{"className":"bg-white border border-gray-200 rounded-lg p-8 mb-8","children":[["$","div",null,{"className":"flex items-center justify-between mb-4","children":[["$","h1",null,{"className":"text-3xl font-bold text-gray-900","children":"State Management for Frontend Interviews"}],["$","div",null,{"className":"flex gap-4","children":[["$","button",null,{"className":"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-star ","children":[["$","polygon","8f66p6",{"points":"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"}],"$undefined"]}],"Bookmark"]}],["$","button",null,{"className":"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-share2 ","children":[["$","circle","gq8acd",{"cx":"18","cy":"5","r":"3"}],["$","circle","w7nqdw",{"cx":"6","cy":"12","r":"3"}],["$","circle","1xt0gg",{"cx":"18","cy":"19","r":"3"}],["$","line","47mynk",{"x1":"8.59","x2":"15.42","y1":"13.51","y2":"17.49"}],["$","line","1n3mei",{"x1":"15.41","x2":"8.59","y1":"6.51","y2":"10.49"}],"$undefined"]}],"Share"]}]]}]]}],["$","div",null,{"className":"flex gap-8 mb-4","children":[["$","div",null,{"className":"flex items-center gap-2 text-sm text-gray-600","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock ","children":[["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],["$","polyline","68esgv",{"points":"12 6 12 12 16 14"}],"$undefined"]}],"2-3 hours"]}],["$","span",null,{"className":"px-3 py-1 rounded-full text-xs font-semibold text-white bg-yellow-500","children":"Intermediate"}],["$","span",null,{"className":"px-3 py-1 rounded-full text-xs font-semibold bg-blue-100 text-blue-700","children":"General"}]]}],false,["$","p",null,{"className":"text-lg text-gray-700 leading-relaxed","children":"**Quản lý trạng thái cho phỏng vấn Frontend**..."}]]}],["$","div",null,{"className":"grid grid-cols-1 lg:grid-cols-3 gap-8","children":[["$","div",null,{"className":"lg:col-span-2","children":["$","div",null,{"className":"bg-white border border-gray-200 rounded-lg p-8","children":["$","$L3",null,{"content":"$4"}]}]}],["$","div",null,{"className":"space-y-6","children":[["$","div",null,{"className":"bg-white border border-gray-200 rounded-lg p-6","children":[["$","h3",null,{"className":"text-lg font-semibold text-gray-900 mb-4","children":"Your Progress"}],["$","div",null,{"className":"w-full bg-gray-200 rounded-full h-2 mb-2","children":["$","div",null,{"className":"bg-blue-600 h-2 rounded-full","style":{"width":"25%"}}]}],["$","p",null,{"className":"text-sm text-gray-600","children":"25% Complete"}]]}],false]}]]}]]}],null],null],null]},[null,["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","learn","children","$6","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","learn","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/interview/_next/static/css/387024c6a2216908.css","precedence":"next","crossOrigin":"$undefined"}]],["$","$L8",null,{"children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}],"params":{}}]],null],null],["$L9",null]]]]
9:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","meta","2",{"name":"next-size-adjust"}]]
1:null
