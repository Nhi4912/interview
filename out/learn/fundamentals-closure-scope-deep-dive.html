<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/interview/_next/static/css/387024c6a2216908.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js"/><script src="/interview/_next/static/chunks/fd9d1056-6922f449a204c2cc.js" async=""></script><script src="/interview/_next/static/chunks/117-e7ecc085ce9cfab3.js" async=""></script><script src="/interview/_next/static/chunks/main-app-b06be5f3411c20c3.js" async=""></script><script src="/interview/_next/static/chunks/918-3273b83890f10546.js" async=""></script><script src="/interview/_next/static/chunks/972-011bba60ed155615.js" async=""></script><script src="/interview/_next/static/chunks/930-3262a6c9c5acace4.js" async=""></script><script src="/interview/_next/static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js" async=""></script><script src="/interview/_next/static/chunks/710-dfaa11b4dff08f8e.js" async=""></script><script src="/interview/_next/static/chunks/233-3e0c1d820a17eca9.js" async=""></script><script src="/interview/_next/static/chunks/app/layout-333f4adcd11f8f39.js" async=""></script><title>Frontend Interview Prep 2025 - Big Tech Interview Guide</title><meta name="description" content="Comprehensive frontend interview preparation for Big Tech companies including React, TypeScript, algorithms, and system design."/><link rel="icon" href="/favicon.ico"/><meta name="theme-color" content="#1a1a1a"/><meta property="og:title" content="Frontend Interview Prep 2025"/><meta property="og:description" content="Complete guide for frontend engineers targeting Big Tech companies"/><meta property="og:type" content="website"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><meta name="next-size-adjust"/><script src="/interview/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script><style data-styled="" data-styled-version="6.1.19">*{margin:0;padding:0;box-sizing:border-box;}/*!sc*/
html{font-size:16px;line-height:1.5;scroll-behavior:smooth;}/*!sc*/
body{font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;font-size:1rem;line-height:1.5;color:#1e293b;background-color:#ffffff;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
h1,h2,h3,h4,h5,h6{font-weight:700;line-height:1.25;margin-bottom:0.5em;}/*!sc*/
h1{font-size:3rem;}/*!sc*/
@media (max-width: 768px){h1{font-size:2.25rem;}}/*!sc*/
h2{font-size:2.25rem;}/*!sc*/
@media (max-width: 768px){h2{font-size:1.875rem;}}/*!sc*/
h3{font-size:1.875rem;}/*!sc*/
@media (max-width: 768px){h3{font-size:1.5rem;}}/*!sc*/
h4{font-size:1.5rem;}/*!sc*/
@media (max-width: 768px){h4{font-size:1.25rem;}}/*!sc*/
h5{font-size:1.25rem;}/*!sc*/
h6{font-size:1.125rem;}/*!sc*/
p{margin-bottom:1rem;line-height:1.75;}/*!sc*/
a{color:#3b82f6;text-decoration:none;transition:color 0.15s ease;}/*!sc*/
a:hover{color:#2563eb;}/*!sc*/
a:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
button{cursor:pointer;border:none;background:none;font-family:inherit;font-size:inherit;}/*!sc*/
button:disabled{cursor:not-allowed;opacity:0.6;}/*!sc*/
button:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
input,textarea,select{font-family:inherit;font-size:inherit;}/*!sc*/
input:focus,textarea:focus,select:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
img{max-width:100%;height:auto;}/*!sc*/
ul,ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
li{margin-bottom:0.25rem;}/*!sc*/
blockquote{margin:1rem 0;padding:1rem;border-left:4px solid #3b82f6;background-color:#f1f5f9;font-style:italic;}/*!sc*/
code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;background-color:#f1f5f9;padding:0.2em 0.4em;border-radius:0.25rem;}/*!sc*/
pre{background-color:#f1f5f9;padding:1rem;border-radius:0.5rem;overflow-x:auto;margin-bottom:1rem;}/*!sc*/
pre code{background:none;padding:0;}/*!sc*/
table{width:100%;border-collapse:collapse;margin-bottom:1rem;}/*!sc*/
th,td{padding:0.75rem;text-align:left;border-bottom:1px solid #e2e8f0;}/*!sc*/
th{font-weight:600;background-color:#f1f5f9;}/*!sc*/
.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0;}/*!sc*/
.skip-link{position:absolute;top:-40px;left:6px;background:#3b82f6;color:white;padding:8px;text-decoration:none;border-radius:4px;z-index:100;}/*!sc*/
.skip-link:focus{top:6px;}/*!sc*/
::-webkit-scrollbar{width:8px;height:8px;}/*!sc*/
::-webkit-scrollbar-track{background:#f1f5f9;}/*!sc*/
::-webkit-scrollbar-thumb{background:#94a3b8;border-radius:4px;}/*!sc*/
::-webkit-scrollbar-thumb:hover{background:#64748b;}/*!sc*/
::selection{background:#3b82f6;color:white;}/*!sc*/
.focus-visible{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
.fade-in{opacity:0;animation:fadeIn 0.3s ease forwards;}/*!sc*/
.slide-up{transform:translateY(20px);opacity:0;animation:slideUp 0.3s ease forwards;}/*!sc*/
@keyframes fadeIn{to{opacity:1;}}/*!sc*/
@keyframes slideUp{to{transform:translateY(0);opacity:1;}}/*!sc*/
@media print{*{background:white!important;color:black!important;box-shadow:none!important;text-shadow:none!important;}a,a:visited{text-decoration:underline;}h1,h2,h3,h4,h5,h6{break-after:avoid;}pre,blockquote{border:1px solid #999;break-inside:avoid;}img{max-width:100%!important;}@page{margin:0.5in;}}/*!sc*/
data-styled.g19[id="sc-global-kxA-Ddz1"]{content:"sc-global-kxA-Ddz1,"}/*!sc*/
.hNPaTO{position:fixed;top:0;width:100%;z-index:1020;background:transparent;backdrop-filter:blur(10px);border-bottom:1px solid transparent;transition:all 0.3s ease;}/*!sc*/
data-styled.g20[id="sc-dNdcvo"]{content:"hNPaTO,"}/*!sc*/
.jJxjWc{max-width:1200px;margin:0 auto;padding:0 2rem;display:flex;align-items:center;justify-content:space-between;height:70px;}/*!sc*/
data-styled.g21[id="sc-fbQrwq"]{content:"jJxjWc,"}/*!sc*/
.jwmRwa{display:flex;align-items:center;gap:0.5rem;font-size:1.5rem;font-weight:700;color:#3b82f6;text-decoration:none;cursor:pointer;}/*!sc*/
.jwmRwa:hover{color:#2563eb;}/*!sc*/
data-styled.g22[id="sc-gGKoUb"]{content:"jwmRwa,"}/*!sc*/
.KQdZw{display:flex;align-items:center;gap:2rem;}/*!sc*/
@media (max-width: 768px){.KQdZw{display:none;}}/*!sc*/
data-styled.g23[id="sc-hwddKA"]{content:"KQdZw,"}/*!sc*/
.ETszJ{color:#1e293b;font-weight:500;text-decoration:none;transition:color 0.15s ease;position:relative;}/*!sc*/
.ETszJ:hover{color:#3b82f6;}/*!sc*/
.ETszJ:after{content:'';position:absolute;bottom:-5px;left:0;width:0;height:2px;background:#3b82f6;transition:width 0.15s ease;}/*!sc*/
.ETszJ:hover:after{width:100%;}/*!sc*/
data-styled.g24[id="sc-jaXbil"]{content:"ETszJ,"}/*!sc*/
.foClcg{display:none;background:none;border:none;color:#1e293b;cursor:pointer;padding:0.5rem;}/*!sc*/
@media (max-width: 768px){.foClcg{display:block;}}/*!sc*/
data-styled.g25[id="sc-eqNDNG"]{content:"foClcg,"}/*!sc*/
.kBjfBo{display:flex;align-items:center;gap:0.5rem;background:#f1f5f9;border:1px solid #e2e8f0;border-radius:0.5rem;padding:0.5rem 1rem;color:#64748b;font-size:0.9rem;transition:all 0.15s ease;}/*!sc*/
.kBjfBo:hover{background:#ffffff;border-color:#3b82f6;}/*!sc*/
data-styled.g29[id="sc-eQwNpu"]{content:"kBjfBo,"}/*!sc*/
.booJNS{background:#1e293b;color:white;padding:3rem 0 1rem;margin-top:auto;}/*!sc*/
data-styled.g30[id="sc-gvqKNf"]{content:"booJNS,"}/*!sc*/
.fVoYcP{max-width:1200px;margin:0 auto;padding:0 2rem;}/*!sc*/
data-styled.g31[id="sc-cOpnSz"]{content:"fVoYcP,"}/*!sc*/
.kKfrkv{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:2rem;margin-bottom:2rem;}/*!sc*/
@media (max-width: 768px){.kKfrkv{grid-template-columns:1fr 1fr;gap:1.5rem;}}/*!sc*/
@media (max-width: 480px){.kKfrkv{grid-template-columns:1fr;}}/*!sc*/
data-styled.g32[id="sc-kjwdDK"]{content:"kKfrkv,"}/*!sc*/
.inEXDm h3{font-size:1.1rem;font-weight:600;margin-bottom:1rem;color:white;}/*!sc*/
.inEXDm ul{list-style:none;padding:0;margin:0;}/*!sc*/
.inEXDm li{margin-bottom:0.5rem;}/*!sc*/
.inEXDm a{color:rgba(255, 255, 255, 0.7);text-decoration:none;transition:color 0.15s ease;}/*!sc*/
.inEXDm a:hover{color:white;}/*!sc*/
data-styled.g33[id="sc-eVqvcJ"]{content:"inEXDm,"}/*!sc*/
.hWhopJ{display:flex;align-items:center;gap:0.5rem;font-size:1.2rem;font-weight:700;margin-bottom:1rem;color:white;}/*!sc*/
data-styled.g34[id="sc-bbbBoY"]{content:"hWhopJ,"}/*!sc*/
.exeTne{color:rgba(255, 255, 255, 0.7);line-height:1.6;margin-bottom:1rem;}/*!sc*/
data-styled.g35[id="sc-cdmAjP"]{content:"exeTne,"}/*!sc*/
.cgXMuV{display:flex;gap:1rem;}/*!sc*/
.cgXMuV a{display:flex;align-items:center;justify-content:center;width:40px;height:40px;background:rgba(255, 255, 255, 0.1);border-radius:0.5rem;color:rgba(255, 255, 255, 0.7);transition:all 0.15s ease;}/*!sc*/
.cgXMuV a:hover{background:rgba(255, 255, 255, 0.2);color:white;}/*!sc*/
data-styled.g36[id="sc-jytpVa"]{content:"cgXMuV,"}/*!sc*/
.iQqwrD{border-top:1px solid rgba(255, 255, 255, 0.1);padding-top:2rem;display:flex;justify-content:space-between;align-items:center;}/*!sc*/
@media (max-width: 768px){.iQqwrD{flex-direction:column;gap:1rem;text-align:center;}}/*!sc*/
data-styled.g37[id="sc-eknHtZ"]{content:"iQqwrD,"}/*!sc*/
.gObJRG{color:rgba(255, 255, 255, 0.7);margin:0;font-size:0.9rem;}/*!sc*/
data-styled.g38[id="sc-pYNGo"]{content:"gObJRG,"}/*!sc*/
.eBqBtc{display:flex;gap:2rem;}/*!sc*/
@media (max-width: 480px){.eBqBtc{flex-direction:column;gap:1rem;}}/*!sc*/
.eBqBtc a{color:rgba(255, 255, 255, 0.7);text-decoration:none;font-size:0.9rem;transition:color 0.15s ease;}/*!sc*/
.eBqBtc a:hover{color:white;}/*!sc*/
data-styled.g39[id="sc-cCVJLD"]{content:"eBqBtc,"}/*!sc*/
.kmsQDA{color:#1e293b;line-height:1.6;}/*!sc*/
.kmsQDA h1,.kmsQDA h2,.kmsQDA h3,.kmsQDA h4,.kmsQDA h5,.kmsQDA h6{color:#1e293b;margin-top:2rem;margin-bottom:1rem;font-weight:600;}/*!sc*/
.kmsQDA h1{font-size:2rem;border-bottom:2px solid #e2e8f0;padding-bottom:0.5rem;}/*!sc*/
.kmsQDA h2{font-size:1.5rem;border-bottom:1px solid #e2e8f0;padding-bottom:0.3rem;}/*!sc*/
.kmsQDA h3{font-size:1.25rem;}/*!sc*/
.kmsQDA h4{font-size:1.1rem;}/*!sc*/
.kmsQDA p{margin-bottom:1rem;color:#64748b;}/*!sc*/
.kmsQDA a{color:#3b82f6;text-decoration:none;}/*!sc*/
.kmsQDA a:hover{text-decoration:underline;}/*!sc*/
.kmsQDA ul,.kmsQDA ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
.kmsQDA ul li,.kmsQDA ol li{margin-bottom:0.5rem;color:#64748b;}/*!sc*/
.kmsQDA blockquote{border-left:4px solid #3b82f6;padding-left:1rem;margin:1rem 0;font-style:italic;color:#64748b;background:#f1f5f9;padding:1rem;border-radius:0.5rem;}/*!sc*/
.kmsQDA code{background:#f1f5f9;padding:0.2rem 0.4rem;border-radius:0.25rem;font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;color:#f59e0b;}/*!sc*/
.kmsQDA pre{background:#ffffff;border:1px solid #e2e8f0;border-radius:0.5rem;padding:1rem;margin:1rem 0;overflow-x:auto;}/*!sc*/
.kmsQDA pre code{background:none;padding:0;color:#1e293b;font-size:0.9rem;}/*!sc*/
.kmsQDA table{width:100%;border-collapse:collapse;margin:1rem 0;}/*!sc*/
.kmsQDA table th,.kmsQDA table td{border:1px solid #e2e8f0;padding:0.5rem;text-align:left;}/*!sc*/
.kmsQDA table th{background:#ffffff;font-weight:600;}/*!sc*/
.kmsQDA table tr:nth-child(even){background:#f1f5f9;}/*!sc*/
.kmsQDA hr{border:none;height:1px;background:#e2e8f0;margin:2rem 0;}/*!sc*/
.kmsQDA .highlight{background:#3b82f620;padding:0.2rem 0.4rem;border-radius:0.25rem;font-weight:600;}/*!sc*/
.kmsQDA .hljs{background:#ffffff;color:#1e293b;}/*!sc*/
.kmsQDA .hljs-keyword{color:#3b82f6;font-weight:600;}/*!sc*/
.kmsQDA .hljs-string{color:#10b981;}/*!sc*/
.kmsQDA .hljs-function{color:#f59e0b;}/*!sc*/
.kmsQDA .hljs-comment{color:#94a3b8;font-style:italic;}/*!sc*/
.kmsQDA .hljs-number{color:#f59e0b;}/*!sc*/
.kmsQDA .hljs-variable{color:#1e293b;}/*!sc*/
.kmsQDA .hljs-title{color:#f59e0b;font-weight:600;}/*!sc*/
data-styled.g40[id="sc-jYczwO"]{content:"kmsQDA,"}/*!sc*/
</style></head><body class="__className_6eac61"><div style="min-height:100vh;display:flex;flex-direction:column"><nav class="sc-dNdcvo hNPaTO"><div class="sc-fbQrwq jJxjWc"><a href="/interview"><a class="sc-gGKoUb jwmRwa"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</a></a><div class="sc-hwddKA KQdZw"><a href="/interview/problems"><a class="sc-jaXbil ETszJ">Problems</a></a><a href="/interview/learn"><a class="sc-jaXbil ETszJ">Learn</a></a><a href="/interview/study-guide"><a class="sc-jaXbil ETszJ">Study Guide</a></a><a href="/interview/system-design"><a class="sc-jaXbil ETszJ">System Design</a></a><a href="/interview/performance"><a class="sc-jaXbil ETszJ">Performance</a></a><a href="/interview/accessibility"><a class="sc-jaXbil ETszJ">Accessibility</a></a><a href="/interview/interview-tips"><a class="sc-jaXbil ETszJ">Interview Tips</a></a><button class="sc-eQwNpu kBjfBo"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search "><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg>Search</button></div><button class="sc-eqNDNG foClcg"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu "><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button></div></nav><main style="flex:1"><div class="max-w-6xl mx-auto px-8 py-24"><div class="flex items-center gap-4 mb-8"><a href="/interview/learn"><button class="flex items-center gap-2 bg-gray-100 border border-gray-300 text-gray-700 px-4 py-3 rounded-md font-medium hover:bg-gray-200 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left "><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg>Back to Learn</button></a></div><div class="bg-white border border-gray-200 rounded-lg p-8 mb-8"><div class="flex items-center justify-between mb-4"><h1 class="text-3xl font-bold text-gray-900">JavaScript Closures &amp; Scope: Complete Deep Dive</h1><div class="flex gap-4"><button class="flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-star "><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>Bookmark</button><button class="flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share2 "><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" x2="15.42" y1="13.51" y2="17.49"></line><line x1="15.41" x2="8.59" y1="6.51" y2="10.49"></line></svg>Share</button></div></div><div class="flex gap-8 mb-4"><div class="flex items-center gap-2 text-sm text-gray-600"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock "><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>2-3 hours</div><span class="px-3 py-1 rounded-full text-xs font-semibold text-white bg-yellow-500">Intermediate</span><span class="px-3 py-1 rounded-full text-xs font-semibold bg-blue-100 text-blue-700">General</span></div><p class="text-lg text-gray-700 leading-relaxed">**Scope** determines the accessibility of variables, functions, and objects in different parts of your code. It defines the **context** in which variables exist and can be accessed....</p></div><div class="grid grid-cols-1 lg:grid-cols-3 gap-8"><div class="lg:col-span-2"><div class="bg-white border border-gray-200 rounded-lg p-8"><div class="sc-jYczwO kmsQDA"><h1 id="javascript-closures-&amp;-scope:-complete-deep-dive" node="[object Object]">JavaScript Closures &amp; Scope: Complete Deep Dive</h1>
<h2 id="table-of-contents" node="[object Object]">Table of Contents</h2>
<ul>
<li><a href="#understanding-scope" node="[object Object]">Understanding Scope</a></li>
<li><a href="#lexical-scoping" node="[object Object]">Lexical Scoping</a></li>
<li><a href="#what-are-closures" node="[object Object]">What are Closures?</a></li>
<li><a href="#how-closures-work" node="[object Object]">How Closures Work</a></li>
<li><a href="#closure-use-cases" node="[object Object]">Closure Use Cases</a></li>
<li><a href="#memory-management" node="[object Object]">Memory Management</a></li>
<li><a href="#visual-diagrams" node="[object Object]">Visual Diagrams</a></li>
<li><a href="#common-patterns" node="[object Object]">Common Patterns</a></li>
<li><a href="#performance-considerations" node="[object Object]">Performance Considerations</a></li>
<li><a href="#interview-questions--answers" node="[object Object]">Interview Questions &amp; Answers</a></li>
<li><a href="#advanced-examples" node="[object Object]">Advanced Examples</a></li>
</ul>
<h2 id="understanding-scope" node="[object Object]">Understanding Scope</h2>
<h3 id="what-is-scope?" node="[object Object]">What is Scope?</h3>
<p><strong>Scope</strong> determines the accessibility of variables, functions, and objects in different parts of your code. It defines the <strong>context</strong> in which variables exist and can be accessed.</p>
<h4>Types of Scope in JavaScript:</h4>
<p><strong>1. Global Scope</strong></p>
<ul>
<li>Variables accessible from anywhere in the program</li>
<li>Properties of the global object (window in browsers)</li>
</ul>
<p><strong>2. Function Scope</strong></p>
<ul>
<li>Variables accessible only within the function</li>
<li>Created when function is invoked</li>
</ul>
<p><strong>3. Block Scope</strong> (ES6+)</p>
<ul>
<li>Variables accessible only within the block {}</li>
<li>Applies to <pre><code class="hljs undefined">let</code></pre> and <pre><code class="hljs undefined">const</code></pre> declarations</li>
</ul>
<p><strong>4. Module Scope</strong> (ES6+)</p>
<ul>
<li>Variables accessible only within the module</li>
<li>Top-level scope of a module</li>
</ul>
<h3 id="scope-chain" node="[object Object]">Scope Chain</h3>
<p>JavaScript uses a <strong>scope chain</strong> to resolve variable access:</p>
<pre><pre><code class="hljs undefined">┌─────────────────────────────────────────┐
│            SCOPE CHAIN                  │
│                                         │
│  Inner Scope                            │
│  ┌─────────────────────────────────┐    │
│  │  Look for variable here first  │    │
│  │  ↓ Not found? Go up the chain  │    │
│  └─────────────────────────────────┘    │
│                │                        │
│  Outer Scope   ↓                        │
│  ┌─────────────────────────────────┐    │
│  │  Look for variable here        │    │
│  │  ↓ Not found? Continue up      │    │
│  └─────────────────────────────────┘    │
│                │                        │
│  Global Scope  ↓                        │
│  ┌─────────────────────────────────┐    │
│  │  Look for variable here        │    │
│  │  ↓ Not found? ReferenceError   │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
</code></pre></pre>
<h3 id="detailed-scope-example" node="[object Object]">Detailed Scope Example</h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Global Scope</span>
<span class="hljs-keyword">const</span> globalVar = <span class="hljs-string">&quot;I am global&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Outer Function Scope</span>
  <span class="hljs-keyword">const</span> outerVar = <span class="hljs-string">&quot;I am outer&quot;</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Inner Function Scope</span>
    <span class="hljs-keyword">const</span> innerVar = <span class="hljs-string">&quot;I am inner&quot;</span>;

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(innerVar); <span class="hljs-comment">// ✅ Accessible - same scope</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVar); <span class="hljs-comment">// ✅ Accessible - outer scope</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(globalVar); <span class="hljs-comment">// ✅ Accessible - global scope</span>
  }

  <span class="hljs-title function_">innerFunction</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(innerVar); <span class="hljs-comment">// ❌ ReferenceError - not in scope</span>
}

<span class="hljs-title function_">outerFunction</span>();
</code></pre></pre>
<p><strong>Scope Chain Resolution:</strong></p>
<pre><pre><code class="hljs undefined">innerFunction scope: { innerVar }
        ↓ (if not found)
outerFunction scope: { outerVar }
        ↓ (if not found)
Global scope: { globalVar }
        ↓ (if not found)
ReferenceError: variable is not defined
</code></pre></pre>
<h2 id="lexical-scoping" node="[object Object]">Lexical Scoping</h2>
<h3 id="what-is-lexical-scoping?" node="[object Object]">What is Lexical Scoping?</h3>
<p><strong>Lexical Scoping</strong> means that the scope of variables is determined by where they are declared in the code, not where they are called from.</p>
<h4>Key Principles:</h4>
<p><strong>1. Static Scope</strong></p>
<ul>
<li>Scope is determined at <strong>compile time</strong></li>
<li>Based on <strong>where</strong> variables and functions are declared</li>
<li><strong>Not</strong> where they are called</li>
</ul>
<p><strong>2. Nested Function Access</strong></p>
<ul>
<li>Inner functions have access to outer function variables</li>
<li>Outer functions <strong>cannot</strong> access inner function variables</li>
</ul>
<h3 id="lexical-scoping-example" node="[object Object]">Lexical Scoping Example</h3>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Global John&quot;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createGreeting</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;Function John&quot;</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">${name}</span>!`</span>);
  };
}

<span class="hljs-keyword">const</span> greeting = <span class="hljs-title function_">createGreeting</span>();
<span class="hljs-title function_">greeting</span>(); <span class="hljs-comment">// &quot;Hello, Function John!&quot;</span>

<span class="hljs-comment">// Even though we call greeting() in global scope,</span>
<span class="hljs-comment">// it still uses the &#x27;name&#x27; from where it was defined</span>
</code></pre></pre>
<p>{% endraw %}</p>
<p><strong>Visual Representation:</strong></p>
<pre><pre><code class="hljs undefined">┌─────────────────────────────────────────┐
│         LEXICAL ENVIRONMENT            │
│                                         │
│  Global: { name: &#x27;Global John&#x27; }        │
│  │                                      │
│  └─ createGreeting(): {                 │
│       name: &#x27;Function John&#x27;,            │
│       greet: function() {...}           │
│     }                                   │
│                                         │
│  greet() function &quot;remembers&quot;           │
│  the scope where it was created         │
└─────────────────────────────────────────┘
</code></pre></pre>
<h2 id="what-are-closures?" node="[object Object]">What are Closures?</h2>
<h3 id="definition" node="[object Object]">Definition</h3>
<p>A <strong>Closure</strong> is a feature where an inner function has access to variables from its outer (enclosing) scope even after the outer function has finished executing.</p>
<h4>Three Key Characteristics:</h4>
<p><strong>1. Access to Outer Variables</strong></p>
<ul>
<li>Inner function can access outer function&#x27;s variables</li>
</ul>
<p><strong>2. Persistent Scope</strong></p>
<ul>
<li>Outer function&#x27;s variables remain accessible even after it returns</li>
</ul>
<p><strong>3. Data Privacy</strong></p>
<ul>
<li>Variables in the closure are private to that specific instance</li>
</ul>
<h3 id="simple-closure-example" node="[object Object]">Simple Closure Example</h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outerFunction</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-comment">// This variable is &quot;captured&quot; by the closure</span>
  <span class="hljs-keyword">const</span> outerVariable = x;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params">y</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(outerVariable + y);
  }

  <span class="hljs-keyword">return</span> innerFunction;
}

<span class="hljs-keyword">const</span> myClosure = <span class="hljs-title function_">outerFunction</span>(<span class="hljs-number">10</span>);
<span class="hljs-title function_">myClosure</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// Outputs: 15</span>

<span class="hljs-comment">// outerFunction has finished executing,</span>
<span class="hljs-comment">// but innerFunction still has access to outerVariable</span>
</code></pre></pre>
<h3 id="closure-creation-process" node="[object Object]">Closure Creation Process</h3>
<pre><pre><code class="hljs undefined">Step 1: outerFunction(10) is called
┌─────────────────────────────────────┐
│ outerFunction Execution Context     │
│ Variables: { x: 10, outerVariable: 10 } │
│ Functions: { innerFunction }        │
└─────────────────────────────────────┘

Step 2: innerFunction is created and returned
┌─────────────────────────────────────┐
│ Closure Created                     │
│ Contains: { outerVariable: 10 }     │
│ Function: innerFunction             │
└─────────────────────────────────────┘

Step 3: outerFunction execution context is destroyed
But the closure preserves outerVariable!

Step 4: myClosure(5) is called
┌─────────────────────────────────────┐
│ innerFunction Execution Context     │
│ Has access to: { y: 5 }            │
│ Plus closure: { outerVariable: 10 } │
│ Result: 10 + 5 = 15                 │
└─────────────────────────────────────┘
</code></pre></pre>
<h2 id="how-closures-work" node="[object Object]">How Closures Work</h2>
<h3 id="behind-the-scenes:-lexical-environment" node="[object Object]">Behind the Scenes: Lexical Environment</h3>
<p>Every function in JavaScript maintains a reference to its <strong>Lexical Environment</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeCounter</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// This is in the Lexical Environment</span>

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    count++; <span class="hljs-comment">// Accesses the captured variable</span>
    <span class="hljs-keyword">return</span> count;
  };
}

<span class="hljs-keyword">const</span> counter1 = <span class="hljs-title function_">makeCounter</span>();
<span class="hljs-keyword">const</span> counter2 = <span class="hljs-title function_">makeCounter</span>();

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter1</span>()); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter1</span>()); <span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter2</span>()); <span class="hljs-comment">// 1 (independent closure)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">counter1</span>()); <span class="hljs-comment">// 3</span>
</code></pre></pre>
<p><strong>Memory Structure:</strong></p>
<pre><pre><code class="hljs undefined">┌─────────────────────────────────────────┐
│           MEMORY HEAP                   │
│                                         │
│  counter1 Closure:                      │
│  ┌─────────────────────────────────┐    │
│  │ Lexical Environment:            │    │
│  │ { count: 3 }                    │    │
│  │ Function: [anonymous function]  │    │
│  └─────────────────────────────────┘    │
│                                         │
│  counter2 Closure:                      │
│  ┌─────────────────────────────────┐    │
│  │ Lexical Environment:            │    │
│  │ { count: 1 }                    │    │
│  │ Function: [anonymous function]  │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
</code></pre></pre>
<h3 id="variable-capture-vs-reference" node="[object Object]">Variable Capture vs Reference</h3>
<p><strong>Important</strong>: Closures capture variables by <strong>reference</strong>, not by value:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createFunctions</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> functions = [];

  <span class="hljs-comment">// Common mistake</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
    functions.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// Captures reference to &#x27;i&#x27;</span>
    });
  }

  <span class="hljs-keyword">return</span> functions;
}

<span class="hljs-keyword">const</span> funcs = <span class="hljs-title function_">createFunctions</span>();
funcs[<span class="hljs-number">0</span>](); <span class="hljs-comment">// 3 (not 0!)</span>
funcs[<span class="hljs-number">1</span>](); <span class="hljs-comment">// 3 (not 1!)</span>
funcs[<span class="hljs-number">2</span>](); <span class="hljs-comment">// 3 (not 2!)</span>
</code></pre></pre>
<p><strong>Why this happens:</strong></p>
<pre><pre><code class="hljs undefined">All three functions share the same lexical environment
that contains the variable &#x27;i&#x27;.

When the loop finishes, i = 3.
All functions reference the same &#x27;i&#x27; variable.
</code></pre></pre>
<p><strong>Solutions:</strong></p>
<p><strong>1. Use <pre><code class="hljs undefined">let</code></pre> (block scope):</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createFunctions</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> functions = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
    <span class="hljs-comment">// &#x27;let&#x27; creates new scope each iteration</span>
    functions.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);
    });
  }

  <span class="hljs-keyword">return</span> functions;
}

<span class="hljs-keyword">const</span> funcs = <span class="hljs-title function_">createFunctions</span>();
funcs[<span class="hljs-number">0</span>](); <span class="hljs-comment">// 0</span>
funcs[<span class="hljs-number">1</span>](); <span class="hljs-comment">// 1</span>
funcs[<span class="hljs-number">2</span>](); <span class="hljs-comment">// 2</span>
</code></pre></pre>
<p><strong>2. Use IIFE (Immediately Invoked Function Expression):</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createFunctions</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> functions = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
    functions.<span class="hljs-title function_">push</span>(
      (<span class="hljs-keyword">function</span> (<span class="hljs-params">index</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(index);
        };
      })(i)
    ); <span class="hljs-comment">// IIFE creates new scope with &#x27;index&#x27;</span>
  }

  <span class="hljs-keyword">return</span> functions;
}
</code></pre></pre>
<h2 id="closure-use-cases" node="[object Object]">Closure Use Cases</h2>
<h3 id="1.-module-pattern" node="[object Object]">1. Module Pattern</h3>
<p>Create private variables and methods:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Calculator</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Private variables</span>
  <span class="hljs-keyword">let</span> history = [];
  <span class="hljs-keyword">let</span> currentValue = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// Private methods</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addToHistory</span>(<span class="hljs-params">operation, value</span>) {
    history.<span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">${operation}</span>: <span class="hljs-subst">${value}</span>`</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateNumber</span>(<span class="hljs-params">num</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> num !== <span class="hljs-string">&quot;number&quot;</span> || <span class="hljs-built_in">isNaN</span>(num)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid number&quot;</span>);
    }
  }

  <span class="hljs-comment">// Public API</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">add</span>(<span class="hljs-params">num</span>) {
      <span class="hljs-title function_">validateNumber</span>(num);
      currentValue += num;
      <span class="hljs-title function_">addToHistory</span>(<span class="hljs-string">&quot;ADD&quot;</span>, num);
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// Method chaining</span>
    },

    <span class="hljs-title function_">subtract</span>(<span class="hljs-params">num</span>) {
      <span class="hljs-title function_">validateNumber</span>(num);
      currentValue -= num;
      <span class="hljs-title function_">addToHistory</span>(<span class="hljs-string">&quot;SUBTRACT&quot;</span>, num);
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
    },

    <span class="hljs-title function_">getValue</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> currentValue;
    },

    <span class="hljs-title function_">getHistory</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> [...history]; <span class="hljs-comment">// Return copy, not reference</span>
    },

    <span class="hljs-title function_">clear</span>(<span class="hljs-params"></span>) {
      currentValue = <span class="hljs-number">0</span>;
      history = [];
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
    },
  };
})();

<span class="hljs-comment">// Usage</span>
<span class="hljs-title class_">Calculator</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">subtract</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">add</span>(<span class="hljs-number">5</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Calculator</span>.<span class="hljs-title function_">getValue</span>()); <span class="hljs-comment">// 12</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Calculator</span>.<span class="hljs-title function_">getHistory</span>()); <span class="hljs-comment">// [&#x27;ADD: 10&#x27;, &#x27;SUBTRACT: 3&#x27;, &#x27;ADD: 5&#x27;]</span>

<span class="hljs-comment">// Private variables are not accessible</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Calculator</span>.<span class="hljs-property">history</span>); <span class="hljs-comment">// undefined</span>
</code></pre></pre>
<h3 id="2.-factory-functions" node="[object Object]">2. Factory Functions</h3>
<p>Create objects with private state:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createBankAccount</span>(<span class="hljs-params">initialBalance = <span class="hljs-number">0</span></span>) {
  <span class="hljs-keyword">let</span> balance = initialBalance;
  <span class="hljs-keyword">let</span> transactionHistory = [];

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">recordTransaction</span>(<span class="hljs-params">type, amount</span>) {
    transactionHistory.<span class="hljs-title function_">push</span>({
      type,
      amount,
      <span class="hljs-attr">timestamp</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),
      <span class="hljs-attr">balanceAfter</span>: balance,
    });
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">deposit</span>(<span class="hljs-params">amount</span>) {
      <span class="hljs-keyword">if</span> (amount &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Deposit amount must be positive&quot;</span>);
      }
      balance += amount;
      <span class="hljs-title function_">recordTransaction</span>(<span class="hljs-string">&quot;DEPOSIT&quot;</span>, amount);
      <span class="hljs-keyword">return</span> balance;
    },

    <span class="hljs-title function_">withdraw</span>(<span class="hljs-params">amount</span>) {
      <span class="hljs-keyword">if</span> (amount &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Withdrawal amount must be positive&quot;</span>);
      }
      <span class="hljs-keyword">if</span> (amount &gt; balance) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Insufficient funds&quot;</span>);
      }
      balance -= amount;
      <span class="hljs-title function_">recordTransaction</span>(<span class="hljs-string">&quot;WITHDRAWAL&quot;</span>, amount);
      <span class="hljs-keyword">return</span> balance;
    },

    <span class="hljs-title function_">getBalance</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> balance;
    },

    <span class="hljs-title function_">getTransactionHistory</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> transactionHistory.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">t</span>) =&gt;</span> ({ ...t })); <span class="hljs-comment">// Deep copy</span>
    },
  };
}

<span class="hljs-keyword">const</span> account1 = <span class="hljs-title function_">createBankAccount</span>(<span class="hljs-number">100</span>);
<span class="hljs-keyword">const</span> account2 = <span class="hljs-title function_">createBankAccount</span>(<span class="hljs-number">50</span>);

account1.<span class="hljs-title function_">deposit</span>(<span class="hljs-number">25</span>);
account2.<span class="hljs-title function_">withdraw</span>(<span class="hljs-number">10</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(account1.<span class="hljs-title function_">getBalance</span>()); <span class="hljs-comment">// 125</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(account2.<span class="hljs-title function_">getBalance</span>()); <span class="hljs-comment">// 40</span>

<span class="hljs-comment">// Each account has its own private state</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(account1.<span class="hljs-property">balance</span>); <span class="hljs-comment">// undefined (private)</span>
</code></pre></pre>
<h3 id="3.-event-handlers-with-state" node="[object Object]">3. Event Handlers with State</h3>
<p>Maintain state in event handlers:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createButtonWithCounter</span>(<span class="hljs-params">buttonId</span>) {
  <span class="hljs-keyword">let</span> clickCount = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">let</span> lastClickTime = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(buttonId);

  button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
    clickCount++;
    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    <span class="hljs-keyword">const</span> timeSinceLastClick = lastClickTime ? now - lastClickTime : <span class="hljs-number">0</span>;

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Button clicked <span class="hljs-subst">${clickCount}</span> times`</span>);

    <span class="hljs-keyword">if</span> (timeSinceLastClick &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Time since last click: <span class="hljs-subst">${timeSinceLastClick}</span>ms`</span>);
    }

    lastClickTime = now;

    <span class="hljs-comment">// Update button text with click count</span>
    button.<span class="hljs-property">textContent</span> = <span class="hljs-string">`Clicked <span class="hljs-subst">${clickCount}</span> times`</span>;
  });

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">getClickCount</span>: <span class="hljs-function">() =&gt;</span> clickCount,
    <span class="hljs-attr">reset</span>: <span class="hljs-function">() =&gt;</span> {
      clickCount = <span class="hljs-number">0</span>;
      lastClickTime = <span class="hljs-literal">null</span>;
      button.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;Click me&quot;</span>;
    },
  };
}

<span class="hljs-keyword">const</span> buttonCounter = <span class="hljs-title function_">createButtonWithCounter</span>(<span class="hljs-string">&quot;myButton&quot;</span>);
</code></pre></pre>
<h3 id="4.-memoization-(caching)" node="[object Object]">4. Memoization (Caching)</h3>
<p>Cache expensive function results:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">memoize</span>(<span class="hljs-params">fn</span>) {
  <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
    <span class="hljs-keyword">const</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(args);

    <span class="hljs-keyword">if</span> (cache.<span class="hljs-title function_">has</span>(key)) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Cache hit!&quot;</span>);
      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">get</span>(key);
    }

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Computing result...&quot;</span>);
    <span class="hljs-keyword">const</span> result = fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
    cache.<span class="hljs-title function_">set</span>(key, result);
    <span class="hljs-keyword">return</span> result;
  };
}

<span class="hljs-comment">// Expensive function</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>) {
  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">fibonacci</span>(n - <span class="hljs-number">2</span>);
}

<span class="hljs-keyword">const</span> memoizedFibonacci = <span class="hljs-title function_">memoize</span>(fibonacci);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">memoizedFibonacci</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// Computing result... 55</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">memoizedFibonacci</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// Cache hit! 55</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">memoizedFibonacci</span>(<span class="hljs-number">11</span>)); <span class="hljs-comment">// Computing result... 89</span>
</code></pre></pre>
<h3 id="5.-partial-application-&amp;-currying" node="[object Object]">5. Partial Application &amp; Currying</h3>
<p>Create specialized functions:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Partial Application</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">a, b, c</span>) {
  <span class="hljs-keyword">return</span> a * b * c;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">partial</span>(<span class="hljs-params">fn, ...fixedArgs</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...remainingArgs</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(...fixedArgs, ...remainingArgs);
  };
}

<span class="hljs-keyword">const</span> multiplyByTwo = <span class="hljs-title function_">partial</span>(multiply, <span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> multiplyByTwoAndThree = <span class="hljs-title function_">partial</span>(multiply, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">multiplyByTwo</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 2 * 3 * 4 = 24</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">multiplyByTwoAndThree</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 2 * 3 * 5 = 30</span>

<span class="hljs-comment">// Currying</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span>(<span class="hljs-params">fn</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">curried</span>(<span class="hljs-params">...args</span>) {
    <span class="hljs-keyword">if</span> (args.<span class="hljs-property">length</span> &gt;= fn.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...nextArgs</span>) {
        <span class="hljs-keyword">return</span> curried.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args.<span class="hljs-title function_">concat</span>(nextArgs));
      };
    }
  };
}

<span class="hljs-keyword">const</span> curriedMultiply = <span class="hljs-title function_">curry</span>(multiply);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">curriedMultiply</span>(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 24</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">curriedMultiply</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 24</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">curriedMultiply</span>(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)); <span class="hljs-comment">// 24</span>
</code></pre></pre>
<h2 id="memory-management" node="[object Object]">Memory Management</h2>
<h3 id="closure-memory-considerations" node="[object Object]">Closure Memory Considerations</h3>
<p>Closures can lead to memory leaks if not handled properly:</p>
<p><strong>Problem: Accidental Object Retention</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">attachListeners</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> largeObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&quot;data&quot;</span>);

  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// This closure keeps largeObject in memory</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button clicked&quot;</span>);
  });
}

<span class="hljs-title function_">attachListeners</span>();
<span class="hljs-comment">// largeObject remains in memory even though it&#x27;s not used!</span>
</code></pre></pre>
<p><strong>Solution: Explicit Cleanup</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">attachListeners</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> largeObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&quot;data&quot;</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">clickHandler</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Button clicked&quot;</span>);
    <span class="hljs-comment">// Don&#x27;t reference largeObject here</span>
  }

  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, clickHandler);

  <span class="hljs-comment">// Cleanup function</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">document</span>
      .<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;button&quot;</span>)
      .<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, clickHandler);
    <span class="hljs-comment">// largeObject will be garbage collected</span>
  };
}

<span class="hljs-keyword">const</span> cleanup = <span class="hljs-title function_">attachListeners</span>();
<span class="hljs-comment">// Later...</span>
<span class="hljs-title function_">cleanup</span>();
</code></pre></pre>
<h3 id="memory-leak-prevention" node="[object Object]">Memory Leak Prevention</h3>
<p><strong>1. Avoid Unnecessary Variable Capture</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// BAD: Captures unnecessary variables</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createHandler</span>(<span class="hljs-params">data</span>) {
  <span class="hljs-keyword">const</span> largeArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>);
  <span class="hljs-keyword">const</span> someOtherStuff = {
    <span class="hljs-comment">/* ... */</span>
  };

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// Only needs &#x27;data&#x27;, but captures everything</span>
  };
}

<span class="hljs-comment">// GOOD: Only capture what you need</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createHandler</span>(<span class="hljs-params">data</span>) {
  <span class="hljs-keyword">const</span> largeArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>);
  <span class="hljs-keyword">const</span> someOtherStuff = {
    <span class="hljs-comment">/* ... */</span>
  };

  <span class="hljs-comment">// Extract only what you need</span>
  <span class="hljs-keyword">const</span> neededData = data;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(neededData);
  };
}
</code></pre></pre>
<p><strong>2. Break Circular References</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setupComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;component&quot;</span>);

  element.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Circular reference: element -&gt; function -&gt; element</span>
    element.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&quot;red&quot;</span>;
  };

  <span class="hljs-comment">// Break the cycle</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) {
    element.<span class="hljs-property">onclick</span> = <span class="hljs-literal">null</span>;
  };
}
</code></pre></pre>
<h2 id="visual-diagrams" node="[object Object]">Visual Diagrams</h2>
<h3 id="closure-memory-structure" node="[object Object]">Closure Memory Structure</h3>
<pre><pre><code class="hljs undefined">┌─────────────────────────────────────────────────────────────┐
│                    JAVASCRIPT MEMORY                        │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                  CALL STACK                         │    │
│  │                                                     │    │
│  │  ┌─────────────────────────────────────────────┐    │    │
│  │  │        Global Execution Context             │    │    │
│  │  │                                             │    │    │
│  │  │  Variables: { counter: [Function] }         │    │    │
│  │  └─────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │                    HEAP MEMORY                      │    │
│  │                                                     │    │
│  │  ┌─────────────────────────────────────────────┐    │    │
│  │  │           Closure Object                    │    │    │
│  │  │                                             │    │    │
│  │  │  Lexical Environment:                       │    │    │
│  │  │  ┌─────────────────────────────────────┐    │    │    │
│  │  │  │  Variables: { count: 0 }            │    │    │    │
│  │  │  └─────────────────────────────────────┘    │    │    │
│  │  │                                             │    │    │
│  │  │  Function Code:                             │    │    │
│  │  │  ┌─────────────────────────────────────┐    │    │    │
│  │  │  │  function() {                       │    │    │    │
│  │  │  │    count++;                         │    │    │    │
│  │  │  │    return count;                    │    │    │    │
│  │  │  │  }                                  │    │    │    │
│  │  │  └─────────────────────────────────────┘    │    │    │
│  │  └─────────────────────────────────────────────┘    │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │               REFERENCE CHAIN                       │    │
│  │                                                     │    │
│  │  counter variable ──────────→ Closure Object        │    │
│  │                                    │                │    │
│  │                                    ▼                │    │
│  │                           Lexical Environment       │    │
│  │                                    │                │    │
│  │                                    ▼                │    │
│  │                              { count: 0 }           │    │
│  └─────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────┘
</code></pre></pre>
<h3 id="scope-chain-resolution" node="[object Object]">Scope Chain Resolution</h3>
<pre><pre><code class="hljs undefined">Function Call: innerFunction()

Step 1: Look in Local Scope
┌─────────────────────────────────┐
│   innerFunction Scope           │
│                                 │
│   Looking for: variableName     │
│   Found: [ ] Yes [ ] No         │
│                                 │
└─────────────────────────────────┘
                │
                ▼ (if not found)
Step 2: Look in Outer Function Scope
┌─────────────────────────────────┐
│   outerFunction Scope           │
│                                 │
│   Looking for: variableName     │
│   Found: [ ] Yes [ ] No         │
│                                 │
└─────────────────────────────────┘
                │
                ▼ (if not found)
Step 3: Look in Global Scope
┌─────────────────────────────────┐
│   Global Scope                  │
│                                 │
│   Looking for: variableName     │
│   Found: [ ] Yes [ ] No         │
│                                 │
└─────────────────────────────────┘
                │
                ▼ (if not found)
        ReferenceError!
</code></pre></pre>
<h2 id="performance-considerations" node="[object Object]">Performance Considerations</h2>
<h3 id="closure-performance-impact" node="[object Object]">Closure Performance Impact</h3>
<p><strong>1. Memory Usage</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Each closure instance maintains its own scope</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> largeArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>); <span class="hljs-comment">// Each instance has this!</span>

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> ++count;
  };
}

<span class="hljs-comment">// Creates 1000 closures, each with its own largeArray</span>
<span class="hljs-keyword">const</span> counters = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: <span class="hljs-number">1000</span> }, createCounter);
</code></pre></pre>
<p><strong>2. Garbage Collection</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Closure prevents garbage collection</span>
<span class="hljs-keyword">let</span> globalRef;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createClosure</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> largeData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-string">&quot;data&quot;</span>);

  globalRef = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> largeData.<span class="hljs-property">length</span>; <span class="hljs-comment">// Keeps largeData alive</span>
  };
}

<span class="hljs-title function_">createClosure</span>();
<span class="hljs-comment">// largeData cannot be garbage collected while globalRef exists</span>
</code></pre></pre>
<p><strong>3. Performance Optimization</strong></p>
<p><strong>Bad: Recreating closures in render</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">{ items }</span>) {
  <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
      <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>
      <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> handleClick(item.id)} // New closure each render!
    &gt;
      {item.name}
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  ));
}
</code></pre></pre>
<p><strong>Good: Memoized or stable references</strong></p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">{ items }</span>) {
  <span class="hljs-keyword">const</span> handleClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {
    <span class="hljs-comment">// Handle click</span>
  }, []);

  <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> handleClick(item.id)}&gt;
      {item.name}
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
  ));
}
</code></pre></pre>
<h2 id="interview-questions-&amp;-answers" node="[object Object]">Interview Questions &amp; Answers</h2>
<h3 id="q1:-what-will-this-code-output-and-why?" node="[object Object]">Q1: What will this code output and why?</h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);
  }, <span class="hljs-number">100</span>);
}
</code></pre></pre>
<p><strong>Answer</strong>: It will output <pre><code class="hljs undefined">3</code></pre> three times.</p>
<p><strong>Explanation</strong>:</p>
<ul>
<li>The <pre><code class="hljs undefined">setTimeout</code></pre> callbacks are executed after the loop completes</li>
<li>All three closures capture a reference to the same variable <pre><code class="hljs undefined">i</code></pre></li>
<li>When the callbacks execute, <pre><code class="hljs undefined">i</code></pre> has the value 3 (the final value after the loop)</li>
</ul>
<p><strong>Solutions</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Solution 1: Use let (block scope)</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// 0, 1, 2</span>
  }, <span class="hljs-number">100</span>);
}

<span class="hljs-comment">// Solution 2: IIFE</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
  (<span class="hljs-keyword">function</span> (<span class="hljs-params">j</span>) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j); <span class="hljs-comment">// 0, 1, 2</span>
    }, <span class="hljs-number">100</span>);
  })(i);
}

<span class="hljs-comment">// Solution 3: bind</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
  <span class="hljs-built_in">setTimeout</span>(
    <span class="hljs-keyword">function</span> (<span class="hljs-params">j</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j); <span class="hljs-comment">// 0, 1, 2</span>
    }.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i),
    <span class="hljs-number">100</span>
  );
}
</code></pre></pre>
<h3 id="q2:-explain-how-this-module-pattern-works:" node="[object Object]">Q2: Explain how this module pattern works:</h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Module</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> privateVar = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">privateFunction</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Private function called&quot;</span>);
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">publicMethod</span>(<span class="hljs-params"></span>) {
      privateVar++;
      <span class="hljs-title function_">privateFunction</span>();
      <span class="hljs-keyword">return</span> privateVar;
    },

    <span class="hljs-title function_">getPrivateVar</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> privateVar;
    },
  };
})();
</code></pre></pre>
<p><strong>Answer</strong>:
This is the <strong>Module Pattern</strong> using an IIFE (Immediately Invoked Function Expression):</p>
<ol>
<li><strong>IIFE</strong>: Creates a private scope immediately</li>
<li><strong>Private variables</strong>: <pre><code class="hljs undefined">privateVar</code></pre> and <pre><code class="hljs undefined">privateFunction</code></pre> are enclosed in the function scope</li>
<li><strong>Public API</strong>: The returned object exposes only the methods we want to be public</li>
<li><strong>Closure</strong>: The returned methods maintain access to the private variables</li>
<li><strong>Encapsulation</strong>: Private variables cannot be accessed directly from outside</li>
</ol>
<p><strong>Usage</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-title function_">publicMethod</span>()); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-title function_">getPrivateVar</span>()); <span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Module</span>.<span class="hljs-property">privateVar</span>); <span class="hljs-comment">// undefined (private)</span>
</code></pre></pre>
<h3 id="q3:-what&#x27;s-the-difference-between-these-two-approaches?" node="[object Object]">Q3: What&#x27;s the difference between these two approaches?</h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Approach 1</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) {
    <span class="hljs-keyword">return</span> x * y;
  };
}

<span class="hljs-comment">// Approach 2</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">multiply</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-keyword">return</span> x * y;
}
</code></pre></pre>
<p><strong>Answer</strong>:</p>
<p><strong>Approach 1 (Closure)</strong>:</p>
<ul>
<li>Creates a <strong>specialized function</strong> with <pre><code class="hljs undefined">x</code></pre> &quot;baked in&quot;</li>
<li>Each call to <pre><code class="hljs undefined">createMultiplier</code></pre> creates a new closure</li>
<li>Useful for <strong>partial application</strong> and <strong>function specialization</strong></li>
<li>More memory usage (maintains closure scope)</li>
</ul>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">const</span> double = <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-number">2</span>);
<span class="hljs-keyword">const</span> triple = <span class="hljs-title function_">createMultiplier</span>(<span class="hljs-number">3</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">double</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">triple</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 15</span>
</code></pre></pre>
<p><strong>Approach 2 (Regular function)</strong>:</p>
<ul>
<li>Direct multiplication without closure</li>
<li>More <strong>memory efficient</strong></li>
<li>Requires both parameters each time</li>
<li>No function specialization</li>
</ul>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">multiply</span>(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">multiply</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">// 15</span>
</code></pre></pre>
<h3 id="q4:-how-do-you-create-private-methods-in-javascript?" node="[object Object]">Q4: How do you create private methods in JavaScript?</h3>
<p><strong>Answer</strong>:</p>
<p><strong>1. Module Pattern with IIFE</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyModule</span> = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// Private variables and methods</span>
  <span class="hljs-keyword">let</span> privateCounter = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">privateMethod</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This is private&quot;</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">incrementCounter</span>(<span class="hljs-params"></span>) {
    privateCounter++;
    <span class="hljs-title function_">privateMethod</span>();
  }

  <span class="hljs-comment">// Public API</span>
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">increment</span>: incrementCounter,
    <span class="hljs-title function_">getCount</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> privateCounter;
    },
  };
})();
</code></pre></pre>
<p><strong>2. Factory Function</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> privateVar = <span class="hljs-string">&quot;secret&quot;</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">privateMethod</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Accessing <span class="hljs-subst">${privateVar}</span>`</span>;
  }

  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">publicMethod</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">privateMethod</span>();
    },
  };
}
</code></pre></pre>
<p><strong>3. WeakMap Pattern</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">const</span> privateData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    privateData.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, {
      <span class="hljs-attr">secret</span>: <span class="hljs-string">&quot;private value&quot;</span>,
      <span class="hljs-title function_">privateMethod</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is private&quot;</span>;
      },
    });
  }

  <span class="hljs-title function_">publicMethod</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> data = privateData.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>);
    <span class="hljs-keyword">return</span> data.<span class="hljs-title function_">privateMethod</span>();
  }
}
</code></pre></pre>
<p><strong>4. Private Fields (ES2022)</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {
  #privateField = <span class="hljs-string">&quot;secret&quot;</span>;

  #<span class="hljs-title function_">privateMethod</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;This is private&quot;</span>;
  }

  <span class="hljs-title function_">publicMethod</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">privateMethod</span>();
  }
}
</code></pre></pre>
<h3 id="q5:-explain-memory-leaks-with-closures-and-how-to-prevent-them." node="[object Object]">Q5: Explain memory leaks with closures and how to prevent them.</h3>
<p><strong>Answer</strong>:</p>
<p><strong>Common Memory Leak Scenarios</strong>:</p>
<p><strong>1. Event Listeners with Closures</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// PROBLEM: Memory leak</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setupComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> largeData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>);

  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Clicked&quot;</span>); <span class="hljs-comment">// Keeps largeData in memory</span>
  };
}

<span class="hljs-comment">// SOLUTION: Explicit cleanup</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setupComponent</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> largeData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000000</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">clickHandler</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Clicked&quot;</span>);
    <span class="hljs-comment">// Don&#x27;t reference largeData</span>
  }

  <span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;button&quot;</span>);
  button.<span class="hljs-property">onclick</span> = clickHandler;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params"></span>) {
    button.<span class="hljs-property">onclick</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-comment">// Now largeData can be garbage collected</span>
  };
}
</code></pre></pre>
<p><strong>2. Circular References</strong>:</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// PROBLEM: Circular reference</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createNode</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> node = {
    <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">children</span>: [],
    <span class="hljs-attr">cleanup</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-comment">// This creates a circular reference</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">parent</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = [];
    },
  };

  <span class="hljs-keyword">return</span> node;
}

<span class="hljs-comment">// SOLUTION: WeakMap or explicit cleanup</span>
<span class="hljs-keyword">const</span> nodeCleanup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">createNode</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> node = {
    <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">children</span>: [],
  };

  nodeCleanup.<span class="hljs-title function_">set</span>(node, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    node.<span class="hljs-property">parent</span> = <span class="hljs-literal">null</span>;
    node.<span class="hljs-property">children</span> = [];
  });

  <span class="hljs-keyword">return</span> node;
}
</code></pre></pre>
<p><strong>Prevention Strategies</strong>:</p>
<ol>
<li><strong>Remove event listeners</strong> when no longer needed</li>
<li><strong>Avoid capturing unnecessary variables</strong> in closures</li>
<li><strong>Use WeakMap</strong> for private data</li>
<li><strong>Set references to null</strong> when done</li>
<li><strong>Use tools</strong> like Chrome DevTools Memory tab to detect leaks</li>
</ol>
<p>This comprehensive guide covers closures and scope from fundamental concepts to advanced patterns, providing the deep understanding needed for senior frontend engineering interviews.</p>
<h1 id="additional-advanced-interview-q&amp;a-and-visuals" node="[object Object]">Additional Advanced Interview Q&amp;A and Visuals</h1>
<h2 id="q:-how-can-closures-cause-memory-leaks-in-javascript-applications?" node="[object Object]">Q: How can closures cause memory leaks in JavaScript applications?</h2>
<p><strong>Answer (English):</strong></p>
<ul>
<li>Closures keep references to variables in their scope chain</li>
<li>If a closure references large data or DOM nodes, and is attached to a global or long-lived object (e.g., event handler), the data cannot be garbage collected</li>
<li>Always clean up event handlers and avoid unnecessary references in closures</li>
</ul>
<p><strong>Answer (Vietnamese):</strong></p>
<ul>
<li>Closure giữ tham chiếu tới biến trong scope chain</li>
<li>Nếu closure tham chiếu dữ liệu lớn hoặc DOM node, và được gán cho global hoặc object sống lâu (ví dụ event handler), dữ liệu sẽ không được giải phóng bộ nhớ</li>
<li>Luôn cleanup event handler và tránh giữ tham chiếu không cần thiết trong closure</li>
</ul>
<hr/>
<h2 id="diagram:-closure-memory-leak" node="[object Object]">Diagram: Closure Memory Leak</h2>
<pre><pre><code class="hljs hljs language-mermaid">flowchart TD
  A[Create Closure] --&gt; B[References Large Data]
  B --&gt; C[Assign to Global/Event Handler]
  C --&gt; D[Large Data Not GC&#x27;d]
  D --&gt; E[Memory Leak]
</code></pre></pre>
<hr/>
<h2 id="q:-how-would-you-use-closures-to-implement-a-private-counter-with-increment-and-reset-methods?" node="[object Object]">Q: How would you use closures to implement a private counter with increment and reset methods?</h2>
<p><strong>Answer (English):</strong></p>
<ul>
<li>Use a factory function that returns an object with methods</li>
<li>The counter variable is private in the closure</li>
</ul>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createCounter</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> {
    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> ++count;
    },
    <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) {
      count = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> count;
    },
  };
}
<span class="hljs-keyword">const</span> counter = <span class="hljs-title function_">createCounter</span>();
counter.<span class="hljs-title function_">increment</span>(); <span class="hljs-comment">// 1</span>
counter.<span class="hljs-title function_">reset</span>(); <span class="hljs-comment">// 0</span>
</code></pre></pre>
<p><strong>Answer (Vietnamese):</strong></p>
<ul>
<li>Dùng factory function trả về object chứa các method</li>
<li>Biến counter là private trong closure</li>
</ul>
<hr/></div></div></div><div class="space-y-6"><div class="bg-white border border-gray-200 rounded-lg p-6"><h3 class="text-lg font-semibold text-gray-900 mb-4">Your Progress</h3><div class="w-full bg-gray-200 rounded-full h-2 mb-2"><div class="bg-blue-600 h-2 rounded-full" style="width:25%"></div></div><p class="text-sm text-gray-600">25% Complete</p></div></div></div></div></main><footer class="sc-gvqKNf booJNS"><div class="sc-cOpnSz fVoYcP"><div class="sc-kjwdDK kKfrkv"><div class="sc-eVqvcJ inEXDm"><div class="sc-bbbBoY hWhopJ"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</div><p class="sc-cdmAjP exeTne">Comprehensive interview preparation for frontend engineers targeting Big Tech companies.</p><div class="sc-jytpVa cgXMuV"><a href="https://github.com" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github "><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><a href="https://twitter.com" aria-label="Twitter"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-twitter "><path d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"></path></svg></a><a href="https://linkedin.com" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-linkedin "><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect width="4" height="12" x="2" y="9"></rect><circle cx="4" cy="4" r="2"></circle></svg></a><a href="mailto:contact@example.com" aria-label="Email"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail "><rect width="20" height="16" x="2" y="4" rx="2"></rect><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path></svg></a></div></div><div class="sc-eVqvcJ inEXDm"><h3>Study Materials</h3><ul><li><a href="/algorithms">Algorithms</a></li><li><a href="/react">React &amp; Frontend</a></li><li><a href="/system-design">System Design</a></li><li><a href="/typescript">TypeScript</a></li><li><a href="/performance">Performance</a></li></ul></div><div class="sc-eVqvcJ inEXDm"><h3>Companies</h3><ul><li><a href="/google">Google</a></li><li><a href="/meta">Meta</a></li><li><a href="/amazon">Amazon</a></li><li><a href="/microsoft">Microsoft</a></li><li><a href="/apple">Apple</a></li></ul></div><div class="sc-eVqvcJ inEXDm"><h3>Resources</h3><ul><li><a href="/interview-tips">Interview Tips</a></li><li><a href="/coding-challenges">Coding Challenges</a></li><li><a href="/mock-interviews">Mock Interviews</a></li><li><a href="/blog">Blog</a></li><li><a href="/faq">FAQ</a></li></ul></div></div><div class="sc-eknHtZ iQqwrD"><p class="sc-pYNGo gObJRG">© 2025 Frontend Interview Prep. All rights reserved.</p><div class="sc-cCVJLD eBqBtc"><a href="/privacy">Privacy Policy</a><a href="/terms">Terms of Service</a><a href="/contact">Contact</a></div></div></div></footer></div><script src="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/interview/_next/static/css/387024c6a2216908.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[2846,[],\"\"]\n5:I[2972,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"930\",\"static/chunks/930-3262a6c9c5acace4.js\",\"289\",\"static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js\"],\"\"]\n6:I[5907,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"930\",\"static/chunks/930-3262a6c9c5acace4.js\",\"289\",\"static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js\"],\"default\"]\n8:I[4707,[],\"\"]\na:I[6423,[],\"\"]\nb:I[2,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"710\",\"static/chunks/710-dfaa11b4dff08f8e.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"233\",\"static/chunks/233-3e0c1d820a17eca9.js\",\"185\",\"static/chunks/app/layout-333f4adcd11f8f39.js\"],\"default\",1]\nd:I[1060,[],\"\"]\n7:T85d8,"])</script><script>self.__next_f.push([1,"# JavaScript Closures \u0026 Scope: Complete Deep Dive\n\n## Table of Contents\n\n- [Understanding Scope](#understanding-scope)\n- [Lexical Scoping](#lexical-scoping)\n- [What are Closures?](#what-are-closures)\n- [How Closures Work](#how-closures-work)\n- [Closure Use Cases](#closure-use-cases)\n- [Memory Management](#memory-management)\n- [Visual Diagrams](#visual-diagrams)\n- [Common Patterns](#common-patterns)\n- [Performance Considerations](#performance-considerations)\n- [Interview Questions \u0026 Answers](#interview-questions--answers)\n- [Advanced Examples](#advanced-examples)\n\n## Understanding Scope\n\n### What is Scope?\n\n**Scope** determines the accessibility of variables, functions, and objects in different parts of your code. It defines the **context** in which variables exist and can be accessed.\n\n#### Types of Scope in JavaScript:\n\n**1. Global Scope**\n\n- Variables accessible from anywhere in the program\n- Properties of the global object (window in browsers)\n\n**2. Function Scope**\n\n- Variables accessible only within the function\n- Created when function is invoked\n\n**3. Block Scope** (ES6+)\n\n- Variables accessible only within the block {}\n- Applies to `let` and `const` declarations\n\n**4. Module Scope** (ES6+)\n\n- Variables accessible only within the module\n- Top-level scope of a module\n\n### Scope Chain\n\nJavaScript uses a **scope chain** to resolve variable access:\n\n```\n┌─────────────────────────────────────────┐\n│            SCOPE CHAIN                  │\n│                                         │\n│  Inner Scope                            │\n│  ┌─────────────────────────────────┐    │\n│  │  Look for variable here first  │    │\n│  │  ↓ Not found? Go up the chain  │    │\n│  └─────────────────────────────────┘    │\n│                │                        │\n│  Outer Scope   ↓                        │\n│  ┌─────────────────────────────────┐    │\n│  │  Look for variable here        │    │\n│  │  ↓ Not found? Continue up      │    │\n│  └─────────────────────────────────┘    │\n│                │                        │\n│  Global Scope  ↓                        │\n│  ┌─────────────────────────────────┐    │\n│  │  Look for variable here        │    │\n│  │  ↓ Not found? ReferenceError   │    │\n│  └─────────────────────────────────┘    │\n└─────────────────────────────────────────┘\n```\n\n### Detailed Scope Example\n\n```javascript\n// Global Scope\nconst globalVar = \"I am global\";\n\nfunction outerFunction() {\n  // Outer Function Scope\n  const outerVar = \"I am outer\";\n\n  function innerFunction() {\n    // Inner Function Scope\n    const innerVar = \"I am inner\";\n\n    console.log(innerVar); // ✅ Accessible - same scope\n    console.log(outerVar); // ✅ Accessible - outer scope\n    console.log(globalVar); // ✅ Accessible - global scope\n  }\n\n  innerFunction();\n  console.log(innerVar); // ❌ ReferenceError - not in scope\n}\n\nouterFunction();\n```\n\n**Scope Chain Resolution:**\n\n```\ninnerFunction scope: { innerVar }\n        ↓ (if not found)\nouterFunction scope: { outerVar }\n        ↓ (if not found)\nGlobal scope: { globalVar }\n        ↓ (if not found)\nReferenceError: variable is not defined\n```\n\n## Lexical Scoping\n\n### What is Lexical Scoping?\n\n**Lexical Scoping** means that the scope of variables is determined by where they are declared in the code, not where they are called from.\n\n#### Key Principles:\n\n**1. Static Scope**\n\n- Scope is determined at **compile time**\n- Based on **where** variables and functions are declared\n- **Not** where they are called\n\n**2. Nested Function Access**\n\n- Inner functions have access to outer function variables\n- Outer functions **cannot** access inner function variables\n\n### Lexical Scoping Example\n\n{% raw %}\n```javascript\nconst name = \"Global John\";\n\nfunction createGreeting() {\n  const name = \"Function John\";\n\n  return function greet() {\n    console.log(`Hello, ${name}!`);\n  };\n}\n\nconst greeting = createGreeting();\ngreeting(); // \"Hello, Function John!\"\n\n// Even though we call greeting() in global scope,\n// it still uses the 'name' from where it was defined\n```\n{% endraw %}\n\n**Visual Representation:**\n\n```\n┌─────────────────────────────────────────┐\n│         LEXICAL ENVIRONMENT            │\n│                                         │\n│  Global: { name: 'Global John' }        │\n│  │                                      │\n│  └─ createGreeting(): {                 │\n│       name: 'Function John',            │\n│       greet: function() {...}           │\n│     }                                   │\n│                                         │\n│  greet() function \"remembers\"           │\n│  the scope where it was created         │\n└─────────────────────────────────────────┘\n```\n\n## What are Closures?\n\n### Definition\n\nA **Closure** is a feature where an inner function has access to variables from its outer (enclosing) scope even after the outer function has finished executing.\n\n#### Three Key Characteristics:\n\n**1. Access to Outer Variables**\n\n- Inner function can access outer function's variables\n\n**2. Persistent Scope**\n\n- Outer function's variables remain accessible even after it returns\n\n**3. Data Privacy**\n\n- Variables in the closure are private to that specific instance\n\n### Simple Closure Example\n\n```javascript\nfunction outerFunction(x) {\n  // This variable is \"captured\" by the closure\n  const outerVariable = x;\n\n  function innerFunction(y) {\n    console.log(outerVariable + y);\n  }\n\n  return innerFunction;\n}\n\nconst myClosure = outerFunction(10);\nmyClosure(5); // Outputs: 15\n\n// outerFunction has finished executing,\n// but innerFunction still has access to outerVariable\n```\n\n### Closure Creation Process\n\n```\nStep 1: outerFunction(10) is called\n┌─────────────────────────────────────┐\n│ outerFunction Execution Context     │\n│ Variables: { x: 10, outerVariable: 10 } │\n│ Functions: { innerFunction }        │\n└─────────────────────────────────────┘\n\nStep 2: innerFunction is created and returned\n┌─────────────────────────────────────┐\n│ Closure Created                     │\n│ Contains: { outerVariable: 10 }     │\n│ Function: innerFunction             │\n└─────────────────────────────────────┘\n\nStep 3: outerFunction execution context is destroyed\nBut the closure preserves outerVariable!\n\nStep 4: myClosure(5) is called\n┌─────────────────────────────────────┐\n│ innerFunction Execution Context     │\n│ Has access to: { y: 5 }            │\n│ Plus closure: { outerVariable: 10 } │\n│ Result: 10 + 5 = 15                 │\n└─────────────────────────────────────┘\n```\n\n## How Closures Work\n\n### Behind the Scenes: Lexical Environment\n\nEvery function in JavaScript maintains a reference to its **Lexical Environment**:\n\n```javascript\nfunction makeCounter() {\n  let count = 0; // This is in the Lexical Environment\n\n  return function () {\n    count++; // Accesses the captured variable\n    return count;\n  };\n}\n\nconst counter1 = makeCounter();\nconst counter2 = makeCounter();\n\nconsole.log(counter1()); // 1\nconsole.log(counter1()); // 2\nconsole.log(counter2()); // 1 (independent closure)\nconsole.log(counter1()); // 3\n```\n\n**Memory Structure:**\n\n```\n┌─────────────────────────────────────────┐\n│           MEMORY HEAP                   │\n│                                         │\n│  counter1 Closure:                      │\n│  ┌─────────────────────────────────┐    │\n│  │ Lexical Environment:            │    │\n│  │ { count: 3 }                    │    │\n│  │ Function: [anonymous function]  │    │\n│  └─────────────────────────────────┘    │\n│                                         │\n│  counter2 Closure:                      │\n│  ┌─────────────────────────────────┐    │\n│  │ Lexical Environment:            │    │\n│  │ { count: 1 }                    │    │\n│  │ Function: [anonymous function]  │    │\n│  └─────────────────────────────────┘    │\n└─────────────────────────────────────────┘\n```\n\n### Variable Capture vs Reference\n\n**Important**: Closures capture variables by **reference**, not by value:\n\n```javascript\nfunction createFunctions() {\n  const functions = [];\n\n  // Common mistake\n  for (var i = 0; i \u003c 3; i++) {\n    functions.push(function () {\n      console.log(i); // Captures reference to 'i'\n    });\n  }\n\n  return functions;\n}\n\nconst funcs = createFunctions();\nfuncs[0](); // 3 (not 0!)\nfuncs[1](); // 3 (not 1!)\nfuncs[2](); // 3 (not 2!)\n```\n\n**Why this happens:**\n\n```\nAll three functions share the same lexical environment\nthat contains the variable 'i'.\n\nWhen the loop finishes, i = 3.\nAll functions reference the same 'i' variable.\n```\n\n**Solutions:**\n\n**1. Use `let` (block scope):**\n\n```javascript\nfunction createFunctions() {\n  const functions = [];\n\n  for (let i = 0; i \u003c 3; i++) {\n    // 'let' creates new scope each iteration\n    functions.push(function () {\n      console.log(i);\n    });\n  }\n\n  return functions;\n}\n\nconst funcs = createFunctions();\nfuncs[0](); // 0\nfuncs[1](); // 1\nfuncs[2](); // 2\n```\n\n**2. Use IIFE (Immediately Invoked Function Expression):**\n\n```javascript\nfunction createFunctions() {\n  const functions = [];\n\n  for (var i = 0; i \u003c 3; i++) {\n    functions.push(\n      (function (index) {\n        return function () {\n          console.log(index);\n        };\n      })(i)\n    ); // IIFE creates new scope with 'index'\n  }\n\n  return functions;\n}\n```\n\n## Closure Use Cases\n\n### 1. Module Pattern\n\nCreate private variables and methods:\n\n```javascript\nconst Calculator = (function () {\n  // Private variables\n  let history = [];\n  let currentValue = 0;\n\n  // Private methods\n  function addToHistory(operation, value) {\n    history.push(`${operation}: ${value}`);\n  }\n\n  function validateNumber(num) {\n    if (typeof num !== \"number\" || isNaN(num)) {\n      throw new Error(\"Invalid number\");\n    }\n  }\n\n  // Public API\n  return {\n    add(num) {\n      validateNumber(num);\n      currentValue += num;\n      addToHistory(\"ADD\", num);\n      return this; // Method chaining\n    },\n\n    subtract(num) {\n      validateNumber(num);\n      currentValue -= num;\n      addToHistory(\"SUBTRACT\", num);\n      return this;\n    },\n\n    getValue() {\n      return currentValue;\n    },\n\n    getHistory() {\n      return [...history]; // Return copy, not reference\n    },\n\n    clear() {\n      currentValue = 0;\n      history = [];\n      return this;\n    },\n  };\n})();\n\n// Usage\nCalculator.add(10).subtract(3).add(5);\n\nconsole.log(Calculator.getValue()); // 12\nconsole.log(Calculator.getHistory()); // ['ADD: 10', 'SUBTRACT: 3', 'ADD: 5']\n\n// Private variables are not accessible\nconsole.log(Calculator.history); // undefined\n```\n\n### 2. Factory Functions\n\nCreate objects with private state:\n\n```javascript\nfunction createBankAccount(initialBalance = 0) {\n  let balance = initialBalance;\n  let transactionHistory = [];\n\n  function recordTransaction(type, amount) {\n    transactionHistory.push({\n      type,\n      amount,\n      timestamp: new Date(),\n      balanceAfter: balance,\n    });\n  }\n\n  return {\n    deposit(amount) {\n      if (amount \u003c= 0) {\n        throw new Error(\"Deposit amount must be positive\");\n      }\n      balance += amount;\n      recordTransaction(\"DEPOSIT\", amount);\n      return balance;\n    },\n\n    withdraw(amount) {\n      if (amount \u003c= 0) {\n        throw new Error(\"Withdrawal amount must be positive\");\n      }\n      if (amount \u003e balance) {\n        throw new Error(\"Insufficient funds\");\n      }\n      balance -= amount;\n      recordTransaction(\"WITHDRAWAL\", amount);\n      return balance;\n    },\n\n    getBalance() {\n      return balance;\n    },\n\n    getTransactionHistory() {\n      return transactionHistory.map((t) =\u003e ({ ...t })); // Deep copy\n    },\n  };\n}\n\nconst account1 = createBankAccount(100);\nconst account2 = createBankAccount(50);\n\naccount1.deposit(25);\naccount2.withdraw(10);\n\nconsole.log(account1.getBalance()); // 125\nconsole.log(account2.getBalance()); // 40\n\n// Each account has its own private state\nconsole.log(account1.balance); // undefined (private)\n```\n\n### 3. Event Handlers with State\n\nMaintain state in event handlers:\n\n```javascript\nfunction createButtonWithCounter(buttonId) {\n  let clickCount = 0;\n  let lastClickTime = null;\n\n  const button = document.getElementById(buttonId);\n\n  button.addEventListener(\"click\", function (event) {\n    clickCount++;\n    const now = Date.now();\n    const timeSinceLastClick = lastClickTime ? now - lastClickTime : 0;\n\n    console.log(`Button clicked ${clickCount} times`);\n\n    if (timeSinceLastClick \u003e 0) {\n      console.log(`Time since last click: ${timeSinceLastClick}ms`);\n    }\n\n    lastClickTime = now;\n\n    // Update button text with click count\n    button.textContent = `Clicked ${clickCount} times`;\n  });\n\n  return {\n    getClickCount: () =\u003e clickCount,\n    reset: () =\u003e {\n      clickCount = 0;\n      lastClickTime = null;\n      button.textContent = \"Click me\";\n    },\n  };\n}\n\nconst buttonCounter = createButtonWithCounter(\"myButton\");\n```\n\n### 4. Memoization (Caching)\n\nCache expensive function results:\n\n```javascript\nfunction memoize(fn) {\n  const cache = new Map();\n\n  return function (...args) {\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      console.log(\"Cache hit!\");\n      return cache.get(key);\n    }\n\n    console.log(\"Computing result...\");\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Expensive function\nfunction fibonacci(n) {\n  if (n \u003c= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nconst memoizedFibonacci = memoize(fibonacci);\n\nconsole.log(memoizedFibonacci(10)); // Computing result... 55\nconsole.log(memoizedFibonacci(10)); // Cache hit! 55\nconsole.log(memoizedFibonacci(11)); // Computing result... 89\n```\n\n### 5. Partial Application \u0026 Currying\n\nCreate specialized functions:\n\n```javascript\n// Partial Application\nfunction multiply(a, b, c) {\n  return a * b * c;\n}\n\nfunction partial(fn, ...fixedArgs) {\n  return function (...remainingArgs) {\n    return fn(...fixedArgs, ...remainingArgs);\n  };\n}\n\nconst multiplyByTwo = partial(multiply, 2);\nconst multiplyByTwoAndThree = partial(multiply, 2, 3);\n\nconsole.log(multiplyByTwo(3, 4)); // 2 * 3 * 4 = 24\nconsole.log(multiplyByTwoAndThree(5)); // 2 * 3 * 5 = 30\n\n// Currying\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length \u003e= fn.length) {\n      return fn.apply(this, args);\n    } else {\n      return function (...nextArgs) {\n        return curried.apply(this, args.concat(nextArgs));\n      };\n    }\n  };\n}\n\nconst curriedMultiply = curry(multiply);\n\nconsole.log(curriedMultiply(2)(3)(4)); // 24\nconsole.log(curriedMultiply(2, 3)(4)); // 24\nconsole.log(curriedMultiply(2)(3, 4)); // 24\n```\n\n## Memory Management\n\n### Closure Memory Considerations\n\nClosures can lead to memory leaks if not handled properly:\n\n**Problem: Accidental Object Retention**\n\n```javascript\nfunction attachListeners() {\n  const largeObject = new Array(1000000).fill(\"data\");\n\n  document.getElementById(\"button\").addEventListener(\"click\", function () {\n    // This closure keeps largeObject in memory\n    console.log(\"Button clicked\");\n  });\n}\n\nattachListeners();\n// largeObject remains in memory even though it's not used!\n```\n\n**Solution: Explicit Cleanup**\n\n```javascript\nfunction attachListeners() {\n  const largeObject = new Array(1000000).fill(\"data\");\n\n  function clickHandler() {\n    console.log(\"Button clicked\");\n    // Don't reference largeObject here\n  }\n\n  document.getElementById(\"button\").addEventListener(\"click\", clickHandler);\n\n  // Cleanup function\n  return function cleanup() {\n    document\n      .getElementById(\"button\")\n      .removeEventListener(\"click\", clickHandler);\n    // largeObject will be garbage collected\n  };\n}\n\nconst cleanup = attachListeners();\n// Later...\ncleanup();\n```\n\n### Memory Leak Prevention\n\n**1. Avoid Unnecessary Variable Capture**\n\n```javascript\n// BAD: Captures unnecessary variables\nfunction createHandler(data) {\n  const largeArray = new Array(1000000);\n  const someOtherStuff = {\n    /* ... */\n  };\n\n  return function () {\n    console.log(data); // Only needs 'data', but captures everything\n  };\n}\n\n// GOOD: Only capture what you need\nfunction createHandler(data) {\n  const largeArray = new Array(1000000);\n  const someOtherStuff = {\n    /* ... */\n  };\n\n  // Extract only what you need\n  const neededData = data;\n\n  return function () {\n    console.log(neededData);\n  };\n}\n```\n\n**2. Break Circular References**\n\n```javascript\nfunction setupComponent() {\n  const element = document.getElementById(\"component\");\n\n  element.onclick = function () {\n    // Circular reference: element -\u003e function -\u003e element\n    element.style.color = \"red\";\n  };\n\n  // Break the cycle\n  return function cleanup() {\n    element.onclick = null;\n  };\n}\n```\n\n## Visual Diagrams\n\n### Closure Memory Structure\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                    JAVASCRIPT MEMORY                        │\n│                                                             │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │                  CALL STACK                         │    │\n│  │                                                     │    │\n│  │  ┌─────────────────────────────────────────────┐    │    │\n│  │  │        Global Execution Context             │    │    │\n│  │  │                                             │    │    │\n│  │  │  Variables: { counter: [Function] }         │    │    │\n│  │  └─────────────────────────────────────────────┘    │    │\n│  └─────────────────────────────────────────────────────┘    │\n│                                                             │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │                    HEAP MEMORY                      │    │\n│  │                                                     │    │\n│  │  ┌─────────────────────────────────────────────┐    │    │\n│  │  │           Closure Object                    │    │    │\n│  │  │                                             │    │    │\n│  │  │  Lexical Environment:                       │    │    │\n│  │  │  ┌─────────────────────────────────────┐    │    │    │\n│  │  │  │  Variables: { count: 0 }            │    │    │    │\n│  │  │  └─────────────────────────────────────┘    │    │    │\n│  │  │                                             │    │    │\n│  │  │  Function Code:                             │    │    │\n│  │  │  ┌─────────────────────────────────────┐    │    │    │\n│  │  │  │  function() {                       │    │    │    │\n│  │  │  │    count++;                         │    │    │    │\n│  │  │  │    return count;                    │    │    │    │\n│  │  │  │  }                                  │    │    │    │\n│  │  │  └─────────────────────────────────────┘    │    │    │\n│  │  └─────────────────────────────────────────────┘    │    │\n│  └─────────────────────────────────────────────────────┘    │\n│                                                             │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │               REFERENCE CHAIN                       │    │\n│  │                                                     │    │\n│  │  counter variable ──────────→ Closure Object        │    │\n│  │                                    │                │    │\n│  │                                    ▼                │    │\n│  │                           Lexical Environment       │    │\n│  │                                    │                │    │\n│  │                                    ▼                │    │\n│  │                              { count: 0 }           │    │\n│  └─────────────────────────────────────────────────────┘    │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### Scope Chain Resolution\n\n```\nFunction Call: innerFunction()\n\nStep 1: Look in Local Scope\n┌─────────────────────────────────┐\n│   innerFunction Scope           │\n│                                 │\n│   Looking for: variableName     │\n│   Found: [ ] Yes [ ] No         │\n│                                 │\n└─────────────────────────────────┘\n                │\n                ▼ (if not found)\nStep 2: Look in Outer Function Scope\n┌─────────────────────────────────┐\n│   outerFunction Scope           │\n│                                 │\n│   Looking for: variableName     │\n│   Found: [ ] Yes [ ] No         │\n│                                 │\n└─────────────────────────────────┘\n                │\n                ▼ (if not found)\nStep 3: Look in Global Scope\n┌─────────────────────────────────┐\n│   Global Scope                  │\n│                                 │\n│   Looking for: variableName     │\n│   Found: [ ] Yes [ ] No         │\n│                                 │\n└─────────────────────────────────┘\n                │\n                ▼ (if not found)\n        ReferenceError!\n```\n\n## Performance Considerations\n\n### Closure Performance Impact\n\n**1. Memory Usage**\n\n```javascript\n// Each closure instance maintains its own scope\nfunction createCounter() {\n  let count = 0;\n  const largeArray = new Array(1000000); // Each instance has this!\n\n  return function () {\n    return ++count;\n  };\n}\n\n// Creates 1000 closures, each with its own largeArray\nconst counters = Array.from({ length: 1000 }, createCounter);\n```\n\n**2. Garbage Collection**\n\n```javascript\n// Closure prevents garbage collection\nlet globalRef;\n\nfunction createClosure() {\n  const largeData = new Array(1000000).fill(\"data\");\n\n  globalRef = function () {\n    return largeData.length; // Keeps largeData alive\n  };\n}\n\ncreateClosure();\n// largeData cannot be garbage collected while globalRef exists\n```\n\n**3. Performance Optimization**\n\n**Bad: Recreating closures in render**\n\n```javascript\nfunction MyComponent({ items }) {\n  return items.map((item) =\u003e (\n    \u003cbutton\n      key={item.id}\n      onClick={() =\u003e handleClick(item.id)} // New closure each render!\n    \u003e\n      {item.name}\n    \u003c/button\u003e\n  ));\n}\n```\n\n**Good: Memoized or stable references**\n\n```javascript\nfunction MyComponent({ items }) {\n  const handleClick = useCallback((id) =\u003e {\n    // Handle click\n  }, []);\n\n  return items.map((item) =\u003e (\n    \u003cbutton key={item.id} onClick={() =\u003e handleClick(item.id)}\u003e\n      {item.name}\n    \u003c/button\u003e\n  ));\n}\n```\n\n## Interview Questions \u0026 Answers\n\n### Q1: What will this code output and why?\n\n```javascript\nfor (var i = 0; i \u003c 3; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100);\n}\n```\n\n**Answer**: It will output `3` three times.\n\n**Explanation**:\n\n- The `setTimeout` callbacks are executed after the loop completes\n- All three closures capture a reference to the same variable `i`\n- When the callbacks execute, `i` has the value 3 (the final value after the loop)\n\n**Solutions**:\n\n```javascript\n// Solution 1: Use let (block scope)\nfor (let i = 0; i \u003c 3; i++) {\n  setTimeout(function () {\n    console.log(i); // 0, 1, 2\n  }, 100);\n}\n\n// Solution 2: IIFE\nfor (var i = 0; i \u003c 3; i++) {\n  (function (j) {\n    setTimeout(function () {\n      console.log(j); // 0, 1, 2\n    }, 100);\n  })(i);\n}\n\n// Solution 3: bind\nfor (var i = 0; i \u003c 3; i++) {\n  setTimeout(\n    function (j) {\n      console.log(j); // 0, 1, 2\n    }.bind(null, i),\n    100\n  );\n}\n```\n\n### Q2: Explain how this module pattern works:\n\n```javascript\nconst Module = (function () {\n  let privateVar = 0;\n\n  function privateFunction() {\n    console.log(\"Private function called\");\n  }\n\n  return {\n    publicMethod() {\n      privateVar++;\n      privateFunction();\n      return privateVar;\n    },\n\n    getPrivateVar() {\n      return privateVar;\n    },\n  };\n})();\n```\n\n**Answer**:\nThis is the **Module Pattern** using an IIFE (Immediately Invoked Function Expression):\n\n1. **IIFE**: Creates a private scope immediately\n2. **Private variables**: `privateVar` and `privateFunction` are enclosed in the function scope\n3. **Public API**: The returned object exposes only the methods we want to be public\n4. **Closure**: The returned methods maintain access to the private variables\n5. **Encapsulation**: Private variables cannot be accessed directly from outside\n\n**Usage**:\n\n```javascript\nconsole.log(Module.publicMethod()); // 1\nconsole.log(Module.getPrivateVar()); // 1\nconsole.log(Module.privateVar); // undefined (private)\n```\n\n### Q3: What's the difference between these two approaches?\n\n```javascript\n// Approach 1\nfunction createMultiplier(x) {\n  return function (y) {\n    return x * y;\n  };\n}\n\n// Approach 2\nfunction multiply(x, y) {\n  return x * y;\n}\n```\n\n**Answer**:\n\n**Approach 1 (Closure)**:\n\n- Creates a **specialized function** with `x` \"baked in\"\n- Each call to `createMultiplier` creates a new closure\n- Useful for **partial application** and **function specialization**\n- More memory usage (maintains closure scope)\n\n```javascript\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\nconsole.log(double(5)); // 10\nconsole.log(triple(5)); // 15\n```\n\n**Approach 2 (Regular function)**:\n\n- Direct multiplication without closure\n- More **memory efficient**\n- Requires both parameters each time\n- No function specialization\n\n```javascript\nconsole.log(multiply(2, 5)); // 10\nconsole.log(multiply(3, 5)); // 15\n```\n\n### Q4: How do you create private methods in JavaScript?\n\n**Answer**:\n\n**1. Module Pattern with IIFE**:\n\n```javascript\nconst MyModule = (function () {\n  // Private variables and methods\n  let privateCounter = 0;\n\n  function privateMethod() {\n    console.log(\"This is private\");\n  }\n\n  function incrementCounter() {\n    privateCounter++;\n    privateMethod();\n  }\n\n  // Public API\n  return {\n    increment: incrementCounter,\n    getCount() {\n      return privateCounter;\n    },\n  };\n})();\n```\n\n**2. Factory Function**:\n\n```javascript\nfunction createObject() {\n  let privateVar = \"secret\";\n\n  function privateMethod() {\n    return `Accessing ${privateVar}`;\n  }\n\n  return {\n    publicMethod() {\n      return privateMethod();\n    },\n  };\n}\n```\n\n**3. WeakMap Pattern**:\n\n```javascript\nconst privateData = new WeakMap();\n\nclass MyClass {\n  constructor() {\n    privateData.set(this, {\n      secret: \"private value\",\n      privateMethod() {\n        return \"This is private\";\n      },\n    });\n  }\n\n  publicMethod() {\n    const data = privateData.get(this);\n    return data.privateMethod();\n  }\n}\n```\n\n**4. Private Fields (ES2022)**:\n\n```javascript\nclass MyClass {\n  #privateField = \"secret\";\n\n  #privateMethod() {\n    return \"This is private\";\n  }\n\n  publicMethod() {\n    return this.#privateMethod();\n  }\n}\n```\n\n### Q5: Explain memory leaks with closures and how to prevent them.\n\n**Answer**:\n\n**Common Memory Leak Scenarios**:\n\n**1. Event Listeners with Closures**:\n\n```javascript\n// PROBLEM: Memory leak\nfunction setupComponent() {\n  const largeData = new Array(1000000);\n\n  document.getElementById(\"button\").onclick = function () {\n    console.log(\"Clicked\"); // Keeps largeData in memory\n  };\n}\n\n// SOLUTION: Explicit cleanup\nfunction setupComponent() {\n  const largeData = new Array(1000000);\n\n  function clickHandler() {\n    console.log(\"Clicked\");\n    // Don't reference largeData\n  }\n\n  const button = document.getElementById(\"button\");\n  button.onclick = clickHandler;\n\n  return function cleanup() {\n    button.onclick = null;\n    // Now largeData can be garbage collected\n  };\n}\n```\n\n**2. Circular References**:\n\n```javascript\n// PROBLEM: Circular reference\nfunction createNode() {\n  const node = {\n    parent: null,\n    children: [],\n    cleanup: function () {\n      // This creates a circular reference\n      this.parent = null;\n      this.children = [];\n    },\n  };\n\n  return node;\n}\n\n// SOLUTION: WeakMap or explicit cleanup\nconst nodeCleanup = new WeakMap();\n\nfunction createNode() {\n  const node = {\n    parent: null,\n    children: [],\n  };\n\n  nodeCleanup.set(node, function () {\n    node.parent = null;\n    node.children = [];\n  });\n\n  return node;\n}\n```\n\n**Prevention Strategies**:\n\n1. **Remove event listeners** when no longer needed\n2. **Avoid capturing unnecessary variables** in closures\n3. **Use WeakMap** for private data\n4. **Set references to null** when done\n5. **Use tools** like Chrome DevTools Memory tab to detect leaks\n\nThis comprehensive guide covers closures and scope from fundamental concepts to advanced patterns, providing the deep understanding needed for senior frontend engineering interviews.\n\n# Additional Advanced Interview Q\u0026A and Visuals\n\n## Q: How can closures cause memory leaks in JavaScript applications?\n\n**Answer (English):**\n\n- Closures keep references to variables in their scope chain\n- If a closure references large data or DOM nodes, and is attached to a global or long-lived object (e.g., event handler), the data cannot be garbage collected\n- Always clean up event handlers and avoid unnecessary references in closures\n\n**Answer (Vietnamese):**\n\n- Closure giữ tham chiếu tới biến trong scope chain\n- Nếu closure tham chiếu dữ liệu lớn hoặc DOM node, và được gán cho global hoặc object sống lâu (ví dụ event handler), dữ liệu sẽ không được giải phóng bộ nhớ\n- Luôn cleanup event handler và tránh giữ tham chiếu không cần thiết trong closure\n\n---\n\n## Diagram: Closure Memory Leak\n\n```mermaid\nflowchart TD\n  A[Create Closure] --\u003e B[References Large Data]\n  B --\u003e C[Assign to Global/Event Handler]\n  C --\u003e D[Large Data Not GC'd]\n  D --\u003e E[Memory Leak]\n```\n\n---\n\n## Q: How would you use closures to implement a private counter with increment and reset methods?\n\n**Answer (English):**\n\n- Use a factory function that returns an object with methods\n- The counter variable is private in the closure\n\n```javascript\nfunction createCounter() {\n  let count = 0;\n  return {\n    increment() {\n      return ++count;\n    },\n    reset() {\n      count = 0;\n      return count;\n    },\n  };\n}\nconst counter = createCounter();\ncounter.increment(); // 1\ncounter.reset(); // 0\n```\n\n**Answer (Vietnamese):**\n\n- Dùng factory function trả về object chứa các method\n- Biến counter là private trong closure\n\n---\n"])</script><script>self.__next_f.push([1,"9:[\"topic\",\"fundamentals-closure-scope-deep-dive\",\"d\"]\ne:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L3\",null,{\"buildId\":\"2NmUhWiPdVVBzVtDZlggk\",\"assetPrefix\":\"/interview\",\"urlParts\":[\"\",\"learn\",\"fundamentals-closure-scope-deep-dive\"],\"initialTree\":[\"\",{\"children\":[\"learn\",{\"children\":[[\"topic\",\"fundamentals-closure-scope-deep-dive\",\"d\"],{\"children\":[\"__PAGE__?{\\\"topic\\\":\\\"fundamentals-closure-scope-deep-dive\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"learn\",{\"children\":[[\"topic\",\"fundamentals-closure-scope-deep-dive\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",[\"$\",\"div\",null,{\"className\":\"max-w-6xl mx-auto px-8 py-24\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-4 mb-8\",\"children\":[\"$\",\"$L5\",null,{\"href\":\"/learn\",\"children\":[\"$\",\"button\",null,{\"className\":\"flex items-center gap-2 bg-gray-100 border border-gray-300 text-gray-700 px-4 py-3 rounded-md font-medium hover:bg-gray-200 transition-colors\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-arrow-left \",\"children\":[[\"$\",\"path\",\"1l729n\",{\"d\":\"m12 19-7-7 7-7\"}],[\"$\",\"path\",\"x3x0zl\",{\"d\":\"M19 12H5\"}],\"$undefined\"]}],\"Back to Learn\"]}]}]}],[\"$\",\"div\",null,{\"className\":\"bg-white border border-gray-200 rounded-lg p-8 mb-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center justify-between mb-4\",\"children\":[[\"$\",\"h1\",null,{\"className\":\"text-3xl font-bold text-gray-900\",\"children\":\"JavaScript Closures \u0026 Scope: Complete Deep Dive\"}],[\"$\",\"div\",null,{\"className\":\"flex gap-4\",\"children\":[[\"$\",\"button\",null,{\"className\":\"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-star \",\"children\":[[\"$\",\"polygon\",\"8f66p6\",{\"points\":\"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2\"}],\"$undefined\"]}],\"Bookmark\"]}],[\"$\",\"button\",null,{\"className\":\"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-share2 \",\"children\":[[\"$\",\"circle\",\"gq8acd\",{\"cx\":\"18\",\"cy\":\"5\",\"r\":\"3\"}],[\"$\",\"circle\",\"w7nqdw\",{\"cx\":\"6\",\"cy\":\"12\",\"r\":\"3\"}],[\"$\",\"circle\",\"1xt0gg\",{\"cx\":\"18\",\"cy\":\"19\",\"r\":\"3\"}],[\"$\",\"line\",\"47mynk\",{\"x1\":\"8.59\",\"x2\":\"15.42\",\"y1\":\"13.51\",\"y2\":\"17.49\"}],[\"$\",\"line\",\"1n3mei\",{\"x1\":\"15.41\",\"x2\":\"8.59\",\"y1\":\"6.51\",\"y2\":\"10.49\"}],\"$undefined\"]}],\"Share\"]}]]}]]}],[\"$\",\"div\",null,{\"className\":\"flex gap-8 mb-4\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-2 text-sm text-gray-600\",\"children\":[[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":16,\"height\":16,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-clock \",\"children\":[[\"$\",\"circle\",\"1mglay\",{\"cx\":\"12\",\"cy\":\"12\",\"r\":\"10\"}],[\"$\",\"polyline\",\"68esgv\",{\"points\":\"12 6 12 12 16 14\"}],\"$undefined\"]}],\"2-3 hours\"]}],[\"$\",\"span\",null,{\"className\":\"px-3 py-1 rounded-full text-xs font-semibold text-white bg-yellow-500\",\"children\":\"Intermediate\"}],[\"$\",\"span\",null,{\"className\":\"px-3 py-1 rounded-full text-xs font-semibold bg-blue-100 text-blue-700\",\"children\":\"General\"}]]}],false,[\"$\",\"p\",null,{\"className\":\"text-lg text-gray-700 leading-relaxed\",\"children\":\"**Scope** determines the accessibility of variables, functions, and objects in different parts of your code. It defines the **context** in which variables exist and can be accessed....\"}]]}],[\"$\",\"div\",null,{\"className\":\"grid grid-cols-1 lg:grid-cols-3 gap-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"lg:col-span-2\",\"children\":[\"$\",\"div\",null,{\"className\":\"bg-white border border-gray-200 rounded-lg p-8\",\"children\":[\"$\",\"$L6\",null,{\"content\":\"$7\"}]}]}],[\"$\",\"div\",null,{\"className\":\"space-y-6\",\"children\":[[\"$\",\"div\",null,{\"className\":\"bg-white border border-gray-200 rounded-lg p-6\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-lg font-semibold text-gray-900 mb-4\",\"children\":\"Your Progress\"}],[\"$\",\"div\",null,{\"className\":\"w-full bg-gray-200 rounded-full h-2 mb-2\",\"children\":[\"$\",\"div\",null,{\"className\":\"bg-blue-600 h-2 rounded-full\",\"style\":{\"width\":\"25%\"}}]}],[\"$\",\"p\",null,{\"className\":\"text-sm text-gray-600\",\"children\":\"25% Complete\"}]]}],false]}]]}]]}],null],null],null]},[null,[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"learn\",\"children\",\"$9\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"learn\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/interview/_next/static/css/387024c6a2216908.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$Lb\",null,{\"children\":[\"$\",\"$L8\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$La\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}],\"params\":{}}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lc\"],\"globalErrorComponent\":\"$d\",\"missingSlots\":\"$We\"}]\n"])</script><script>self.__next_f.push([1,"c:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"2\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>