2:I[2972,["918","static/chunks/918-3273b83890f10546.js","972","static/chunks/972-011bba60ed155615.js","930","static/chunks/930-3262a6c9c5acace4.js","289","static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js"],""]
3:I[5907,["918","static/chunks/918-3273b83890f10546.js","972","static/chunks/972-011bba60ed155615.js","930","static/chunks/930-3262a6c9c5acace4.js","289","static/chunks/app/learn/%5Btopic%5D/page-4ab144227f7a7b3e.js"],"default"]
5:I[4707,[],""]
7:I[6423,[],""]
8:I[2,["918","static/chunks/918-3273b83890f10546.js","710","static/chunks/710-dfaa11b4dff08f8e.js","972","static/chunks/972-011bba60ed155615.js","233","static/chunks/233-3e0c1d820a17eca9.js","185","static/chunks/app/layout-333f4adcd11f8f39.js"],"default",1]
4:T2a89,
# Construct Binary Tree from Preorder and Inorder Traversal



## Problem Description

 * of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.  *  *  * Companies: Amazon, Google, Microsoft, Facebook  * 

## Solutions

{% raw %}
/**
 * Construct Binary Tree from Preorder and Inorder Traversal
 *
 * Problem: Given two integer arrays preorder and inorder where preorder is the preorder traversal
 * of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.
 *
 * LeetCode: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
 *
 * Companies: Amazon, Google, Microsoft, Facebook
 *
 * Difficulty: Medium
 *
 * Key Concepts: Tree reconstruction, hash map, divide and conquer
 */

/**
 * Definition for a binary tree node.
 */
class TreeNode {
  val: number;
  left: TreeNode | null;
  right: TreeNode | null;

  constructor(
    val: number = 0,
    left: TreeNode | null = null,
    right: TreeNode | null = null
  ) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

/**
 * Solution 1: Hash Map Approach (Optimal)
 *
 * Time Complexity: O(n) - Each node is visited once
 * Space Complexity: O(n) - Hash map storage + recursion stack
 *
 * Approach:
 * 1. Use hash map to store inorder indices for O(1) lookup
 * 2. Use preorder to determine root nodes
 * 3. Use inorder to determine left/right subtree boundaries
 * 4. Recursively build left and right subtrees
 *
 * Thuật toán:
 * 1. Sử dụng hash map để lưu chỉ số inorder cho việc tìm kiếm O(1)
 * 2. Sử dụng preorder để xác định các nút gốc
 * 3. Sử dụng inorder để xác định ranh giới cây con trái/phải
 * 4. Đệ quy xây dựng cây con trái và phải
 */
function buildTree(preorder: number[], inorder: number[]): TreeNode | null {
  // Create hash map for O(1) inorder index lookup
  const inorderMap = new Map<number, number>();
  for (let i = 0; i < inorder.length; i++) {
    inorderMap.set(inorder[i], i);
  }

  let preorderIndex = 0;

  function buildTreeHelper(left: number, right: number): TreeNode | null {
    // Base case: no elements to construct
    if (left > right) return null;

    // Get current root from preorder
    const rootVal = preorder[preorderIndex++];
    const root = new TreeNode(rootVal);

    // Find root position in inorder
    const inorderIndex = inorderMap.get(rootVal)!;

    // Recursively build left and right subtrees
    root.left = buildTreeHelper(left, inorderIndex - 1);
    root.right = buildTreeHelper(inorderIndex + 1, right);

    return root;
  }

  return buildTreeHelper(0, inorder.length - 1);
}

/**
 * Solution 2: Array Slice Approach (Less Efficient)
 *
 * Time Complexity: O(n²) - Array slicing takes O(n) each time
 * Space Complexity: O(n) - Recursion stack + new arrays
 *
 * Approach:
 * 1. Find root from preorder (first element)
 * 2. Find root position in inorder
 * 3. Split arrays into left and right subtrees
 * 4. Recursively build subtrees
 *
 * Thuật toán:
 * 1. Tìm gốc từ preorder (phần tử đầu tiên)
 * 2. Tìm vị trí gốc trong inorder
 * 3. Chia mảng thành cây con trái và phải
 * 4. Đệ quy xây dựng các cây con
 */
function buildTreeArraySlice(
  preorder: number[],
  inorder: number[]
): TreeNode | null {
  if (preorder.length === 0 || inorder.length === 0) return null;

  const rootVal = preorder[0];
  const root = new TreeNode(rootVal);

  // Find root index in inorder
  const rootIndex = inorder.indexOf(rootVal);

  // Build left subtree
  const leftInorder = inorder.slice(0, rootIndex);
  const leftPreorder = preorder.slice(1, 1 + leftInorder.length);
  root.left = buildTreeArraySlice(leftPreorder, leftInorder);

  // Build right subtree
  const rightInorder = inorder.slice(rootIndex + 1);
  const rightPreorder = preorder.slice(1 + leftInorder.length);
  root.right = buildTreeArraySlice(rightPreorder, rightInorder);

  return root;
}

/**
 * Solution 3: Iterative Approach using Stack
 *
 * Time Complexity: O(n)
 * Space Complexity: O(n)
 *
 * Approach:
 * 1. Use stack to keep track of nodes
 * 2. Use preorder to create nodes
 * 3. Use inorder to determine when to pop from stack
 *
 * Thuật toán:
 * 1. Sử dụng stack để theo dõi các nút
 * 2. Sử dụng preorder để tạo các nút
 * 3. Sử dụng inorder để xác định khi nào pop từ stack
 */
function buildTreeIterative(
  preorder: number[],
  inorder: number[]
): TreeNode | null {
  if (preorder.length === 0) return null;

  const root = new TreeNode(preorder[0]);
  const stack: TreeNode[] = [root];
  let inorderIndex = 0;

  for (let i = 1; i < preorder.length; i++) {
    const currentVal = preorder[i];
    let node = stack[stack.length - 1];

    // If current node is not the inorder successor of top of stack
    if (node.val !== inorder[inorderIndex]) {
      node.left = new TreeNode(currentVal);
      stack.push(node.left);
    } else {
      // Pop nodes from stack until we find the right place
      while (
        stack.length > 0 &&
        stack[stack.length - 1].val === inorder[inorderIndex]
      ) {
        node = stack.pop()!;
        inorderIndex++;
      }
      node.right = new TreeNode(currentVal);
      stack.push(node.right);
    }
  }

  return root;
}

/**
 * Utility function to print tree in level order (for testing)
 */
function printTreeLevelOrder(root: TreeNode | null): void {
  if (!root) {
    console.log("Empty tree");
    return;
  }

  const queue: (TreeNode | null)[] = [root];
  const result: (number | null)[] = [];

  while (queue.length > 0) {
    const node = queue.shift();
    if (node) {
      result.push(node.val);
      queue.push(node.left);
      queue.push(node.right);
    } else {
      result.push(null);
    }
  }

  // Remove trailing nulls
  while (result.length > 0 && result[result.length - 1] === null) {
    result.pop();
  }

  console.log("Level order:", result);
}

/**
 * Utility function to get inorder traversal (for verification)
 */
function getInorderTraversal(root: TreeNode | null): number[] {
  const result: number[] = [];

  function inorder(node: TreeNode | null): void {
    if (!node) return;
    inorder(node.left);
    result.push(node.val);
    inorder(node.right);
  }

  inorder(root);
  return result;
}

/**
 * Utility function to get preorder traversal (for verification)
 */
function getPreorderTraversal(root: TreeNode | null): number[] {
  const result: number[] = [];

  function preorder(node: TreeNode | null): void {
    if (!node) return;
    result.push(node.val);
    preorder(node.left);
    preorder(node.right);
  }

  preorder(root);
  return result;
}

// Test cases
function runTests(): void {
  console.log(
    "=== Testing Construct Binary Tree from Preorder and Inorder Traversal ===\n"
  );

  // Test Case 1: Simple tree
  console.log("Test Case 1: Simple tree");
  const preorder1 = [3, 9, 20, 15, 7];
  const inorder1 = [9, 3, 15, 20, 7];

  const tree1 = buildTree(preorder1, inorder1);
  console.log("Preorder input:", preorder1);
  console.log("Inorder input:", inorder1);
  console.log("Generated preorder:", getPreorderTraversal(tree1));
  console.log("Generated inorder:", getInorderTraversal(tree1));
  console.log(
    "Match:",
    JSON.stringify(getPreorderTraversal(tree1)) === JSON.stringify(preorder1) &&
      JSON.stringify(getInorderTraversal(tree1)) === JSON.stringify(inorder1)
  );
  printTreeLevelOrder(tree1);
  console.log();

  // Test Case 2: Single node
  console.log("Test Case 2: Single node");
  const preorder2 = [1];
  const inorder2 = [1];

  const tree2 = buildTree(preorder2, inorder2);
  console.log("Preorder input:", preorder2);
  console.log("Inorder input:", inorder2);
  console.log("Generated preorder:", getPreorderTraversal(tree2));
  console.log("Generated inorder:", getInorderTraversal(tree2));
  console.log(
    "Match:",
    JSON.stringify(getPreorderTraversal(tree2)) === JSON.stringify(preorder2) &&
      JSON.stringify(getInorderTraversal(tree2)) === JSON.stringify(inorder2)
  );
  printTreeLevelOrder(tree2);
  console.log();

  // Test Case 3: Left-skewed tree
  console.log("Test Case 3: Left-skewed tree");
  const preorder3 = [1, 2, 3];
  const inorder3 = [3, 2, 1];

  const tree3 = buildTree(preorder3, inorder3);
  console.log("Preorder input:", preorder3);
  console.log("Inorder input:", inorder3);
  console.log("Generated preorder:", getPreorderTraversal(tree3));
  console.log("Generated inorder:", getInorderTraversal(tree3));
  console.log(
    "Match:",
    JSON.stringify(getPreorderTraversal(tree3)) === JSON.stringify(preorder3) &&
      JSON.stringify(getInorderTraversal(tree3)) === JSON.stringify(inorder3)
  );
  printTreeLevelOrder(tree3);
  console.log();

  // Test Case 4: Right-skewed tree
  console.log("Test Case 4: Right-skewed tree");
  const preorder4 = [1, 2, 3];
  const inorder4 = [1, 2, 3];

  const tree4 = buildTree(preorder4, inorder4);
  console.log("Preorder input:", preorder4);
  console.log("Inorder input:", inorder4);
  console.log("Generated preorder:", getPreorderTraversal(tree4));
  console.log("Generated inorder:", getInorderTraversal(tree4));
  console.log(
    "Match:",
    JSON.stringify(getPreorderTraversal(tree4)) === JSON.stringify(preorder4) &&
      JSON.stringify(getInorderTraversal(tree4)) === JSON.stringify(inorder4)
  );
  printTreeLevelOrder(tree4);
  console.log();

  // Test Case 5: Complex tree
  console.log("Test Case 5: Complex tree");
  const preorder5 = [1, 2, 4, 5, 3, 6];
  const inorder5 = [4, 2, 5, 1, 6, 3];

  const tree5 = buildTree(preorder5, inorder5);
  console.log("Preorder input:", preorder5);
  console.log("Inorder input:", inorder5);
  console.log("Generated preorder:", getPreorderTraversal(tree5));
  console.log("Generated inorder:", getInorderTraversal(tree5));
  console.log(
    "Match:",
    JSON.stringify(getPreorderTraversal(tree5)) === JSON.stringify(preorder5) &&
      JSON.stringify(getInorderTraversal(tree5)) === JSON.stringify(inorder5)
  );
  printTreeLevelOrder(tree5);
  console.log();

  // Performance comparison
  console.log("=== Performance Comparison ===");
  const largePreorder = Array.from({ length: 1000 }, (_, i) => i);
  const largeInorder = [...largePreorder].sort((a, b) => a - b);

  console.time("Hash Map Approach");
  buildTree(largePreorder, largeInorder);
  console.timeEnd("Hash Map Approach");

  console.time("Array Slice Approach");
  buildTreeArraySlice(largePreorder, largeInorder);
  console.timeEnd("Array Slice Approach");

  console.time("Iterative Approach");
  buildTreeIterative(largePreorder, largeInorder);
  console.timeEnd("Iterative Approach");
}

// Run tests
runTests();

export { buildTree, buildTreeArraySlice, buildTreeIterative, TreeNode };
{% endraw %}
6:["topic","tree-graph-problems-08-construct-binary-tree-from-preorder-and-inorder-traversal","d"]
0:["GkGybauu5extr5oVPcZnD",[[["",{"children":["learn",{"children":[["topic","tree-graph-problems-08-construct-binary-tree-from-preorder-and-inorder-traversal","d"],{"children":["__PAGE__?{\"topic\":\"tree-graph-problems-08-construct-binary-tree-from-preorder-and-inorder-traversal\"}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["learn",{"children":[["topic","tree-graph-problems-08-construct-binary-tree-from-preorder-and-inorder-traversal","d"],{"children":["__PAGE__",{},[["$L1",["$","div",null,{"className":"max-w-6xl mx-auto px-8 py-24","children":[["$","div",null,{"className":"flex items-center gap-4 mb-8","children":["$","$L2",null,{"href":"/learn","children":["$","button",null,{"className":"flex items-center gap-2 bg-gray-100 border border-gray-300 text-gray-700 px-4 py-3 rounded-md font-medium hover:bg-gray-200 transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left ","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"Back to Learn"]}]}]}],["$","div",null,{"className":"bg-white border border-gray-200 rounded-lg p-8 mb-8","children":[["$","div",null,{"className":"flex items-center justify-between mb-4","children":[["$","h1",null,{"className":"text-3xl font-bold text-gray-900","children":"Construct Binary Tree from Preorder and Inorder Traversal"}],["$","div",null,{"className":"flex gap-4","children":[["$","button",null,{"className":"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-star ","children":[["$","polygon","8f66p6",{"points":"12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"}],"$undefined"]}],"Bookmark"]}],["$","button",null,{"className":"flex items-center gap-2 bg-transparent text-gray-700 border border-gray-300 px-6 py-3 rounded-md font-semibold hover:bg-gray-50 transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-share2 ","children":[["$","circle","gq8acd",{"cx":"18","cy":"5","r":"3"}],["$","circle","w7nqdw",{"cx":"6","cy":"12","r":"3"}],["$","circle","1xt0gg",{"cx":"18","cy":"19","r":"3"}],["$","line","47mynk",{"x1":"8.59","x2":"15.42","y1":"13.51","y2":"17.49"}],["$","line","1n3mei",{"x1":"15.41","x2":"8.59","y1":"6.51","y2":"10.49"}],"$undefined"]}],"Share"]}]]}]]}],["$","div",null,{"className":"flex gap-8 mb-4","children":[["$","div",null,{"className":"flex items-center gap-2 text-sm text-gray-600","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":16,"height":16,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock ","children":[["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],["$","polyline","68esgv",{"points":"12 6 12 12 16 14"}],"$undefined"]}],"2-3 hours"]}],["$","span",null,{"className":"px-3 py-1 rounded-full text-xs font-semibold text-white bg-red-500","children":"Easy"}],["$","span",null,{"className":"px-3 py-1 rounded-full text-xs font-semibold bg-blue-100 text-blue-700","children":"Tree/Graph"}]]}],["$","div",null,{"className":"flex flex-wrap gap-2 mb-4","children":[["$","span","0",{"className":"bg-gray-100 text-gray-600 px-3 py-1 rounded-md text-xs font-medium","children":"Tree/Graph"}],["$","span","1",{"className":"bg-gray-100 text-gray-600 px-3 py-1 rounded-md text-xs font-medium","children":"Hash Table"}]]}],["$","p",null,{"className":"text-lg text-gray-700 leading-relaxed","children":" * of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.  *  *  * Companies: Amazon, Google, Microsoft, Facebook  * ..."}]]}],["$","div",null,{"className":"grid grid-cols-1 lg:grid-cols-3 gap-8","children":[["$","div",null,{"className":"lg:col-span-2","children":["$","div",null,{"className":"bg-white border border-gray-200 rounded-lg p-8","children":["$","$L3",null,{"content":"$4"}]}]}],["$","div",null,{"className":"space-y-6","children":[["$","div",null,{"className":"bg-white border border-gray-200 rounded-lg p-6","children":[["$","h3",null,{"className":"text-lg font-semibold text-gray-900 mb-4","children":"Your Progress"}],["$","div",null,{"className":"w-full bg-gray-200 rounded-full h-2 mb-2","children":["$","div",null,{"className":"bg-blue-600 h-2 rounded-full","style":{"width":"25%"}}]}],["$","p",null,{"className":"text-sm text-gray-600","children":"25% Complete"}]]}],false]}]]}]]}],null],null],null]},[null,["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","learn","children","$6","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","learn","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/interview/_next/static/css/387024c6a2216908.css","precedence":"next","crossOrigin":"$undefined"}]],["$","$L8",null,{"children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L7",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}],"params":{}}]],null],null],["$L9",null]]]]
9:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","meta","2",{"name":"next-size-adjust"}]]
1:null
