2:I[5907,["918","static/chunks/918-3273b83890f10546.js","930","static/chunks/930-3262a6c9c5acace4.js","687","static/chunks/app/docs/%5B...slug%5D/page-32962e9542d32755.js"],"default"]
4:I[4707,[],""]
6:I[6423,[],""]
7:I[2,["918","static/chunks/918-3273b83890f10546.js","710","static/chunks/710-dfaa11b4dff08f8e.js","972","static/chunks/972-011bba60ed155615.js","233","static/chunks/233-3e0c1d820a17eca9.js","185","static/chunks/app/layout-333f4adcd11f8f39.js"],"default",1]
3:T52ae,# üåê Browser Architecture Deep Dive

## üìã Table of Contents

- [Browser Process Model](#browser-process-model)
- [Rendering Pipeline](#rendering-pipeline)
- [Network Stack](#network-stack)
- [Security Model](#security-model)
- [Performance Optimization](#performance-optimization)
- [Visual Diagrams](#visual-diagrams)

## üèóÔ∏è Browser Process Model

### Multi-Process Architecture

```mermaid
graph TB
    subgraph "Browser Process"
        A[Browser Process] --> B[UI Thread]
        A --> C[Network Thread]
        A --> D[Storage Thread]
    end

    subgraph "Renderer Processes"
        E[Renderer Process 1] --> F[Main Thread]
        E --> G[Compositor Thread]
        E --> H[Raster Thread]

        I[Renderer Process 2] --> J[Main Thread]
        I --> K[Compositor Thread]
        I --> L[Raster Thread]
    end

    subgraph "Utility Processes"
        M[GPU Process] --> N[Hardware Acceleration]
        O[Plugin Process] --> P[Flash, PDF]
        Q[Extension Process] --> R[Browser Extensions]
    end
```

### Process Communication

```mermaid
sequenceDiagram
    participant User
    participant Browser
    participant Renderer
    participant Network
    participant GPU

    User->>Browser: Navigate to URL
    Browser->>Network: Fetch page
    Network-->>Browser: HTML/CSS/JS
    Browser->>Renderer: Create renderer process
    Renderer->>Renderer: Parse & render
    Renderer->>GPU: Composite layers
    GPU-->>Renderer: Display frame
    Renderer-->>Browser: Page ready
    Browser-->>User: Show page
```

## üé® Rendering Pipeline

### Critical Rendering Path

```mermaid
graph LR
    A[HTML] --> B[DOM Tree]
    C[CSS] --> D[CSSOM Tree]
    B --> E[Render Tree]
    D --> E
    E --> F[Layout]
    F --> G[Paint]
    G --> H[Composite]
```

### Detailed Rendering Steps

```mermaid
graph TB
    subgraph "Parsing"
        A[HTML Bytes] --> B[HTML Parser]
        B --> C[DOM Tree]
        D[CSS Bytes] --> E[CSS Parser]
        E --> F[CSSOM Tree]
    end

    subgraph "Rendering"
        C --> G[Render Tree]
        F --> G
        G --> H[Layout]
        H --> I[Paint]
        I --> J[Composite]
    end

    subgraph "JavaScript"
        K[JavaScript] --> L[DOM Manipulation]
        L --> M[Style Recalculation]
        M --> N[Layout Reflow]
        N --> O[Repaint]
        O --> P[Recomposite]
    end
```

### DOM Tree Construction

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <div id="container">
      <h1>Hello World</h1>
      <p>This is a paragraph.</p>
    </div>
  </body>
</html>
```

```mermaid
graph TD
    A[Document] --> B[html]
    B --> C[head]
    B --> D[body]
    C --> E[title]
    D --> F[div#container]
    F --> G[h1]
    F --> H[p]
    G --> I[Text: Hello World]
    H --> J[Text: This is a paragraph]
```

### CSSOM Tree Construction

```css
body {
  font-size: 16px;
  margin: 0;
}

#container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
}

h1 {
  color: #333;
  font-size: 2em;
}

p {
  color: #666;
  line-height: 1.6;
}
```

```mermaid
graph TD
    A[CSSOM] --> B[body]
    A --> C[#container]
    A --> D[h1]
    A --> E[p]

    B --> F[font-size: 16px]
    B --> G[margin: 0]

    C --> H[width: 100%]
    C --> I[max-width: 1200px]
    C --> J[margin: 0 auto]

    D --> K[color: #333]
    D --> L[font-size: 2em]

    E --> M[color: #666]
    E --> N[line-height: 1.6]
```

## üåê Network Stack

### HTTP Request/Response Flow

```mermaid
sequenceDiagram
    participant Browser
    participant DNS
    participant TCP
    participant TLS
    participant Server

    Browser->>DNS: DNS Lookup
    DNS-->>Browser: IP Address
    Browser->>TCP: TCP Handshake
    TCP-->>Browser: Connection Established
    Browser->>TLS: TLS Handshake
    TLS-->>Browser: Encrypted Connection
    Browser->>Server: HTTP Request
    Server-->>Browser: HTTP Response
    Browser->>Browser: Parse Response
```

### Resource Loading Pipeline

```mermaid
graph TB
    subgraph "Resource Discovery"
        A[HTML Parsing] --> B[Resource Discovery]
        B --> C[CSS Files]
        B --> D[JavaScript Files]
        B --> E[Images]
        B --> F[Fonts]
    end

    subgraph "Loading Priority"
        G[Critical Resources] --> H[High Priority]
        I[Non-Critical] --> J[Low Priority]
        K[Lazy Load] --> L[On Demand]
    end

    subgraph "Caching"
        M[Memory Cache] --> N[Disk Cache]
        N --> O[Network Request]
    end
```

### Network Optimization Strategies

```javascript
// 1. Resource Hints
const resourceHints = `
    <!-- DNS Prefetch -->
    <link rel="dns-prefetch" href="//cdn.example.com">
    
    <!-- Preconnect -->
    <link rel="preconnect" href="https://api.example.com">
    
    <!-- Preload Critical Resources -->
    <link rel="preload" href="/critical.css" as="style">
    <link rel="preload" href="/critical.js" as="script">
    
    <!-- Prefetch Non-Critical Resources -->
    <link rel="prefetch" href="/next-page.js">
    
    <!-- Preload Images -->
    <link rel="preload" href="/hero-image.jpg" as="image">
`;

// 2. Service Worker Caching
class CacheManager {
  constructor() {
    this.cacheName = "app-cache-v1";
    this.criticalResources = ["/", "/styles/main.css", "/scripts/app.js"];
  }

  async install(event) {
    const cache = await caches.open(this.cacheName);
    await cache.addAll(this.criticalResources);
  }

  async fetch(event) {
    const cachedResponse = await caches.match(event.request);
    if (cachedResponse) {
      return cachedResponse;
    }

    const networkResponse = await fetch(event.request);
    const cache = await caches.open(this.cacheName);
    cache.put(event.request, networkResponse.clone());

    return networkResponse;
  }
}

// 3. HTTP/2 Server Push
const http2Push = `
    // Server-side (Node.js with HTTP/2)
    const http2 = require('http2');
    const fs = require('fs');
    
    const server = http2.createSecureServer({
        key: fs.readFileSync('key.pem'),
        cert: fs.readFileSync('cert.pem')
    });
    
    server.on('stream', (stream, headers) => {
        if (headers[':path'] === '/') {
            // Push critical CSS
            stream.pushStream({ ':path': '/styles/critical.css' }, (pushStream) => {
                pushStream.respondWithFile('./styles/critical.css');
            });
            
            // Push critical JS
            stream.pushStream({ ':path': '/scripts/critical.js' }, (pushStream) => {
                pushStream.respondWithFile('./scripts/critical.js');
            });
            
            stream.respondWithFile('./index.html');
        }
    });
`;
```

## üîí Security Model

### Same-Origin Policy

```mermaid
graph TB
    subgraph "Same-Origin Policy"
        A[Origin] --> B[Protocol]
        A --> C[Host]
        A --> D[Port]
    end

    subgraph "Cross-Origin Restrictions"
        E[DOM Access] --> F[Blocked]
        G[Cookie Access] --> H[Blocked]
        I[Network Requests] --> J[CORS Required]
    end
```

### Content Security Policy (CSP)

```javascript
// CSP Implementation
const cspHeaders = {
  "Content-Security-Policy": `
        default-src 'self';
        script-src 'self' 'unsafe-inline' https://cdn.example.com;
        style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
        img-src 'self' data: https:;
        font-src 'self' https://fonts.gstatic.com;
        connect-src 'self' https://api.example.com;
        frame-src 'none';
        object-src 'none';
        base-uri 'self';
        form-action 'self';
    `
    .replace(/\s+/g, " ")
    .trim(),
};

// CSP Violation Reporting
const cspReporting = `
    <meta http-equiv="Content-Security-Policy" 
          content="default-src 'self'; report-uri /csp-report">
`;

// CSP Nonce for Inline Scripts
const cspNonce = `
    <script nonce="random-nonce-here">
        // This script is allowed because of the nonce
        console.log('CSP compliant inline script');
    </script>
`;
```

### Cross-Origin Resource Sharing (CORS)

{% raw %}
```javascript
// CORS Implementation
class CORSHandler {
  constructor() {
    this.allowedOrigins = [
      "https://app.example.com",
      "https://admin.example.com",
    ];
    this.allowedMethods = ["GET", "POST", "PUT", "DELETE", "OPTIONS"];
    this.allowedHeaders = ["Content-Type", "Authorization"];
  }

  handleRequest(req, res) {
    const origin = req.headers.origin;

    // Check if origin is allowed
    if (this.allowedOrigins.includes(origin)) {
      res.setHeader("Access-Control-Allow-Origin", origin);
    }

    // Handle preflight requests
    if (req.method === "OPTIONS") {
      res.setHeader(
        "Access-Control-Allow-Methods",
        this.allowedMethods.join(", ")
      );
      res.setHeader(
        "Access-Control-Allow-Headers",
        this.allowedHeaders.join(", ")
      );
      res.setHeader("Access-Control-Max-Age", "86400"); // 24 hours
      res.status(200).end();
      return;
    }

    // Handle actual request
    res.setHeader("Access-Control-Allow-Credentials", "true");
    this.processRequest(req, res);
  }

  processRequest(req, res) {
    // Handle the actual request logic
    res.json({ message: "CORS enabled response" });
  }
}

// Client-side CORS handling
class CORSClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;

    const config = {
      method: "GET",
      credentials: "include", // Include cookies
      headers: {
        "Content-Type": "application/json",
        ...options.headers,
      },
      ...options,
    };

    try {
      const response = await fetch(url, config);

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("CORS request failed:", error);
      throw error;
    }
  }
}
```
{% endraw %}

## ‚ö° Performance Optimization

### Rendering Performance

{% raw %}
```javascript
// 1. Optimize Layout Thrashing
class LayoutOptimizer {
  constructor() {
    this.pendingReads = [];
    this.pendingWrites = [];
    this.scheduled = false;
  }

  // Batch read operations
  read(callback) {
    this.pendingReads.push(callback);
    this.schedule();
  }

  // Batch write operations
  write(callback) {
    this.pendingWrites.push(callback);
    this.schedule();
  }

  schedule() {
    if (!this.scheduled) {
      this.scheduled = true;
      requestAnimationFrame(() => this.flush());
    }
  }

  flush() {
    // Execute all reads first
    this.pendingReads.forEach((callback) => callback());
    this.pendingReads.length = 0;

    // Then execute all writes
    this.pendingWrites.forEach((callback) => callback());
    this.pendingWrites.length = 0;

    this.scheduled = false;
  }
}

// Usage
const optimizer = new LayoutOptimizer();

// ‚ùå Bad: Layout thrashing
function badExample() {
  const elements = document.querySelectorAll(".item");
  elements.forEach((element) => {
    const height = element.offsetHeight; // Read
    element.style.height = height * 2 + "px"; // Write
  });
}

// ‚úÖ Good: Batched operations
function goodExample() {
  const elements = document.querySelectorAll(".item");

  // Batch reads
  optimizer.read(() => {
    elements.forEach((element) => {
      element.dataset.height = element.offsetHeight;
    });
  });

  // Batch writes
  optimizer.write(() => {
    elements.forEach((element) => {
      const height = element.dataset.height;
      element.style.height = height * 2 + "px";
    });
  });
}

// 2. Virtual Scrolling
class VirtualScroller {
  constructor(container, itemHeight, totalItems) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.totalItems = totalItems;
    this.visibleItems = Math.ceil(container.clientHeight / itemHeight);
    this.scrollTop = 0;
    this.startIndex = 0;
    this.endIndex = this.visibleItems;

    this.setup();
  }

  setup() {
    // Create viewport
    this.viewport = document.createElement("div");
    this.viewport.style.height = `${this.totalItems * this.itemHeight}px`;
    this.viewport.style.position = "relative";

    // Create visible items container
    this.visibleContainer = document.createElement("div");
    this.visibleContainer.style.position = "absolute";
    this.visibleContainer.style.top = "0";
    this.visibleContainer.style.left = "0";
    this.visibleContainer.style.right = "0";

    this.viewport.appendChild(this.visibleContainer);
    this.container.appendChild(this.viewport);

    // Add scroll listener
    this.container.addEventListener("scroll", this.handleScroll.bind(this));

    this.render();
  }

  handleScroll() {
    this.scrollTop = this.container.scrollTop;
    this.updateVisibleRange();
    this.render();
  }

  updateVisibleRange() {
    this.startIndex = Math.floor(this.scrollTop / this.itemHeight);
    this.endIndex = Math.min(
      this.startIndex + this.visibleItems + 1,
      this.totalItems
    );
  }

  render() {
    this.visibleContainer.innerHTML = "";
    this.visibleContainer.style.transform = `translateY(${
      this.startIndex * this.itemHeight
    }px)`;

    for (let i = this.startIndex; i < this.endIndex; i++) {
      const item = this.createItem(i);
      this.visibleContainer.appendChild(item);
    }
  }

  createItem(index) {
    const item = document.createElement("div");
    item.style.height = `${this.itemHeight}px`;
    item.textContent = `Item ${index + 1}`;
    return item;
  }
}

// 3. Intersection Observer for Lazy Loading
class LazyLoader {
  constructor() {
    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      {
        rootMargin: "50px",
        threshold: 0.1,
      }
    );
  }

  observe(element) {
    this.observer.observe(element);
  }

  handleIntersection(entries) {
    entries.forEach((entry) => {
      if (entry.isIntersecting) {
        this.loadContent(entry.target);
        this.observer.unobserve(entry.target);
      }
    });
  }

  loadContent(element) {
    const src = element.dataset.src;
    if (src) {
      if (element.tagName === "IMG") {
        element.src = src;
      } else if (element.tagName === "IFRAME") {
        element.src = src;
      }
      element.removeAttribute("data-src");
    }
  }
}

// Usage
const lazyLoader = new LazyLoader();
document.querySelectorAll("[data-src]").forEach((element) => {
  lazyLoader.observe(element);
});
```
{% endraw %}

## üéØ Memory Management

### Memory Leaks Prevention

```javascript
// 1. Event Listener Cleanup
class EventManager {
  constructor() {
    this.listeners = new Map();
  }

  addListener(element, event, handler) {
    if (!this.listeners.has(element)) {
      this.listeners.set(element, new Map());
    }

    const elementListeners = this.listeners.get(element);
    if (!elementListeners.has(event)) {
      elementListeners.set(event, []);
    }

    elementListeners.get(event).push(handler);
    element.addEventListener(event, handler);
  }

  removeListener(element, event, handler) {
    const elementListeners = this.listeners.get(element);
    if (elementListeners) {
      const handlers = elementListeners.get(event);
      if (handlers) {
        const index = handlers.indexOf(handler);
        if (index > -1) {
          handlers.splice(index, 1);
          element.removeEventListener(event, handler);
        }
      }
    }
  }

  cleanup(element) {
    const elementListeners = this.listeners.get(element);
    if (elementListeners) {
      elementListeners.forEach((handlers, event) => {
        handlers.forEach((handler) => {
          element.removeEventListener(event, handler);
        });
      });
      this.listeners.delete(element);
    }
  }
}

// 2. WeakMap for Caching
class CacheManager {
  constructor() {
    this.cache = new WeakMap();
  }

  set(key, value) {
    this.cache.set(key, value);
  }

  get(key) {
    return this.cache.get(key);
  }

  has(key) {
    return this.cache.has(key);
  }

  // No need for cleanup - WeakMap automatically removes entries
  // when the key object is garbage collected
}

// 3. AbortController for Cancellable Requests
class RequestManager {
  constructor() {
    this.controllers = new Map();
  }

  async request(url, options = {}) {
    const controller = new AbortController();
    this.controllers.set(url, controller);

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
      });

      this.controllers.delete(url);
      return response;
    } catch (error) {
      if (error.name === "AbortError") {
        console.log("Request was cancelled");
      }
      throw error;
    }
  }

  cancel(url) {
    const controller = this.controllers.get(url);
    if (controller) {
      controller.abort();
      this.controllers.delete(url);
    }
  }

  cancelAll() {
    this.controllers.forEach((controller) => controller.abort());
    this.controllers.clear();
  }
}
```

## üìä Performance Monitoring

### Real User Monitoring (RUM)

{% raw %}
```javascript
class PerformanceMonitor {
  constructor() {
    this.metrics = {};
    this.init();
  }

  init() {
    // Core Web Vitals
    this.observeLCP();
    this.observeFID();
    this.observeCLS();

    // Custom metrics
    this.observeCustomMetrics();

    // Error tracking
    this.observeErrors();
  }

  observeLCP() {
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      this.metrics.lcp = lastEntry.startTime;
      this.reportMetric("LCP", lastEntry.startTime);
    }).observe({ entryTypes: ["largest-contentful-paint"] });
  }

  observeFID() {
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        this.metrics.fid = entry.processingStart - entry.startTime;
        this.reportMetric("FID", this.metrics.fid);
      });
    }).observe({ entryTypes: ["first-input"] });
  }

  observeCLS() {
    let clsValue = 0;
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      });
      this.metrics.cls = clsValue;
      this.reportMetric("CLS", clsValue);
    }).observe({ entryTypes: ["layout-shift"] });
  }

  observeCustomMetrics() {
    // Custom timing
    performance.mark("app-start");

    // Measure app initialization
    window.addEventListener("load", () => {
      performance.mark("app-loaded");
      performance.measure("app-init", "app-start", "app-loaded");

      const measure = performance.getEntriesByName("app-init")[0];
      this.reportMetric("AppInit", measure.duration);
    });
  }

  observeErrors() {
    window.addEventListener("error", (event) => {
      this.reportError("JavaScript Error", {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
      });
    });

    window.addEventListener("unhandledrejection", (event) => {
      this.reportError("Unhandled Promise Rejection", {
        reason: event.reason,
      });
    });
  }

  reportMetric(name, value) {
    // Send to analytics service
    console.log(`Metric: ${name} = ${value}`);

    // You could send this to Google Analytics, custom analytics, etc.
    if (window.gtag) {
      window.gtag("event", "performance", {
        metric_name: name,
        metric_value: value,
      });
    }
  }

  reportError(type, details) {
    console.error(`Error: ${type}`, details);

    // Send to error tracking service
    if (window.Sentry) {
      window.Sentry.captureException(new Error(type), {
        extra: details,
      });
    }
  }

  getMetrics() {
    return {
      ...this.metrics,
      navigation: performance.getEntriesByType("navigation")[0],
      memory: performance.memory,
    };
  }
}

// Usage
const monitor = new PerformanceMonitor();

// Get metrics after page load
window.addEventListener("load", () => {
  setTimeout(() => {
    console.log("Performance Metrics:", monitor.getMetrics());
  }, 1000);
});
```
{% endraw %}

---

## üéØ Summary

Understanding browser architecture helps you:

1. **Optimize performance** by leveraging browser capabilities
2. **Debug issues** more effectively
3. **Write more efficient code** that works with the browser's rendering pipeline
4. **Implement security best practices** to protect users
5. **Monitor and improve** real-world performance

### Key Takeaways

- **Multi-process architecture** provides security and stability
- **Rendering pipeline** affects performance and user experience
- **Network optimization** reduces loading times
- **Security model** protects users from malicious code
- **Memory management** prevents leaks and improves performance

### Next Steps

1. **Profile your applications** using browser DevTools
2. **Monitor Core Web Vitals** in production
3. **Implement performance optimizations** based on browser capabilities
4. **Stay updated** with browser features and best practices
5:["slug","theory-and-visuals/browser-architecture","c"]
0:["GkGybauu5extr5oVPcZnD",[[["",{"children":["docs",{"children":[["slug","theory-and-visuals/browser-architecture","c"],{"children":["__PAGE__?{\"slug\":[\"theory-and-visuals\",\"browser-architecture\"]}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["docs",{"children":[["slug","theory-and-visuals/browser-architecture","c"],{"children":["__PAGE__",{},[["$L1",["$","div",null,{"style":{"maxWidth":"1200px","margin":"0 auto","padding":"2rem","paddingTop":"6rem"},"children":[["$","div",null,{"style":{"marginBottom":"2rem"},"children":[["$","nav",null,{"style":{"color":"#64748b","fontSize":"0.9rem","marginBottom":"1rem"},"children":[["$","a",null,{"href":"/interview","style":{"color":"#3b82f6","textDecoration":"none"},"children":"Home"}]," > ",["$","span",null,{"children":"theory-and-visuals > browser-architecture"}]]}],["$","h1",null,{"style":{"fontSize":"2.5rem","fontWeight":"800","marginBottom":"0.5rem","color":"#1e293b"},"children":"Browser Architecture"}],["$","div",null,{"style":{"color":"#64748b","fontSize":"0.9rem","marginBottom":"2rem"},"children":[["$","span",null,{"children":["üìÅ ","theory-and-visuals/browser-architecture.md"]}],"$undefined","$undefined"]}]]}],["$","$L2",null,{"content":"$3"}]]}],null],null],null]},[null,["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","docs","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","docs","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/interview/_next/static/css/387024c6a2216908.css","precedence":"next","crossOrigin":"$undefined"}]],["$","$L7",null,{"children":["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}],"params":{}}]],null],null],["$L8",null]]]]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Browser Architecture - Frontend Interview Docs"}],["$","meta","3",{"name":"description","content":"# üåê Browser Architecture Deep Dive  ## üìã Table of Contents  - [Browser Process Model](#browser-process-model) - [Rendering Pipeline](#rendering-pipeline) - [N"}],["$","meta","4",{"property":"og:title","content":"Browser Architecture - Frontend Interview Docs"}],["$","meta","5",{"property":"og:description","content":"# üåê Browser Architecture Deep Dive  ## üìã Table of Contents  - [Browser Process Model](#browser-process-model) - [Rendering Pipeline](#rendering-pipeline) - [N"}],["$","meta","6",{"property":"og:type","content":"article"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"Browser Architecture - Frontend Interview Docs"}],["$","meta","9",{"name":"twitter:description","content":"# üåê Browser Architecture Deep Dive  ## üìã Table of Contents  - [Browser Process Model](#browser-process-model) - [Rendering Pipeline](#rendering-pipeline) - [N"}],["$","meta","10",{"name":"next-size-adjust"}]]
1:null
