<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/interview/_next/static/css/387024c6a2216908.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js"/><script src="/interview/_next/static/chunks/fd9d1056-6922f449a204c2cc.js" async=""></script><script src="/interview/_next/static/chunks/117-e7ecc085ce9cfab3.js" async=""></script><script src="/interview/_next/static/chunks/main-app-b06be5f3411c20c3.js" async=""></script><script src="/interview/_next/static/chunks/918-3273b83890f10546.js" async=""></script><script src="/interview/_next/static/chunks/930-3262a6c9c5acace4.js" async=""></script><script src="/interview/_next/static/chunks/app/docs/%5B...slug%5D/page-036ada1d0a865043.js" async=""></script><script src="/interview/_next/static/chunks/710-dfaa11b4dff08f8e.js" async=""></script><script src="/interview/_next/static/chunks/972-011bba60ed155615.js" async=""></script><script src="/interview/_next/static/chunks/233-3e0c1d820a17eca9.js" async=""></script><script src="/interview/_next/static/chunks/app/layout-333f4adcd11f8f39.js" async=""></script><title>Frontend Interview Prep 2025 - Big Tech Interview Guide</title><meta name="description" content="Comprehensive frontend interview preparation for Big Tech companies including React, TypeScript, algorithms, and system design."/><link rel="icon" href="/favicon.ico"/><meta name="theme-color" content="#1a1a1a"/><meta property="og:title" content="Frontend Interview Prep 2025"/><meta property="og:description" content="Complete guide for frontend engineers targeting Big Tech companies"/><meta property="og:type" content="website"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><title>Algorithms Data Structures Frontend - Frontend Interview Docs</title><meta name="description" content="# Algorithms &amp; Data Structures for Frontend  ## Overview Frontend engineers need strong algorithmic thinking for optimization, data manipulation, and building e"/><meta property="og:title" content="Algorithms Data Structures Frontend - Frontend Interview Docs"/><meta property="og:description" content="# Algorithms &amp; Data Structures for Frontend  ## Overview Frontend engineers need strong algorithmic thinking for optimization, data manipulation, and building e"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Algorithms Data Structures Frontend - Frontend Interview Docs"/><meta name="twitter:description" content="# Algorithms &amp; Data Structures for Frontend  ## Overview Frontend engineers need strong algorithmic thinking for optimization, data manipulation, and building e"/><meta name="next-size-adjust"/><script src="/interview/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script><style data-styled="" data-styled-version="6.1.19">*{margin:0;padding:0;box-sizing:border-box;}/*!sc*/
html{font-size:16px;line-height:1.5;scroll-behavior:smooth;}/*!sc*/
body{font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;font-size:1rem;line-height:1.5;color:#1e293b;background-color:#ffffff;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
h1,h2,h3,h4,h5,h6{font-weight:700;line-height:1.25;margin-bottom:0.5em;}/*!sc*/
h1{font-size:3rem;}/*!sc*/
@media (max-width: 768px){h1{font-size:2.25rem;}}/*!sc*/
h2{font-size:2.25rem;}/*!sc*/
@media (max-width: 768px){h2{font-size:1.875rem;}}/*!sc*/
h3{font-size:1.875rem;}/*!sc*/
@media (max-width: 768px){h3{font-size:1.5rem;}}/*!sc*/
h4{font-size:1.5rem;}/*!sc*/
@media (max-width: 768px){h4{font-size:1.25rem;}}/*!sc*/
h5{font-size:1.25rem;}/*!sc*/
h6{font-size:1.125rem;}/*!sc*/
p{margin-bottom:1rem;line-height:1.75;}/*!sc*/
a{color:#3b82f6;text-decoration:none;transition:color 0.15s ease;}/*!sc*/
a:hover{color:#2563eb;}/*!sc*/
a:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
button{cursor:pointer;border:none;background:none;font-family:inherit;font-size:inherit;}/*!sc*/
button:disabled{cursor:not-allowed;opacity:0.6;}/*!sc*/
button:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
input,textarea,select{font-family:inherit;font-size:inherit;}/*!sc*/
input:focus,textarea:focus,select:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
img{max-width:100%;height:auto;}/*!sc*/
ul,ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
li{margin-bottom:0.25rem;}/*!sc*/
blockquote{margin:1rem 0;padding:1rem;border-left:4px solid #3b82f6;background-color:#f1f5f9;font-style:italic;}/*!sc*/
code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;background-color:#f1f5f9;padding:0.2em 0.4em;border-radius:0.25rem;}/*!sc*/
pre{background-color:#f1f5f9;padding:1rem;border-radius:0.5rem;overflow-x:auto;margin-bottom:1rem;}/*!sc*/
pre code{background:none;padding:0;}/*!sc*/
table{width:100%;border-collapse:collapse;margin-bottom:1rem;}/*!sc*/
th,td{padding:0.75rem;text-align:left;border-bottom:1px solid #e2e8f0;}/*!sc*/
th{font-weight:600;background-color:#f1f5f9;}/*!sc*/
.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0;}/*!sc*/
.skip-link{position:absolute;top:-40px;left:6px;background:#3b82f6;color:white;padding:8px;text-decoration:none;border-radius:4px;z-index:100;}/*!sc*/
.skip-link:focus{top:6px;}/*!sc*/
::-webkit-scrollbar{width:8px;height:8px;}/*!sc*/
::-webkit-scrollbar-track{background:#f1f5f9;}/*!sc*/
::-webkit-scrollbar-thumb{background:#94a3b8;border-radius:4px;}/*!sc*/
::-webkit-scrollbar-thumb:hover{background:#64748b;}/*!sc*/
::selection{background:#3b82f6;color:white;}/*!sc*/
.focus-visible{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
.fade-in{opacity:0;animation:fadeIn 0.3s ease forwards;}/*!sc*/
.slide-up{transform:translateY(20px);opacity:0;animation:slideUp 0.3s ease forwards;}/*!sc*/
@keyframes fadeIn{to{opacity:1;}}/*!sc*/
@keyframes slideUp{to{transform:translateY(0);opacity:1;}}/*!sc*/
@media print{*{background:white!important;color:black!important;box-shadow:none!important;text-shadow:none!important;}a,a:visited{text-decoration:underline;}h1,h2,h3,h4,h5,h6{break-after:avoid;}pre,blockquote{border:1px solid #999;break-inside:avoid;}img{max-width:100%!important;}@page{margin:0.5in;}}/*!sc*/
data-styled.g21[id="sc-global-kxA-Ddz1"]{content:"sc-global-kxA-Ddz1,"}/*!sc*/
.iIQwfN{position:fixed;top:0;width:100%;z-index:1020;background:transparent;backdrop-filter:blur(10px);border-bottom:1px solid transparent;transition:all 0.3s ease;}/*!sc*/
data-styled.g22[id="sc-gGKoUb"]{content:"iIQwfN,"}/*!sc*/
.cEuiWg{max-width:1200px;margin:0 auto;padding:0 2rem;display:flex;align-items:center;justify-content:space-between;height:70px;}/*!sc*/
data-styled.g23[id="sc-hwddKA"]{content:"cEuiWg,"}/*!sc*/
.bqPomF{display:flex;align-items:center;gap:0.5rem;font-size:1.5rem;font-weight:700;color:#3b82f6;text-decoration:none;cursor:pointer;}/*!sc*/
.bqPomF:hover{color:#2563eb;}/*!sc*/
data-styled.g24[id="sc-jaXbil"]{content:"bqPomF,"}/*!sc*/
.iwwpNe{display:flex;align-items:center;gap:2rem;}/*!sc*/
@media (max-width: 768px){.iwwpNe{display:none;}}/*!sc*/
data-styled.g25[id="sc-eqNDNG"]{content:"iwwpNe,"}/*!sc*/
.iuGltB{color:#1e293b;font-weight:500;text-decoration:none;transition:color 0.15s ease;position:relative;}/*!sc*/
.iuGltB:hover{color:#3b82f6;}/*!sc*/
.iuGltB:after{content:'';position:absolute;bottom:-5px;left:0;width:0;height:2px;background:#3b82f6;transition:width 0.15s ease;}/*!sc*/
.iuGltB:hover:after{width:100%;}/*!sc*/
data-styled.g26[id="sc-fVHBlr"]{content:"iuGltB,"}/*!sc*/
.lmsDAj{display:none;background:none;border:none;color:#1e293b;cursor:pointer;padding:0.5rem;}/*!sc*/
@media (max-width: 768px){.lmsDAj{display:block;}}/*!sc*/
data-styled.g27[id="sc-gLaqbQ"]{content:"lmsDAj,"}/*!sc*/
.keTsRT{display:flex;align-items:center;gap:0.5rem;background:#f1f5f9;border:1px solid #e2e8f0;border-radius:0.5rem;padding:0.5rem 1rem;color:#64748b;font-size:0.9rem;transition:all 0.15s ease;}/*!sc*/
.keTsRT:hover{background:#ffffff;border-color:#3b82f6;}/*!sc*/
data-styled.g31[id="sc-cOpnSz"]{content:"keTsRT,"}/*!sc*/
.hrfQfY{background:#1e293b;color:white;padding:3rem 0 1rem;margin-top:auto;}/*!sc*/
data-styled.g32[id="sc-kjwdDK"]{content:"hrfQfY,"}/*!sc*/
.dwFHjZ{max-width:1200px;margin:0 auto;padding:0 2rem;}/*!sc*/
data-styled.g33[id="sc-eVqvcJ"]{content:"dwFHjZ,"}/*!sc*/
.kWATso{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:2rem;margin-bottom:2rem;}/*!sc*/
@media (max-width: 768px){.kWATso{grid-template-columns:1fr 1fr;gap:1.5rem;}}/*!sc*/
@media (max-width: 480px){.kWATso{grid-template-columns:1fr;}}/*!sc*/
data-styled.g34[id="sc-bbbBoY"]{content:"kWATso,"}/*!sc*/
.fBmmqS h3{font-size:1.1rem;font-weight:600;margin-bottom:1rem;color:white;}/*!sc*/
.fBmmqS ul{list-style:none;padding:0;margin:0;}/*!sc*/
.fBmmqS li{margin-bottom:0.5rem;}/*!sc*/
.fBmmqS a{color:rgba(255, 255, 255, 0.7);text-decoration:none;transition:color 0.15s ease;}/*!sc*/
.fBmmqS a:hover{color:white;}/*!sc*/
data-styled.g35[id="sc-cdmAjP"]{content:"fBmmqS,"}/*!sc*/
.iNKxsb{display:flex;align-items:center;gap:0.5rem;font-size:1.2rem;font-weight:700;margin-bottom:1rem;color:white;}/*!sc*/
data-styled.g36[id="sc-jytpVa"]{content:"iNKxsb,"}/*!sc*/
.fYhkiV{color:rgba(255, 255, 255, 0.7);line-height:1.6;margin-bottom:1rem;}/*!sc*/
data-styled.g37[id="sc-eknHtZ"]{content:"fYhkiV,"}/*!sc*/
.eVAQiq{display:flex;gap:1rem;}/*!sc*/
.eVAQiq a{display:flex;align-items:center;justify-content:center;width:40px;height:40px;background:rgba(255, 255, 255, 0.1);border-radius:0.5rem;color:rgba(255, 255, 255, 0.7);transition:all 0.15s ease;}/*!sc*/
.eVAQiq a:hover{background:rgba(255, 255, 255, 0.2);color:white;}/*!sc*/
data-styled.g38[id="sc-pYNGo"]{content:"eVAQiq,"}/*!sc*/
.fgJmHp{border-top:1px solid rgba(255, 255, 255, 0.1);padding-top:2rem;display:flex;justify-content:space-between;align-items:center;}/*!sc*/
@media (max-width: 768px){.fgJmHp{flex-direction:column;gap:1rem;text-align:center;}}/*!sc*/
data-styled.g39[id="sc-cCVJLD"]{content:"fgJmHp,"}/*!sc*/
.gYGLHT{color:rgba(255, 255, 255, 0.7);margin:0;font-size:0.9rem;}/*!sc*/
data-styled.g40[id="sc-jYczwO"]{content:"gYGLHT,"}/*!sc*/
.ghBULZ{display:flex;gap:2rem;}/*!sc*/
@media (max-width: 480px){.ghBULZ{flex-direction:column;gap:1rem;}}/*!sc*/
.ghBULZ a{color:rgba(255, 255, 255, 0.7);text-decoration:none;font-size:0.9rem;transition:color 0.15s ease;}/*!sc*/
.ghBULZ a:hover{color:white;}/*!sc*/
data-styled.g41[id="sc-dNFkOE"]{content:"ghBULZ,"}/*!sc*/
.AtpPI{color:#1e293b;line-height:1.6;}/*!sc*/
.AtpPI h1,.AtpPI h2,.AtpPI h3,.AtpPI h4,.AtpPI h5,.AtpPI h6{color:#1e293b;margin-top:2rem;margin-bottom:1rem;font-weight:600;}/*!sc*/
.AtpPI h1{font-size:2rem;border-bottom:2px solid #e2e8f0;padding-bottom:0.5rem;}/*!sc*/
.AtpPI h2{font-size:1.5rem;border-bottom:1px solid #e2e8f0;padding-bottom:0.3rem;}/*!sc*/
.AtpPI h3{font-size:1.25rem;}/*!sc*/
.AtpPI h4{font-size:1.1rem;}/*!sc*/
.AtpPI p{margin-bottom:1rem;color:#64748b;}/*!sc*/
.AtpPI a{color:#3b82f6;text-decoration:none;}/*!sc*/
.AtpPI a:hover{text-decoration:underline;}/*!sc*/
.AtpPI ul,.AtpPI ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
.AtpPI ul li,.AtpPI ol li{margin-bottom:0.5rem;color:#64748b;}/*!sc*/
.AtpPI blockquote{border-left:4px solid #3b82f6;padding-left:1rem;margin:1rem 0;font-style:italic;color:#64748b;background:#f1f5f9;padding:1rem;border-radius:0.5rem;}/*!sc*/
.AtpPI code{background:#f1f5f9;padding:0.2rem 0.4rem;border-radius:0.25rem;font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;color:#f59e0b;}/*!sc*/
.AtpPI pre{background:#ffffff;border:1px solid #e2e8f0;border-radius:0.5rem;padding:1rem;margin:1rem 0;overflow-x:auto;}/*!sc*/
.AtpPI pre code{background:none;padding:0;color:#1e293b;font-size:0.9rem;}/*!sc*/
.AtpPI table{width:100%;border-collapse:collapse;margin:1rem 0;}/*!sc*/
.AtpPI table th,.AtpPI table td{border:1px solid #e2e8f0;padding:0.5rem;text-align:left;}/*!sc*/
.AtpPI table th{background:#ffffff;font-weight:600;}/*!sc*/
.AtpPI table tr:nth-child(even){background:#f1f5f9;}/*!sc*/
.AtpPI hr{border:none;height:1px;background:#e2e8f0;margin:2rem 0;}/*!sc*/
.AtpPI .highlight{background:#3b82f620;padding:0.2rem 0.4rem;border-radius:0.25rem;font-weight:600;}/*!sc*/
.AtpPI .hljs{background:#ffffff;color:#1e293b;}/*!sc*/
.AtpPI .hljs-keyword{color:#3b82f6;font-weight:600;}/*!sc*/
.AtpPI .hljs-string{color:#10b981;}/*!sc*/
.AtpPI .hljs-function{color:#f59e0b;}/*!sc*/
.AtpPI .hljs-comment{color:#94a3b8;font-style:italic;}/*!sc*/
.AtpPI .hljs-number{color:#f59e0b;}/*!sc*/
.AtpPI .hljs-variable{color:#1e293b;}/*!sc*/
.AtpPI .hljs-title{color:#f59e0b;font-weight:600;}/*!sc*/
data-styled.g42[id="sc-fszimp"]{content:"AtpPI,"}/*!sc*/
</style></head><body class="__className_6eac61"><div style="min-height:100vh;display:flex;flex-direction:column"><nav class="sc-gGKoUb iIQwfN"><div class="sc-hwddKA cEuiWg"><a href="/interview"><a class="sc-jaXbil bqPomF"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</a></a><div class="sc-eqNDNG iwwpNe"><a href="/interview/problems"><a class="sc-fVHBlr iuGltB">Problems</a></a><a href="/interview/learn"><a class="sc-fVHBlr iuGltB">Learn</a></a><a href="/interview/study-guide"><a class="sc-fVHBlr iuGltB">Study Guide</a></a><a href="/interview/system-design"><a class="sc-fVHBlr iuGltB">System Design</a></a><a href="/interview/performance"><a class="sc-fVHBlr iuGltB">Performance</a></a><a href="/interview/accessibility"><a class="sc-fVHBlr iuGltB">Accessibility</a></a><a href="/interview/interview-tips"><a class="sc-fVHBlr iuGltB">Interview Tips</a></a><button class="sc-cOpnSz keTsRT"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search "><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg>Search</button></div><button class="sc-gLaqbQ lmsDAj"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu "><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button></div></nav><main style="flex:1"><div style="max-width:1200px;margin:0 auto;padding:2rem;padding-top:6rem"><div style="margin-bottom:2rem"><nav style="color:#64748b;font-size:0.9rem;margin-bottom:1rem"><a href="/interview" style="color:#3b82f6;text-decoration:none">Home</a> &gt; <span>frontend &gt; fundamentals &gt; algorithms-data-structures-frontend</span></nav><h1 style="font-size:2.5rem;font-weight:800;margin-bottom:0.5rem;color:#1e293b">Algorithms Data Structures Frontend</h1><div style="color:#64748b;font-size:0.9rem;margin-bottom:2rem"><span>üìÅ <!-- -->frontend/fundamentals/algorithms-data-structures-frontend.md</span></div></div><div class="sc-fszimp AtpPI"><h1 id="algorithms-&amp;-data-structures-for-frontend" node="[object Object]">Algorithms &amp; Data Structures for Frontend</h1>
<h2 id="overview" node="[object Object]">Overview</h2>
<p>Frontend engineers need strong algorithmic thinking for optimization, data manipulation, and building efficient user interfaces. This guide covers essential algorithms and data structures with frontend-specific applications.</p>
<hr/>
<h2 id="essential-data-structures-for-frontend" node="[object Object]">Essential Data Structures for Frontend</h2>
<h3 id="[object-object]" node="[object Object]"><strong>Advanced Array Manipulation</strong></h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Frontend-specific array algorithms and optimizations</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FrontendArrayAlgorithms</span> {
  
  <span class="hljs-comment">// Virtual scrolling algorithm for large lists</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">virtualScrolling</span>(<span class="hljs-params">items, containerHeight, itemHeight, scrollTop</span>) {
    <span class="hljs-keyword">const</span> totalItems = items.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">const</span> visibleCount = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">ceil</span>(containerHeight / itemHeight);
    <span class="hljs-keyword">const</span> bufferSize = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">5</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(visibleCount / <span class="hljs-number">2</span>));
    
    <span class="hljs-keyword">const</span> startIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(scrollTop / itemHeight) - bufferSize);
    <span class="hljs-keyword">const</span> endIndex = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(totalItems - <span class="hljs-number">1</span>, startIndex + visibleCount + bufferSize * <span class="hljs-number">2</span>);
    
    <span class="hljs-keyword">const</span> visibleItems = items.<span class="hljs-title function_">slice</span>(startIndex, endIndex + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> offsetY = startIndex * itemHeight;
    <span class="hljs-keyword">const</span> totalHeight = totalItems * itemHeight;
    
    <span class="hljs-keyword">return</span> {
      visibleItems,
      startIndex,
      endIndex,
      offsetY,
      totalHeight,
      <span class="hljs-attr">spacerTop</span>: offsetY,
      <span class="hljs-attr">spacerBottom</span>: totalHeight - (endIndex + <span class="hljs-number">1</span>) * itemHeight
    };
  }

  <span class="hljs-comment">// Efficient filtering for real-time search</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">fuzzySearch</span>(<span class="hljs-params">items, query, keys = [<span class="hljs-string">&#x27;name&#x27;</span>]</span>) {
    <span class="hljs-keyword">if</span> (!query.<span class="hljs-title function_">trim</span>()) <span class="hljs-keyword">return</span> items;
    
    <span class="hljs-keyword">const</span> queryTerms = query.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">term</span> =&gt;</span> term.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>);
    
    <span class="hljs-keyword">const</span> results = items.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> {
      <span class="hljs-keyword">let</span> score = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">let</span> matches = <span class="hljs-number">0</span>;
      
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> keys) {
        <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">String</span>(item[key] || <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">toLowerCase</span>();
        
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> term <span class="hljs-keyword">of</span> queryTerms) {
          <span class="hljs-comment">// Exact match bonus</span>
          <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">includes</span>(term)) {
            score += term.<span class="hljs-property">length</span> * <span class="hljs-number">10</span>;
            matches++;
          }
          
          <span class="hljs-comment">// Fuzzy match</span>
          <span class="hljs-keyword">const</span> fuzzyScore = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fuzzyMatchScore</span>(value, term);
          <span class="hljs-keyword">if</span> (fuzzyScore &gt; <span class="hljs-number">0.5</span>) {
            score += fuzzyScore * <span class="hljs-number">5</span>;
            matches++;
          }
        }
      }
      
      <span class="hljs-keyword">return</span> {
        item,
        <span class="hljs-attr">score</span>: matches &gt; <span class="hljs-number">0</span> ? score / queryTerms.<span class="hljs-property">length</span> : <span class="hljs-number">0</span>,
        matches
      };
    });
    
    <span class="hljs-keyword">return</span> results
      .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result.<span class="hljs-property">score</span> &gt; <span class="hljs-number">0</span>)
      .<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">score</span> - a.<span class="hljs-property">score</span>)
      .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> result.<span class="hljs-property">item</span>);
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">fuzzyMatchScore</span>(<span class="hljs-params">text, pattern</span>) {
    <span class="hljs-keyword">const</span> textLen = text.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">const</span> patternLen = pattern.<span class="hljs-property">length</span>;
    
    <span class="hljs-keyword">if</span> (patternLen === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (patternLen &gt; textLen) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Dynamic programming approach</span>
    <span class="hljs-keyword">const</span> dp = <span class="hljs-title class_">Array</span>(patternLen + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(textLen + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));
    
    <span class="hljs-comment">// Initialize base cases</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt;= textLen; j++) {
      dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">1</span>;
    }
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= patternLen; i++) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = i; j &lt;= textLen; j++) {
        <span class="hljs-keyword">if</span> (pattern[i - <span class="hljs-number">1</span>] === text[j - <span class="hljs-number">1</span>]) {
          dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];
        } <span class="hljs-keyword">else</span> {
          dp[i][j] = dp[i][j - <span class="hljs-number">1</span>] * <span class="hljs-number">0.9</span>; <span class="hljs-comment">// Penalty for skipping characters</span>
        }
      }
    }
    
    <span class="hljs-keyword">return</span> dp[patternLen][textLen];
  }

  <span class="hljs-comment">// Efficient grouping for data visualization</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">groupByWithAggregation</span>(<span class="hljs-params">items, groupKey, aggregations = {}</span>) {
    <span class="hljs-keyword">const</span> groups = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> items) {
      <span class="hljs-keyword">const</span> key = <span class="hljs-keyword">typeof</span> groupKey === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title function_">groupKey</span>(item) : item[groupKey];
      
      <span class="hljs-keyword">if</span> (!groups.<span class="hljs-title function_">has</span>(key)) {
        groups.<span class="hljs-title function_">set</span>(key, {
          key,
          <span class="hljs-attr">items</span>: [],
          <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
          <span class="hljs-attr">aggregates</span>: {}
        });
      }
      
      <span class="hljs-keyword">const</span> group = groups.<span class="hljs-title function_">get</span>(key);
      group.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(item);
      group.<span class="hljs-property">count</span>++;
      
      <span class="hljs-comment">// Calculate aggregations</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [aggKey, aggConfig] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(aggregations)) {
        <span class="hljs-keyword">const</span> { field, type } = aggConfig;
        <span class="hljs-keyword">const</span> value = <span class="hljs-keyword">typeof</span> field === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title function_">field</span>(item) : item[field];
        
        <span class="hljs-keyword">if</span> (!group.<span class="hljs-property">aggregates</span>[aggKey]) {
          group.<span class="hljs-property">aggregates</span>[aggKey] = type === <span class="hljs-string">&#x27;avg&#x27;</span> ? { <span class="hljs-attr">sum</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> } : 
                                     type === <span class="hljs-string">&#x27;min&#x27;</span> ? <span class="hljs-title class_">Infinity</span> :
                                     type === <span class="hljs-string">&#x27;max&#x27;</span> ? -<span class="hljs-title class_">Infinity</span> : <span class="hljs-number">0</span>;
        }
        
        <span class="hljs-keyword">switch</span> (type) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;sum&#x27;</span>:
            group.<span class="hljs-property">aggregates</span>[aggKey] += value || <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;avg&#x27;</span>:
            group.<span class="hljs-property">aggregates</span>[aggKey].<span class="hljs-property">sum</span> += value || <span class="hljs-number">0</span>;
            group.<span class="hljs-property">aggregates</span>[aggKey].<span class="hljs-property">count</span>++;
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;min&#x27;</span>:
            group.<span class="hljs-property">aggregates</span>[aggKey] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(group.<span class="hljs-property">aggregates</span>[aggKey], value || <span class="hljs-number">0</span>);
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;max&#x27;</span>:
            group.<span class="hljs-property">aggregates</span>[aggKey] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(group.<span class="hljs-property">aggregates</span>[aggKey], value || <span class="hljs-number">0</span>);
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;count&#x27;</span>:
            group.<span class="hljs-property">aggregates</span>[aggKey]++;
            <span class="hljs-keyword">break</span>;
        }
      }
    }
    
    <span class="hljs-comment">// Finalize average calculations</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> group <span class="hljs-keyword">of</span> groups.<span class="hljs-title function_">values</span>()) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [aggKey, aggConfig] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(aggregations)) {
        <span class="hljs-keyword">if</span> (aggConfig.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;avg&#x27;</span> &amp;&amp; group.<span class="hljs-property">aggregates</span>[aggKey]) {
          <span class="hljs-keyword">const</span> { sum, count } = group.<span class="hljs-property">aggregates</span>[aggKey];
          group.<span class="hljs-property">aggregates</span>[aggKey] = count &gt; <span class="hljs-number">0</span> ? sum / count : <span class="hljs-number">0</span>;
        }
      }
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(groups.<span class="hljs-title function_">values</span>());
  }

  <span class="hljs-comment">// Optimized sorting for UI tables</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">multiColumnSort</span>(<span class="hljs-params">items, sortConfigs</span>) {
    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">slice</span>().<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> config <span class="hljs-keyword">of</span> sortConfigs) {
        <span class="hljs-keyword">const</span> { key, direction = <span class="hljs-string">&#x27;asc&#x27;</span>, type = <span class="hljs-string">&#x27;string&#x27;</span> } = config;
        
        <span class="hljs-keyword">let</span> valueA = <span class="hljs-keyword">typeof</span> key === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title function_">key</span>(a) : a[key];
        <span class="hljs-keyword">let</span> valueB = <span class="hljs-keyword">typeof</span> key === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title function_">key</span>(b) : b[key];
        
        <span class="hljs-comment">// Handle null/undefined values</span>
        <span class="hljs-keyword">if</span> (valueA == <span class="hljs-literal">null</span> &amp;&amp; valueB == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span> (valueA == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> direction === <span class="hljs-string">&#x27;asc&#x27;</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (valueB == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> direction === <span class="hljs-string">&#x27;asc&#x27;</span> ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
        
        <span class="hljs-comment">// Type-specific comparison</span>
        <span class="hljs-keyword">let</span> comparison = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">switch</span> (type) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;number&#x27;</span>:
            comparison = <span class="hljs-title class_">Number</span>(valueA) - <span class="hljs-title class_">Number</span>(valueB);
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;date&#x27;</span>:
            comparison = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(valueA) - <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(valueB);
            <span class="hljs-keyword">break</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;string&#x27;</span>:
          <span class="hljs-attr">default</span>:
            comparison = <span class="hljs-title class_">String</span>(valueA).<span class="hljs-title function_">localeCompare</span>(<span class="hljs-title class_">String</span>(valueB));
            <span class="hljs-keyword">break</span>;
        }
        
        <span class="hljs-keyword">if</span> (comparison !== <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> direction === <span class="hljs-string">&#x27;asc&#x27;</span> ? comparison : -comparison;
        }
      }
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    });
  }

  <span class="hljs-comment">// Efficient pagination with cursor-based approach</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">paginateWithCursor</span>(<span class="hljs-params">items, cursor = <span class="hljs-literal">null</span>, pageSize = <span class="hljs-number">10</span>, sortKey = <span class="hljs-string">&#x27;id&#x27;</span></span>) {
    <span class="hljs-keyword">let</span> startIndex = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">if</span> (cursor) {
      startIndex = items.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> 
        (<span class="hljs-keyword">typeof</span> sortKey === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title function_">sortKey</span>(item) : item[sortKey]) &gt; cursor
      );
      <span class="hljs-keyword">if</span> (startIndex === -<span class="hljs-number">1</span>) startIndex = items.<span class="hljs-property">length</span>;
    }
    
    <span class="hljs-keyword">const</span> pageItems = items.<span class="hljs-title function_">slice</span>(startIndex, startIndex + pageSize);
    <span class="hljs-keyword">const</span> hasNext = startIndex + pageSize &lt; items.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">const</span> nextCursor = hasNext &amp;&amp; pageItems.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> ?
      (<span class="hljs-keyword">typeof</span> sortKey === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title function_">sortKey</span>(pageItems[pageItems.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]) : 
       pageItems[pageItems.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>][sortKey]) : <span class="hljs-literal">null</span>;
    
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">items</span>: pageItems,
      hasNext,
      nextCursor,
      <span class="hljs-attr">totalCount</span>: items.<span class="hljs-property">length</span>,
      pageSize
    };
  }
}
</code></pre></pre>
<h3 id="[object-object]" node="[object Object]"><strong>Tree Structures for UI Components</strong></h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Tree data structures for hierarchical UI components</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UITreeStructures</span> {
  
  <span class="hljs-comment">// Tree structure for nested menus/navigation</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">buildNavigationTree</span>(<span class="hljs-params">flatItems, parentKey = <span class="hljs-string">&#x27;parentId&#x27;</span>, idKey = <span class="hljs-string">&#x27;id&#x27;</span></span>) {
    <span class="hljs-keyword">const</span> itemMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> rootItems = [];
    
    <span class="hljs-comment">// First pass: create lookup map</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> flatItems) {
      itemMap.<span class="hljs-title function_">set</span>(item[idKey], { ...item, <span class="hljs-attr">children</span>: [] });
    }
    
    <span class="hljs-comment">// Second pass: build tree structure</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> flatItems) {
      <span class="hljs-keyword">const</span> treeItem = itemMap.<span class="hljs-title function_">get</span>(item[idKey]);
      <span class="hljs-keyword">const</span> parentId = item[parentKey];
      
      <span class="hljs-keyword">if</span> (parentId &amp;&amp; itemMap.<span class="hljs-title function_">has</span>(parentId)) {
        itemMap.<span class="hljs-title function_">get</span>(parentId).<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(treeItem);
      } <span class="hljs-keyword">else</span> {
        rootItems.<span class="hljs-title function_">push</span>(treeItem);
      }
    }
    
    <span class="hljs-keyword">return</span> rootItems;
  }

  <span class="hljs-comment">// Tree traversal for component hierarchy</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">traverseComponentTree</span>(<span class="hljs-params">rootComponent, callback, traversalType = <span class="hljs-string">&#x27;preorder&#x27;</span></span>) {
    <span class="hljs-keyword">const</span> results = [];
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">preorderTraversal</span> = (<span class="hljs-params">component, depth = <span class="hljs-number">0</span>, path = []</span>) =&gt; {
      <span class="hljs-keyword">const</span> currentPath = [...path, component.<span class="hljs-property">id</span> || component.<span class="hljs-property">name</span>];
      <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">callback</span>(component, depth, currentPath);
      <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">undefined</span>) results.<span class="hljs-title function_">push</span>(result);
      
      <span class="hljs-keyword">if</span> (component.<span class="hljs-property">children</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> component.<span class="hljs-property">children</span>) {
          <span class="hljs-title function_">preorderTraversal</span>(child, depth + <span class="hljs-number">1</span>, currentPath);
        }
      }
    };
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">postorderTraversal</span> = (<span class="hljs-params">component, depth = <span class="hljs-number">0</span>, path = []</span>) =&gt; {
      <span class="hljs-keyword">const</span> currentPath = [...path, component.<span class="hljs-property">id</span> || component.<span class="hljs-property">name</span>];
      
      <span class="hljs-keyword">if</span> (component.<span class="hljs-property">children</span>) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> component.<span class="hljs-property">children</span>) {
          <span class="hljs-title function_">postorderTraversal</span>(child, depth + <span class="hljs-number">1</span>, currentPath);
        }
      }
      
      <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">callback</span>(component, depth, currentPath);
      <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">undefined</span>) results.<span class="hljs-title function_">push</span>(result);
    };
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">levelOrderTraversal</span> = (<span class="hljs-params">rootComponent</span>) =&gt; {
      <span class="hljs-keyword">const</span> queue = [{ <span class="hljs-attr">component</span>: rootComponent, <span class="hljs-attr">depth</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">path</span>: [] }];
      
      <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">const</span> { component, depth, path } = queue.<span class="hljs-title function_">shift</span>();
        <span class="hljs-keyword">const</span> currentPath = [...path, component.<span class="hljs-property">id</span> || component.<span class="hljs-property">name</span>];
        
        <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">callback</span>(component, depth, currentPath);
        <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">undefined</span>) results.<span class="hljs-title function_">push</span>(result);
        
        <span class="hljs-keyword">if</span> (component.<span class="hljs-property">children</span>) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> component.<span class="hljs-property">children</span>) {
            queue.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">component</span>: child, <span class="hljs-attr">depth</span>: depth + <span class="hljs-number">1</span>, <span class="hljs-attr">path</span>: currentPath });
          }
        }
      }
    };
    
    <span class="hljs-keyword">switch</span> (traversalType) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;preorder&#x27;</span>:
        <span class="hljs-title function_">preorderTraversal</span>(rootComponent);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;postorder&#x27;</span>:
        <span class="hljs-title function_">postorderTraversal</span>(rootComponent);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;levelorder&#x27;</span>:
        <span class="hljs-title function_">levelOrderTraversal</span>(rootComponent);
        <span class="hljs-keyword">break</span>;
    }
    
    <span class="hljs-keyword">return</span> results;
  }

  <span class="hljs-comment">// Find node in tree with path tracking</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">findNodeWithPath</span>(<span class="hljs-params">tree, predicate, path = []</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">predicate</span>(tree)) {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">node</span>: tree, <span class="hljs-attr">path</span>: [...path, tree] };
    }
    
    <span class="hljs-keyword">if</span> (tree.<span class="hljs-property">children</span>) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> tree.<span class="hljs-property">children</span>) {
        <span class="hljs-keyword">const</span> result = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">findNodeWithPath</span>(child, predicate, [...path, tree]);
        <span class="hljs-keyword">if</span> (result) <span class="hljs-keyword">return</span> result;
      }
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-comment">// Tree diffing algorithm for efficient updates</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">diffTrees</span>(<span class="hljs-params">oldTree, newTree, options = {}</span>) {
    <span class="hljs-keyword">const</span> { 
      keyProperty = <span class="hljs-string">&#x27;id&#x27;</span>,
      compareProperties = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>]
    } = options;
    
    <span class="hljs-keyword">const</span> changes = [];
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">diff</span> = (<span class="hljs-params">oldNode, newNode, path = []</span>) =&gt; {
      <span class="hljs-keyword">const</span> currentPath = [...path];
      
      <span class="hljs-keyword">if</span> (!oldNode &amp;&amp; newNode) {
        <span class="hljs-comment">// Node added</span>
        changes.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD&#x27;</span>,
          <span class="hljs-attr">path</span>: currentPath,
          <span class="hljs-attr">node</span>: newNode
        });
        <span class="hljs-keyword">return</span>;
      }
      
      <span class="hljs-keyword">if</span> (oldNode &amp;&amp; !newNode) {
        <span class="hljs-comment">// Node removed</span>
        changes.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;REMOVE&#x27;</span>,
          <span class="hljs-attr">path</span>: currentPath,
          <span class="hljs-attr">node</span>: oldNode
        });
        <span class="hljs-keyword">return</span>;
      }
      
      <span class="hljs-keyword">if</span> (!oldNode &amp;&amp; !newNode) <span class="hljs-keyword">return</span>;
      
      <span class="hljs-comment">// Check for property changes</span>
      <span class="hljs-keyword">const</span> propertyChanges = {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">of</span> compareProperties) {
        <span class="hljs-keyword">if</span> (oldNode[prop] !== newNode[prop]) {
          propertyChanges[prop] = {
            <span class="hljs-attr">old</span>: oldNode[prop],
            <span class="hljs-attr">new</span>: newNode[prop]
          };
        }
      }
      
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(propertyChanges).<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        changes.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;UPDATE&#x27;</span>,
          <span class="hljs-attr">path</span>: currentPath,
          <span class="hljs-attr">changes</span>: propertyChanges
        });
      }
      
      <span class="hljs-comment">// Diff children</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">diffChildren</span>(
        oldNode.<span class="hljs-property">children</span> || [],
        newNode.<span class="hljs-property">children</span> || [],
        [...currentPath, newNode[keyProperty]],
        keyProperty,
        changes
      );
    };
    
    <span class="hljs-title function_">diff</span>(oldTree, newTree);
    <span class="hljs-keyword">return</span> changes;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">diffChildren</span>(<span class="hljs-params">oldChildren, newChildren, path, keyProperty, changes</span>) {
    <span class="hljs-keyword">const</span> oldMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> newMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    
    <span class="hljs-comment">// Create lookup maps</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> oldChildren) {
      oldMap.<span class="hljs-title function_">set</span>(child[keyProperty], child);
    }
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> newChildren) {
      newMap.<span class="hljs-title function_">set</span>(child[keyProperty], child);
    }
    
    <span class="hljs-comment">// Find added, removed, and updated children</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, newChild] <span class="hljs-keyword">of</span> newMap) {
      <span class="hljs-keyword">const</span> oldChild = oldMap.<span class="hljs-title function_">get</span>(key);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">diffTrees</span>(oldChild, newChild, [...path, key]);
    }
    
    <span class="hljs-comment">// Find removed children</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, oldChild] <span class="hljs-keyword">of</span> oldMap) {
      <span class="hljs-keyword">if</span> (!newMap.<span class="hljs-title function_">has</span>(key)) {
        changes.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;REMOVE&#x27;</span>,
          <span class="hljs-attr">path</span>: [...path, key],
          <span class="hljs-attr">node</span>: oldChild
        });
      }
    }
  }

  <span class="hljs-comment">// Virtualized tree rendering for large hierarchies</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">virtualizeTree</span>(<span class="hljs-params">tree, visibleRange, itemHeight</span>) {
    <span class="hljs-keyword">const</span> flattenedNodes = [];
    <span class="hljs-keyword">const</span> expandedNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">flatten</span> = (<span class="hljs-params">node, depth = <span class="hljs-number">0</span>, parentExpanded = <span class="hljs-literal">true</span></span>) =&gt; {
      <span class="hljs-keyword">if</span> (!parentExpanded) <span class="hljs-keyword">return</span>;
      
      flattenedNodes.<span class="hljs-title function_">push</span>({
        ...node,
        depth,
        <span class="hljs-attr">index</span>: flattenedNodes.<span class="hljs-property">length</span>,
        <span class="hljs-attr">hasChildren</span>: node.<span class="hljs-property">children</span> &amp;&amp; node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>,
        <span class="hljs-attr">isExpanded</span>: expandedNodes.<span class="hljs-title function_">has</span>(node.<span class="hljs-property">id</span>)
      });
      
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">children</span> &amp;&amp; expandedNodes.<span class="hljs-title function_">has</span>(node.<span class="hljs-property">id</span>)) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> node.<span class="hljs-property">children</span>) {
          <span class="hljs-title function_">flatten</span>(child, depth + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);
        }
      }
    };
    
    <span class="hljs-title function_">flatten</span>(tree);
    
    <span class="hljs-keyword">const</span> { startIndex, endIndex } = visibleRange;
    <span class="hljs-keyword">const</span> visibleNodes = flattenedNodes.<span class="hljs-title function_">slice</span>(startIndex, endIndex + <span class="hljs-number">1</span>);
    
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">totalHeight</span>: flattenedNodes.<span class="hljs-property">length</span> * itemHeight,
      visibleNodes,
      <span class="hljs-attr">totalCount</span>: flattenedNodes.<span class="hljs-property">length</span>,
      <span class="hljs-attr">toggleExpanded</span>: <span class="hljs-function">(<span class="hljs-params">nodeId</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (expandedNodes.<span class="hljs-title function_">has</span>(nodeId)) {
          expandedNodes.<span class="hljs-title function_">delete</span>(nodeId);
        } <span class="hljs-keyword">else</span> {
          expandedNodes.<span class="hljs-title function_">add</span>(nodeId);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">virtualizeTree</span>(tree, visibleRange, itemHeight);
      }
    };
  }
}
</code></pre></pre>
<hr/>
<h2 id="graph-algorithms-for-frontend" node="[object Object]">Graph Algorithms for Frontend</h2>
<h3 id="[object-object]" node="[object Object]"><strong>Component Dependency Resolution</strong></h3>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Graph algorithms for managing component dependencies and relationships</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FrontendGraphAlgorithms</span> {
  
  <span class="hljs-comment">// Topological sort for component loading order</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">topologicalSort</span>(<span class="hljs-params">dependencies</span>) {
    <span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> inDegree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> result = [];
    
    <span class="hljs-comment">// Build graph and calculate in-degrees</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [component, deps] <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(dependencies)) {
      <span class="hljs-keyword">if</span> (!graph.<span class="hljs-title function_">has</span>(component)) {
        graph.<span class="hljs-title function_">set</span>(component, []);
        inDegree.<span class="hljs-title function_">set</span>(component, <span class="hljs-number">0</span>);
      }
      
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> dep <span class="hljs-keyword">of</span> deps) {
        <span class="hljs-keyword">if</span> (!graph.<span class="hljs-title function_">has</span>(dep)) {
          graph.<span class="hljs-title function_">set</span>(dep, []);
          inDegree.<span class="hljs-title function_">set</span>(dep, <span class="hljs-number">0</span>);
        }
        
        graph.<span class="hljs-title function_">get</span>(dep).<span class="hljs-title function_">push</span>(component);
        inDegree.<span class="hljs-title function_">set</span>(component, inDegree.<span class="hljs-title function_">get</span>(component) + <span class="hljs-number">1</span>);
      }
    }
    
    <span class="hljs-comment">// Kahn&#x27;s algorithm</span>
    <span class="hljs-keyword">const</span> queue = [];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [component, degree] <span class="hljs-keyword">of</span> inDegree) {
      <span class="hljs-keyword">if</span> (degree === <span class="hljs-number">0</span>) {
        queue.<span class="hljs-title function_">push</span>(component);
      }
    }
    
    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> current = queue.<span class="hljs-title function_">shift</span>();
      result.<span class="hljs-title function_">push</span>(current);
      
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> graph.<span class="hljs-title function_">get</span>(current) || []) {
        inDegree.<span class="hljs-title function_">set</span>(neighbor, inDegree.<span class="hljs-title function_">get</span>(neighbor) - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span> (inDegree.<span class="hljs-title function_">get</span>(neighbor) === <span class="hljs-number">0</span>) {
          queue.<span class="hljs-title function_">push</span>(neighbor);
        }
      }
    }
    
    <span class="hljs-comment">// Check for circular dependencies</span>
    <span class="hljs-keyword">if</span> (result.<span class="hljs-property">length</span> !== inDegree.<span class="hljs-property">size</span>) {
      <span class="hljs-keyword">const</span> remaining = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(inDegree.<span class="hljs-title function_">keys</span>()).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">k</span> =&gt;</span> !result.<span class="hljs-title function_">includes</span>(k));
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Circular dependency detected: <span class="hljs-subst">${remaining.join(<span class="hljs-string">&#x27;, &#x27;</span>)}</span>`</span>);
    }
    
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-comment">// Find strongly connected components for circular dependency detection</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">findStronglyConnectedComponents</span>(<span class="hljs-params">graph</span>) {
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    <span class="hljs-keyword">const</span> stack = [];
    <span class="hljs-keyword">const</span> components = [];
    
    <span class="hljs-comment">// First DFS to fill stack</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">dfs1</span> = (<span class="hljs-params">node</span>) =&gt; {
      visited.<span class="hljs-title function_">add</span>(node);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> graph.<span class="hljs-title function_">get</span>(node) || []) {
        <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(neighbor)) {
          <span class="hljs-title function_">dfs1</span>(neighbor);
        }
      }
      stack.<span class="hljs-title function_">push</span>(node);
    };
    
    <span class="hljs-comment">// Build reverse graph</span>
    <span class="hljs-keyword">const</span> reverseGraph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [node, neighbors] <span class="hljs-keyword">of</span> graph) {
      <span class="hljs-keyword">if</span> (!reverseGraph.<span class="hljs-title function_">has</span>(node)) {
        reverseGraph.<span class="hljs-title function_">set</span>(node, []);
      }
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">if</span> (!reverseGraph.<span class="hljs-title function_">has</span>(neighbor)) {
          reverseGraph.<span class="hljs-title function_">set</span>(neighbor, []);
        }
        reverseGraph.<span class="hljs-title function_">get</span>(neighbor).<span class="hljs-title function_">push</span>(node);
      }
    }
    
    <span class="hljs-comment">// Second DFS on reverse graph</span>
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">dfs2</span> = (<span class="hljs-params">node, component</span>) =&gt; {
      visited.<span class="hljs-title function_">add</span>(node);
      component.<span class="hljs-title function_">push</span>(node);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> reverseGraph.<span class="hljs-title function_">get</span>(node) || []) {
        <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(neighbor)) {
          <span class="hljs-title function_">dfs2</span>(neighbor, component);
        }
      }
    };
    
    <span class="hljs-comment">// Process all nodes</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> node <span class="hljs-keyword">of</span> graph.<span class="hljs-title function_">keys</span>()) {
      <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(node)) {
        <span class="hljs-title function_">dfs1</span>(node);
      }
    }
    
    visited.<span class="hljs-title function_">clear</span>();
    
    <span class="hljs-keyword">while</span> (stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> node = stack.<span class="hljs-title function_">pop</span>();
      <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(node)) {
        <span class="hljs-keyword">const</span> component = [];
        <span class="hljs-title function_">dfs2</span>(node, component);
        components.<span class="hljs-title function_">push</span>(component);
      }
    }
    
    <span class="hljs-keyword">return</span> components;
  }

  <span class="hljs-comment">// Shortest path for component communication</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">findShortestPath</span>(<span class="hljs-params">graph, start, end</span>) {
    <span class="hljs-keyword">if</span> (start === end) <span class="hljs-keyword">return</span> [start];
    
    <span class="hljs-keyword">const</span> queue = [[start]];
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([start]);
    
    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> path = queue.<span class="hljs-title function_">shift</span>();
      <span class="hljs-keyword">const</span> current = path[path.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
      
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> graph.<span class="hljs-title function_">get</span>(current) || []) {
        <span class="hljs-keyword">if</span> (neighbor === end) {
          <span class="hljs-keyword">return</span> [...path, neighbor];
        }
        
        <span class="hljs-keyword">if</span> (!visited.<span class="hljs-title function_">has</span>(neighbor)) {
          visited.<span class="hljs-title function_">add</span>(neighbor);
          queue.<span class="hljs-title function_">push</span>([...path, neighbor]);
        }
      }
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// No path found</span>
  }

  <span class="hljs-comment">// Component hierarchy analysis using graph traversal</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">analyzeComponentHierarchy</span>(<span class="hljs-params">componentTree</span>) {
    <span class="hljs-keyword">const</span> analysis = {
      <span class="hljs-attr">depth</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">breadth</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">totalComponents</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">leafComponents</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">componentsByLevel</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(),
      <span class="hljs-attr">cyclomaticComplexity</span>: <span class="hljs-number">0</span>
    };
    
    <span class="hljs-keyword">const</span> queue = [{ <span class="hljs-attr">component</span>: componentTree, <span class="hljs-attr">level</span>: <span class="hljs-number">0</span> }];
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    
    <span class="hljs-keyword">while</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> { component, level } = queue.<span class="hljs-title function_">shift</span>();
      
      <span class="hljs-keyword">if</span> (visited.<span class="hljs-title function_">has</span>(component.<span class="hljs-property">id</span>)) {
        analysis.<span class="hljs-property">cyclomaticComplexity</span>++; <span class="hljs-comment">// Potential cycle</span>
        <span class="hljs-keyword">continue</span>;
      }
      
      visited.<span class="hljs-title function_">add</span>(component.<span class="hljs-property">id</span>);
      analysis.<span class="hljs-property">totalComponents</span>++;
      analysis.<span class="hljs-property">depth</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(analysis.<span class="hljs-property">depth</span>, level);
      
      <span class="hljs-keyword">if</span> (!analysis.<span class="hljs-property">componentsByLevel</span>.<span class="hljs-title function_">has</span>(level)) {
        analysis.<span class="hljs-property">componentsByLevel</span>.<span class="hljs-title function_">set</span>(level, <span class="hljs-number">0</span>);
      }
      analysis.<span class="hljs-property">componentsByLevel</span>.<span class="hljs-title function_">set</span>(level, analysis.<span class="hljs-property">componentsByLevel</span>.<span class="hljs-title function_">get</span>(level) + <span class="hljs-number">1</span>);
      
      <span class="hljs-keyword">if</span> (!component.<span class="hljs-property">children</span> || component.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
        analysis.<span class="hljs-property">leafComponents</span>++;
      } <span class="hljs-keyword">else</span> {
        analysis.<span class="hljs-property">breadth</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(analysis.<span class="hljs-property">breadth</span>, component.<span class="hljs-property">children</span>.<span class="hljs-property">length</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> child <span class="hljs-keyword">of</span> component.<span class="hljs-property">children</span>) {
          queue.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">component</span>: child, <span class="hljs-attr">level</span>: level + <span class="hljs-number">1</span> });
        }
      }
    }
    
    <span class="hljs-keyword">return</span> analysis;
  }

  <span class="hljs-comment">// Graph coloring for conflict resolution</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">graphColoring</span>(<span class="hljs-params">conflictGraph, colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>]</span>) {
    <span class="hljs-keyword">const</span> coloring = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> nodes = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(conflictGraph.<span class="hljs-title function_">keys</span>());
    
    <span class="hljs-comment">// Sort nodes by degree (most connected first)</span>
    nodes.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> degreeA = conflictGraph.<span class="hljs-title function_">get</span>(a)?.<span class="hljs-property">length</span> || <span class="hljs-number">0</span>;
      <span class="hljs-keyword">const</span> degreeB = conflictGraph.<span class="hljs-title function_">get</span>(b)?.<span class="hljs-property">length</span> || <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> degreeB - degreeA;
    });
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> node <span class="hljs-keyword">of</span> nodes) {
      <span class="hljs-keyword">const</span> usedColors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
      
      <span class="hljs-comment">// Check colors used by neighbors</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> conflictGraph.<span class="hljs-title function_">get</span>(node) || []) {
        <span class="hljs-keyword">if</span> (coloring.<span class="hljs-title function_">has</span>(neighbor)) {
          usedColors.<span class="hljs-title function_">add</span>(coloring.<span class="hljs-title function_">get</span>(neighbor));
        }
      }
      
      <span class="hljs-comment">// Find first available color</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> color <span class="hljs-keyword">of</span> colors) {
        <span class="hljs-keyword">if</span> (!usedColors.<span class="hljs-title function_">has</span>(color)) {
          coloring.<span class="hljs-title function_">set</span>(node, color);
          <span class="hljs-keyword">break</span>;
        }
      }
      
      <span class="hljs-comment">// If no color available, add a new one</span>
      <span class="hljs-keyword">if</span> (!coloring.<span class="hljs-title function_">has</span>(node)) {
        <span class="hljs-keyword">const</span> newColor = <span class="hljs-string">`color_<span class="hljs-subst">${colors.length}</span>`</span>;
        colors.<span class="hljs-title function_">push</span>(newColor);
        coloring.<span class="hljs-title function_">set</span>(node, newColor);
      }
    }
    
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">coloring</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(coloring),
      <span class="hljs-attr">colorCount</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(coloring.<span class="hljs-title function_">values</span>()).<span class="hljs-property">size</span>,
      <span class="hljs-attr">isValidColoring</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">validateColoring</span>(conflictGraph, coloring)
    };
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">validateColoring</span>(<span class="hljs-params">graph, coloring</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [node, neighbors] <span class="hljs-keyword">of</span> graph) {
      <span class="hljs-keyword">const</span> nodeColor = coloring.<span class="hljs-title function_">get</span>(node);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> neighbor <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">if</span> (coloring.<span class="hljs-title function_">get</span>(neighbor) === nodeColor) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">// Minimum spanning tree for optimal component connections</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">minimumSpanningTree</span>(<span class="hljs-params">graph, weights</span>) {
    <span class="hljs-keyword">const</span> mst = [];
    <span class="hljs-keyword">const</span> visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    <span class="hljs-keyword">const</span> edges = [];
    
    <span class="hljs-comment">// Convert graph to edge list</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [<span class="hljs-keyword">from</span>, neighbors] <span class="hljs-keyword">of</span> graph) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> to <span class="hljs-keyword">of</span> neighbors) {
        <span class="hljs-keyword">const</span> weight = weights.<span class="hljs-title function_">get</span>(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">from</span>}</span>-<span class="hljs-subst">${to}</span>`</span>) || weights.<span class="hljs-title function_">get</span>(<span class="hljs-string">`<span class="hljs-subst">${to}</span>-<span class="hljs-subst">${<span class="hljs-keyword">from</span>}</span>`</span>) || <span class="hljs-number">1</span>;
        edges.<span class="hljs-title function_">push</span>({ <span class="hljs-keyword">from</span>, to, weight });
      }
    }
    
    <span class="hljs-comment">// Sort edges by weight</span>
    edges.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-property">weight</span> - b.<span class="hljs-property">weight</span>);
    
    <span class="hljs-comment">// Union-Find data structure</span>
    <span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> rank = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">find</span> = (<span class="hljs-params">x</span>) =&gt; {
      <span class="hljs-keyword">if</span> (!parent.<span class="hljs-title function_">has</span>(x)) {
        parent.<span class="hljs-title function_">set</span>(x, x);
        rank.<span class="hljs-title function_">set</span>(x, <span class="hljs-number">0</span>);
      }
      <span class="hljs-keyword">if</span> (parent.<span class="hljs-title function_">get</span>(x) !== x) {
        parent.<span class="hljs-title function_">set</span>(x, <span class="hljs-title function_">find</span>(parent.<span class="hljs-title function_">get</span>(x)));
      }
      <span class="hljs-keyword">return</span> parent.<span class="hljs-title function_">get</span>(x);
    };
    
    <span class="hljs-keyword">const</span> <span class="hljs-title function_">union</span> = (<span class="hljs-params">x, y</span>) =&gt; {
      <span class="hljs-keyword">const</span> rootX = <span class="hljs-title function_">find</span>(x);
      <span class="hljs-keyword">const</span> rootY = <span class="hljs-title function_">find</span>(y);
      
      <span class="hljs-keyword">if</span> (rootX !== rootY) {
        <span class="hljs-keyword">if</span> (rank.<span class="hljs-title function_">get</span>(rootX) &lt; rank.<span class="hljs-title function_">get</span>(rootY)) {
          parent.<span class="hljs-title function_">set</span>(rootX, rootY);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rank.<span class="hljs-title function_">get</span>(rootX) &gt; rank.<span class="hljs-title function_">get</span>(rootY)) {
          parent.<span class="hljs-title function_">set</span>(rootY, rootX);
        } <span class="hljs-keyword">else</span> {
          parent.<span class="hljs-title function_">set</span>(rootY, rootX);
          rank.<span class="hljs-title function_">set</span>(rootX, rank.<span class="hljs-title function_">get</span>(rootX) + <span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    };
    
    <span class="hljs-comment">// Kruskal&#x27;s algorithm</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> edge <span class="hljs-keyword">of</span> edges) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">union</span>(edge.<span class="hljs-property">from</span>, edge.<span class="hljs-property">to</span>)) {
        mst.<span class="hljs-title function_">push</span>(edge);
      }
    }
    
    <span class="hljs-keyword">return</span> mst;
  }
}
</code></pre></pre>
<p>{% endraw %}</p>
<hr/>
<h2 id="optimization-algorithms" node="[object Object]">Optimization Algorithms</h2>
<h3 id="[object-object]" node="[object Object]"><strong>Frontend-Specific Optimizations</strong></h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Optimization algorithms for frontend performance</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FrontendOptimizationAlgorithms</span> {
  
  <span class="hljs-comment">// Bundle splitting optimization using dynamic programming</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">optimizeBundleSplitting</span>(<span class="hljs-params">modules, maxBundleSize = <span class="hljs-number">250000</span></span>) {
    <span class="hljs-keyword">const</span> n = modules.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">const</span> dp = <span class="hljs-title class_">Array</span>(n + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>().<span class="hljs-title function_">map</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Array</span>(maxBundleSize + <span class="hljs-number">1</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">0</span>));
    <span class="hljs-keyword">const</span> bundles = [];
    
    <span class="hljs-comment">// Sort modules by importance/usage frequency</span>
    modules.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (b.<span class="hljs-property">importance</span> || <span class="hljs-number">0</span>) - (a.<span class="hljs-property">importance</span> || <span class="hljs-number">0</span>));
    
    <span class="hljs-comment">// Dynamic programming to find optimal bundles</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
      <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = modules[i - <span class="hljs-number">1</span>];
      <span class="hljs-keyword">const</span> size = <span class="hljs-variable language_">module</span>.<span class="hljs-property">size</span>;
      <span class="hljs-keyword">const</span> value = <span class="hljs-variable language_">module</span>.<span class="hljs-property">importance</span> || <span class="hljs-number">1</span>;
      
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> w = <span class="hljs-number">0</span>; w &lt;= maxBundleSize; w++) {
        dp[i][w] = dp[i - <span class="hljs-number">1</span>][w]; <span class="hljs-comment">// Don&#x27;t include current module</span>
        
        <span class="hljs-keyword">if</span> (size &lt;= w) {
          dp[i][w] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(dp[i][w], dp[i - <span class="hljs-number">1</span>][w - size] + value);
        }
      }
    }
    
    <span class="hljs-comment">// Backtrack to find which modules to include</span>
    <span class="hljs-keyword">let</span> w = maxBundleSize;
    <span class="hljs-keyword">const</span> currentBundle = [];
    <span class="hljs-keyword">let</span> currentSize = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = n; i &gt; <span class="hljs-number">0</span> &amp;&amp; w &gt; <span class="hljs-number">0</span>; i--) {
      <span class="hljs-keyword">if</span> (dp[i][w] !== dp[i - <span class="hljs-number">1</span>][w]) {
        <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = modules[i - <span class="hljs-number">1</span>];
        currentBundle.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">module</span>);
        currentSize += <span class="hljs-variable language_">module</span>.<span class="hljs-property">size</span>;
        w -= <span class="hljs-variable language_">module</span>.<span class="hljs-property">size</span>;
      }
    }
    
    bundles.<span class="hljs-title function_">push</span>({
      <span class="hljs-attr">modules</span>: currentBundle,
      <span class="hljs-attr">size</span>: currentSize,
      <span class="hljs-attr">value</span>: dp[n][maxBundleSize]
    });
    
    <span class="hljs-comment">// Recursively create remaining bundles</span>
    <span class="hljs-keyword">const</span> remainingModules = modules.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> !currentBundle.<span class="hljs-title function_">includes</span>(m));
    <span class="hljs-keyword">if</span> (remainingModules.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> remainingBundles = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">optimizeBundleSplitting</span>(remainingModules, maxBundleSize);
      bundles.<span class="hljs-title function_">push</span>(...remainingBundles);
    }
    
    <span class="hljs-keyword">return</span> bundles;
  }

  <span class="hljs-comment">// Resource loading optimization using greedy algorithm</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">optimizeResourceLoading</span>(<span class="hljs-params">resources, bandwidth = <span class="hljs-number">1000000</span></span>) { <span class="hljs-comment">// 1MB/s default</span>
    <span class="hljs-keyword">const</span> critical = resources.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">critical</span>);
    <span class="hljs-keyword">const</span> nonCritical = resources.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> !r.<span class="hljs-property">critical</span>);
    
    <span class="hljs-comment">// Sort critical resources by priority, non-critical by size/importance ratio</span>
    critical.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (b.<span class="hljs-property">priority</span> || <span class="hljs-number">0</span>) - (a.<span class="hljs-property">priority</span> || <span class="hljs-number">0</span>));
    nonCritical.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> ratioA = (a.<span class="hljs-property">importance</span> || <span class="hljs-number">1</span>) / a.<span class="hljs-property">size</span>;
      <span class="hljs-keyword">const</span> ratioB = (b.<span class="hljs-property">importance</span> || <span class="hljs-number">1</span>) / b.<span class="hljs-property">size</span>;
      <span class="hljs-keyword">return</span> ratioB - ratioA;
    });
    
    <span class="hljs-keyword">const</span> loadingSchedule = [];
    <span class="hljs-keyword">let</span> currentTime = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> currentBandwidth = bandwidth;
    
    <span class="hljs-comment">// Schedule critical resources first</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> resource <span class="hljs-keyword">of</span> critical) {
      <span class="hljs-keyword">const</span> loadTime = resource.<span class="hljs-property">size</span> / currentBandwidth;
      loadingSchedule.<span class="hljs-title function_">push</span>({
        resource,
        <span class="hljs-attr">startTime</span>: currentTime,
        <span class="hljs-attr">endTime</span>: currentTime + loadTime,
        <span class="hljs-attr">priority</span>: <span class="hljs-string">&#x27;critical&#x27;</span>
      });
      currentTime += loadTime;
    }
    
    <span class="hljs-comment">// Schedule non-critical resources</span>
    <span class="hljs-keyword">const</span> nonCriticalBatches = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createLoadingBatches</span>(nonCritical, bandwidth);
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> batch <span class="hljs-keyword">of</span> nonCriticalBatches) {
      <span class="hljs-keyword">const</span> batchStartTime = currentTime;
      <span class="hljs-keyword">let</span> maxBatchTime = <span class="hljs-number">0</span>;
      
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> resource <span class="hljs-keyword">of</span> batch) {
        <span class="hljs-keyword">const</span> loadTime = resource.<span class="hljs-property">size</span> / (bandwidth / batch.<span class="hljs-property">length</span>); <span class="hljs-comment">// Parallel loading</span>
        loadingSchedule.<span class="hljs-title function_">push</span>({
          resource,
          <span class="hljs-attr">startTime</span>: batchStartTime,
          <span class="hljs-attr">endTime</span>: batchStartTime + loadTime,
          <span class="hljs-attr">priority</span>: <span class="hljs-string">&#x27;normal&#x27;</span>
        });
        maxBatchTime = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxBatchTime, loadTime);
      }
      
      currentTime += maxBatchTime;
    }
    
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">schedule</span>: loadingSchedule,
      <span class="hljs-attr">totalTime</span>: currentTime,
      <span class="hljs-attr">criticalTime</span>: critical.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, r</span>) =&gt;</span> sum + (r.<span class="hljs-property">size</span> / bandwidth), <span class="hljs-number">0</span>)
    };
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">createLoadingBatches</span>(<span class="hljs-params">resources, bandwidth</span>) {
    <span class="hljs-keyword">const</span> batches = [];
    <span class="hljs-keyword">let</span> currentBatch = [];
    <span class="hljs-keyword">let</span> currentBatchSize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">const</span> maxBatchSize = bandwidth * <span class="hljs-number">0.5</span>; <span class="hljs-comment">// Don&#x27;t exceed 50% bandwidth per batch</span>
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> resource <span class="hljs-keyword">of</span> resources) {
      <span class="hljs-keyword">if</span> (currentBatchSize + resource.<span class="hljs-property">size</span> &gt; maxBatchSize &amp;&amp; currentBatch.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        batches.<span class="hljs-title function_">push</span>([...currentBatch]);
        currentBatch = [resource];
        currentBatchSize = resource.<span class="hljs-property">size</span>;
      } <span class="hljs-keyword">else</span> {
        currentBatch.<span class="hljs-title function_">push</span>(resource);
        currentBatchSize += resource.<span class="hljs-property">size</span>;
      }
    }
    
    <span class="hljs-keyword">if</span> (currentBatch.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      batches.<span class="hljs-title function_">push</span>(currentBatch);
    }
    
    <span class="hljs-keyword">return</span> batches;
  }

  <span class="hljs-comment">// Cache optimization using LRU and frequency-based algorithms</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">optimizeCache</span>(<span class="hljs-params">accessPattern, cacheSize = <span class="hljs-number">100</span></span>) {
    <span class="hljs-keyword">const</span> lruCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> frequencyCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    <span class="hljs-keyword">const</span> accessCount = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    
    <span class="hljs-keyword">let</span> lruHits = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> frequencyHits = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Simulate LRU cache</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> accessPattern) {
      <span class="hljs-keyword">if</span> (lruCache.<span class="hljs-title function_">has</span>(item)) {
        lruHits++;
        <span class="hljs-comment">// Move to end (most recently used)</span>
        lruCache.<span class="hljs-title function_">delete</span>(item);
        lruCache.<span class="hljs-title function_">set</span>(item, <span class="hljs-literal">true</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (lruCache.<span class="hljs-property">size</span> &gt;= cacheSize) {
          <span class="hljs-comment">// Remove least recently used (first item)</span>
          <span class="hljs-keyword">const</span> lru = lruCache.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>;
          lruCache.<span class="hljs-title function_">delete</span>(lru);
        }
        lruCache.<span class="hljs-title function_">set</span>(item, <span class="hljs-literal">true</span>);
      }
    }
    
    <span class="hljs-comment">// Reset for frequency-based cache</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> accessPattern) {
      accessCount.<span class="hljs-title function_">set</span>(item, (accessCount.<span class="hljs-title function_">get</span>(item) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);
      
      <span class="hljs-keyword">if</span> (frequencyCache.<span class="hljs-title function_">has</span>(item)) {
        frequencyHits++;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (frequencyCache.<span class="hljs-property">size</span> &gt;= cacheSize) {
          <span class="hljs-comment">// Remove least frequently used</span>
          <span class="hljs-keyword">let</span> lfu = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">let</span> minCount = <span class="hljs-title class_">Infinity</span>;
          
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> cachedItem <span class="hljs-keyword">of</span> frequencyCache.<span class="hljs-title function_">keys</span>()) {
            <span class="hljs-keyword">const</span> count = accessCount.<span class="hljs-title function_">get</span>(cachedItem) || <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (count &lt; minCount) {
              minCount = count;
              lfu = cachedItem;
            }
          }
          
          <span class="hljs-keyword">if</span> (lfu) {
            frequencyCache.<span class="hljs-title function_">delete</span>(lfu);
          }
        }
        frequencyCache.<span class="hljs-title function_">set</span>(item, <span class="hljs-literal">true</span>);
      }
    }
    
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">lru</span>: {
        <span class="hljs-attr">hits</span>: lruHits,
        <span class="hljs-attr">hitRate</span>: lruHits / accessPattern.<span class="hljs-property">length</span>
      },
      <span class="hljs-attr">frequency</span>: {
        <span class="hljs-attr">hits</span>: frequencyHits,
        <span class="hljs-attr">hitRate</span>: frequencyHits / accessPattern.<span class="hljs-property">length</span>
      },
      <span class="hljs-attr">recommendation</span>: frequencyHits &gt; lruHits ? <span class="hljs-string">&#x27;frequency-based&#x27;</span> : <span class="hljs-string">&#x27;lru&#x27;</span>
    };
  }

  <span class="hljs-comment">// Image optimization algorithm</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">optimizeImageLoading</span>(<span class="hljs-params">images, viewportSize = { width: <span class="hljs-number">1920</span>, height: <span class="hljs-number">1080</span> }</span>) {
    <span class="hljs-keyword">const</span> optimizedImages = [];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> image <span class="hljs-keyword">of</span> images) {
      <span class="hljs-keyword">const</span> optimization = {
        <span class="hljs-attr">original</span>: image,
        <span class="hljs-attr">recommendations</span>: []
      };
      
      <span class="hljs-comment">// Resize recommendation</span>
      <span class="hljs-keyword">if</span> (image.<span class="hljs-property">width</span> &gt; viewportSize.<span class="hljs-property">width</span> || image.<span class="hljs-property">height</span> &gt; viewportSize.<span class="hljs-property">height</span>) {
        <span class="hljs-keyword">const</span> scale = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(
          viewportSize.<span class="hljs-property">width</span> / image.<span class="hljs-property">width</span>,
          viewportSize.<span class="hljs-property">height</span> / image.<span class="hljs-property">height</span>
        );
        
        optimization.<span class="hljs-property">recommendations</span>.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;resize&#x27;</span>,
          <span class="hljs-attr">newWidth</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(image.<span class="hljs-property">width</span> * scale),
          <span class="hljs-attr">newHeight</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(image.<span class="hljs-property">height</span> * scale),
          <span class="hljs-attr">savings</span>: <span class="hljs-string">`<span class="hljs-subst">${(<span class="hljs-number">100</span> - scale * <span class="hljs-number">100</span>).toFixed(<span class="hljs-number">1</span>)}</span>% size reduction`</span>
        });
      }
      
      <span class="hljs-comment">// Format recommendation</span>
      <span class="hljs-keyword">const</span> formatRecommendation = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getOptimalImageFormat</span>(image);
      <span class="hljs-keyword">if</span> (formatRecommendation) {
        optimization.<span class="hljs-property">recommendations</span>.<span class="hljs-title function_">push</span>(formatRecommendation);
      }
      
      <span class="hljs-comment">// Lazy loading recommendation</span>
      <span class="hljs-keyword">if</span> (!image.<span class="hljs-property">critical</span>) {
        optimization.<span class="hljs-property">recommendations</span>.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;lazy-loading&#x27;</span>,
          <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;Load image when it enters viewport&#x27;</span>
        });
      }
      
      <span class="hljs-comment">// Progressive loading recommendation</span>
      <span class="hljs-keyword">if</span> (image.<span class="hljs-property">size</span> &gt; <span class="hljs-number">100000</span>) { <span class="hljs-comment">// 100KB</span>
        optimization.<span class="hljs-property">recommendations</span>.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;progressive&#x27;</span>,
          <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;Use progressive JPEG or WebP&#x27;</span>
        });
      }
      
      optimizedImages.<span class="hljs-title function_">push</span>(optimization);
    }
    
    <span class="hljs-keyword">return</span> optimizedImages;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getOptimalImageFormat</span>(<span class="hljs-params">image</span>) {
    <span class="hljs-keyword">if</span> (image.<span class="hljs-property">hasTransparency</span>) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;format&#x27;</span>,
        <span class="hljs-attr">recommendation</span>: <span class="hljs-string">&#x27;WebP or PNG&#x27;</span>,
        <span class="hljs-attr">reason</span>: <span class="hljs-string">&#x27;Image has transparency&#x27;</span>
      };
    }
    
    <span class="hljs-keyword">if</span> (image.<span class="hljs-property">isPhoto</span>) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;format&#x27;</span>,
        <span class="hljs-attr">recommendation</span>: <span class="hljs-string">&#x27;WebP or JPEG&#x27;</span>,
        <span class="hljs-attr">reason</span>: <span class="hljs-string">&#x27;Photographic content compresses well with lossy formats&#x27;</span>
      };
    }
    
    <span class="hljs-keyword">if</span> (image.<span class="hljs-property">hasText</span> || image.<span class="hljs-property">isIcon</span>) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;format&#x27;</span>,
        <span class="hljs-attr">recommendation</span>: <span class="hljs-string">&#x27;SVG or WebP&#x27;</span>,
        <span class="hljs-attr">reason</span>: <span class="hljs-string">&#x27;Vector format better for text and icons&#x27;</span>
      };
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-comment">// Code splitting optimization</span>
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">optimizeCodeSplitting</span>(<span class="hljs-params">componentUsage, bundleTargetSize = <span class="hljs-number">250000</span></span>) {
    <span class="hljs-keyword">const</span> components = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(componentUsage).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">[name, data]</span>) =&gt;</span> ({
      name,
      ...data
    }));
    
    <span class="hljs-comment">// Group components by usage patterns</span>
    <span class="hljs-keyword">const</span> highFrequency = components.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.<span class="hljs-property">frequency</span> &gt; <span class="hljs-number">0.7</span>);
    <span class="hljs-keyword">const</span> mediumFrequency = components.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.<span class="hljs-property">frequency</span> &gt; <span class="hljs-number">0.3</span> &amp;&amp; c.<span class="hljs-property">frequency</span> &lt;= <span class="hljs-number">0.7</span>);
    <span class="hljs-keyword">const</span> lowFrequency = components.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.<span class="hljs-property">frequency</span> &lt;= <span class="hljs-number">0.3</span>);
    
    <span class="hljs-keyword">const</span> splitStrategy = {
      <span class="hljs-attr">core</span>: {
        <span class="hljs-attr">components</span>: highFrequency,
        <span class="hljs-attr">priority</span>: <span class="hljs-string">&#x27;critical&#x27;</span>,
        <span class="hljs-attr">loadStrategy</span>: <span class="hljs-string">&#x27;eager&#x27;</span>
      },
      <span class="hljs-attr">features</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">groupComponentsByFeature</span>(mediumFrequency, bundleTargetSize),
      <span class="hljs-attr">lazy</span>: {
        <span class="hljs-attr">components</span>: lowFrequency,
        <span class="hljs-attr">priority</span>: <span class="hljs-string">&#x27;low&#x27;</span>,
        <span class="hljs-attr">loadStrategy</span>: <span class="hljs-string">&#x27;lazy&#x27;</span>
      }
    };
    
    <span class="hljs-keyword">return</span> splitStrategy;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">groupComponentsByFeature</span>(<span class="hljs-params">components, targetSize</span>) {
    <span class="hljs-keyword">const</span> features = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    
    <span class="hljs-comment">// Group by feature/route</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> component <span class="hljs-keyword">of</span> components) {
      <span class="hljs-keyword">const</span> feature = component.<span class="hljs-property">feature</span> || component.<span class="hljs-property">route</span> || <span class="hljs-string">&#x27;common&#x27;</span>;
      <span class="hljs-keyword">if</span> (!features.<span class="hljs-title function_">has</span>(feature)) {
        features.<span class="hljs-title function_">set</span>(feature, []);
      }
      features.<span class="hljs-title function_">get</span>(feature).<span class="hljs-title function_">push</span>(component);
    }
    
    <span class="hljs-comment">// Optimize bundle sizes within features</span>
    <span class="hljs-keyword">const</span> optimizedFeatures = [];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [featureName, featureComponents] <span class="hljs-keyword">of</span> features) {
      <span class="hljs-keyword">const</span> totalSize = featureComponents.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, c</span>) =&gt;</span> sum + c.<span class="hljs-property">size</span>, <span class="hljs-number">0</span>);
      
      <span class="hljs-keyword">if</span> (totalSize &lt;= targetSize) {
        optimizedFeatures.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">name</span>: featureName,
          <span class="hljs-attr">components</span>: featureComponents,
          <span class="hljs-attr">size</span>: totalSize,
          <span class="hljs-attr">loadStrategy</span>: <span class="hljs-string">&#x27;route-based&#x27;</span>
        });
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Split large features into smaller bundles</span>
        <span class="hljs-keyword">const</span> subBundles = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">splitLargeFeature</span>(featureComponents, targetSize);
        optimizedFeatures.<span class="hljs-title function_">push</span>(...subBundles.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">bundle</span> =&gt;</span> ({
          <span class="hljs-attr">name</span>: <span class="hljs-string">`<span class="hljs-subst">${featureName}</span>-<span class="hljs-subst">${bundle.index}</span>`</span>,
          <span class="hljs-attr">components</span>: bundle.<span class="hljs-property">components</span>,
          <span class="hljs-attr">size</span>: bundle.<span class="hljs-property">size</span>,
          <span class="hljs-attr">loadStrategy</span>: <span class="hljs-string">&#x27;progressive&#x27;</span>
        })));
      }
    }
    
    <span class="hljs-keyword">return</span> optimizedFeatures;
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">splitLargeFeature</span>(<span class="hljs-params">components, targetSize</span>) {
    <span class="hljs-keyword">const</span> bundles = [];
    <span class="hljs-keyword">let</span> currentBundle = [];
    <span class="hljs-keyword">let</span> currentSize = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> bundleIndex = <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">// Sort by dependency order and importance</span>
    components.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (b.<span class="hljs-property">importance</span> || <span class="hljs-number">0</span>) - (a.<span class="hljs-property">importance</span> || <span class="hljs-number">0</span>));
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> component <span class="hljs-keyword">of</span> components) {
      <span class="hljs-keyword">if</span> (currentSize + component.<span class="hljs-property">size</span> &gt; targetSize &amp;&amp; currentBundle.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        bundles.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">index</span>: bundleIndex++,
          <span class="hljs-attr">components</span>: [...currentBundle],
          <span class="hljs-attr">size</span>: currentSize
        });
        currentBundle = [component];
        currentSize = component.<span class="hljs-property">size</span>;
      } <span class="hljs-keyword">else</span> {
        currentBundle.<span class="hljs-title function_">push</span>(component);
        currentSize += component.<span class="hljs-property">size</span>;
      }
    }
    
    <span class="hljs-keyword">if</span> (currentBundle.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      bundles.<span class="hljs-title function_">push</span>({
        <span class="hljs-attr">index</span>: bundleIndex,
        <span class="hljs-attr">components</span>: currentBundle,
        <span class="hljs-attr">size</span>: currentSize
      });
    }
    
    <span class="hljs-keyword">return</span> bundles;
  }
}
</code></pre></pre>
<p>This comprehensive guide provides essential algorithms and data structures specifically tailored for frontend development challenges, optimization problems, and user interface requirements commonly encountered in Big Tech interviews.</p></div></div></main><footer class="sc-kjwdDK hrfQfY"><div class="sc-eVqvcJ dwFHjZ"><div class="sc-bbbBoY kWATso"><div class="sc-cdmAjP fBmmqS"><div class="sc-jytpVa iNKxsb"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</div><p class="sc-eknHtZ fYhkiV">Comprehensive interview preparation for frontend engineers targeting Big Tech companies.</p><div class="sc-pYNGo eVAQiq"><a href="https://github.com" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github "><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><a href="https://twitter.com" aria-label="Twitter"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-twitter "><path d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"></path></svg></a><a href="https://linkedin.com" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-linkedin "><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect width="4" height="12" x="2" y="9"></rect><circle cx="4" cy="4" r="2"></circle></svg></a><a href="mailto:contact@example.com" aria-label="Email"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail "><rect width="20" height="16" x="2" y="4" rx="2"></rect><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path></svg></a></div></div><div class="sc-cdmAjP fBmmqS"><h3>Study Materials</h3><ul><li><a href="/algorithms">Algorithms</a></li><li><a href="/react">React &amp; Frontend</a></li><li><a href="/system-design">System Design</a></li><li><a href="/typescript">TypeScript</a></li><li><a href="/performance">Performance</a></li></ul></div><div class="sc-cdmAjP fBmmqS"><h3>Companies</h3><ul><li><a href="/google">Google</a></li><li><a href="/meta">Meta</a></li><li><a href="/amazon">Amazon</a></li><li><a href="/microsoft">Microsoft</a></li><li><a href="/apple">Apple</a></li></ul></div><div class="sc-cdmAjP fBmmqS"><h3>Resources</h3><ul><li><a href="/interview-tips">Interview Tips</a></li><li><a href="/coding-challenges">Coding Challenges</a></li><li><a href="/mock-interviews">Mock Interviews</a></li><li><a href="/blog">Blog</a></li><li><a href="/faq">FAQ</a></li></ul></div></div><div class="sc-cCVJLD fgJmHp"><p class="sc-jYczwO gYGLHT">¬© 2025 Frontend Interview Prep. All rights reserved.</p><div class="sc-dNFkOE ghBULZ"><a href="/privacy">Privacy Policy</a><a href="/terms">Terms of Service</a><a href="/contact">Contact</a></div></div></div></footer></div><script src="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/interview/_next/static/css/387024c6a2216908.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[2846,[],\"\"]\n5:I[5907,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"930\",\"static/chunks/930-3262a6c9c5acace4.js\",\"687\",\"static/chunks/app/docs/%5B...slug%5D/page-036ada1d0a865043.js\"],\"default\"]\n7:I[4707,[],\"\"]\n9:I[6423,[],\"\"]\na:I[2,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"710\",\"static/chunks/710-dfaa11b4dff08f8e.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"233\",\"static/chunks/233-3e0c1d820a17eca9.js\",\"185\",\"static/chunks/app/layout-333f4adcd11f8f39.js\"],\"default\",1]\nc:I[1060,[],\"\"]\n6:T8625,"])</script><script>self.__next_f.push([1,"# Algorithms \u0026 Data Structures for Frontend\n\n## Overview\nFrontend engineers need strong algorithmic thinking for optimization, data manipulation, and building efficient user interfaces. This guide covers essential algorithms and data structures with frontend-specific applications.\n\n---\n\n## Essential Data Structures for Frontend\n\n### **Advanced Array Manipulation**\n\n```javascript\n// Frontend-specific array algorithms and optimizations\nclass FrontendArrayAlgorithms {\n  \n  // Virtual scrolling algorithm for large lists\n  static virtualScrolling(items, containerHeight, itemHeight, scrollTop) {\n    const totalItems = items.length;\n    const visibleCount = Math.ceil(containerHeight / itemHeight);\n    const bufferSize = Math.min(5, Math.floor(visibleCount / 2));\n    \n    const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - bufferSize);\n    const endIndex = Math.min(totalItems - 1, startIndex + visibleCount + bufferSize * 2);\n    \n    const visibleItems = items.slice(startIndex, endIndex + 1);\n    const offsetY = startIndex * itemHeight;\n    const totalHeight = totalItems * itemHeight;\n    \n    return {\n      visibleItems,\n      startIndex,\n      endIndex,\n      offsetY,\n      totalHeight,\n      spacerTop: offsetY,\n      spacerBottom: totalHeight - (endIndex + 1) * itemHeight\n    };\n  }\n\n  // Efficient filtering for real-time search\n  static fuzzySearch(items, query, keys = ['name']) {\n    if (!query.trim()) return items;\n    \n    const queryTerms = query.toLowerCase().split(' ').filter(term =\u003e term.length \u003e 0);\n    \n    const results = items.map(item =\u003e {\n      let score = 0;\n      let matches = 0;\n      \n      for (const key of keys) {\n        const value = String(item[key] || '').toLowerCase();\n        \n        for (const term of queryTerms) {\n          // Exact match bonus\n          if (value.includes(term)) {\n            score += term.length * 10;\n            matches++;\n          }\n          \n          // Fuzzy match\n          const fuzzyScore = this.fuzzyMatchScore(value, term);\n          if (fuzzyScore \u003e 0.5) {\n            score += fuzzyScore * 5;\n            matches++;\n          }\n        }\n      }\n      \n      return {\n        item,\n        score: matches \u003e 0 ? score / queryTerms.length : 0,\n        matches\n      };\n    });\n    \n    return results\n      .filter(result =\u003e result.score \u003e 0)\n      .sort((a, b) =\u003e b.score - a.score)\n      .map(result =\u003e result.item);\n  }\n\n  static fuzzyMatchScore(text, pattern) {\n    const textLen = text.length;\n    const patternLen = pattern.length;\n    \n    if (patternLen === 0) return 1;\n    if (patternLen \u003e textLen) return 0;\n    \n    // Dynamic programming approach\n    const dp = Array(patternLen + 1).fill().map(() =\u003e Array(textLen + 1).fill(0));\n    \n    // Initialize base cases\n    for (let j = 0; j \u003c= textLen; j++) {\n      dp[0][j] = 1;\n    }\n    \n    for (let i = 1; i \u003c= patternLen; i++) {\n      for (let j = i; j \u003c= textLen; j++) {\n        if (pattern[i - 1] === text[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1];\n        } else {\n          dp[i][j] = dp[i][j - 1] * 0.9; // Penalty for skipping characters\n        }\n      }\n    }\n    \n    return dp[patternLen][textLen];\n  }\n\n  // Efficient grouping for data visualization\n  static groupByWithAggregation(items, groupKey, aggregations = {}) {\n    const groups = new Map();\n    \n    for (const item of items) {\n      const key = typeof groupKey === 'function' ? groupKey(item) : item[groupKey];\n      \n      if (!groups.has(key)) {\n        groups.set(key, {\n          key,\n          items: [],\n          count: 0,\n          aggregates: {}\n        });\n      }\n      \n      const group = groups.get(key);\n      group.items.push(item);\n      group.count++;\n      \n      // Calculate aggregations\n      for (const [aggKey, aggConfig] of Object.entries(aggregations)) {\n        const { field, type } = aggConfig;\n        const value = typeof field === 'function' ? field(item) : item[field];\n        \n        if (!group.aggregates[aggKey]) {\n          group.aggregates[aggKey] = type === 'avg' ? { sum: 0, count: 0 } : \n                                     type === 'min' ? Infinity :\n                                     type === 'max' ? -Infinity : 0;\n        }\n        \n        switch (type) {\n          case 'sum':\n            group.aggregates[aggKey] += value || 0;\n            break;\n          case 'avg':\n            group.aggregates[aggKey].sum += value || 0;\n            group.aggregates[aggKey].count++;\n            break;\n          case 'min':\n            group.aggregates[aggKey] = Math.min(group.aggregates[aggKey], value || 0);\n            break;\n          case 'max':\n            group.aggregates[aggKey] = Math.max(group.aggregates[aggKey], value || 0);\n            break;\n          case 'count':\n            group.aggregates[aggKey]++;\n            break;\n        }\n      }\n    }\n    \n    // Finalize average calculations\n    for (const group of groups.values()) {\n      for (const [aggKey, aggConfig] of Object.entries(aggregations)) {\n        if (aggConfig.type === 'avg' \u0026\u0026 group.aggregates[aggKey]) {\n          const { sum, count } = group.aggregates[aggKey];\n          group.aggregates[aggKey] = count \u003e 0 ? sum / count : 0;\n        }\n      }\n    }\n    \n    return Array.from(groups.values());\n  }\n\n  // Optimized sorting for UI tables\n  static multiColumnSort(items, sortConfigs) {\n    return items.slice().sort((a, b) =\u003e {\n      for (const config of sortConfigs) {\n        const { key, direction = 'asc', type = 'string' } = config;\n        \n        let valueA = typeof key === 'function' ? key(a) : a[key];\n        let valueB = typeof key === 'function' ? key(b) : b[key];\n        \n        // Handle null/undefined values\n        if (valueA == null \u0026\u0026 valueB == null) continue;\n        if (valueA == null) return direction === 'asc' ? 1 : -1;\n        if (valueB == null) return direction === 'asc' ? -1 : 1;\n        \n        // Type-specific comparison\n        let comparison = 0;\n        switch (type) {\n          case 'number':\n            comparison = Number(valueA) - Number(valueB);\n            break;\n          case 'date':\n            comparison = new Date(valueA) - new Date(valueB);\n            break;\n          case 'string':\n          default:\n            comparison = String(valueA).localeCompare(String(valueB));\n            break;\n        }\n        \n        if (comparison !== 0) {\n          return direction === 'asc' ? comparison : -comparison;\n        }\n      }\n      return 0;\n    });\n  }\n\n  // Efficient pagination with cursor-based approach\n  static paginateWithCursor(items, cursor = null, pageSize = 10, sortKey = 'id') {\n    let startIndex = 0;\n    \n    if (cursor) {\n      startIndex = items.findIndex(item =\u003e \n        (typeof sortKey === 'function' ? sortKey(item) : item[sortKey]) \u003e cursor\n      );\n      if (startIndex === -1) startIndex = items.length;\n    }\n    \n    const pageItems = items.slice(startIndex, startIndex + pageSize);\n    const hasNext = startIndex + pageSize \u003c items.length;\n    const nextCursor = hasNext \u0026\u0026 pageItems.length \u003e 0 ?\n      (typeof sortKey === 'function' ? sortKey(pageItems[pageItems.length - 1]) : \n       pageItems[pageItems.length - 1][sortKey]) : null;\n    \n    return {\n      items: pageItems,\n      hasNext,\n      nextCursor,\n      totalCount: items.length,\n      pageSize\n    };\n  }\n}\n```\n\n### **Tree Structures for UI Components**\n\n```javascript\n// Tree data structures for hierarchical UI components\nclass UITreeStructures {\n  \n  // Tree structure for nested menus/navigation\n  static buildNavigationTree(flatItems, parentKey = 'parentId', idKey = 'id') {\n    const itemMap = new Map();\n    const rootItems = [];\n    \n    // First pass: create lookup map\n    for (const item of flatItems) {\n      itemMap.set(item[idKey], { ...item, children: [] });\n    }\n    \n    // Second pass: build tree structure\n    for (const item of flatItems) {\n      const treeItem = itemMap.get(item[idKey]);\n      const parentId = item[parentKey];\n      \n      if (parentId \u0026\u0026 itemMap.has(parentId)) {\n        itemMap.get(parentId).children.push(treeItem);\n      } else {\n        rootItems.push(treeItem);\n      }\n    }\n    \n    return rootItems;\n  }\n\n  // Tree traversal for component hierarchy\n  static traverseComponentTree(rootComponent, callback, traversalType = 'preorder') {\n    const results = [];\n    \n    const preorderTraversal = (component, depth = 0, path = []) =\u003e {\n      const currentPath = [...path, component.id || component.name];\n      const result = callback(component, depth, currentPath);\n      if (result !== undefined) results.push(result);\n      \n      if (component.children) {\n        for (const child of component.children) {\n          preorderTraversal(child, depth + 1, currentPath);\n        }\n      }\n    };\n    \n    const postorderTraversal = (component, depth = 0, path = []) =\u003e {\n      const currentPath = [...path, component.id || component.name];\n      \n      if (component.children) {\n        for (const child of component.children) {\n          postorderTraversal(child, depth + 1, currentPath);\n        }\n      }\n      \n      const result = callback(component, depth, currentPath);\n      if (result !== undefined) results.push(result);\n    };\n    \n    const levelOrderTraversal = (rootComponent) =\u003e {\n      const queue = [{ component: rootComponent, depth: 0, path: [] }];\n      \n      while (queue.length \u003e 0) {\n        const { component, depth, path } = queue.shift();\n        const currentPath = [...path, component.id || component.name];\n        \n        const result = callback(component, depth, currentPath);\n        if (result !== undefined) results.push(result);\n        \n        if (component.children) {\n          for (const child of component.children) {\n            queue.push({ component: child, depth: depth + 1, path: currentPath });\n          }\n        }\n      }\n    };\n    \n    switch (traversalType) {\n      case 'preorder':\n        preorderTraversal(rootComponent);\n        break;\n      case 'postorder':\n        postorderTraversal(rootComponent);\n        break;\n      case 'levelorder':\n        levelOrderTraversal(rootComponent);\n        break;\n    }\n    \n    return results;\n  }\n\n  // Find node in tree with path tracking\n  static findNodeWithPath(tree, predicate, path = []) {\n    if (predicate(tree)) {\n      return { node: tree, path: [...path, tree] };\n    }\n    \n    if (tree.children) {\n      for (const child of tree.children) {\n        const result = this.findNodeWithPath(child, predicate, [...path, tree]);\n        if (result) return result;\n      }\n    }\n    \n    return null;\n  }\n\n  // Tree diffing algorithm for efficient updates\n  static diffTrees(oldTree, newTree, options = {}) {\n    const { \n      keyProperty = 'id',\n      compareProperties = ['name', 'value', 'type']\n    } = options;\n    \n    const changes = [];\n    \n    const diff = (oldNode, newNode, path = []) =\u003e {\n      const currentPath = [...path];\n      \n      if (!oldNode \u0026\u0026 newNode) {\n        // Node added\n        changes.push({\n          type: 'ADD',\n          path: currentPath,\n          node: newNode\n        });\n        return;\n      }\n      \n      if (oldNode \u0026\u0026 !newNode) {\n        // Node removed\n        changes.push({\n          type: 'REMOVE',\n          path: currentPath,\n          node: oldNode\n        });\n        return;\n      }\n      \n      if (!oldNode \u0026\u0026 !newNode) return;\n      \n      // Check for property changes\n      const propertyChanges = {};\n      for (const prop of compareProperties) {\n        if (oldNode[prop] !== newNode[prop]) {\n          propertyChanges[prop] = {\n            old: oldNode[prop],\n            new: newNode[prop]\n          };\n        }\n      }\n      \n      if (Object.keys(propertyChanges).length \u003e 0) {\n        changes.push({\n          type: 'UPDATE',\n          path: currentPath,\n          changes: propertyChanges\n        });\n      }\n      \n      // Diff children\n      this.diffChildren(\n        oldNode.children || [],\n        newNode.children || [],\n        [...currentPath, newNode[keyProperty]],\n        keyProperty,\n        changes\n      );\n    };\n    \n    diff(oldTree, newTree);\n    return changes;\n  }\n\n  static diffChildren(oldChildren, newChildren, path, keyProperty, changes) {\n    const oldMap = new Map();\n    const newMap = new Map();\n    \n    // Create lookup maps\n    for (const child of oldChildren) {\n      oldMap.set(child[keyProperty], child);\n    }\n    \n    for (const child of newChildren) {\n      newMap.set(child[keyProperty], child);\n    }\n    \n    // Find added, removed, and updated children\n    for (const [key, newChild] of newMap) {\n      const oldChild = oldMap.get(key);\n      this.diffTrees(oldChild, newChild, [...path, key]);\n    }\n    \n    // Find removed children\n    for (const [key, oldChild] of oldMap) {\n      if (!newMap.has(key)) {\n        changes.push({\n          type: 'REMOVE',\n          path: [...path, key],\n          node: oldChild\n        });\n      }\n    }\n  }\n\n  // Virtualized tree rendering for large hierarchies\n  static virtualizeTree(tree, visibleRange, itemHeight) {\n    const flattenedNodes = [];\n    const expandedNodes = new Set();\n    \n    const flatten = (node, depth = 0, parentExpanded = true) =\u003e {\n      if (!parentExpanded) return;\n      \n      flattenedNodes.push({\n        ...node,\n        depth,\n        index: flattenedNodes.length,\n        hasChildren: node.children \u0026\u0026 node.children.length \u003e 0,\n        isExpanded: expandedNodes.has(node.id)\n      });\n      \n      if (node.children \u0026\u0026 expandedNodes.has(node.id)) {\n        for (const child of node.children) {\n          flatten(child, depth + 1, true);\n        }\n      }\n    };\n    \n    flatten(tree);\n    \n    const { startIndex, endIndex } = visibleRange;\n    const visibleNodes = flattenedNodes.slice(startIndex, endIndex + 1);\n    \n    return {\n      totalHeight: flattenedNodes.length * itemHeight,\n      visibleNodes,\n      totalCount: flattenedNodes.length,\n      toggleExpanded: (nodeId) =\u003e {\n        if (expandedNodes.has(nodeId)) {\n          expandedNodes.delete(nodeId);\n        } else {\n          expandedNodes.add(nodeId);\n        }\n        return this.virtualizeTree(tree, visibleRange, itemHeight);\n      }\n    };\n  }\n}\n```\n\n---\n\n## Graph Algorithms for Frontend\n\n### **Component Dependency Resolution**\n\n{% raw %}\n```javascript\n// Graph algorithms for managing component dependencies and relationships\nclass FrontendGraphAlgorithms {\n  \n  // Topological sort for component loading order\n  static topologicalSort(dependencies) {\n    const graph = new Map();\n    const inDegree = new Map();\n    const result = [];\n    \n    // Build graph and calculate in-degrees\n    for (const [component, deps] of Object.entries(dependencies)) {\n      if (!graph.has(component)) {\n        graph.set(component, []);\n        inDegree.set(component, 0);\n      }\n      \n      for (const dep of deps) {\n        if (!graph.has(dep)) {\n          graph.set(dep, []);\n          inDegree.set(dep, 0);\n        }\n        \n        graph.get(dep).push(component);\n        inDegree.set(component, inDegree.get(component) + 1);\n      }\n    }\n    \n    // Kahn's algorithm\n    const queue = [];\n    for (const [component, degree] of inDegree) {\n      if (degree === 0) {\n        queue.push(component);\n      }\n    }\n    \n    while (queue.length \u003e 0) {\n      const current = queue.shift();\n      result.push(current);\n      \n      for (const neighbor of graph.get(current) || []) {\n        inDegree.set(neighbor, inDegree.get(neighbor) - 1);\n        if (inDegree.get(neighbor) === 0) {\n          queue.push(neighbor);\n        }\n      }\n    }\n    \n    // Check for circular dependencies\n    if (result.length !== inDegree.size) {\n      const remaining = Array.from(inDegree.keys()).filter(k =\u003e !result.includes(k));\n      throw new Error(`Circular dependency detected: ${remaining.join(', ')}`);\n    }\n    \n    return result;\n  }\n\n  // Find strongly connected components for circular dependency detection\n  static findStronglyConnectedComponents(graph) {\n    const visited = new Set();\n    const stack = [];\n    const components = [];\n    \n    // First DFS to fill stack\n    const dfs1 = (node) =\u003e {\n      visited.add(node);\n      for (const neighbor of graph.get(node) || []) {\n        if (!visited.has(neighbor)) {\n          dfs1(neighbor);\n        }\n      }\n      stack.push(node);\n    };\n    \n    // Build reverse graph\n    const reverseGraph = new Map();\n    for (const [node, neighbors] of graph) {\n      if (!reverseGraph.has(node)) {\n        reverseGraph.set(node, []);\n      }\n      for (const neighbor of neighbors) {\n        if (!reverseGraph.has(neighbor)) {\n          reverseGraph.set(neighbor, []);\n        }\n        reverseGraph.get(neighbor).push(node);\n      }\n    }\n    \n    // Second DFS on reverse graph\n    const dfs2 = (node, component) =\u003e {\n      visited.add(node);\n      component.push(node);\n      for (const neighbor of reverseGraph.get(node) || []) {\n        if (!visited.has(neighbor)) {\n          dfs2(neighbor, component);\n        }\n      }\n    };\n    \n    // Process all nodes\n    for (const node of graph.keys()) {\n      if (!visited.has(node)) {\n        dfs1(node);\n      }\n    }\n    \n    visited.clear();\n    \n    while (stack.length \u003e 0) {\n      const node = stack.pop();\n      if (!visited.has(node)) {\n        const component = [];\n        dfs2(node, component);\n        components.push(component);\n      }\n    }\n    \n    return components;\n  }\n\n  // Shortest path for component communication\n  static findShortestPath(graph, start, end) {\n    if (start === end) return [start];\n    \n    const queue = [[start]];\n    const visited = new Set([start]);\n    \n    while (queue.length \u003e 0) {\n      const path = queue.shift();\n      const current = path[path.length - 1];\n      \n      for (const neighbor of graph.get(current) || []) {\n        if (neighbor === end) {\n          return [...path, neighbor];\n        }\n        \n        if (!visited.has(neighbor)) {\n          visited.add(neighbor);\n          queue.push([...path, neighbor]);\n        }\n      }\n    }\n    \n    return null; // No path found\n  }\n\n  // Component hierarchy analysis using graph traversal\n  static analyzeComponentHierarchy(componentTree) {\n    const analysis = {\n      depth: 0,\n      breadth: 0,\n      totalComponents: 0,\n      leafComponents: 0,\n      componentsByLevel: new Map(),\n      cyclomaticComplexity: 0\n    };\n    \n    const queue = [{ component: componentTree, level: 0 }];\n    const visited = new Set();\n    \n    while (queue.length \u003e 0) {\n      const { component, level } = queue.shift();\n      \n      if (visited.has(component.id)) {\n        analysis.cyclomaticComplexity++; // Potential cycle\n        continue;\n      }\n      \n      visited.add(component.id);\n      analysis.totalComponents++;\n      analysis.depth = Math.max(analysis.depth, level);\n      \n      if (!analysis.componentsByLevel.has(level)) {\n        analysis.componentsByLevel.set(level, 0);\n      }\n      analysis.componentsByLevel.set(level, analysis.componentsByLevel.get(level) + 1);\n      \n      if (!component.children || component.children.length === 0) {\n        analysis.leafComponents++;\n      } else {\n        analysis.breadth = Math.max(analysis.breadth, component.children.length);\n        for (const child of component.children) {\n          queue.push({ component: child, level: level + 1 });\n        }\n      }\n    }\n    \n    return analysis;\n  }\n\n  // Graph coloring for conflict resolution\n  static graphColoring(conflictGraph, colors = ['red', 'blue', 'green', 'yellow']) {\n    const coloring = new Map();\n    const nodes = Array.from(conflictGraph.keys());\n    \n    // Sort nodes by degree (most connected first)\n    nodes.sort((a, b) =\u003e {\n      const degreeA = conflictGraph.get(a)?.length || 0;\n      const degreeB = conflictGraph.get(b)?.length || 0;\n      return degreeB - degreeA;\n    });\n    \n    for (const node of nodes) {\n      const usedColors = new Set();\n      \n      // Check colors used by neighbors\n      for (const neighbor of conflictGraph.get(node) || []) {\n        if (coloring.has(neighbor)) {\n          usedColors.add(coloring.get(neighbor));\n        }\n      }\n      \n      // Find first available color\n      for (const color of colors) {\n        if (!usedColors.has(color)) {\n          coloring.set(node, color);\n          break;\n        }\n      }\n      \n      // If no color available, add a new one\n      if (!coloring.has(node)) {\n        const newColor = `color_${colors.length}`;\n        colors.push(newColor);\n        coloring.set(node, newColor);\n      }\n    }\n    \n    return {\n      coloring: Object.fromEntries(coloring),\n      colorCount: new Set(coloring.values()).size,\n      isValidColoring: this.validateColoring(conflictGraph, coloring)\n    };\n  }\n\n  static validateColoring(graph, coloring) {\n    for (const [node, neighbors] of graph) {\n      const nodeColor = coloring.get(node);\n      for (const neighbor of neighbors) {\n        if (coloring.get(neighbor) === nodeColor) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // Minimum spanning tree for optimal component connections\n  static minimumSpanningTree(graph, weights) {\n    const mst = [];\n    const visited = new Set();\n    const edges = [];\n    \n    // Convert graph to edge list\n    for (const [from, neighbors] of graph) {\n      for (const to of neighbors) {\n        const weight = weights.get(`${from}-${to}`) || weights.get(`${to}-${from}`) || 1;\n        edges.push({ from, to, weight });\n      }\n    }\n    \n    // Sort edges by weight\n    edges.sort((a, b) =\u003e a.weight - b.weight);\n    \n    // Union-Find data structure\n    const parent = new Map();\n    const rank = new Map();\n    \n    const find = (x) =\u003e {\n      if (!parent.has(x)) {\n        parent.set(x, x);\n        rank.set(x, 0);\n      }\n      if (parent.get(x) !== x) {\n        parent.set(x, find(parent.get(x)));\n      }\n      return parent.get(x);\n    };\n    \n    const union = (x, y) =\u003e {\n      const rootX = find(x);\n      const rootY = find(y);\n      \n      if (rootX !== rootY) {\n        if (rank.get(rootX) \u003c rank.get(rootY)) {\n          parent.set(rootX, rootY);\n        } else if (rank.get(rootX) \u003e rank.get(rootY)) {\n          parent.set(rootY, rootX);\n        } else {\n          parent.set(rootY, rootX);\n          rank.set(rootX, rank.get(rootX) + 1);\n        }\n        return true;\n      }\n      return false;\n    };\n    \n    // Kruskal's algorithm\n    for (const edge of edges) {\n      if (union(edge.from, edge.to)) {\n        mst.push(edge);\n      }\n    }\n    \n    return mst;\n  }\n}\n```\n{% endraw %}\n\n---\n\n## Optimization Algorithms\n\n### **Frontend-Specific Optimizations**\n\n```javascript\n// Optimization algorithms for frontend performance\nclass FrontendOptimizationAlgorithms {\n  \n  // Bundle splitting optimization using dynamic programming\n  static optimizeBundleSplitting(modules, maxBundleSize = 250000) {\n    const n = modules.length;\n    const dp = Array(n + 1).fill().map(() =\u003e Array(maxBundleSize + 1).fill(0));\n    const bundles = [];\n    \n    // Sort modules by importance/usage frequency\n    modules.sort((a, b) =\u003e (b.importance || 0) - (a.importance || 0));\n    \n    // Dynamic programming to find optimal bundles\n    for (let i = 1; i \u003c= n; i++) {\n      const module = modules[i - 1];\n      const size = module.size;\n      const value = module.importance || 1;\n      \n      for (let w = 0; w \u003c= maxBundleSize; w++) {\n        dp[i][w] = dp[i - 1][w]; // Don't include current module\n        \n        if (size \u003c= w) {\n          dp[i][w] = Math.max(dp[i][w], dp[i - 1][w - size] + value);\n        }\n      }\n    }\n    \n    // Backtrack to find which modules to include\n    let w = maxBundleSize;\n    const currentBundle = [];\n    let currentSize = 0;\n    \n    for (let i = n; i \u003e 0 \u0026\u0026 w \u003e 0; i--) {\n      if (dp[i][w] !== dp[i - 1][w]) {\n        const module = modules[i - 1];\n        currentBundle.push(module);\n        currentSize += module.size;\n        w -= module.size;\n      }\n    }\n    \n    bundles.push({\n      modules: currentBundle,\n      size: currentSize,\n      value: dp[n][maxBundleSize]\n    });\n    \n    // Recursively create remaining bundles\n    const remainingModules = modules.filter(m =\u003e !currentBundle.includes(m));\n    if (remainingModules.length \u003e 0) {\n      const remainingBundles = this.optimizeBundleSplitting(remainingModules, maxBundleSize);\n      bundles.push(...remainingBundles);\n    }\n    \n    return bundles;\n  }\n\n  // Resource loading optimization using greedy algorithm\n  static optimizeResourceLoading(resources, bandwidth = 1000000) { // 1MB/s default\n    const critical = resources.filter(r =\u003e r.critical);\n    const nonCritical = resources.filter(r =\u003e !r.critical);\n    \n    // Sort critical resources by priority, non-critical by size/importance ratio\n    critical.sort((a, b) =\u003e (b.priority || 0) - (a.priority || 0));\n    nonCritical.sort((a, b) =\u003e {\n      const ratioA = (a.importance || 1) / a.size;\n      const ratioB = (b.importance || 1) / b.size;\n      return ratioB - ratioA;\n    });\n    \n    const loadingSchedule = [];\n    let currentTime = 0;\n    let currentBandwidth = bandwidth;\n    \n    // Schedule critical resources first\n    for (const resource of critical) {\n      const loadTime = resource.size / currentBandwidth;\n      loadingSchedule.push({\n        resource,\n        startTime: currentTime,\n        endTime: currentTime + loadTime,\n        priority: 'critical'\n      });\n      currentTime += loadTime;\n    }\n    \n    // Schedule non-critical resources\n    const nonCriticalBatches = this.createLoadingBatches(nonCritical, bandwidth);\n    \n    for (const batch of nonCriticalBatches) {\n      const batchStartTime = currentTime;\n      let maxBatchTime = 0;\n      \n      for (const resource of batch) {\n        const loadTime = resource.size / (bandwidth / batch.length); // Parallel loading\n        loadingSchedule.push({\n          resource,\n          startTime: batchStartTime,\n          endTime: batchStartTime + loadTime,\n          priority: 'normal'\n        });\n        maxBatchTime = Math.max(maxBatchTime, loadTime);\n      }\n      \n      currentTime += maxBatchTime;\n    }\n    \n    return {\n      schedule: loadingSchedule,\n      totalTime: currentTime,\n      criticalTime: critical.reduce((sum, r) =\u003e sum + (r.size / bandwidth), 0)\n    };\n  }\n\n  static createLoadingBatches(resources, bandwidth) {\n    const batches = [];\n    let currentBatch = [];\n    let currentBatchSize = 0;\n    const maxBatchSize = bandwidth * 0.5; // Don't exceed 50% bandwidth per batch\n    \n    for (const resource of resources) {\n      if (currentBatchSize + resource.size \u003e maxBatchSize \u0026\u0026 currentBatch.length \u003e 0) {\n        batches.push([...currentBatch]);\n        currentBatch = [resource];\n        currentBatchSize = resource.size;\n      } else {\n        currentBatch.push(resource);\n        currentBatchSize += resource.size;\n      }\n    }\n    \n    if (currentBatch.length \u003e 0) {\n      batches.push(currentBatch);\n    }\n    \n    return batches;\n  }\n\n  // Cache optimization using LRU and frequency-based algorithms\n  static optimizeCache(accessPattern, cacheSize = 100) {\n    const lruCache = new Map();\n    const frequencyCache = new Map();\n    const accessCount = new Map();\n    \n    let lruHits = 0;\n    let frequencyHits = 0;\n    \n    // Simulate LRU cache\n    for (const item of accessPattern) {\n      if (lruCache.has(item)) {\n        lruHits++;\n        // Move to end (most recently used)\n        lruCache.delete(item);\n        lruCache.set(item, true);\n      } else {\n        if (lruCache.size \u003e= cacheSize) {\n          // Remove least recently used (first item)\n          const lru = lruCache.keys().next().value;\n          lruCache.delete(lru);\n        }\n        lruCache.set(item, true);\n      }\n    }\n    \n    // Reset for frequency-based cache\n    for (const item of accessPattern) {\n      accessCount.set(item, (accessCount.get(item) || 0) + 1);\n      \n      if (frequencyCache.has(item)) {\n        frequencyHits++;\n      } else {\n        if (frequencyCache.size \u003e= cacheSize) {\n          // Remove least frequently used\n          let lfu = null;\n          let minCount = Infinity;\n          \n          for (const cachedItem of frequencyCache.keys()) {\n            const count = accessCount.get(cachedItem) || 0;\n            if (count \u003c minCount) {\n              minCount = count;\n              lfu = cachedItem;\n            }\n          }\n          \n          if (lfu) {\n            frequencyCache.delete(lfu);\n          }\n        }\n        frequencyCache.set(item, true);\n      }\n    }\n    \n    return {\n      lru: {\n        hits: lruHits,\n        hitRate: lruHits / accessPattern.length\n      },\n      frequency: {\n        hits: frequencyHits,\n        hitRate: frequencyHits / accessPattern.length\n      },\n      recommendation: frequencyHits \u003e lruHits ? 'frequency-based' : 'lru'\n    };\n  }\n\n  // Image optimization algorithm\n  static optimizeImageLoading(images, viewportSize = { width: 1920, height: 1080 }) {\n    const optimizedImages = [];\n    \n    for (const image of images) {\n      const optimization = {\n        original: image,\n        recommendations: []\n      };\n      \n      // Resize recommendation\n      if (image.width \u003e viewportSize.width || image.height \u003e viewportSize.height) {\n        const scale = Math.min(\n          viewportSize.width / image.width,\n          viewportSize.height / image.height\n        );\n        \n        optimization.recommendations.push({\n          type: 'resize',\n          newWidth: Math.floor(image.width * scale),\n          newHeight: Math.floor(image.height * scale),\n          savings: `${(100 - scale * 100).toFixed(1)}% size reduction`\n        });\n      }\n      \n      // Format recommendation\n      const formatRecommendation = this.getOptimalImageFormat(image);\n      if (formatRecommendation) {\n        optimization.recommendations.push(formatRecommendation);\n      }\n      \n      // Lazy loading recommendation\n      if (!image.critical) {\n        optimization.recommendations.push({\n          type: 'lazy-loading',\n          description: 'Load image when it enters viewport'\n        });\n      }\n      \n      // Progressive loading recommendation\n      if (image.size \u003e 100000) { // 100KB\n        optimization.recommendations.push({\n          type: 'progressive',\n          description: 'Use progressive JPEG or WebP'\n        });\n      }\n      \n      optimizedImages.push(optimization);\n    }\n    \n    return optimizedImages;\n  }\n\n  static getOptimalImageFormat(image) {\n    if (image.hasTransparency) {\n      return {\n        type: 'format',\n        recommendation: 'WebP or PNG',\n        reason: 'Image has transparency'\n      };\n    }\n    \n    if (image.isPhoto) {\n      return {\n        type: 'format',\n        recommendation: 'WebP or JPEG',\n        reason: 'Photographic content compresses well with lossy formats'\n      };\n    }\n    \n    if (image.hasText || image.isIcon) {\n      return {\n        type: 'format',\n        recommendation: 'SVG or WebP',\n        reason: 'Vector format better for text and icons'\n      };\n    }\n    \n    return null;\n  }\n\n  // Code splitting optimization\n  static optimizeCodeSplitting(componentUsage, bundleTargetSize = 250000) {\n    const components = Object.entries(componentUsage).map(([name, data]) =\u003e ({\n      name,\n      ...data\n    }));\n    \n    // Group components by usage patterns\n    const highFrequency = components.filter(c =\u003e c.frequency \u003e 0.7);\n    const mediumFrequency = components.filter(c =\u003e c.frequency \u003e 0.3 \u0026\u0026 c.frequency \u003c= 0.7);\n    const lowFrequency = components.filter(c =\u003e c.frequency \u003c= 0.3);\n    \n    const splitStrategy = {\n      core: {\n        components: highFrequency,\n        priority: 'critical',\n        loadStrategy: 'eager'\n      },\n      features: this.groupComponentsByFeature(mediumFrequency, bundleTargetSize),\n      lazy: {\n        components: lowFrequency,\n        priority: 'low',\n        loadStrategy: 'lazy'\n      }\n    };\n    \n    return splitStrategy;\n  }\n\n  static groupComponentsByFeature(components, targetSize) {\n    const features = new Map();\n    \n    // Group by feature/route\n    for (const component of components) {\n      const feature = component.feature || component.route || 'common';\n      if (!features.has(feature)) {\n        features.set(feature, []);\n      }\n      features.get(feature).push(component);\n    }\n    \n    // Optimize bundle sizes within features\n    const optimizedFeatures = [];\n    \n    for (const [featureName, featureComponents] of features) {\n      const totalSize = featureComponents.reduce((sum, c) =\u003e sum + c.size, 0);\n      \n      if (totalSize \u003c= targetSize) {\n        optimizedFeatures.push({\n          name: featureName,\n          components: featureComponents,\n          size: totalSize,\n          loadStrategy: 'route-based'\n        });\n      } else {\n        // Split large features into smaller bundles\n        const subBundles = this.splitLargeFeature(featureComponents, targetSize);\n        optimizedFeatures.push(...subBundles.map(bundle =\u003e ({\n          name: `${featureName}-${bundle.index}`,\n          components: bundle.components,\n          size: bundle.size,\n          loadStrategy: 'progressive'\n        })));\n      }\n    }\n    \n    return optimizedFeatures;\n  }\n\n  static splitLargeFeature(components, targetSize) {\n    const bundles = [];\n    let currentBundle = [];\n    let currentSize = 0;\n    let bundleIndex = 0;\n    \n    // Sort by dependency order and importance\n    components.sort((a, b) =\u003e (b.importance || 0) - (a.importance || 0));\n    \n    for (const component of components) {\n      if (currentSize + component.size \u003e targetSize \u0026\u0026 currentBundle.length \u003e 0) {\n        bundles.push({\n          index: bundleIndex++,\n          components: [...currentBundle],\n          size: currentSize\n        });\n        currentBundle = [component];\n        currentSize = component.size;\n      } else {\n        currentBundle.push(component);\n        currentSize += component.size;\n      }\n    }\n    \n    if (currentBundle.length \u003e 0) {\n      bundles.push({\n        index: bundleIndex,\n        components: currentBundle,\n        size: currentSize\n      });\n    }\n    \n    return bundles;\n  }\n}\n```\n\nThis comprehensive guide provides essential algorithms and data structures specifically tailored for frontend development challenges, optimization problems, and user interface requirements commonly encountered in Big Tech interviews.\n"])</script><script>self.__next_f.push([1,"8:[\"slug\",\"frontend/fundamentals/algorithms-data-structures-frontend\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L3\",null,{\"buildId\":\"fjDGwqtt1UnBZeA2uH4xO\",\"assetPrefix\":\"/interview\",\"urlParts\":[\"\",\"docs\",\"frontend\",\"fundamentals\",\"algorithms-data-structures-frontend\"],\"initialTree\":[\"\",{\"children\":[\"docs\",{\"children\":[[\"slug\",\"frontend/fundamentals/algorithms-data-structures-frontend\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"frontend\\\",\\\"fundamentals\\\",\\\"algorithms-data-structures-frontend\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"docs\",{\"children\":[[\"slug\",\"frontend/fundamentals/algorithms-data-structures-frontend\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",[\"$\",\"div\",null,{\"style\":{\"maxWidth\":\"1200px\",\"margin\":\"0 auto\",\"padding\":\"2rem\",\"paddingTop\":\"6rem\"},\"children\":[[\"$\",\"div\",null,{\"style\":{\"marginBottom\":\"2rem\"},\"children\":[[\"$\",\"nav\",null,{\"style\":{\"color\":\"#64748b\",\"fontSize\":\"0.9rem\",\"marginBottom\":\"1rem\"},\"children\":[[\"$\",\"a\",null,{\"href\":\"/interview\",\"style\":{\"color\":\"#3b82f6\",\"textDecoration\":\"none\"},\"children\":\"Home\"}],\" \u003e \",[\"$\",\"span\",null,{\"children\":\"frontend \u003e fundamentals \u003e algorithms-data-structures-frontend\"}]]}],[\"$\",\"h1\",null,{\"style\":{\"fontSize\":\"2.5rem\",\"fontWeight\":\"800\",\"marginBottom\":\"0.5rem\",\"color\":\"#1e293b\"},\"children\":\"Algorithms Data Structures Frontend\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#64748b\",\"fontSize\":\"0.9rem\",\"marginBottom\":\"2rem\"},\"children\":[[\"$\",\"span\",null,{\"children\":[\"üìÅ \",\"frontend/fundamentals/algorithms-data-structures-frontend.md\"]}],\"$undefined\",\"$undefined\"]}]]}],[\"$\",\"$L5\",null,{\"content\":\"$6\"}]]}],null],null],null]},[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"docs\",\"children\",\"$8\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"docs\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/interview/_next/static/css/387024c6a2216908.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}],\"params\":{}}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Algorithms Data Structures Frontend - Frontend Interview Docs\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"# Algorithms \u0026 Data Structures for Frontend  ## Overview Frontend engineers need strong algorithmic thinking for optimization, data manipulation, and building e\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"Algorithms Data Structures Frontend - Frontend Interview Docs\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"# Algorithms \u0026 Data Structures for Frontend  ## Overview Frontend engineers need strong algorithmic thinking for optimization, data manipulation, and building e\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Algorithms Data Structures Frontend - Frontend Interview Docs\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"# Algorithms \u0026 Data Structures for Frontend  ## Overview Frontend engineers need strong algorithmic thinking for optimization, data manipulation, and building e\"}],[\"$\",\"meta\",\"10\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>