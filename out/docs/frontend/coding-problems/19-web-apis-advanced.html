<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/interview/_next/static/css/387024c6a2216908.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js"/><script src="/interview/_next/static/chunks/fd9d1056-6922f449a204c2cc.js" async=""></script><script src="/interview/_next/static/chunks/117-e7ecc085ce9cfab3.js" async=""></script><script src="/interview/_next/static/chunks/main-app-b06be5f3411c20c3.js" async=""></script><script src="/interview/_next/static/chunks/918-3273b83890f10546.js" async=""></script><script src="/interview/_next/static/chunks/930-3262a6c9c5acace4.js" async=""></script><script src="/interview/_next/static/chunks/app/docs/%5B...slug%5D/page-036ada1d0a865043.js" async=""></script><script src="/interview/_next/static/chunks/710-dfaa11b4dff08f8e.js" async=""></script><script src="/interview/_next/static/chunks/972-011bba60ed155615.js" async=""></script><script src="/interview/_next/static/chunks/233-3e0c1d820a17eca9.js" async=""></script><script src="/interview/_next/static/chunks/app/layout-333f4adcd11f8f39.js" async=""></script><title>Frontend Interview Prep 2025 - Big Tech Interview Guide</title><meta name="description" content="Comprehensive frontend interview preparation for Big Tech companies including React, TypeScript, algorithms, and system design."/><link rel="icon" href="/favicon.ico"/><meta name="theme-color" content="#1a1a1a"/><meta property="og:title" content="Frontend Interview Prep 2025"/><meta property="og:description" content="Complete guide for frontend engineers targeting Big Tech companies"/><meta property="og:type" content="website"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><title>Advanced Web APIs Challenges - Frontend Interview Docs</title><meta name="description" content=" # Advanced Web APIs Challenges  ## Overview Modern Web APIs provide powerful capabilities for building sophisticated frontend applications. These challenges fo"/><meta property="og:title" content="Advanced Web APIs Challenges - Frontend Interview Docs"/><meta property="og:description" content=" # Advanced Web APIs Challenges  ## Overview Modern Web APIs provide powerful capabilities for building sophisticated frontend applications. These challenges fo"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Advanced Web APIs Challenges - Frontend Interview Docs"/><meta name="twitter:description" content=" # Advanced Web APIs Challenges  ## Overview Modern Web APIs provide powerful capabilities for building sophisticated frontend applications. These challenges fo"/><meta name="next-size-adjust"/><script src="/interview/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script><style data-styled="" data-styled-version="6.1.19">*{margin:0;padding:0;box-sizing:border-box;}/*!sc*/
html{font-size:16px;line-height:1.5;scroll-behavior:smooth;}/*!sc*/
body{font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;font-size:1rem;line-height:1.5;color:#1e293b;background-color:#ffffff;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
h1,h2,h3,h4,h5,h6{font-weight:700;line-height:1.25;margin-bottom:0.5em;}/*!sc*/
h1{font-size:3rem;}/*!sc*/
@media (max-width: 768px){h1{font-size:2.25rem;}}/*!sc*/
h2{font-size:2.25rem;}/*!sc*/
@media (max-width: 768px){h2{font-size:1.875rem;}}/*!sc*/
h3{font-size:1.875rem;}/*!sc*/
@media (max-width: 768px){h3{font-size:1.5rem;}}/*!sc*/
h4{font-size:1.5rem;}/*!sc*/
@media (max-width: 768px){h4{font-size:1.25rem;}}/*!sc*/
h5{font-size:1.25rem;}/*!sc*/
h6{font-size:1.125rem;}/*!sc*/
p{margin-bottom:1rem;line-height:1.75;}/*!sc*/
a{color:#3b82f6;text-decoration:none;transition:color 0.15s ease;}/*!sc*/
a:hover{color:#2563eb;}/*!sc*/
a:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
button{cursor:pointer;border:none;background:none;font-family:inherit;font-size:inherit;}/*!sc*/
button:disabled{cursor:not-allowed;opacity:0.6;}/*!sc*/
button:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
input,textarea,select{font-family:inherit;font-size:inherit;}/*!sc*/
input:focus,textarea:focus,select:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
img{max-width:100%;height:auto;}/*!sc*/
ul,ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
li{margin-bottom:0.25rem;}/*!sc*/
blockquote{margin:1rem 0;padding:1rem;border-left:4px solid #3b82f6;background-color:#f1f5f9;font-style:italic;}/*!sc*/
code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;background-color:#f1f5f9;padding:0.2em 0.4em;border-radius:0.25rem;}/*!sc*/
pre{background-color:#f1f5f9;padding:1rem;border-radius:0.5rem;overflow-x:auto;margin-bottom:1rem;}/*!sc*/
pre code{background:none;padding:0;}/*!sc*/
table{width:100%;border-collapse:collapse;margin-bottom:1rem;}/*!sc*/
th,td{padding:0.75rem;text-align:left;border-bottom:1px solid #e2e8f0;}/*!sc*/
th{font-weight:600;background-color:#f1f5f9;}/*!sc*/
.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0;}/*!sc*/
.skip-link{position:absolute;top:-40px;left:6px;background:#3b82f6;color:white;padding:8px;text-decoration:none;border-radius:4px;z-index:100;}/*!sc*/
.skip-link:focus{top:6px;}/*!sc*/
::-webkit-scrollbar{width:8px;height:8px;}/*!sc*/
::-webkit-scrollbar-track{background:#f1f5f9;}/*!sc*/
::-webkit-scrollbar-thumb{background:#94a3b8;border-radius:4px;}/*!sc*/
::-webkit-scrollbar-thumb:hover{background:#64748b;}/*!sc*/
::selection{background:#3b82f6;color:white;}/*!sc*/
.focus-visible{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
.fade-in{opacity:0;animation:fadeIn 0.3s ease forwards;}/*!sc*/
.slide-up{transform:translateY(20px);opacity:0;animation:slideUp 0.3s ease forwards;}/*!sc*/
@keyframes fadeIn{to{opacity:1;}}/*!sc*/
@keyframes slideUp{to{transform:translateY(0);opacity:1;}}/*!sc*/
@media print{*{background:white!important;color:black!important;box-shadow:none!important;text-shadow:none!important;}a,a:visited{text-decoration:underline;}h1,h2,h3,h4,h5,h6{break-after:avoid;}pre,blockquote{border:1px solid #999;break-inside:avoid;}img{max-width:100%!important;}@page{margin:0.5in;}}/*!sc*/
data-styled.g65[id="sc-global-kxA-Ddz1"]{content:"sc-global-kxA-Ddz1,"}/*!sc*/
.cIzzQl{position:fixed;top:0;width:100%;z-index:1020;background:transparent;backdrop-filter:blur(10px);border-bottom:1px solid transparent;transition:all 0.3s ease;}/*!sc*/
data-styled.g66[id="sc-dTWiOz"]{content:"cIzzQl,"}/*!sc*/
.cqZxah{max-width:1200px;margin:0 auto;padding:0 2rem;display:flex;align-items:center;justify-content:space-between;height:70px;}/*!sc*/
data-styled.g67[id="sc-eJoXEY"]{content:"cqZxah,"}/*!sc*/
.hUlCET{display:flex;align-items:center;gap:0.5rem;font-size:1.5rem;font-weight:700;color:#3b82f6;text-decoration:none;cursor:pointer;}/*!sc*/
.hUlCET:hover{color:#2563eb;}/*!sc*/
data-styled.g68[id="sc-goiVcJ"]{content:"hUlCET,"}/*!sc*/
.fXlING{display:flex;align-items:center;gap:2rem;}/*!sc*/
@media (max-width: 768px){.fXlING{display:none;}}/*!sc*/
data-styled.g69[id="sc-gSifMm"]{content:"fXlING,"}/*!sc*/
.ctmqex{color:#1e293b;font-weight:500;text-decoration:none;transition:color 0.15s ease;position:relative;}/*!sc*/
.ctmqex:hover{color:#3b82f6;}/*!sc*/
.ctmqex:after{content:'';position:absolute;bottom:-5px;left:0;width:0;height:2px;background:#3b82f6;transition:width 0.15s ease;}/*!sc*/
.ctmqex:hover:after{width:100%;}/*!sc*/
data-styled.g70[id="sc-ixcdjX"]{content:"ctmqex,"}/*!sc*/
.eTvMgH{display:none;background:none;border:none;color:#1e293b;cursor:pointer;padding:0.5rem;}/*!sc*/
@media (max-width: 768px){.eTvMgH{display:block;}}/*!sc*/
data-styled.g71[id="sc-eQaGpr"]{content:"eTvMgH,"}/*!sc*/
.cRlGRt{display:flex;align-items:center;gap:0.5rem;background:#f1f5f9;border:1px solid #e2e8f0;border-radius:0.5rem;padding:0.5rem 1rem;color:#64748b;font-size:0.9rem;transition:all 0.15s ease;}/*!sc*/
.cRlGRt:hover{background:#ffffff;border-color:#3b82f6;}/*!sc*/
data-styled.g75[id="sc-bBhMX"]{content:"cRlGRt,"}/*!sc*/
.fgAPRO{background:#1e293b;color:white;padding:3rem 0 1rem;margin-top:auto;}/*!sc*/
data-styled.g76[id="sc-hwHXyi"]{content:"fgAPRO,"}/*!sc*/
.bQkEEK{max-width:1200px;margin:0 auto;padding:0 2rem;}/*!sc*/
data-styled.g77[id="sc-ciCoXh"]{content:"bQkEEK,"}/*!sc*/
.lmmFoJ{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:2rem;margin-bottom:2rem;}/*!sc*/
@media (max-width: 768px){.lmmFoJ{grid-template-columns:1fr 1fr;gap:1.5rem;}}/*!sc*/
@media (max-width: 480px){.lmmFoJ{grid-template-columns:1fr;}}/*!sc*/
data-styled.g78[id="sc-jDJeIs"]{content:"lmmFoJ,"}/*!sc*/
.bKIGXv h3{font-size:1.1rem;font-weight:600;margin-bottom:1rem;color:white;}/*!sc*/
.bKIGXv ul{list-style:none;padding:0;margin:0;}/*!sc*/
.bKIGXv li{margin-bottom:0.5rem;}/*!sc*/
.bKIGXv a{color:rgba(255, 255, 255, 0.7);text-decoration:none;transition:color 0.15s ease;}/*!sc*/
.bKIGXv a:hover{color:white;}/*!sc*/
data-styled.g79[id="sc-eEHciv"]{content:"bKIGXv,"}/*!sc*/
.bMtRdQ{display:flex;align-items:center;gap:0.5rem;font-size:1.2rem;font-weight:700;margin-bottom:1rem;color:white;}/*!sc*/
data-styled.g80[id="sc-KsiuK"]{content:"bMtRdQ,"}/*!sc*/
.eRTluy{color:rgba(255, 255, 255, 0.7);line-height:1.6;margin-bottom:1rem;}/*!sc*/
data-styled.g81[id="sc-hqtLyI"]{content:"eRTluy,"}/*!sc*/
.jlMcom{display:flex;gap:1rem;}/*!sc*/
.jlMcom a{display:flex;align-items:center;justify-content:center;width:40px;height:40px;background:rgba(255, 255, 255, 0.1);border-radius:0.5rem;color:rgba(255, 255, 255, 0.7);transition:all 0.15s ease;}/*!sc*/
.jlMcom a:hover{background:rgba(255, 255, 255, 0.2);color:white;}/*!sc*/
data-styled.g82[id="sc-iVnIWt"]{content:"jlMcom,"}/*!sc*/
.fuxrZK{border-top:1px solid rgba(255, 255, 255, 0.1);padding-top:2rem;display:flex;justify-content:space-between;align-items:center;}/*!sc*/
@media (max-width: 768px){.fuxrZK{flex-direction:column;gap:1rem;text-align:center;}}/*!sc*/
data-styled.g83[id="sc-hWgKua"]{content:"fuxrZK,"}/*!sc*/
.fMpVBW{color:rgba(255, 255, 255, 0.7);margin:0;font-size:0.9rem;}/*!sc*/
data-styled.g84[id="sc-jBaHRL"]{content:"fMpVBW,"}/*!sc*/
.fyWnKB{display:flex;gap:2rem;}/*!sc*/
@media (max-width: 480px){.fyWnKB{flex-direction:column;gap:1rem;}}/*!sc*/
.fyWnKB a{color:rgba(255, 255, 255, 0.7);text-decoration:none;font-size:0.9rem;transition:color 0.15s ease;}/*!sc*/
.fyWnKB a:hover{color:white;}/*!sc*/
data-styled.g85[id="sc-gFqXPY"]{content:"fyWnKB,"}/*!sc*/
.lojcFA{color:#1e293b;line-height:1.6;}/*!sc*/
.lojcFA h1,.lojcFA h2,.lojcFA h3,.lojcFA h4,.lojcFA h5,.lojcFA h6{color:#1e293b;margin-top:2rem;margin-bottom:1rem;font-weight:600;}/*!sc*/
.lojcFA h1{font-size:2rem;border-bottom:2px solid #e2e8f0;padding-bottom:0.5rem;}/*!sc*/
.lojcFA h2{font-size:1.5rem;border-bottom:1px solid #e2e8f0;padding-bottom:0.3rem;}/*!sc*/
.lojcFA h3{font-size:1.25rem;}/*!sc*/
.lojcFA h4{font-size:1.1rem;}/*!sc*/
.lojcFA p{margin-bottom:1rem;color:#64748b;}/*!sc*/
.lojcFA a{color:#3b82f6;text-decoration:none;}/*!sc*/
.lojcFA a:hover{text-decoration:underline;}/*!sc*/
.lojcFA ul,.lojcFA ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
.lojcFA ul li,.lojcFA ol li{margin-bottom:0.5rem;color:#64748b;}/*!sc*/
.lojcFA blockquote{border-left:4px solid #3b82f6;padding-left:1rem;margin:1rem 0;font-style:italic;color:#64748b;background:#f1f5f9;padding:1rem;border-radius:0.5rem;}/*!sc*/
.lojcFA code{background:#f1f5f9;padding:0.2rem 0.4rem;border-radius:0.25rem;font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;color:#f59e0b;}/*!sc*/
.lojcFA pre{background:#ffffff;border:1px solid #e2e8f0;border-radius:0.5rem;padding:1rem;margin:1rem 0;overflow-x:auto;}/*!sc*/
.lojcFA pre code{background:none;padding:0;color:#1e293b;font-size:0.9rem;}/*!sc*/
.lojcFA table{width:100%;border-collapse:collapse;margin:1rem 0;}/*!sc*/
.lojcFA table th,.lojcFA table td{border:1px solid #e2e8f0;padding:0.5rem;text-align:left;}/*!sc*/
.lojcFA table th{background:#ffffff;font-weight:600;}/*!sc*/
.lojcFA table tr:nth-child(even){background:#f1f5f9;}/*!sc*/
.lojcFA hr{border:none;height:1px;background:#e2e8f0;margin:2rem 0;}/*!sc*/
.lojcFA .highlight{background:#3b82f620;padding:0.2rem 0.4rem;border-radius:0.25rem;font-weight:600;}/*!sc*/
.lojcFA .hljs{background:#ffffff;color:#1e293b;}/*!sc*/
.lojcFA .hljs-keyword{color:#3b82f6;font-weight:600;}/*!sc*/
.lojcFA .hljs-string{color:#10b981;}/*!sc*/
.lojcFA .hljs-function{color:#f59e0b;}/*!sc*/
.lojcFA .hljs-comment{color:#94a3b8;font-style:italic;}/*!sc*/
.lojcFA .hljs-number{color:#f59e0b;}/*!sc*/
.lojcFA .hljs-variable{color:#1e293b;}/*!sc*/
.lojcFA .hljs-title{color:#f59e0b;font-weight:600;}/*!sc*/
data-styled.g86[id="sc-ikkVnJ"]{content:"lojcFA,"}/*!sc*/
</style></head><body class="__className_6eac61"><div style="min-height:100vh;display:flex;flex-direction:column"><nav class="sc-dTWiOz cIzzQl"><div class="sc-eJoXEY cqZxah"><a href="/interview"><a class="sc-goiVcJ hUlCET"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</a></a><div class="sc-gSifMm fXlING"><a href="/interview/problems"><a class="sc-ixcdjX ctmqex">Problems</a></a><a href="/interview/learn"><a class="sc-ixcdjX ctmqex">Learn</a></a><a href="/interview/study-guide"><a class="sc-ixcdjX ctmqex">Study Guide</a></a><a href="/interview/system-design"><a class="sc-ixcdjX ctmqex">System Design</a></a><a href="/interview/performance"><a class="sc-ixcdjX ctmqex">Performance</a></a><a href="/interview/accessibility"><a class="sc-ixcdjX ctmqex">Accessibility</a></a><a href="/interview/interview-tips"><a class="sc-ixcdjX ctmqex">Interview Tips</a></a><button class="sc-bBhMX cRlGRt"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search "><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg>Search</button></div><button class="sc-eQaGpr eTvMgH"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu "><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button></div></nav><main style="flex:1"><div style="max-width:1200px;margin:0 auto;padding:2rem;padding-top:6rem"><div style="margin-bottom:2rem"><nav style="color:#64748b;font-size:0.9rem;margin-bottom:1rem"><a href="/interview" style="color:#3b82f6;text-decoration:none">Home</a> &gt; <span>frontend &gt; coding-problems &gt; 19-web-apis-advanced</span></nav><h1 style="font-size:2.5rem;font-weight:800;margin-bottom:0.5rem;color:#1e293b">Advanced Web APIs Challenges</h1><div style="color:#64748b;font-size:0.9rem;margin-bottom:2rem"><span>üìÅ <!-- -->frontend/coding-problems/19-web-apis-advanced.md</span></div></div><div class="sc-ikkVnJ lojcFA"><h1 id="advanced-web-apis-challenges" node="[object Object]">Advanced Web APIs Challenges</h1>
<h2 id="overview" node="[object Object]">Overview</h2>
<p>Modern Web APIs provide powerful capabilities for building sophisticated frontend applications. These challenges focus on APIs commonly tested in Big Tech interviews.</p>
<hr/>
<h2 id="challenge-1:-advanced-service-worker-with-background-sync" node="[object Object]">Challenge 1: Advanced Service Worker with Background Sync</h2>
<h3 id="problem-statement" node="[object Object]">Problem Statement</h3>
<p>Implement a robust offline-first application with background sync, push notifications, and intelligent caching strategies.</p>
<h3 id="requirements" node="[object Object]">Requirements</h3>
<ul>
<li>Offline functionality with background sync</li>
<li>Push notification handling</li>
<li>Smart caching (cache-first, network-first, stale-while-revalidate)</li>
<li>Periodic background sync</li>
<li>Message passing between main thread and service worker</li>
</ul>
<h3 id="solution" node="[object Object]">Solution</h3>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-typescript"><span class="hljs-comment">// sw.ts - Service Worker</span>
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">&#x27;app-cache-v1&#x27;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">API_CACHE</span> = <span class="hljs-string">&#x27;api-cache-v1&#x27;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">BACKGROUND_SYNC_TAG</span> = <span class="hljs-string">&#x27;background-sync&#x27;</span>;

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">QueuedRequest</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">method</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">headers</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;;
  <span class="hljs-attr">body</span>?: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">timestamp</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedServiceWorker</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">requestQueue</span>: <span class="hljs-title class_">QueuedRequest</span>[] = [];
  <span class="hljs-keyword">private</span> retryAttempts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>&gt;();

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">install</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> urlsToCache = [
      <span class="hljs-string">&#x27;/&#x27;</span>,
      <span class="hljs-string">&#x27;/static/js/bundle.js&#x27;</span>,
      <span class="hljs-string">&#x27;/static/css/main.css&#x27;</span>,
      <span class="hljs-string">&#x27;/manifest.json&#x27;</span>
    ];

    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>);
    <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">addAll</span>(urlsToCache);
    
    <span class="hljs-comment">// Skip waiting to activate immediately</span>
    <span class="hljs-keyword">await</span> self.<span class="hljs-title function_">skipWaiting</span>();
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">activate</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-comment">// Clean up old caches</span>
    <span class="hljs-keyword">const</span> cacheNames = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">keys</span>();
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(
      cacheNames
        .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> name !== <span class="hljs-variable constant_">CACHE_NAME</span> &amp;&amp; name !== <span class="hljs-variable constant_">API_CACHE</span>)
        .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> caches.<span class="hljs-title function_">delete</span>(name))
    );

    <span class="hljs-comment">// Claim all clients immediately</span>
    <span class="hljs-keyword">await</span> self.<span class="hljs-property">clients</span>.<span class="hljs-title function_">claim</span>();
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleFetch</span>(<span class="hljs-attr">event</span>: <span class="hljs-title class_">FetchEvent</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt; {
    <span class="hljs-keyword">const</span> { request } = event;
    <span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(request.<span class="hljs-property">url</span>);

    <span class="hljs-comment">// Handle API requests</span>
    <span class="hljs-keyword">if</span> (url.<span class="hljs-property">pathname</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/api/&#x27;</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleApiRequest</span>(request);
    }

    <span class="hljs-comment">// Handle static assets</span>
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleStaticRequest</span>(request);
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleApiRequest</span>(<span class="hljs-attr">request</span>: <span class="hljs-title class_">Request</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt; {
    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">API_CACHE</span>);
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Try network first</span>
      <span class="hljs-keyword">const</span> networkResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(request.<span class="hljs-title function_">clone</span>());
      
      <span class="hljs-keyword">if</span> (networkResponse.<span class="hljs-property">ok</span>) {
        <span class="hljs-comment">// Cache successful responses</span>
        <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">put</span>(request, networkResponse.<span class="hljs-title function_">clone</span>());
        <span class="hljs-keyword">return</span> networkResponse;
      }
      
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Network response not ok&#x27;</span>);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// Fall back to cache</span>
      <span class="hljs-keyword">const</span> cachedResponse = <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">match</span>(request);
      
      <span class="hljs-keyword">if</span> (cachedResponse) {
        <span class="hljs-comment">// Queue request for background sync if it&#x27;s a mutation</span>
        <span class="hljs-keyword">if</span> ([<span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;PUT&#x27;</span>, <span class="hljs-string">&#x27;DELETE&#x27;</span>, <span class="hljs-string">&#x27;PATCH&#x27;</span>].<span class="hljs-title function_">includes</span>(request.<span class="hljs-property">method</span>)) {
          <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">queueRequest</span>(request);
        }
        
        <span class="hljs-keyword">return</span> cachedResponse;
      }
      
      <span class="hljs-comment">// If no cache, queue the request and return error response</span>
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">queueRequest</span>(request);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(
        <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">error</span>: <span class="hljs-string">&#x27;Offline - request queued&#x27;</span> }),
        { <span class="hljs-attr">status</span>: <span class="hljs-number">503</span>, <span class="hljs-attr">headers</span>: { <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span> } }
      );
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleStaticRequest</span>(<span class="hljs-attr">request</span>: <span class="hljs-title class_">Request</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">Response</span>&gt; {
    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>);
    
    <span class="hljs-comment">// Cache first strategy for static assets</span>
    <span class="hljs-keyword">const</span> cachedResponse = <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">match</span>(request);
    <span class="hljs-keyword">if</span> (cachedResponse) {
      <span class="hljs-keyword">return</span> cachedResponse;
    }

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> networkResponse = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(request);
      <span class="hljs-keyword">if</span> (networkResponse.<span class="hljs-property">ok</span>) {
        <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">put</span>(request, networkResponse.<span class="hljs-title function_">clone</span>());
      }
      <span class="hljs-keyword">return</span> networkResponse;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">// Return offline page for navigation requests</span>
      <span class="hljs-keyword">if</span> (request.<span class="hljs-property">mode</span> === <span class="hljs-string">&#x27;navigate&#x27;</span>) {
        <span class="hljs-keyword">const</span> offlinePage = <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;/offline.html&#x27;</span>);
        <span class="hljs-keyword">return</span> offlinePage || <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-string">&#x27;Offline&#x27;</span>, { <span class="hljs-attr">status</span>: <span class="hljs-number">503</span> });
      }
      
      <span class="hljs-keyword">throw</span> error;
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">queueRequest</span>(<span class="hljs-attr">request</span>: <span class="hljs-title class_">Request</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> <span class="hljs-attr">queuedRequest</span>: <span class="hljs-title class_">QueuedRequest</span> = {
      <span class="hljs-attr">id</span>: crypto.<span class="hljs-title function_">randomUUID</span>(),
      <span class="hljs-attr">url</span>: request.<span class="hljs-property">url</span>,
      <span class="hljs-attr">method</span>: request.<span class="hljs-property">method</span>,
      <span class="hljs-attr">headers</span>: <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(request.<span class="hljs-property">headers</span>.<span class="hljs-title function_">entries</span>()),
      <span class="hljs-attr">body</span>: request.<span class="hljs-property">method</span> !== <span class="hljs-string">&#x27;GET&#x27;</span> ? <span class="hljs-keyword">await</span> request.<span class="hljs-title function_">text</span>() : <span class="hljs-literal">undefined</span>,
      <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestQueue</span>.<span class="hljs-title function_">push</span>(queuedRequest);
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">saveRequestQueue</span>();
    
    <span class="hljs-comment">// Register for background sync</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> self &amp;&amp; <span class="hljs-string">&#x27;sync&#x27;</span> <span class="hljs-keyword">in</span> self.<span class="hljs-property">registration</span>) {
      <span class="hljs-keyword">await</span> self.<span class="hljs-property">registration</span>.<span class="hljs-property">sync</span>.<span class="hljs-title function_">register</span>(<span class="hljs-variable constant_">BACKGROUND_SYNC_TAG</span>);
    }
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleBackgroundSync</span>(<span class="hljs-attr">tag</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">if</span> (tag === <span class="hljs-variable constant_">BACKGROUND_SYNC_TAG</span>) {
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">processRequestQueue</span>();
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">processRequestQueue</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadRequestQueue</span>();
    
    <span class="hljs-keyword">const</span> <span class="hljs-attr">failedRequests</span>: <span class="hljs-title class_">QueuedRequest</span>[] = [];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> queuedRequest <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestQueue</span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> request = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>(queuedRequest.<span class="hljs-property">url</span>, {
          <span class="hljs-attr">method</span>: queuedRequest.<span class="hljs-property">method</span>,
          <span class="hljs-attr">headers</span>: queuedRequest.<span class="hljs-property">headers</span>,
          <span class="hljs-attr">body</span>: queuedRequest.<span class="hljs-property">body</span>
        });

        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(request);
        
        <span class="hljs-keyword">if</span> (response.<span class="hljs-property">ok</span>) {
          <span class="hljs-comment">// Success - notify main thread</span>
          <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">notifyClients</span>(<span class="hljs-string">&#x27;sync-success&#x27;</span>, { 
            <span class="hljs-attr">requestId</span>: queuedRequest.<span class="hljs-property">id</span>,
            <span class="hljs-attr">url</span>: queuedRequest.<span class="hljs-property">url</span> 
          });
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`HTTP <span class="hljs-subst">${response.status}</span>`</span>);
        }
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-keyword">const</span> attempts = <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryAttempts</span>.<span class="hljs-title function_">get</span>(queuedRequest.<span class="hljs-property">id</span>) || <span class="hljs-number">0</span>;
        
        <span class="hljs-keyword">if</span> (attempts &lt; <span class="hljs-number">3</span>) {
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">retryAttempts</span>.<span class="hljs-title function_">set</span>(queuedRequest.<span class="hljs-property">id</span>, attempts + <span class="hljs-number">1</span>);
          failedRequests.<span class="hljs-title function_">push</span>(queuedRequest);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// Max retries reached - notify failure</span>
          <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">notifyClients</span>(<span class="hljs-string">&#x27;sync-failed&#x27;</span>, {
            <span class="hljs-attr">requestId</span>: queuedRequest.<span class="hljs-property">id</span>,
            <span class="hljs-attr">url</span>: queuedRequest.<span class="hljs-property">url</span>,
            <span class="hljs-attr">error</span>: error.<span class="hljs-property">message</span>
          });
        }
      }
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestQueue</span> = failedRequests;
    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">saveRequestQueue</span>();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">saveRequestQueue</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>);
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">requestQueue</span>));
    <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">put</span>(<span class="hljs-string">&#x27;/sw-queue&#x27;</span>, response);
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">loadRequestQueue</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> cache = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>);
    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> cache.<span class="hljs-title function_">match</span>(<span class="hljs-string">&#x27;/sw-queue&#x27;</span>);
    
    <span class="hljs-keyword">if</span> (response) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestQueue</span> = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();
    }
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handlePush</span>(<span class="hljs-attr">event</span>: <span class="hljs-title class_">PushEvent</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> data = event.<span class="hljs-property">data</span>?.<span class="hljs-title function_">json</span>() || {};
    
    <span class="hljs-keyword">const</span> <span class="hljs-attr">options</span>: <span class="hljs-title class_">NotificationOptions</span> = {
      <span class="hljs-attr">title</span>: data.<span class="hljs-property">title</span> || <span class="hljs-string">&#x27;New Notification&#x27;</span>,
      <span class="hljs-attr">body</span>: data.<span class="hljs-property">body</span> || <span class="hljs-string">&#x27;You have a new message&#x27;</span>,
      <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;/icon-192x192.png&#x27;</span>,
      <span class="hljs-attr">badge</span>: <span class="hljs-string">&#x27;/badge-72x72.png&#x27;</span>,
      <span class="hljs-attr">tag</span>: data.<span class="hljs-property">tag</span> || <span class="hljs-string">&#x27;default&#x27;</span>,
      <span class="hljs-attr">data</span>: data.<span class="hljs-property">data</span> || {},
      <span class="hljs-attr">actions</span>: [
        { <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;view&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;View&#x27;</span> },
        { <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;dismiss&#x27;</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Dismiss&#x27;</span> }
      ],
      <span class="hljs-attr">requireInteraction</span>: <span class="hljs-literal">true</span>
    };

    <span class="hljs-keyword">await</span> self.<span class="hljs-property">registration</span>.<span class="hljs-title function_">showNotification</span>(options.<span class="hljs-property">title</span>!, options);
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleNotificationClick</span>(<span class="hljs-attr">event</span>: <span class="hljs-title class_">NotificationEvent</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    event.<span class="hljs-property">notification</span>.<span class="hljs-title function_">close</span>();

    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">action</span> === <span class="hljs-string">&#x27;view&#x27;</span>) {
      <span class="hljs-keyword">const</span> urlToOpen = event.<span class="hljs-property">notification</span>.<span class="hljs-property">data</span>?.<span class="hljs-property">url</span> || <span class="hljs-string">&#x27;/&#x27;</span>;
      
      <span class="hljs-keyword">const</span> windowClients = <span class="hljs-keyword">await</span> self.<span class="hljs-property">clients</span>.<span class="hljs-title function_">matchAll</span>({
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;window&#x27;</span>,
        <span class="hljs-attr">includeUncontrolled</span>: <span class="hljs-literal">true</span>
      });

      <span class="hljs-comment">// Check if app is already open</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> client <span class="hljs-keyword">of</span> windowClients) {
        <span class="hljs-keyword">if</span> (client.<span class="hljs-property">url</span> === urlToOpen &amp;&amp; <span class="hljs-string">&#x27;focus&#x27;</span> <span class="hljs-keyword">in</span> client) {
          <span class="hljs-keyword">return</span> client.<span class="hljs-title function_">focus</span>();
        }
      }

      <span class="hljs-comment">// Open new window</span>
      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">clients</span>.<span class="hljs-property">openWindow</span>) {
        <span class="hljs-keyword">return</span> self.<span class="hljs-property">clients</span>.<span class="hljs-title function_">openWindow</span>(urlToOpen);
      }
    }
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-attr">event</span>: <span class="hljs-title class_">ExtendableMessageEvent</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> { <span class="hljs-keyword">type</span>, payload } = event.<span class="hljs-property">data</span>;

    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">type</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;SKIP_WAITING&#x27;</span>:
        <span class="hljs-keyword">await</span> self.<span class="hljs-title function_">skipWaiting</span>();
        <span class="hljs-keyword">break</span>;
      
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;GET_QUEUE_STATUS&#x27;</span>:
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadRequestQueue</span>();
        event.<span class="hljs-property">ports</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">postMessage</span>({
          <span class="hljs-attr">queueLength</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestQueue</span>.<span class="hljs-property">length</span>,
          <span class="hljs-attr">requests</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestQueue</span>
        });
        <span class="hljs-keyword">break</span>;
      
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;CLEAR_CACHE&#x27;</span>:
        <span class="hljs-keyword">const</span> cacheNames = <span class="hljs-keyword">await</span> caches.<span class="hljs-title function_">keys</span>();
        <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(cacheNames.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> caches.<span class="hljs-title function_">delete</span>(name)));
        event.<span class="hljs-property">ports</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> });
        <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">notifyClients</span>(<span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">payload</span>: <span class="hljs-built_in">any</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">const</span> clients = <span class="hljs-keyword">await</span> self.<span class="hljs-property">clients</span>.<span class="hljs-title function_">matchAll</span>();
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> client <span class="hljs-keyword">of</span> clients) {
      client.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-keyword">type</span>, payload });
    }
  }
}

<span class="hljs-comment">// Initialize service worker</span>
<span class="hljs-keyword">const</span> sw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdvancedServiceWorker</span>();

self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">waitUntil</span>(sw.<span class="hljs-title function_">install</span>());
});

self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">waitUntil</span>(sw.<span class="hljs-title function_">activate</span>());
});

self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">respondWith</span>(sw.<span class="hljs-title function_">handleFetch</span>(event));
});

self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;sync&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">waitUntil</span>(sw.<span class="hljs-title function_">handleBackgroundSync</span>(event.<span class="hljs-property">tag</span>));
});

self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">waitUntil</span>(sw.<span class="hljs-title function_">handlePush</span>(event));
});

self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;notificationclick&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">waitUntil</span>(sw.<span class="hljs-title function_">handleNotificationClick</span>(event));
});

self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  event.<span class="hljs-title function_">waitUntil</span>(sw.<span class="hljs-title function_">handleMessage</span>(event));
});
</code></pre></pre>
<p>{% endraw %}</p>
<pre><pre><code class="hljs hljs language-typescript"><span class="hljs-comment">// main.ts - Main Application</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceWorkerManager</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">registration</span>: <span class="hljs-title class_">ServiceWorkerRegistration</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">private</span> updateAvailable = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">initialize</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">registration</span> = <span class="hljs-keyword">await</span> navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;/sw.js&#x27;</span>);
        
        <span class="hljs-comment">// Handle updates</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">registration</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;updatefound&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
          <span class="hljs-keyword">const</span> newWorker = <span class="hljs-variable language_">this</span>.<span class="hljs-property">registration</span>!.<span class="hljs-property">installing</span>;
          <span class="hljs-keyword">if</span> (newWorker) {
            newWorker.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;statechange&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
              <span class="hljs-keyword">if</span> (newWorker.<span class="hljs-property">state</span> === <span class="hljs-string">&#x27;installed&#x27;</span> &amp;&amp; navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>) {
                <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateAvailable</span> = <span class="hljs-literal">true</span>;
                <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">notifyUpdateAvailable</span>();
              }
            });
          }
        });

        <span class="hljs-comment">// Listen for messages from service worker</span>
        navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleMessage</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));
        
        <span class="hljs-comment">// Request notification permission</span>
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">requestNotificationPermission</span>();
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Service Worker registered successfully&#x27;</span>);
      } <span class="hljs-keyword">catch</span> (error) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Service Worker registration failed:&#x27;</span>, error);
      }
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">handleMessage</span>(<span class="hljs-attr">event</span>: <span class="hljs-title class_">MessageEvent</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> { <span class="hljs-keyword">type</span>, payload } = event.<span class="hljs-property">data</span>;
    
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">type</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;sync-success&#x27;</span>:
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Background sync successful:&#x27;</span>, payload);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showNotification</span>(<span class="hljs-string">&#x27;Sync Complete&#x27;</span>, <span class="hljs-string">&#x27;Your changes have been synced.&#x27;</span>);
        <span class="hljs-keyword">break</span>;
      
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;sync-failed&#x27;</span>:
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Background sync failed:&#x27;</span>, payload);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showNotification</span>(<span class="hljs-string">&#x27;Sync Failed&#x27;</span>, <span class="hljs-string">&#x27;Some changes could not be synced.&#x27;</span>);
        <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">requestNotificationPermission</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;Notification&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>) {
      <span class="hljs-keyword">const</span> permission = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Notification</span>.<span class="hljs-title function_">requestPermission</span>();
      <span class="hljs-keyword">return</span> permission === <span class="hljs-string">&#x27;granted&#x27;</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">subscribeToPush</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">PushSubscription</span> | <span class="hljs-literal">null</span>&gt; {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">registration</span> || !(<span class="hljs-string">&#x27;pushManager&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">registration</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> subscription = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">registration</span>.<span class="hljs-property">pushManager</span>.<span class="hljs-title function_">subscribe</span>({
        <span class="hljs-attr">userVisibleOnly</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">applicationServerKey</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">urlBase64ToUint8Array</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">REACT_APP_VAPID_PUBLIC_KEY</span>!)
      });

      <span class="hljs-comment">// Send subscription to server</span>
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/api/push-subscription&#x27;</span>, {
        <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,
        <span class="hljs-attr">headers</span>: {
          <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,
        },
        <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(subscription)
      });

      <span class="hljs-keyword">return</span> subscription;
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed to subscribe to push notifications:&#x27;</span>, error);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">urlBase64ToUint8Array</span>(<span class="hljs-attr">base64String</span>: <span class="hljs-built_in">string</span>): <span class="hljs-title class_">Uint8Array</span> {
    <span class="hljs-keyword">const</span> padding = <span class="hljs-string">&#x27;=&#x27;</span>.<span class="hljs-title function_">repeat</span>((<span class="hljs-number">4</span> - base64String.<span class="hljs-property">length</span> % <span class="hljs-number">4</span>) % <span class="hljs-number">4</span>);
    <span class="hljs-keyword">const</span> base64 = (base64String + padding)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\-/g</span>, <span class="hljs-string">&#x27;+&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/_/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>);

    <span class="hljs-keyword">const</span> rawData = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">atob</span>(base64);
    <span class="hljs-keyword">const</span> outputArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(rawData.<span class="hljs-property">length</span>);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rawData.<span class="hljs-property">length</span>; ++i) {
      outputArray[i] = rawData.<span class="hljs-title function_">charCodeAt</span>(i);
    }
    <span class="hljs-keyword">return</span> outputArray;
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">getQueueStatus</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt; {
    <span class="hljs-keyword">if</span> (!navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();
      channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        <span class="hljs-title function_">resolve</span>(event.<span class="hljs-property">data</span>);
      };

      navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>.<span class="hljs-title function_">postMessage</span>(
        { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;GET_QUEUE_STATUS&#x27;</span> },
        [channel.<span class="hljs-property">port2</span>]
      );
    });
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">clearCache</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt; {
    <span class="hljs-keyword">if</span> (!navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> channel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageChannel</span>();
      channel.<span class="hljs-property">port1</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        <span class="hljs-title function_">resolve</span>(event.<span class="hljs-property">data</span>.<span class="hljs-property">success</span>);
      };

      navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>.<span class="hljs-title function_">postMessage</span>(
        { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;CLEAR_CACHE&#x27;</span> },
        [channel.<span class="hljs-property">port2</span>]
      );
    });
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">updateServiceWorker</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">updateAvailable</span> &amp;&amp; navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>) {
      navigator.<span class="hljs-property">serviceWorker</span>.<span class="hljs-property">controller</span>.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SKIP_WAITING&#x27;</span> });
      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-title function_">reload</span>();
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">notifyUpdateAvailable</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// Show update notification to user</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">showNotification</span>(<span class="hljs-string">&#x27;Update Available&#x27;</span>, <span class="hljs-string">&#x27;A new version is available. Click to update.&#x27;</span>);
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">showNotification</span>(<span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">body</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;Notification&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span> &amp;&amp; <span class="hljs-title class_">Notification</span>.<span class="hljs-property">permission</span> === <span class="hljs-string">&#x27;granted&#x27;</span>) {
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Notification</span>(title, { body });
    }
  }
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">const</span> swManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceWorkerManager</span>();
swManager.<span class="hljs-title function_">initialize</span>();
</code></pre></pre>
<hr/>
<h2 id="challenge-2:-advanced-intersection-observer-with-virtualization" node="[object Object]">Challenge 2: Advanced Intersection Observer with Virtualization</h2>
<h3 id="problem-statement" node="[object Object]">Problem Statement</h3>
<p>Create a virtualized list component that efficiently handles millions of items using Intersection Observer for performance optimization.</p>
<h3 id="requirements" node="[object Object]">Requirements</h3>
<ul>
<li>Handle 1M+ list items efficiently</li>
<li>Dynamic item heights</li>
<li>Smooth scrolling performance</li>
<li>Intersection-based lazy loading</li>
<li>Memory optimization</li>
</ul>
<h3 id="solution" node="[object Object]">Solution</h3>
<pre><pre><code class="hljs hljs language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">VirtualItem</span> {
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">height</span>?: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ViewportItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">VirtualItem</span> {
  <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">top</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">bottom</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">isVisible</span>: <span class="hljs-built_in">boolean</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualizedList</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">container</span>: <span class="hljs-title class_">HTMLElement</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">scrollContainer</span>: <span class="hljs-title class_">HTMLElement</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">itemContainer</span>: <span class="hljs-title class_">HTMLElement</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">items</span>: <span class="hljs-title class_">VirtualItem</span>[] = [];
  <span class="hljs-keyword">private</span> <span class="hljs-attr">viewportItems</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-title class_">ViewportItem</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  <span class="hljs-keyword">private</span> <span class="hljs-attr">intersectionObserver</span>: <span class="hljs-title class_">IntersectionObserver</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">resizeObserver</span>: <span class="hljs-title class_">ResizeObserver</span>;
  <span class="hljs-keyword">private</span> estimatedItemHeight = <span class="hljs-number">50</span>;
  <span class="hljs-keyword">private</span> viewportHeight = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">private</span> scrollTop = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">private</span> totalHeight = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">private</span> visibleRange = { <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">end</span>: <span class="hljs-number">0</span> };
  <span class="hljs-keyword">private</span> renderBuffer = <span class="hljs-number">5</span>;

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">container</span>: <span class="hljs-title class_">HTMLElement</span>, <span class="hljs-attr">items</span>: <span class="hljs-title class_">VirtualItem</span>[]</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span> = container;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = items;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupDOM</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupObservers</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateLayout</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">setupDOM</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`
      &lt;div class=&quot;virtual-scroll-container&quot; style=&quot;height: 100%; overflow-y: auto;&quot;&gt;
        &lt;div class=&quot;virtual-spacer-top&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;virtual-item-container&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;virtual-spacer-bottom&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    `</span>;

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollContainer</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.virtual-scroll-container&#x27;</span>)!;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemContainer</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.virtual-item-container&#x27;</span>)!;
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollContainer</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleScroll</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>));
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportHeight</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollContainer</span>.<span class="hljs-property">clientHeight</span>;
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">setupObservers</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// Intersection Observer for visibility tracking</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersectionObserver</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(
      <span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entries) {
          <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">parseInt</span>(entry.<span class="hljs-property">target</span>.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-index&#x27;</span>)!, <span class="hljs-number">10</span>);
          <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportItems</span>.<span class="hljs-title function_">get</span>(index);
          
          <span class="hljs-keyword">if</span> (item) {
            item.<span class="hljs-property">isVisible</span> = entry.<span class="hljs-property">isIntersecting</span>;
            
            <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {
              <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">loadItemData</span>(item);
            }
          }
        }
      },
      {
        <span class="hljs-attr">root</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollContainer</span>,
        <span class="hljs-attr">rootMargin</span>: <span class="hljs-string">&#x27;100px 0px&#x27;</span>,
        <span class="hljs-attr">threshold</span>: <span class="hljs-number">0</span>
      }
    );

    <span class="hljs-comment">// Resize Observer for dynamic heights</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resizeObserver</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResizeObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries</span>) =&gt;</span> {
      <span class="hljs-keyword">let</span> needsRecalculation = <span class="hljs-literal">false</span>;
      
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entries) {
        <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">parseInt</span>(entry.<span class="hljs-property">target</span>.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-index&#x27;</span>)!, <span class="hljs-number">10</span>);
        <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportItems</span>.<span class="hljs-title function_">get</span>(index);
        <span class="hljs-keyword">const</span> newHeight = entry.<span class="hljs-property">contentRect</span>.<span class="hljs-property">height</span>;
        
        <span class="hljs-keyword">if</span> (item &amp;&amp; item.<span class="hljs-property">height</span> !== newHeight) {
          item.<span class="hljs-property">height</span> = newHeight;
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[index].<span class="hljs-property">height</span> = newHeight;
          needsRecalculation = <span class="hljs-literal">true</span>;
        }
      }
      
      <span class="hljs-keyword">if</span> (needsRecalculation) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateLayout</span>();
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateSpacers</span>();
      }
    });
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">calculateLayout</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">let</span> currentTop = <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i];
      <span class="hljs-keyword">const</span> height = item.<span class="hljs-property">height</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">estimatedItemHeight</span>;
      
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportItems</span>.<span class="hljs-title function_">has</span>(i)) {
        <span class="hljs-keyword">const</span> viewportItem = <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportItems</span>.<span class="hljs-title function_">get</span>(i)!;
        viewportItem.<span class="hljs-property">top</span> = currentTop;
        viewportItem.<span class="hljs-property">bottom</span> = currentTop + height;
      }
      
      currentTop += height;
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalHeight</span> = currentTop;
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">handleScroll</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollContainer</span>.<span class="hljs-property">scrollTop</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateVisibleRange</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">updateVisibleRange</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> viewportTop = <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollTop</span>;
    <span class="hljs-keyword">const</span> viewportBottom = <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollTop</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportHeight</span>;
    
    <span class="hljs-keyword">let</span> start = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> end = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
    
    <span class="hljs-comment">// Binary search for start</span>
    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> right = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">while</span> (left &lt;= right) {
      <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);
      <span class="hljs-keyword">const</span> itemTop = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getItemTop</span>(mid);
      <span class="hljs-keyword">const</span> itemBottom = itemTop + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getItemHeight</span>(mid);
      
      <span class="hljs-keyword">if</span> (itemBottom &lt; viewportTop) {
        left = mid + <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (itemTop &gt; viewportBottom) {
        right = mid - <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        start = mid;
        <span class="hljs-keyword">break</span>;
      }
    }
    
    <span class="hljs-comment">// Binary search for end</span>
    left = start;
    right = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
    
    <span class="hljs-keyword">while</span> (left &lt;= right) {
      <span class="hljs-keyword">const</span> mid = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>((left + right) / <span class="hljs-number">2</span>);
      <span class="hljs-keyword">const</span> itemTop = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getItemTop</span>(mid);
      <span class="hljs-keyword">const</span> itemBottom = itemTop + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getItemHeight</span>(mid);
      
      <span class="hljs-keyword">if</span> (itemTop &gt; viewportBottom) {
        right = mid - <span class="hljs-number">1</span>;
      } <span class="hljs-keyword">else</span> {
        end = mid;
        left = mid + <span class="hljs-number">1</span>;
      }
    }
    
    <span class="hljs-comment">// Add buffer</span>
    start = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, start - <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderBuffer</span>);
    end = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>, end + <span class="hljs-variable language_">this</span>.<span class="hljs-property">renderBuffer</span>);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleRange</span> = { start, end };
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">getItemTop</span>(<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">let</span> top = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) {
      top += <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getItemHeight</span>(i);
    }
    <span class="hljs-keyword">return</span> top;
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">getItemHeight</span>(<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[index].<span class="hljs-property">height</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">estimatedItemHeight</span>;
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">render</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-comment">// Remove items outside visible range</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [index, item] <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportItems</span>) {
      <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleRange</span>.<span class="hljs-property">start</span> || index &gt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleRange</span>.<span class="hljs-property">end</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">removeItem</span>(index);
      }
    }
    
    <span class="hljs-comment">// Add items in visible range</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleRange</span>.<span class="hljs-property">start</span>; i &lt;= <span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleRange</span>.<span class="hljs-property">end</span>; i++) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportItems</span>.<span class="hljs-title function_">has</span>(i)) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addItem</span>(i);
      }
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateSpacers</span>();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">addItem</span>(<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> item = <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[index];
    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createItemElement</span>(item, index);
    
    <span class="hljs-keyword">const</span> <span class="hljs-attr">viewportItem</span>: <span class="hljs-title class_">ViewportItem</span> = {
      ...item,
      index,
      <span class="hljs-attr">top</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getItemTop</span>(index),
      <span class="hljs-attr">bottom</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getItemTop</span>(index) + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getItemHeight</span>(index),
      <span class="hljs-attr">isVisible</span>: <span class="hljs-literal">false</span>
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportItems</span>.<span class="hljs-title function_">set</span>(index, viewportItem);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemContainer</span>.<span class="hljs-title function_">appendChild</span>(element);
    
    <span class="hljs-comment">// Observe for intersection and resize</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersectionObserver</span>.<span class="hljs-title function_">observe</span>(element);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resizeObserver</span>.<span class="hljs-title function_">observe</span>(element);
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">removeItem</span>(<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemContainer</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">`[data-index=&quot;<span class="hljs-subst">${index}</span>&quot;]`</span>);
    <span class="hljs-keyword">if</span> (element) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersectionObserver</span>.<span class="hljs-title function_">unobserve</span>(element);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">resizeObserver</span>.<span class="hljs-title function_">unobserve</span>(element);
      element.<span class="hljs-title function_">remove</span>();
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportItems</span>.<span class="hljs-title function_">delete</span>(index);
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">createItemElement</span>(<span class="hljs-attr">item</span>: <span class="hljs-title class_">VirtualItem</span>, <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">HTMLElement</span> {
    <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
    element.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;virtual-item&#x27;</span>;
    element.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;data-index&#x27;</span>, index.<span class="hljs-title function_">toString</span>());
    element.<span class="hljs-property">style</span>.<span class="hljs-property">minHeight</span> = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.getItemHeight(index)}</span>px`</span>;
    
    <span class="hljs-comment">// Initially show loading state</span>
    element.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`
      &lt;div class=&quot;item-loading&quot;&gt;
        &lt;div class=&quot;skeleton&quot;&gt;&lt;/div&gt;
      &lt;/div&gt;
    `</span>;
    
    <span class="hljs-keyword">return</span> element;
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">loadItemData</span>(<span class="hljs-attr">item</span>: <span class="hljs-title class_">ViewportItem</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-comment">// Simulate async data loading</span>
    <span class="hljs-keyword">if</span> (!item.<span class="hljs-property">data</span>.<span class="hljs-property">loaded</span>) {
      <span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemContainer</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">`[data-index=&quot;<span class="hljs-subst">${item.index}</span>&quot;]`</span>);
      <span class="hljs-keyword">if</span> (element) {
        <span class="hljs-comment">// Simulate network request</span>
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">100</span>));
        
        item.<span class="hljs-property">data</span>.<span class="hljs-property">loaded</span> = <span class="hljs-literal">true</span>;
        element.<span class="hljs-property">innerHTML</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">renderItemContent</span>(item.<span class="hljs-property">data</span>);
      }
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">renderItemContent</span>(<span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`
      &lt;div class=&quot;item-content&quot;&gt;
        &lt;h3&gt;<span class="hljs-subst">${data.title || <span class="hljs-string">`Item <span class="hljs-subst">${data.id}</span>`</span>}</span>&lt;/h3&gt;
        &lt;p&gt;<span class="hljs-subst">${data.description || <span class="hljs-string">&#x27;Lorem ipsum dolor sit amet...&#x27;</span>}</span>&lt;/p&gt;
        &lt;div class=&quot;item-meta&quot;&gt;
          &lt;span&gt;ID: <span class="hljs-subst">${data.id}</span>&lt;/span&gt;
          &lt;span&gt;Type: <span class="hljs-subst">${data.<span class="hljs-keyword">type</span> || <span class="hljs-string">&#x27;default&#x27;</span>}</span>&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    `</span>;
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">updateSpacers</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> topSpacer = <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.virtual-spacer-top&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>;
    <span class="hljs-keyword">const</span> bottomSpacer = <span class="hljs-variable language_">this</span>.<span class="hljs-property">container</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.virtual-spacer-bottom&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>;
    
    <span class="hljs-keyword">const</span> topHeight = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getItemTop</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleRange</span>.<span class="hljs-property">start</span>);
    <span class="hljs-keyword">const</span> bottomHeight = <span class="hljs-variable language_">this</span>.<span class="hljs-property">totalHeight</span> - <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getItemTop</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">visibleRange</span>.<span class="hljs-property">end</span> + <span class="hljs-number">1</span>);
    
    topSpacer.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">`<span class="hljs-subst">${topHeight}</span>px`</span>;
    bottomSpacer.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">`<span class="hljs-subst">${bottomHeight}</span>px`</span>;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">scrollToIndex</span>(<span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> itemTop = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getItemTop</span>(index);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollContainer</span>.<span class="hljs-property">scrollTop</span> = itemTop;
  }

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">getVisibleItems</span>(): <span class="hljs-title class_">ViewportItem</span>[] {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportItems</span>.<span class="hljs-title function_">values</span>()).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">isVisible</span>);
  }

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">updateItems</span>(<span class="hljs-attr">newItems</span>: <span class="hljs-title class_">VirtualItem</span>[]): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span> = newItems;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewportItems</span>.<span class="hljs-title function_">clear</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemContainer</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&#x27;</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateLayout</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateVisibleRange</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">render</span>();
  }

  <span class="hljs-keyword">public</span> <span class="hljs-title function_">destroy</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">intersectionObserver</span>.<span class="hljs-title function_">disconnect</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resizeObserver</span>.<span class="hljs-title function_">disconnect</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollContainer</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">handleScroll</span>);
  }
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">const</span> generateItems = (<span class="hljs-attr">count</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">VirtualItem</span>[] =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>({ <span class="hljs-attr">length</span>: count }, <span class="hljs-function">(<span class="hljs-params">_, index</span>) =&gt;</span> ({
    <span class="hljs-attr">id</span>: <span class="hljs-string">`item-<span class="hljs-subst">${index}</span>`</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-comment">// Dynamic height</span>
    <span class="hljs-attr">data</span>: {
      <span class="hljs-attr">id</span>: index,
      <span class="hljs-attr">title</span>: <span class="hljs-string">`Item <span class="hljs-subst">${index}</span>`</span>,
      <span class="hljs-attr">description</span>: <span class="hljs-string">`Description for item <span class="hljs-subst">${index}</span>`</span>,
      <span class="hljs-attr">type</span>: [<span class="hljs-string">&#x27;text&#x27;</span>, <span class="hljs-string">&#x27;image&#x27;</span>, <span class="hljs-string">&#x27;video&#x27;</span>][index % <span class="hljs-number">3</span>],
      <span class="hljs-attr">loaded</span>: <span class="hljs-literal">false</span>
    }
  }));
};

<span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;virtual-list-container&#x27;</span>)!;
<span class="hljs-keyword">const</span> items = <span class="hljs-title function_">generateItems</span>(<span class="hljs-number">1000000</span>); <span class="hljs-comment">// 1 million items</span>
<span class="hljs-keyword">const</span> virtualList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VirtualizedList</span>(container, items);
</code></pre></pre>
<h3 id="css-styling" node="[object Object]">CSS Styling</h3>
<pre><pre><code class="hljs hljs language-css"><span class="hljs-selector-class">.virtual-scroll-container</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">overflow-y</span>: auto;
  <span class="hljs-attribute">scroll-behavior</span>: smooth;
}

<span class="hljs-selector-class">.virtual-item</span> {
  <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>;
  <span class="hljs-attribute">transition</span>: background-color <span class="hljs-number">0.2s</span>;
}

<span class="hljs-selector-class">.virtual-item</span><span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;
}

<span class="hljs-selector-class">.item-loading</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">align-items</span>: center;
}

<span class="hljs-selector-class">.skeleton</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">90deg</span>, <span class="hljs-number">#f0f0f0</span> <span class="hljs-number">25%</span>, <span class="hljs-number">#e0e0e0</span> <span class="hljs-number">50%</span>, <span class="hljs-number">#f0f0f0</span> <span class="hljs-number">75%</span>);
  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">200%</span> <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">animation</span>: skeleton-loading <span class="hljs-number">1.5s</span> infinite;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">@keyframes</span> skeleton-loading {
  <span class="hljs-number">0%</span> { <span class="hljs-attribute">background-position</span>: <span class="hljs-number">200%</span> <span class="hljs-number">0</span>; }
  <span class="hljs-number">100%</span> { <span class="hljs-attribute">background-position</span>: -<span class="hljs-number">200%</span> <span class="hljs-number">0</span>; }
}

<span class="hljs-selector-class">.item-content</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
}

<span class="hljs-selector-class">.item-content</span> <span class="hljs-selector-tag">h3</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-number">0</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;
}

<span class="hljs-selector-class">.item-content</span> <span class="hljs-selector-tag">p</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">15px</span> <span class="hljs-number">0</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#666</span>;
  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.5</span>;
}

<span class="hljs-selector-class">.item-meta</span> {
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">gap</span>: <span class="hljs-number">15px</span>;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#999</span>;
}

<span class="hljs-selector-class">.item-meta</span> <span class="hljs-selector-tag">span</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">8px</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#f0f0f0</span>;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">12px</span>;
}
</code></pre></pre>
<hr/>
<h2 id="challenge-3:-real-time-communication-with-webrtc" node="[object Object]">Challenge 3: Real-time Communication with WebRTC</h2>
<h3 id="problem-statement" node="[object Object]">Problem Statement</h3>
<p>Build a peer-to-peer video chat application with screen sharing, file transfer, and real-time messaging.</p>
<h3 id="requirements" node="[object Object]">Requirements</h3>
<ul>
<li>Peer-to-peer video/audio calling</li>
<li>Screen sharing functionality</li>
<li>Real-time text messaging</li>
<li>File transfer over data channels</li>
<li>Connection quality monitoring</li>
</ul>
<h3 id="solution" node="[object Object]">Solution</h3>
<pre><pre><code class="hljs hljs language-typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PeerConnectionConfig</span> {
  <span class="hljs-attr">iceServers</span>: <span class="hljs-title class_">RTCIceServer</span>[];
  <span class="hljs-attr">iceTransportPolicy</span>?: <span class="hljs-title class_">RTCIceTransportPolicy</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MediaConstraints</span> {
  <span class="hljs-attr">video</span>?: <span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">MediaTrackConstraints</span>;
  <span class="hljs-attr">audio</span>?: <span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">MediaTrackConstraints</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">WebRTCManager</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-attr">localConnection</span>: <span class="hljs-title class_">RTCPeerConnection</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">remoteConnection</span>: <span class="hljs-title class_">RTCPeerConnection</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">localStream</span>: <span class="hljs-title class_">MediaStream</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">remoteStream</span>: <span class="hljs-title class_">MediaStream</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">dataChannel</span>: <span class="hljs-title class_">RTCDataChannel</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">signalingChannel</span>: <span class="hljs-title class_">WebSocket</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">localVideo</span>: <span class="hljs-title class_">HTMLVideoElement</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">remoteVideo</span>: <span class="hljs-title class_">HTMLVideoElement</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">connectionStats</span>: <span class="hljs-title class_">Map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-title class_">RTCStatsReport</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  <span class="hljs-keyword">private</span> isScreenSharing = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-attr">originalVideoTrack</span>: <span class="hljs-title class_">MediaStreamTrack</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">private</span> <span class="hljs-attr">config</span>: <span class="hljs-title class_">PeerConnectionConfig</span> = {
    <span class="hljs-attr">iceServers</span>: [
      { <span class="hljs-attr">urls</span>: <span class="hljs-string">&#x27;stun:stun.l.google.com:19302&#x27;</span> },
      { <span class="hljs-attr">urls</span>: <span class="hljs-string">&#x27;stun:stun1.l.google.com:19302&#x27;</span> }
    ]
  };

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">
    <span class="hljs-attr">localVideo</span>: <span class="hljs-title class_">HTMLVideoElement</span>,
    <span class="hljs-attr">remoteVideo</span>: <span class="hljs-title class_">HTMLVideoElement</span>,
    <span class="hljs-attr">signalingServerUrl</span>: <span class="hljs-built_in">string</span>
  </span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">localVideo</span> = localVideo;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteVideo</span> = remoteVideo;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">signalingChannel</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(signalingServerUrl);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupSignaling</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">initializePeerConnections</span>();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">setupSignaling</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">signalingChannel</span>.<span class="hljs-property">onopen</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Signaling channel connected&#x27;</span>);
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">signalingChannel</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-title function_">async</span> (event) =&gt; {
      <span class="hljs-keyword">const</span> message = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>);
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleSignalingMessage</span>(message);
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">signalingChannel</span>.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Signaling channel error:&#x27;</span>, error);
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">signalingChannel</span>.<span class="hljs-property">onclose</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Signaling channel closed&#x27;</span>);
    };
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">initializePeerConnections</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RTCPeerConnection</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteConnection</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RTCPeerConnection</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">config</span>);

    <span class="hljs-comment">// Set up event handlers</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-property">onicecandidate</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">candidate</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendSignalingMessage</span>({
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ice-candidate&#x27;</span>,
          <span class="hljs-attr">candidate</span>: event.<span class="hljs-property">candidate</span>,
          <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;remote&#x27;</span>
        });
      }
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteConnection</span>.<span class="hljs-property">onicecandidate</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">candidate</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendSignalingMessage</span>({
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ice-candidate&#x27;</span>,
          <span class="hljs-attr">candidate</span>: event.<span class="hljs-property">candidate</span>,
          <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;local&#x27;</span>
        });
      }
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-property">ontrack</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteStream</span> = event.<span class="hljs-property">streams</span>[<span class="hljs-number">0</span>];
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteVideo</span>.<span class="hljs-property">srcObject</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteStream</span>;
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteConnection</span>.<span class="hljs-property">ontrack</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-comment">// Handle remote track</span>
    };

    <span class="hljs-comment">// Data channel setup</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupDataChannel</span>();
    
    <span class="hljs-comment">// Connection state monitoring</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setupConnectionMonitoring</span>();
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">setupDataChannel</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-title function_">createDataChannel</span>(<span class="hljs-string">&#x27;messages&#x27;</span>, {
      <span class="hljs-attr">ordered</span>: <span class="hljs-literal">true</span>
    });

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span>.<span class="hljs-property">onopen</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Data channel opened&#x27;</span>);
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleDataChannelMessage</span>(event.<span class="hljs-property">data</span>);
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span>.<span class="hljs-property">onerror</span> = <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Data channel error:&#x27;</span>, error);
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-property">ondatachannel</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> channel = event.<span class="hljs-property">channel</span>;
      channel.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handleDataChannelMessage</span>(event.<span class="hljs-property">data</span>);
      };
    };
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">setupConnectionMonitoring</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-property">onconnectionstatechange</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Local connection state:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-property">connectionState</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateConnectionUI</span>();
    };

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteConnection</span>.<span class="hljs-property">onconnectionstatechange</span> = <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Remote connection state:&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteConnection</span>.<span class="hljs-property">connectionState</span>);
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">updateConnectionUI</span>();
    };

    <span class="hljs-comment">// Start stats monitoring</span>
    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">collectConnectionStats</span>();
    }, <span class="hljs-number">1000</span>);
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">startCall</span>(<span class="hljs-attr">constraints</span>: <span class="hljs-title class_">MediaConstraints</span> = { <span class="hljs-attr">video</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span> }): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Get user media</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span> = <span class="hljs-keyword">await</span> navigator.<span class="hljs-property">mediaDevices</span>.<span class="hljs-title function_">getUserMedia</span>(constraints);
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">localVideo</span>.<span class="hljs-property">srcObject</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span>;

      <span class="hljs-comment">// Add tracks to peer connection</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> track <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span>.<span class="hljs-title function_">getTracks</span>()) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-title function_">addTrack</span>(track, <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span>);
      }

      <span class="hljs-comment">// Create offer</span>
      <span class="hljs-keyword">const</span> offer = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-title function_">createOffer</span>();
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-title function_">setLocalDescription</span>(offer);

      <span class="hljs-comment">// Send offer through signaling</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendSignalingMessage</span>({
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;offer&#x27;</span>,
        <span class="hljs-attr">offer</span>: offer
      });

    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error starting call:&#x27;</span>, error);
      <span class="hljs-keyword">throw</span> error;
    }
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">answerCall</span>(<span class="hljs-attr">offer</span>: <span class="hljs-title class_">RTCSessionDescriptionInit</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">// Get user media</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span> = <span class="hljs-keyword">await</span> navigator.<span class="hljs-property">mediaDevices</span>.<span class="hljs-title function_">getUserMedia</span>({
        <span class="hljs-attr">video</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span>
      });
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">localVideo</span>.<span class="hljs-property">srcObject</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span>;

      <span class="hljs-comment">// Add tracks to peer connection</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> track <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span>.<span class="hljs-title function_">getTracks</span>()) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteConnection</span>.<span class="hljs-title function_">addTrack</span>(track, <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span>);
      }

      <span class="hljs-comment">// Set remote description</span>
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteConnection</span>.<span class="hljs-title function_">setRemoteDescription</span>(offer);

      <span class="hljs-comment">// Create answer</span>
      <span class="hljs-keyword">const</span> answer = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteConnection</span>.<span class="hljs-title function_">createAnswer</span>();
      <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteConnection</span>.<span class="hljs-title function_">setLocalDescription</span>(answer);

      <span class="hljs-comment">// Send answer through signaling</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sendSignalingMessage</span>({
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;answer&#x27;</span>,
        <span class="hljs-attr">answer</span>: answer
      });

    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error answering call:&#x27;</span>, error);
      <span class="hljs-keyword">throw</span> error;
    }
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">startScreenShare</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isScreenSharing</span>) {
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">stopScreenShare</span>();
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-comment">// Get screen capture</span>
      <span class="hljs-keyword">const</span> screenStream = <span class="hljs-keyword">await</span> navigator.<span class="hljs-property">mediaDevices</span>.<span class="hljs-title function_">getDisplayMedia</span>({
        <span class="hljs-attr">video</span>: { <span class="hljs-attr">mediaSource</span>: <span class="hljs-string">&#x27;screen&#x27;</span> },
        <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span>
      });

      <span class="hljs-keyword">const</span> videoTrack = screenStream.<span class="hljs-title function_">getVideoTracks</span>()[<span class="hljs-number">0</span>];
      
      <span class="hljs-comment">// Store original video track</span>
      <span class="hljs-keyword">const</span> sender = <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-title function_">getSenders</span>().<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> 
        s.<span class="hljs-property">track</span> &amp;&amp; s.<span class="hljs-property">track</span>.<span class="hljs-property">kind</span> === <span class="hljs-string">&#x27;video&#x27;</span>
      );

      <span class="hljs-keyword">if</span> (sender &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">originalVideoTrack</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span>.<span class="hljs-title function_">getVideoTracks</span>()[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">await</span> sender.<span class="hljs-title function_">replaceTrack</span>(videoTrack);
      }

      <span class="hljs-comment">// Update local video</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">localVideo</span>.<span class="hljs-property">srcObject</span> = screenStream;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isScreenSharing</span> = <span class="hljs-literal">true</span>;

      <span class="hljs-comment">// Handle screen share end</span>
      videoTrack.<span class="hljs-property">onended</span> = <span class="hljs-title function_">async</span> () =&gt; {
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">stopScreenShare</span>();
      };

    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error starting screen share:&#x27;</span>, error);
      <span class="hljs-keyword">throw</span> error;
    }
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">stopScreenShare</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">isScreenSharing</span> || !<span class="hljs-variable language_">this</span>.<span class="hljs-property">originalVideoTrack</span>) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> sender = <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-title function_">getSenders</span>().<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> 
        s.<span class="hljs-property">track</span> &amp;&amp; s.<span class="hljs-property">track</span>.<span class="hljs-property">kind</span> === <span class="hljs-string">&#x27;video&#x27;</span>
      );

      <span class="hljs-keyword">if</span> (sender) {
        <span class="hljs-keyword">await</span> sender.<span class="hljs-title function_">replaceTrack</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">originalVideoTrack</span>);
      }

      <span class="hljs-comment">// Restore original video stream</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">localVideo</span>.<span class="hljs-property">srcObject</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isScreenSharing</span> = <span class="hljs-literal">false</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">originalVideoTrack</span> = <span class="hljs-literal">null</span>;

    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error stopping screen share:&#x27;</span>, error);
    }
  }

  <span class="hljs-title function_">sendMessage</span>(<span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span>.<span class="hljs-property">readyState</span> === <span class="hljs-string">&#x27;open&#x27;</span>) {
      <span class="hljs-keyword">const</span> messageData = {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;text&#x27;</span>,
        <span class="hljs-attr">content</span>: message,
        <span class="hljs-attr">timestamp</span>: <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()
      };
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span>.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(messageData));
    }
  }

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">sendFile</span>(<span class="hljs-attr">file</span>: <span class="hljs-title class_">File</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-string">&#x27;open&#x27;</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Data channel not ready&#x27;</span>);
    }

    <span class="hljs-keyword">const</span> chunkSize = <span class="hljs-number">16384</span>; <span class="hljs-comment">// 16KB chunks</span>
    <span class="hljs-keyword">const</span> fileReader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>();
    <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// Send file metadata</span>
    <span class="hljs-keyword">const</span> metadata = {
      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;file-start&#x27;</span>,
      <span class="hljs-attr">filename</span>: file.<span class="hljs-property">name</span>,
      <span class="hljs-attr">filesize</span>: file.<span class="hljs-property">size</span>,
      <span class="hljs-attr">filetype</span>: file.<span class="hljs-property">type</span>
    };
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span>.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(metadata));

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
      fileReader.<span class="hljs-property">onload</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> chunk = event.<span class="hljs-property">target</span>!.<span class="hljs-property">result</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">ArrayBuffer</span>;
        
        <span class="hljs-comment">// Send chunk</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span>!.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;file-chunk&#x27;</span>,
          <span class="hljs-attr">data</span>: <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(chunk))
        }));

        offset += chunk.<span class="hljs-property">byteLength</span>;

        <span class="hljs-keyword">if</span> (offset &lt; file.<span class="hljs-property">size</span>) {
          <span class="hljs-comment">// Read next chunk</span>
          <span class="hljs-keyword">const</span> blob = file.<span class="hljs-title function_">slice</span>(offset, offset + chunkSize);
          fileReader.<span class="hljs-title function_">readAsArrayBuffer</span>(blob);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// File transfer complete</span>
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span>!.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({
            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;file-end&#x27;</span>
          }));
          <span class="hljs-title function_">resolve</span>();
        }
      };

      fileReader.<span class="hljs-property">onerror</span> = reject;

      <span class="hljs-comment">// Start reading first chunk</span>
      <span class="hljs-keyword">const</span> blob = file.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, chunkSize);
      fileReader.<span class="hljs-title function_">readAsArrayBuffer</span>(blob);
    });
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">handleDataChannelMessage</span>(<span class="hljs-attr">data</span>: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> message = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(data);
      
      <span class="hljs-keyword">switch</span> (message.<span class="hljs-property">type</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;text&#x27;</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onTextMessage</span>?.(message.<span class="hljs-property">content</span>, message.<span class="hljs-property">timestamp</span>);
          <span class="hljs-keyword">break</span>;
        
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;file-start&#x27;</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFileTransferStart</span>?.(message.<span class="hljs-property">filename</span>, message.<span class="hljs-property">filesize</span>, message.<span class="hljs-property">filetype</span>);
          <span class="hljs-keyword">break</span>;
        
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;file-chunk&#x27;</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFileChunk</span>?.(message.<span class="hljs-property">data</span>);
          <span class="hljs-keyword">break</span>;
        
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;file-end&#x27;</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">onFileTransferComplete</span>?.();
          <span class="hljs-keyword">break</span>;
      }
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error handling data channel message:&#x27;</span>, error);
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">handleSignalingMessage</span>(<span class="hljs-attr">message</span>: <span class="hljs-built_in">any</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">switch</span> (message.<span class="hljs-property">type</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;offer&#x27;</span>:
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">answerCall</span>(message.<span class="hljs-property">offer</span>);
        <span class="hljs-keyword">break</span>;
      
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;answer&#x27;</span>:
        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-title function_">setRemoteDescription</span>(message.<span class="hljs-property">answer</span>);
        <span class="hljs-keyword">break</span>;
      
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ice-candidate&#x27;</span>:
        <span class="hljs-keyword">const</span> connection = message.<span class="hljs-property">target</span> === <span class="hljs-string">&#x27;local&#x27;</span> ? <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span> : <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteConnection</span>;
        <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">addIceCandidate</span>(message.<span class="hljs-property">candidate</span>);
        <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">sendSignalingMessage</span>(<span class="hljs-attr">message</span>: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">signalingChannel</span>.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">WebSocket</span>.<span class="hljs-property">OPEN</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">signalingChannel</span>.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(message));
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-title function_">collectConnectionStats</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> stats = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-title function_">getStats</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">connectionStats</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;local&#x27;</span>, stats);
      
      <span class="hljs-comment">// Analyze stats for quality metrics</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">analyzeConnectionQuality</span>(stats);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Error collecting stats:&#x27;</span>, error);
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">analyzeConnectionQuality</span>(<span class="hljs-attr">stats</span>: <span class="hljs-title class_">RTCStatsReport</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-attr">inboundVideo</span>: <span class="hljs-title class_">RTCInboundRtpStreamStats</span> | <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-attr">outboundVideo</span>: <span class="hljs-title class_">RTCOutboundRtpStreamStats</span> | <span class="hljs-literal">undefined</span>;

    stats.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">report</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (report.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;inbound-rtp&#x27;</span> &amp;&amp; report.<span class="hljs-property">mediaType</span> === <span class="hljs-string">&#x27;video&#x27;</span>) {
        inboundVideo = report <span class="hljs-keyword">as</span> <span class="hljs-title class_">RTCInboundRtpStreamStats</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (report.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;outbound-rtp&#x27;</span> &amp;&amp; report.<span class="hljs-property">mediaType</span> === <span class="hljs-string">&#x27;video&#x27;</span>) {
        outboundVideo = report <span class="hljs-keyword">as</span> <span class="hljs-title class_">RTCOutboundRtpStreamStats</span>;
      }
    });

    <span class="hljs-keyword">if</span> (inboundVideo) {
      <span class="hljs-keyword">const</span> quality = {
        <span class="hljs-attr">packetsLost</span>: inboundVideo.<span class="hljs-property">packetsLost</span> || <span class="hljs-number">0</span>,
        <span class="hljs-attr">packetsReceived</span>: inboundVideo.<span class="hljs-property">packetsReceived</span> || <span class="hljs-number">0</span>,
        <span class="hljs-attr">bytesReceived</span>: inboundVideo.<span class="hljs-property">bytesReceived</span> || <span class="hljs-number">0</span>,
        <span class="hljs-attr">frameWidth</span>: inboundVideo.<span class="hljs-property">frameWidth</span> || <span class="hljs-number">0</span>,
        <span class="hljs-attr">frameHeight</span>: inboundVideo.<span class="hljs-property">frameHeight</span> || <span class="hljs-number">0</span>,
        <span class="hljs-attr">framesPerSecond</span>: inboundVideo.<span class="hljs-property">framesPerSecond</span> || <span class="hljs-number">0</span>
      };

      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onConnectionQualityUpdate</span>?.(quality);
    }
  }

  <span class="hljs-keyword">private</span> <span class="hljs-title function_">updateConnectionUI</span>(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> state = <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-property">connectionState</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onConnectionStateChange</span>?.(state);
  }

  <span class="hljs-comment">// Event handlers (to be set by consumers)</span>
  <span class="hljs-attr">onTextMessage</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">timestamp</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">onFileTransferStart</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">filename</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">filesize</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">filetype</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">onFileChunk</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">chunk</span>: <span class="hljs-built_in">number</span>[]</span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">onFileTransferComplete</span>?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">onConnectionQualityUpdate</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">quality</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">onConnectionStateChange</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">state</span>: <span class="hljs-title class_">RTCPeerConnectionState</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;

  <span class="hljs-keyword">async</span> <span class="hljs-title function_">disconnect</span>(): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; {
    <span class="hljs-comment">// Stop all tracks</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">localStream</span>.<span class="hljs-title function_">getTracks</span>().<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">track</span> =&gt;</span> track.<span class="hljs-title function_">stop</span>());
    }

    <span class="hljs-comment">// Close peer connections</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">localConnection</span>.<span class="hljs-title function_">close</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">remoteConnection</span>.<span class="hljs-title function_">close</span>();

    <span class="hljs-comment">// Close signaling channel</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">signalingChannel</span>.<span class="hljs-title function_">close</span>();

    <span class="hljs-comment">// Close data channel</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataChannel</span>.<span class="hljs-title function_">close</span>();
    }
  }
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-keyword">const</span> localVideo = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;localVideo&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLVideoElement</span>;
<span class="hljs-keyword">const</span> remoteVideo = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;remoteVideo&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLVideoElement</span>;

<span class="hljs-keyword">const</span> webrtc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebRTCManager</span>(
  localVideo,
  remoteVideo,
  <span class="hljs-string">&#x27;wss://your-signaling-server.com&#x27;</span>
);

<span class="hljs-comment">// Set up event handlers</span>
webrtc.<span class="hljs-property">onTextMessage</span> = <span class="hljs-function">(<span class="hljs-params">message, timestamp</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received message:&#x27;</span>, message);
};

webrtc.<span class="hljs-property">onConnectionQualityUpdate</span> = <span class="hljs-function">(<span class="hljs-params">quality</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Connection quality:&#x27;</span>, quality);
};

<span class="hljs-comment">// Start a call</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;startCall&#x27;</span>)?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  webrtc.<span class="hljs-title function_">startCall</span>();
});

<span class="hljs-comment">// Start screen share</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;shareScreen&#x27;</span>)?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
  webrtc.<span class="hljs-title function_">startScreenShare</span>();
});
</code></pre></pre>
<p>These advanced Web API challenges demonstrate mastery of modern browser capabilities essential for senior frontend roles at major tech companies. Each solution includes performance optimization, error handling, and real-world complexity.</p></div></div></main><footer class="sc-hwHXyi fgAPRO"><div class="sc-ciCoXh bQkEEK"><div class="sc-jDJeIs lmmFoJ"><div class="sc-eEHciv bKIGXv"><div class="sc-KsiuK bMtRdQ"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</div><p class="sc-hqtLyI eRTluy">Comprehensive interview preparation for frontend engineers targeting Big Tech companies.</p><div class="sc-iVnIWt jlMcom"><a href="https://github.com" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github "><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><a href="https://twitter.com" aria-label="Twitter"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-twitter "><path d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"></path></svg></a><a href="https://linkedin.com" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-linkedin "><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect width="4" height="12" x="2" y="9"></rect><circle cx="4" cy="4" r="2"></circle></svg></a><a href="mailto:contact@example.com" aria-label="Email"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail "><rect width="20" height="16" x="2" y="4" rx="2"></rect><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path></svg></a></div></div><div class="sc-eEHciv bKIGXv"><h3>Study Materials</h3><ul><li><a href="/algorithms">Algorithms</a></li><li><a href="/react">React &amp; Frontend</a></li><li><a href="/system-design">System Design</a></li><li><a href="/typescript">TypeScript</a></li><li><a href="/performance">Performance</a></li></ul></div><div class="sc-eEHciv bKIGXv"><h3>Companies</h3><ul><li><a href="/google">Google</a></li><li><a href="/meta">Meta</a></li><li><a href="/amazon">Amazon</a></li><li><a href="/microsoft">Microsoft</a></li><li><a href="/apple">Apple</a></li></ul></div><div class="sc-eEHciv bKIGXv"><h3>Resources</h3><ul><li><a href="/interview-tips">Interview Tips</a></li><li><a href="/coding-challenges">Coding Challenges</a></li><li><a href="/mock-interviews">Mock Interviews</a></li><li><a href="/blog">Blog</a></li><li><a href="/faq">FAQ</a></li></ul></div></div><div class="sc-hWgKua fuxrZK"><p class="sc-jBaHRL fMpVBW">¬© 2025 Frontend Interview Prep. All rights reserved.</p><div class="sc-gFqXPY fyWnKB"><a href="/privacy">Privacy Policy</a><a href="/terms">Terms of Service</a><a href="/contact">Contact</a></div></div></div></footer></div><script src="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/interview/_next/static/css/387024c6a2216908.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[2846,[],\"\"]\n5:I[5907,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"930\",\"static/chunks/930-3262a6c9c5acace4.js\",\"687\",\"static/chunks/app/docs/%5B...slug%5D/page-036ada1d0a865043.js\"],\"default\"]\n7:I[4707,[],\"\"]\n9:I[6423,[],\"\"]\na:I[2,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"710\",\"static/chunks/710-dfaa11b4dff08f8e.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"233\",\"static/chunks/233-3e0c1d820a17eca9.js\",\"185\",\"static/chunks/app/layout-333f4adcd11f8f39.js\"],\"default\",1]\nc:I[1060,[],\"\"]\n6:T9a7b,"])</script><script>self.__next_f.push([1,"\n# Advanced Web APIs Challenges\n\n## Overview\nModern Web APIs provide powerful capabilities for building sophisticated frontend applications. These challenges focus on APIs commonly tested in Big Tech interviews.\n\n---\n\n## Challenge 1: Advanced Service Worker with Background Sync\n\n### Problem Statement\nImplement a robust offline-first application with background sync, push notifications, and intelligent caching strategies.\n\n### Requirements\n- Offline functionality with background sync\n- Push notification handling\n- Smart caching (cache-first, network-first, stale-while-revalidate)\n- Periodic background sync\n- Message passing between main thread and service worker\n\n### Solution\n\n{% raw %}\n```typescript\n// sw.ts - Service Worker\nconst CACHE_NAME = 'app-cache-v1';\nconst API_CACHE = 'api-cache-v1';\nconst BACKGROUND_SYNC_TAG = 'background-sync';\n\ninterface QueuedRequest {\n  id: string;\n  url: string;\n  method: string;\n  headers: Record\u003cstring, string\u003e;\n  body?: string;\n  timestamp: number;\n}\n\nclass AdvancedServiceWorker {\n  private requestQueue: QueuedRequest[] = [];\n  private retryAttempts = new Map\u003cstring, number\u003e();\n\n  async install(): Promise\u003cvoid\u003e {\n    const urlsToCache = [\n      '/',\n      '/static/js/bundle.js',\n      '/static/css/main.css',\n      '/manifest.json'\n    ];\n\n    const cache = await caches.open(CACHE_NAME);\n    await cache.addAll(urlsToCache);\n    \n    // Skip waiting to activate immediately\n    await self.skipWaiting();\n  }\n\n  async activate(): Promise\u003cvoid\u003e {\n    // Clean up old caches\n    const cacheNames = await caches.keys();\n    await Promise.all(\n      cacheNames\n        .filter(name =\u003e name !== CACHE_NAME \u0026\u0026 name !== API_CACHE)\n        .map(name =\u003e caches.delete(name))\n    );\n\n    // Claim all clients immediately\n    await self.clients.claim();\n  }\n\n  async handleFetch(event: FetchEvent): Promise\u003cResponse\u003e {\n    const { request } = event;\n    const url = new URL(request.url);\n\n    // Handle API requests\n    if (url.pathname.startsWith('/api/')) {\n      return this.handleApiRequest(request);\n    }\n\n    // Handle static assets\n    return this.handleStaticRequest(request);\n  }\n\n  private async handleApiRequest(request: Request): Promise\u003cResponse\u003e {\n    const cache = await caches.open(API_CACHE);\n    \n    try {\n      // Try network first\n      const networkResponse = await fetch(request.clone());\n      \n      if (networkResponse.ok) {\n        // Cache successful responses\n        await cache.put(request, networkResponse.clone());\n        return networkResponse;\n      }\n      \n      throw new Error('Network response not ok');\n    } catch (error) {\n      // Fall back to cache\n      const cachedResponse = await cache.match(request);\n      \n      if (cachedResponse) {\n        // Queue request for background sync if it's a mutation\n        if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method)) {\n          await this.queueRequest(request);\n        }\n        \n        return cachedResponse;\n      }\n      \n      // If no cache, queue the request and return error response\n      await this.queueRequest(request);\n      return new Response(\n        JSON.stringify({ error: 'Offline - request queued' }),\n        { status: 503, headers: { 'Content-Type': 'application/json' } }\n      );\n    }\n  }\n\n  private async handleStaticRequest(request: Request): Promise\u003cResponse\u003e {\n    const cache = await caches.open(CACHE_NAME);\n    \n    // Cache first strategy for static assets\n    const cachedResponse = await cache.match(request);\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    try {\n      const networkResponse = await fetch(request);\n      if (networkResponse.ok) {\n        await cache.put(request, networkResponse.clone());\n      }\n      return networkResponse;\n    } catch (error) {\n      // Return offline page for navigation requests\n      if (request.mode === 'navigate') {\n        const offlinePage = await cache.match('/offline.html');\n        return offlinePage || new Response('Offline', { status: 503 });\n      }\n      \n      throw error;\n    }\n  }\n\n  private async queueRequest(request: Request): Promise\u003cvoid\u003e {\n    const queuedRequest: QueuedRequest = {\n      id: crypto.randomUUID(),\n      url: request.url,\n      method: request.method,\n      headers: Object.fromEntries(request.headers.entries()),\n      body: request.method !== 'GET' ? await request.text() : undefined,\n      timestamp: Date.now()\n    };\n\n    this.requestQueue.push(queuedRequest);\n    await this.saveRequestQueue();\n    \n    // Register for background sync\n    if ('serviceWorker' in self \u0026\u0026 'sync' in self.registration) {\n      await self.registration.sync.register(BACKGROUND_SYNC_TAG);\n    }\n  }\n\n  async handleBackgroundSync(tag: string): Promise\u003cvoid\u003e {\n    if (tag === BACKGROUND_SYNC_TAG) {\n      await this.processRequestQueue();\n    }\n  }\n\n  private async processRequestQueue(): Promise\u003cvoid\u003e {\n    await this.loadRequestQueue();\n    \n    const failedRequests: QueuedRequest[] = [];\n    \n    for (const queuedRequest of this.requestQueue) {\n      try {\n        const request = new Request(queuedRequest.url, {\n          method: queuedRequest.method,\n          headers: queuedRequest.headers,\n          body: queuedRequest.body\n        });\n\n        const response = await fetch(request);\n        \n        if (response.ok) {\n          // Success - notify main thread\n          await this.notifyClients('sync-success', { \n            requestId: queuedRequest.id,\n            url: queuedRequest.url \n          });\n        } else {\n          throw new Error(`HTTP ${response.status}`);\n        }\n      } catch (error) {\n        const attempts = this.retryAttempts.get(queuedRequest.id) || 0;\n        \n        if (attempts \u003c 3) {\n          this.retryAttempts.set(queuedRequest.id, attempts + 1);\n          failedRequests.push(queuedRequest);\n        } else {\n          // Max retries reached - notify failure\n          await this.notifyClients('sync-failed', {\n            requestId: queuedRequest.id,\n            url: queuedRequest.url,\n            error: error.message\n          });\n        }\n      }\n    }\n    \n    this.requestQueue = failedRequests;\n    await this.saveRequestQueue();\n  }\n\n  private async saveRequestQueue(): Promise\u003cvoid\u003e {\n    const cache = await caches.open(CACHE_NAME);\n    const response = new Response(JSON.stringify(this.requestQueue));\n    await cache.put('/sw-queue', response);\n  }\n\n  private async loadRequestQueue(): Promise\u003cvoid\u003e {\n    const cache = await caches.open(CACHE_NAME);\n    const response = await cache.match('/sw-queue');\n    \n    if (response) {\n      this.requestQueue = await response.json();\n    }\n  }\n\n  async handlePush(event: PushEvent): Promise\u003cvoid\u003e {\n    const data = event.data?.json() || {};\n    \n    const options: NotificationOptions = {\n      title: data.title || 'New Notification',\n      body: data.body || 'You have a new message',\n      icon: '/icon-192x192.png',\n      badge: '/badge-72x72.png',\n      tag: data.tag || 'default',\n      data: data.data || {},\n      actions: [\n        { action: 'view', title: 'View' },\n        { action: 'dismiss', title: 'Dismiss' }\n      ],\n      requireInteraction: true\n    };\n\n    await self.registration.showNotification(options.title!, options);\n  }\n\n  async handleNotificationClick(event: NotificationEvent): Promise\u003cvoid\u003e {\n    event.notification.close();\n\n    if (event.action === 'view') {\n      const urlToOpen = event.notification.data?.url || '/';\n      \n      const windowClients = await self.clients.matchAll({\n        type: 'window',\n        includeUncontrolled: true\n      });\n\n      // Check if app is already open\n      for (const client of windowClients) {\n        if (client.url === urlToOpen \u0026\u0026 'focus' in client) {\n          return client.focus();\n        }\n      }\n\n      // Open new window\n      if (self.clients.openWindow) {\n        return self.clients.openWindow(urlToOpen);\n      }\n    }\n  }\n\n  async handleMessage(event: ExtendableMessageEvent): Promise\u003cvoid\u003e {\n    const { type, payload } = event.data;\n\n    switch (type) {\n      case 'SKIP_WAITING':\n        await self.skipWaiting();\n        break;\n      \n      case 'GET_QUEUE_STATUS':\n        await this.loadRequestQueue();\n        event.ports[0].postMessage({\n          queueLength: this.requestQueue.length,\n          requests: this.requestQueue\n        });\n        break;\n      \n      case 'CLEAR_CACHE':\n        const cacheNames = await caches.keys();\n        await Promise.all(cacheNames.map(name =\u003e caches.delete(name)));\n        event.ports[0].postMessage({ success: true });\n        break;\n    }\n  }\n\n  private async notifyClients(type: string, payload: any): Promise\u003cvoid\u003e {\n    const clients = await self.clients.matchAll();\n    \n    for (const client of clients) {\n      client.postMessage({ type, payload });\n    }\n  }\n}\n\n// Initialize service worker\nconst sw = new AdvancedServiceWorker();\n\nself.addEventListener('install', (event) =\u003e {\n  event.waitUntil(sw.install());\n});\n\nself.addEventListener('activate', (event) =\u003e {\n  event.waitUntil(sw.activate());\n});\n\nself.addEventListener('fetch', (event) =\u003e {\n  event.respondWith(sw.handleFetch(event));\n});\n\nself.addEventListener('sync', (event) =\u003e {\n  event.waitUntil(sw.handleBackgroundSync(event.tag));\n});\n\nself.addEventListener('push', (event) =\u003e {\n  event.waitUntil(sw.handlePush(event));\n});\n\nself.addEventListener('notificationclick', (event) =\u003e {\n  event.waitUntil(sw.handleNotificationClick(event));\n});\n\nself.addEventListener('message', (event) =\u003e {\n  event.waitUntil(sw.handleMessage(event));\n});\n```\n{% endraw %}\n\n```typescript\n// main.ts - Main Application\nclass ServiceWorkerManager {\n  private registration: ServiceWorkerRegistration | null = null;\n  private updateAvailable = false;\n\n  async initialize(): Promise\u003cvoid\u003e {\n    if ('serviceWorker' in navigator) {\n      try {\n        this.registration = await navigator.serviceWorker.register('/sw.js');\n        \n        // Handle updates\n        this.registration.addEventListener('updatefound', () =\u003e {\n          const newWorker = this.registration!.installing;\n          if (newWorker) {\n            newWorker.addEventListener('statechange', () =\u003e {\n              if (newWorker.state === 'installed' \u0026\u0026 navigator.serviceWorker.controller) {\n                this.updateAvailable = true;\n                this.notifyUpdateAvailable();\n              }\n            });\n          }\n        });\n\n        // Listen for messages from service worker\n        navigator.serviceWorker.addEventListener('message', this.handleMessage.bind(this));\n        \n        // Request notification permission\n        await this.requestNotificationPermission();\n        \n        console.log('Service Worker registered successfully');\n      } catch (error) {\n        console.error('Service Worker registration failed:', error);\n      }\n    }\n  }\n\n  private handleMessage(event: MessageEvent): void {\n    const { type, payload } = event.data;\n    \n    switch (type) {\n      case 'sync-success':\n        console.log('Background sync successful:', payload);\n        this.showNotification('Sync Complete', 'Your changes have been synced.');\n        break;\n      \n      case 'sync-failed':\n        console.error('Background sync failed:', payload);\n        this.showNotification('Sync Failed', 'Some changes could not be synced.');\n        break;\n    }\n  }\n\n  async requestNotificationPermission(): Promise\u003cboolean\u003e {\n    if ('Notification' in window) {\n      const permission = await Notification.requestPermission();\n      return permission === 'granted';\n    }\n    return false;\n  }\n\n  async subscribeToPush(): Promise\u003cPushSubscription | null\u003e {\n    if (!this.registration || !('pushManager' in this.registration)) {\n      return null;\n    }\n\n    try {\n      const subscription = await this.registration.pushManager.subscribe({\n        userVisibleOnly: true,\n        applicationServerKey: this.urlBase64ToUint8Array(process.env.REACT_APP_VAPID_PUBLIC_KEY!)\n      });\n\n      // Send subscription to server\n      await fetch('/api/push-subscription', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(subscription)\n      });\n\n      return subscription;\n    } catch (error) {\n      console.error('Failed to subscribe to push notifications:', error);\n      return null;\n    }\n  }\n\n  private urlBase64ToUint8Array(base64String: string): Uint8Array {\n    const padding = '='.repeat((4 - base64String.length % 4) % 4);\n    const base64 = (base64String + padding)\n      .replace(/\\-/g, '+')\n      .replace(/_/g, '/');\n\n    const rawData = window.atob(base64);\n    const outputArray = new Uint8Array(rawData.length);\n\n    for (let i = 0; i \u003c rawData.length; ++i) {\n      outputArray[i] = rawData.charCodeAt(i);\n    }\n    return outputArray;\n  }\n\n  async getQueueStatus(): Promise\u003cany\u003e {\n    if (!navigator.serviceWorker.controller) return null;\n\n    return new Promise((resolve) =\u003e {\n      const channel = new MessageChannel();\n      channel.port1.onmessage = (event) =\u003e {\n        resolve(event.data);\n      };\n\n      navigator.serviceWorker.controller.postMessage(\n        { type: 'GET_QUEUE_STATUS' },\n        [channel.port2]\n      );\n    });\n  }\n\n  async clearCache(): Promise\u003cboolean\u003e {\n    if (!navigator.serviceWorker.controller) return false;\n\n    return new Promise((resolve) =\u003e {\n      const channel = new MessageChannel();\n      channel.port1.onmessage = (event) =\u003e {\n        resolve(event.data.success);\n      };\n\n      navigator.serviceWorker.controller.postMessage(\n        { type: 'CLEAR_CACHE' },\n        [channel.port2]\n      );\n    });\n  }\n\n  async updateServiceWorker(): Promise\u003cvoid\u003e {\n    if (this.updateAvailable \u0026\u0026 navigator.serviceWorker.controller) {\n      navigator.serviceWorker.controller.postMessage({ type: 'SKIP_WAITING' });\n      window.location.reload();\n    }\n  }\n\n  private notifyUpdateAvailable(): void {\n    // Show update notification to user\n    this.showNotification('Update Available', 'A new version is available. Click to update.');\n  }\n\n  private showNotification(title: string, body: string): void {\n    if ('Notification' in window \u0026\u0026 Notification.permission === 'granted') {\n      new Notification(title, { body });\n    }\n  }\n}\n\n// Usage\nconst swManager = new ServiceWorkerManager();\nswManager.initialize();\n```\n\n---\n\n## Challenge 2: Advanced Intersection Observer with Virtualization\n\n### Problem Statement\nCreate a virtualized list component that efficiently handles millions of items using Intersection Observer for performance optimization.\n\n### Requirements\n- Handle 1M+ list items efficiently\n- Dynamic item heights\n- Smooth scrolling performance\n- Intersection-based lazy loading\n- Memory optimization\n\n### Solution\n\n```typescript\ninterface VirtualItem {\n  id: string;\n  height?: number;\n  data: any;\n}\n\ninterface ViewportItem extends VirtualItem {\n  index: number;\n  top: number;\n  bottom: number;\n  isVisible: boolean;\n}\n\nclass VirtualizedList {\n  private container: HTMLElement;\n  private scrollContainer: HTMLElement;\n  private itemContainer: HTMLElement;\n  private items: VirtualItem[] = [];\n  private viewportItems: Map\u003cnumber, ViewportItem\u003e = new Map();\n  private intersectionObserver: IntersectionObserver;\n  private resizeObserver: ResizeObserver;\n  private estimatedItemHeight = 50;\n  private viewportHeight = 0;\n  private scrollTop = 0;\n  private totalHeight = 0;\n  private visibleRange = { start: 0, end: 0 };\n  private renderBuffer = 5;\n\n  constructor(container: HTMLElement, items: VirtualItem[]) {\n    this.container = container;\n    this.items = items;\n    this.setupDOM();\n    this.setupObservers();\n    this.calculateLayout();\n    this.render();\n  }\n\n  private setupDOM(): void {\n    this.container.innerHTML = `\n      \u003cdiv class=\"virtual-scroll-container\" style=\"height: 100%; overflow-y: auto;\"\u003e\n        \u003cdiv class=\"virtual-spacer-top\"\u003e\u003c/div\u003e\n        \u003cdiv class=\"virtual-item-container\"\u003e\u003c/div\u003e\n        \u003cdiv class=\"virtual-spacer-bottom\"\u003e\u003c/div\u003e\n      \u003c/div\u003e\n    `;\n\n    this.scrollContainer = this.container.querySelector('.virtual-scroll-container')!;\n    this.itemContainer = this.container.querySelector('.virtual-item-container')!;\n    \n    this.scrollContainer.addEventListener('scroll', this.handleScroll.bind(this));\n    this.viewportHeight = this.scrollContainer.clientHeight;\n  }\n\n  private setupObservers(): void {\n    // Intersection Observer for visibility tracking\n    this.intersectionObserver = new IntersectionObserver(\n      (entries) =\u003e {\n        for (const entry of entries) {\n          const index = parseInt(entry.target.getAttribute('data-index')!, 10);\n          const item = this.viewportItems.get(index);\n          \n          if (item) {\n            item.isVisible = entry.isIntersecting;\n            \n            if (entry.isIntersecting) {\n              this.loadItemData(item);\n            }\n          }\n        }\n      },\n      {\n        root: this.scrollContainer,\n        rootMargin: '100px 0px',\n        threshold: 0\n      }\n    );\n\n    // Resize Observer for dynamic heights\n    this.resizeObserver = new ResizeObserver((entries) =\u003e {\n      let needsRecalculation = false;\n      \n      for (const entry of entries) {\n        const index = parseInt(entry.target.getAttribute('data-index')!, 10);\n        const item = this.viewportItems.get(index);\n        const newHeight = entry.contentRect.height;\n        \n        if (item \u0026\u0026 item.height !== newHeight) {\n          item.height = newHeight;\n          this.items[index].height = newHeight;\n          needsRecalculation = true;\n        }\n      }\n      \n      if (needsRecalculation) {\n        this.calculateLayout();\n        this.updateSpacers();\n      }\n    });\n  }\n\n  private calculateLayout(): void {\n    let currentTop = 0;\n    \n    for (let i = 0; i \u003c this.items.length; i++) {\n      const item = this.items[i];\n      const height = item.height || this.estimatedItemHeight;\n      \n      if (this.viewportItems.has(i)) {\n        const viewportItem = this.viewportItems.get(i)!;\n        viewportItem.top = currentTop;\n        viewportItem.bottom = currentTop + height;\n      }\n      \n      currentTop += height;\n    }\n    \n    this.totalHeight = currentTop;\n  }\n\n  private handleScroll(): void {\n    this.scrollTop = this.scrollContainer.scrollTop;\n    this.updateVisibleRange();\n    this.render();\n  }\n\n  private updateVisibleRange(): void {\n    const viewportTop = this.scrollTop;\n    const viewportBottom = this.scrollTop + this.viewportHeight;\n    \n    let start = 0;\n    let end = this.items.length - 1;\n    \n    // Binary search for start\n    let left = 0;\n    let right = this.items.length - 1;\n    \n    while (left \u003c= right) {\n      const mid = Math.floor((left + right) / 2);\n      const itemTop = this.getItemTop(mid);\n      const itemBottom = itemTop + this.getItemHeight(mid);\n      \n      if (itemBottom \u003c viewportTop) {\n        left = mid + 1;\n      } else if (itemTop \u003e viewportBottom) {\n        right = mid - 1;\n      } else {\n        start = mid;\n        break;\n      }\n    }\n    \n    // Binary search for end\n    left = start;\n    right = this.items.length - 1;\n    \n    while (left \u003c= right) {\n      const mid = Math.floor((left + right) / 2);\n      const itemTop = this.getItemTop(mid);\n      const itemBottom = itemTop + this.getItemHeight(mid);\n      \n      if (itemTop \u003e viewportBottom) {\n        right = mid - 1;\n      } else {\n        end = mid;\n        left = mid + 1;\n      }\n    }\n    \n    // Add buffer\n    start = Math.max(0, start - this.renderBuffer);\n    end = Math.min(this.items.length - 1, end + this.renderBuffer);\n    \n    this.visibleRange = { start, end };\n  }\n\n  private getItemTop(index: number): number {\n    let top = 0;\n    for (let i = 0; i \u003c index; i++) {\n      top += this.getItemHeight(i);\n    }\n    return top;\n  }\n\n  private getItemHeight(index: number): number {\n    return this.items[index].height || this.estimatedItemHeight;\n  }\n\n  private render(): void {\n    // Remove items outside visible range\n    for (const [index, item] of this.viewportItems) {\n      if (index \u003c this.visibleRange.start || index \u003e this.visibleRange.end) {\n        this.removeItem(index);\n      }\n    }\n    \n    // Add items in visible range\n    for (let i = this.visibleRange.start; i \u003c= this.visibleRange.end; i++) {\n      if (!this.viewportItems.has(i)) {\n        this.addItem(i);\n      }\n    }\n    \n    this.updateSpacers();\n  }\n\n  private addItem(index: number): void {\n    const item = this.items[index];\n    const element = this.createItemElement(item, index);\n    \n    const viewportItem: ViewportItem = {\n      ...item,\n      index,\n      top: this.getItemTop(index),\n      bottom: this.getItemTop(index) + this.getItemHeight(index),\n      isVisible: false\n    };\n    \n    this.viewportItems.set(index, viewportItem);\n    this.itemContainer.appendChild(element);\n    \n    // Observe for intersection and resize\n    this.intersectionObserver.observe(element);\n    this.resizeObserver.observe(element);\n  }\n\n  private removeItem(index: number): void {\n    const element = this.itemContainer.querySelector(`[data-index=\"${index}\"]`);\n    if (element) {\n      this.intersectionObserver.unobserve(element);\n      this.resizeObserver.unobserve(element);\n      element.remove();\n    }\n    \n    this.viewportItems.delete(index);\n  }\n\n  private createItemElement(item: VirtualItem, index: number): HTMLElement {\n    const element = document.createElement('div');\n    element.className = 'virtual-item';\n    element.setAttribute('data-index', index.toString());\n    element.style.minHeight = `${this.getItemHeight(index)}px`;\n    \n    // Initially show loading state\n    element.innerHTML = `\n      \u003cdiv class=\"item-loading\"\u003e\n        \u003cdiv class=\"skeleton\"\u003e\u003c/div\u003e\n      \u003c/div\u003e\n    `;\n    \n    return element;\n  }\n\n  private async loadItemData(item: ViewportItem): Promise\u003cvoid\u003e {\n    // Simulate async data loading\n    if (!item.data.loaded) {\n      const element = this.itemContainer.querySelector(`[data-index=\"${item.index}\"]`);\n      if (element) {\n        // Simulate network request\n        await new Promise(resolve =\u003e setTimeout(resolve, Math.random() * 100));\n        \n        item.data.loaded = true;\n        element.innerHTML = this.renderItemContent(item.data);\n      }\n    }\n  }\n\n  private renderItemContent(data: any): string {\n    return `\n      \u003cdiv class=\"item-content\"\u003e\n        \u003ch3\u003e${data.title || `Item ${data.id}`}\u003c/h3\u003e\n        \u003cp\u003e${data.description || 'Lorem ipsum dolor sit amet...'}\u003c/p\u003e\n        \u003cdiv class=\"item-meta\"\u003e\n          \u003cspan\u003eID: ${data.id}\u003c/span\u003e\n          \u003cspan\u003eType: ${data.type || 'default'}\u003c/span\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    `;\n  }\n\n  private updateSpacers(): void {\n    const topSpacer = this.container.querySelector('.virtual-spacer-top') as HTMLElement;\n    const bottomSpacer = this.container.querySelector('.virtual-spacer-bottom') as HTMLElement;\n    \n    const topHeight = this.getItemTop(this.visibleRange.start);\n    const bottomHeight = this.totalHeight - this.getItemTop(this.visibleRange.end + 1);\n    \n    topSpacer.style.height = `${topHeight}px`;\n    bottomSpacer.style.height = `${bottomHeight}px`;\n  }\n\n  public scrollToIndex(index: number): void {\n    const itemTop = this.getItemTop(index);\n    this.scrollContainer.scrollTop = itemTop;\n  }\n\n  public getVisibleItems(): ViewportItem[] {\n    return Array.from(this.viewportItems.values()).filter(item =\u003e item.isVisible);\n  }\n\n  public updateItems(newItems: VirtualItem[]): void {\n    this.items = newItems;\n    this.viewportItems.clear();\n    this.itemContainer.innerHTML = '';\n    this.calculateLayout();\n    this.updateVisibleRange();\n    this.render();\n  }\n\n  public destroy(): void {\n    this.intersectionObserver.disconnect();\n    this.resizeObserver.disconnect();\n    this.scrollContainer.removeEventListener('scroll', this.handleScroll);\n  }\n}\n\n// Usage\nconst generateItems = (count: number): VirtualItem[] =\u003e {\n  return Array.from({ length: count }, (_, index) =\u003e ({\n    id: `item-${index}`,\n    height: undefined, // Dynamic height\n    data: {\n      id: index,\n      title: `Item ${index}`,\n      description: `Description for item ${index}`,\n      type: ['text', 'image', 'video'][index % 3],\n      loaded: false\n    }\n  }));\n};\n\nconst container = document.getElementById('virtual-list-container')!;\nconst items = generateItems(1000000); // 1 million items\nconst virtualList = new VirtualizedList(container, items);\n```\n\n### CSS Styling\n\n```css\n.virtual-scroll-container {\n  height: 100%;\n  overflow-y: auto;\n  scroll-behavior: smooth;\n}\n\n.virtual-item {\n  border-bottom: 1px solid #eee;\n  transition: background-color 0.2s;\n}\n\n.virtual-item:hover {\n  background-color: #f5f5f5;\n}\n\n.item-loading {\n  padding: 20px;\n  display: flex;\n  align-items: center;\n}\n\n.skeleton {\n  height: 20px;\n  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);\n  background-size: 200% 100%;\n  animation: skeleton-loading 1.5s infinite;\n  border-radius: 4px;\n  flex: 1;\n}\n\n@keyframes skeleton-loading {\n  0% { background-position: 200% 0; }\n  100% { background-position: -200% 0; }\n}\n\n.item-content {\n  padding: 20px;\n}\n\n.item-content h3 {\n  margin: 0 0 10px 0;\n  color: #333;\n}\n\n.item-content p {\n  margin: 0 0 15px 0;\n  color: #666;\n  line-height: 1.5;\n}\n\n.item-meta {\n  display: flex;\n  gap: 15px;\n  font-size: 12px;\n  color: #999;\n}\n\n.item-meta span {\n  padding: 4px 8px;\n  background: #f0f0f0;\n  border-radius: 12px;\n}\n```\n\n---\n\n## Challenge 3: Real-time Communication with WebRTC\n\n### Problem Statement\nBuild a peer-to-peer video chat application with screen sharing, file transfer, and real-time messaging.\n\n### Requirements\n- Peer-to-peer video/audio calling\n- Screen sharing functionality\n- Real-time text messaging\n- File transfer over data channels\n- Connection quality monitoring\n\n### Solution\n\n```typescript\ninterface PeerConnectionConfig {\n  iceServers: RTCIceServer[];\n  iceTransportPolicy?: RTCIceTransportPolicy;\n}\n\ninterface MediaConstraints {\n  video?: boolean | MediaTrackConstraints;\n  audio?: boolean | MediaTrackConstraints;\n}\n\nclass WebRTCManager {\n  private localConnection: RTCPeerConnection;\n  private remoteConnection: RTCPeerConnection;\n  private localStream: MediaStream | null = null;\n  private remoteStream: MediaStream | null = null;\n  private dataChannel: RTCDataChannel | null = null;\n  private signalingChannel: WebSocket;\n  private localVideo: HTMLVideoElement;\n  private remoteVideo: HTMLVideoElement;\n  private connectionStats: Map\u003cstring, RTCStatsReport\u003e = new Map();\n  private isScreenSharing = false;\n  private originalVideoTrack: MediaStreamTrack | null = null;\n\n  private config: PeerConnectionConfig = {\n    iceServers: [\n      { urls: 'stun:stun.l.google.com:19302' },\n      { urls: 'stun:stun1.l.google.com:19302' }\n    ]\n  };\n\n  constructor(\n    localVideo: HTMLVideoElement,\n    remoteVideo: HTMLVideoElement,\n    signalingServerUrl: string\n  ) {\n    this.localVideo = localVideo;\n    this.remoteVideo = remoteVideo;\n    this.signalingChannel = new WebSocket(signalingServerUrl);\n    \n    this.setupSignaling();\n    this.initializePeerConnections();\n  }\n\n  private setupSignaling(): void {\n    this.signalingChannel.onopen = () =\u003e {\n      console.log('Signaling channel connected');\n    };\n\n    this.signalingChannel.onmessage = async (event) =\u003e {\n      const message = JSON.parse(event.data);\n      await this.handleSignalingMessage(message);\n    };\n\n    this.signalingChannel.onerror = (error) =\u003e {\n      console.error('Signaling channel error:', error);\n    };\n\n    this.signalingChannel.onclose = () =\u003e {\n      console.log('Signaling channel closed');\n    };\n  }\n\n  private initializePeerConnections(): void {\n    this.localConnection = new RTCPeerConnection(this.config);\n    this.remoteConnection = new RTCPeerConnection(this.config);\n\n    // Set up event handlers\n    this.localConnection.onicecandidate = (event) =\u003e {\n      if (event.candidate) {\n        this.sendSignalingMessage({\n          type: 'ice-candidate',\n          candidate: event.candidate,\n          target: 'remote'\n        });\n      }\n    };\n\n    this.remoteConnection.onicecandidate = (event) =\u003e {\n      if (event.candidate) {\n        this.sendSignalingMessage({\n          type: 'ice-candidate',\n          candidate: event.candidate,\n          target: 'local'\n        });\n      }\n    };\n\n    this.localConnection.ontrack = (event) =\u003e {\n      this.remoteStream = event.streams[0];\n      this.remoteVideo.srcObject = this.remoteStream;\n    };\n\n    this.remoteConnection.ontrack = (event) =\u003e {\n      // Handle remote track\n    };\n\n    // Data channel setup\n    this.setupDataChannel();\n    \n    // Connection state monitoring\n    this.setupConnectionMonitoring();\n  }\n\n  private setupDataChannel(): void {\n    this.dataChannel = this.localConnection.createDataChannel('messages', {\n      ordered: true\n    });\n\n    this.dataChannel.onopen = () =\u003e {\n      console.log('Data channel opened');\n    };\n\n    this.dataChannel.onmessage = (event) =\u003e {\n      this.handleDataChannelMessage(event.data);\n    };\n\n    this.dataChannel.onerror = (error) =\u003e {\n      console.error('Data channel error:', error);\n    };\n\n    this.localConnection.ondatachannel = (event) =\u003e {\n      const channel = event.channel;\n      channel.onmessage = (event) =\u003e {\n        this.handleDataChannelMessage(event.data);\n      };\n    };\n  }\n\n  private setupConnectionMonitoring(): void {\n    this.localConnection.onconnectionstatechange = () =\u003e {\n      console.log('Local connection state:', this.localConnection.connectionState);\n      this.updateConnectionUI();\n    };\n\n    this.remoteConnection.onconnectionstatechange = () =\u003e {\n      console.log('Remote connection state:', this.remoteConnection.connectionState);\n      this.updateConnectionUI();\n    };\n\n    // Start stats monitoring\n    setInterval(() =\u003e {\n      this.collectConnectionStats();\n    }, 1000);\n  }\n\n  async startCall(constraints: MediaConstraints = { video: true, audio: true }): Promise\u003cvoid\u003e {\n    try {\n      // Get user media\n      this.localStream = await navigator.mediaDevices.getUserMedia(constraints);\n      this.localVideo.srcObject = this.localStream;\n\n      // Add tracks to peer connection\n      for (const track of this.localStream.getTracks()) {\n        this.localConnection.addTrack(track, this.localStream);\n      }\n\n      // Create offer\n      const offer = await this.localConnection.createOffer();\n      await this.localConnection.setLocalDescription(offer);\n\n      // Send offer through signaling\n      this.sendSignalingMessage({\n        type: 'offer',\n        offer: offer\n      });\n\n    } catch (error) {\n      console.error('Error starting call:', error);\n      throw error;\n    }\n  }\n\n  async answerCall(offer: RTCSessionDescriptionInit): Promise\u003cvoid\u003e {\n    try {\n      // Get user media\n      this.localStream = await navigator.mediaDevices.getUserMedia({\n        video: true,\n        audio: true\n      });\n      this.localVideo.srcObject = this.localStream;\n\n      // Add tracks to peer connection\n      for (const track of this.localStream.getTracks()) {\n        this.remoteConnection.addTrack(track, this.localStream);\n      }\n\n      // Set remote description\n      await this.remoteConnection.setRemoteDescription(offer);\n\n      // Create answer\n      const answer = await this.remoteConnection.createAnswer();\n      await this.remoteConnection.setLocalDescription(answer);\n\n      // Send answer through signaling\n      this.sendSignalingMessage({\n        type: 'answer',\n        answer: answer\n      });\n\n    } catch (error) {\n      console.error('Error answering call:', error);\n      throw error;\n    }\n  }\n\n  async startScreenShare(): Promise\u003cvoid\u003e {\n    try {\n      if (this.isScreenSharing) {\n        await this.stopScreenShare();\n        return;\n      }\n\n      // Get screen capture\n      const screenStream = await navigator.mediaDevices.getDisplayMedia({\n        video: { mediaSource: 'screen' },\n        audio: true\n      });\n\n      const videoTrack = screenStream.getVideoTracks()[0];\n      \n      // Store original video track\n      const sender = this.localConnection.getSenders().find(s =\u003e \n        s.track \u0026\u0026 s.track.kind === 'video'\n      );\n\n      if (sender \u0026\u0026 this.localStream) {\n        this.originalVideoTrack = this.localStream.getVideoTracks()[0];\n        await sender.replaceTrack(videoTrack);\n      }\n\n      // Update local video\n      this.localVideo.srcObject = screenStream;\n      this.isScreenSharing = true;\n\n      // Handle screen share end\n      videoTrack.onended = async () =\u003e {\n        await this.stopScreenShare();\n      };\n\n    } catch (error) {\n      console.error('Error starting screen share:', error);\n      throw error;\n    }\n  }\n\n  async stopScreenShare(): Promise\u003cvoid\u003e {\n    if (!this.isScreenSharing || !this.originalVideoTrack) return;\n\n    try {\n      const sender = this.localConnection.getSenders().find(s =\u003e \n        s.track \u0026\u0026 s.track.kind === 'video'\n      );\n\n      if (sender) {\n        await sender.replaceTrack(this.originalVideoTrack);\n      }\n\n      // Restore original video stream\n      this.localVideo.srcObject = this.localStream;\n      this.isScreenSharing = false;\n      this.originalVideoTrack = null;\n\n    } catch (error) {\n      console.error('Error stopping screen share:', error);\n    }\n  }\n\n  sendMessage(message: string): void {\n    if (this.dataChannel \u0026\u0026 this.dataChannel.readyState === 'open') {\n      const messageData = {\n        type: 'text',\n        content: message,\n        timestamp: Date.now()\n      };\n      \n      this.dataChannel.send(JSON.stringify(messageData));\n    }\n  }\n\n  async sendFile(file: File): Promise\u003cvoid\u003e {\n    if (!this.dataChannel || this.dataChannel.readyState !== 'open') {\n      throw new Error('Data channel not ready');\n    }\n\n    const chunkSize = 16384; // 16KB chunks\n    const fileReader = new FileReader();\n    let offset = 0;\n\n    // Send file metadata\n    const metadata = {\n      type: 'file-start',\n      filename: file.name,\n      filesize: file.size,\n      filetype: file.type\n    };\n    \n    this.dataChannel.send(JSON.stringify(metadata));\n\n    return new Promise((resolve, reject) =\u003e {\n      fileReader.onload = (event) =\u003e {\n        const chunk = event.target!.result as ArrayBuffer;\n        \n        // Send chunk\n        this.dataChannel!.send(JSON.stringify({\n          type: 'file-chunk',\n          data: Array.from(new Uint8Array(chunk))\n        }));\n\n        offset += chunk.byteLength;\n\n        if (offset \u003c file.size) {\n          // Read next chunk\n          const blob = file.slice(offset, offset + chunkSize);\n          fileReader.readAsArrayBuffer(blob);\n        } else {\n          // File transfer complete\n          this.dataChannel!.send(JSON.stringify({\n            type: 'file-end'\n          }));\n          resolve();\n        }\n      };\n\n      fileReader.onerror = reject;\n\n      // Start reading first chunk\n      const blob = file.slice(0, chunkSize);\n      fileReader.readAsArrayBuffer(blob);\n    });\n  }\n\n  private handleDataChannelMessage(data: string): void {\n    try {\n      const message = JSON.parse(data);\n      \n      switch (message.type) {\n        case 'text':\n          this.onTextMessage?.(message.content, message.timestamp);\n          break;\n        \n        case 'file-start':\n          this.onFileTransferStart?.(message.filename, message.filesize, message.filetype);\n          break;\n        \n        case 'file-chunk':\n          this.onFileChunk?.(message.data);\n          break;\n        \n        case 'file-end':\n          this.onFileTransferComplete?.();\n          break;\n      }\n    } catch (error) {\n      console.error('Error handling data channel message:', error);\n    }\n  }\n\n  private async handleSignalingMessage(message: any): Promise\u003cvoid\u003e {\n    switch (message.type) {\n      case 'offer':\n        await this.answerCall(message.offer);\n        break;\n      \n      case 'answer':\n        await this.localConnection.setRemoteDescription(message.answer);\n        break;\n      \n      case 'ice-candidate':\n        const connection = message.target === 'local' ? this.localConnection : this.remoteConnection;\n        await connection.addIceCandidate(message.candidate);\n        break;\n    }\n  }\n\n  private sendSignalingMessage(message: any): void {\n    if (this.signalingChannel.readyState === WebSocket.OPEN) {\n      this.signalingChannel.send(JSON.stringify(message));\n    }\n  }\n\n  private async collectConnectionStats(): Promise\u003cvoid\u003e {\n    try {\n      const stats = await this.localConnection.getStats();\n      this.connectionStats.set('local', stats);\n      \n      // Analyze stats for quality metrics\n      this.analyzeConnectionQuality(stats);\n    } catch (error) {\n      console.error('Error collecting stats:', error);\n    }\n  }\n\n  private analyzeConnectionQuality(stats: RTCStatsReport): void {\n    let inboundVideo: RTCInboundRtpStreamStats | undefined;\n    let outboundVideo: RTCOutboundRtpStreamStats | undefined;\n\n    stats.forEach((report) =\u003e {\n      if (report.type === 'inbound-rtp' \u0026\u0026 report.mediaType === 'video') {\n        inboundVideo = report as RTCInboundRtpStreamStats;\n      } else if (report.type === 'outbound-rtp' \u0026\u0026 report.mediaType === 'video') {\n        outboundVideo = report as RTCOutboundRtpStreamStats;\n      }\n    });\n\n    if (inboundVideo) {\n      const quality = {\n        packetsLost: inboundVideo.packetsLost || 0,\n        packetsReceived: inboundVideo.packetsReceived || 0,\n        bytesReceived: inboundVideo.bytesReceived || 0,\n        frameWidth: inboundVideo.frameWidth || 0,\n        frameHeight: inboundVideo.frameHeight || 0,\n        framesPerSecond: inboundVideo.framesPerSecond || 0\n      };\n\n      this.onConnectionQualityUpdate?.(quality);\n    }\n  }\n\n  private updateConnectionUI(): void {\n    const state = this.localConnection.connectionState;\n    this.onConnectionStateChange?.(state);\n  }\n\n  // Event handlers (to be set by consumers)\n  onTextMessage?: (message: string, timestamp: number) =\u003e void;\n  onFileTransferStart?: (filename: string, filesize: number, filetype: string) =\u003e void;\n  onFileChunk?: (chunk: number[]) =\u003e void;\n  onFileTransferComplete?: () =\u003e void;\n  onConnectionQualityUpdate?: (quality: any) =\u003e void;\n  onConnectionStateChange?: (state: RTCPeerConnectionState) =\u003e void;\n\n  async disconnect(): Promise\u003cvoid\u003e {\n    // Stop all tracks\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track =\u003e track.stop());\n    }\n\n    // Close peer connections\n    this.localConnection.close();\n    this.remoteConnection.close();\n\n    // Close signaling channel\n    this.signalingChannel.close();\n\n    // Close data channel\n    if (this.dataChannel) {\n      this.dataChannel.close();\n    }\n  }\n}\n\n// Usage\nconst localVideo = document.getElementById('localVideo') as HTMLVideoElement;\nconst remoteVideo = document.getElementById('remoteVideo') as HTMLVideoElement;\n\nconst webrtc = new WebRTCManager(\n  localVideo,\n  remoteVideo,\n  'wss://your-signaling-server.com'\n);\n\n// Set up event handlers\nwebrtc.onTextMessage = (message, timestamp) =\u003e {\n  console.log('Received message:', message);\n};\n\nwebrtc.onConnectionQualityUpdate = (quality) =\u003e {\n  console.log('Connection quality:', quality);\n};\n\n// Start a call\ndocument.getElementById('startCall')?.addEventListener('click', () =\u003e {\n  webrtc.startCall();\n});\n\n// Start screen share\ndocument.getElementById('shareScreen')?.addEventListener('click', () =\u003e {\n  webrtc.startScreenShare();\n});\n```\n\nThese advanced Web API challenges demonstrate mastery of modern browser capabilities essential for senior frontend roles at major tech companies. Each solution includes performance optimization, error handling, and real-world complexity.\n"])</script><script>self.__next_f.push([1,"8:[\"slug\",\"frontend/coding-problems/19-web-apis-advanced\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L3\",null,{\"buildId\":\"fjDGwqtt1UnBZeA2uH4xO\",\"assetPrefix\":\"/interview\",\"urlParts\":[\"\",\"docs\",\"frontend\",\"coding-problems\",\"19-web-apis-advanced\"],\"initialTree\":[\"\",{\"children\":[\"docs\",{\"children\":[[\"slug\",\"frontend/coding-problems/19-web-apis-advanced\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"frontend\\\",\\\"coding-problems\\\",\\\"19-web-apis-advanced\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"docs\",{\"children\":[[\"slug\",\"frontend/coding-problems/19-web-apis-advanced\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",[\"$\",\"div\",null,{\"style\":{\"maxWidth\":\"1200px\",\"margin\":\"0 auto\",\"padding\":\"2rem\",\"paddingTop\":\"6rem\"},\"children\":[[\"$\",\"div\",null,{\"style\":{\"marginBottom\":\"2rem\"},\"children\":[[\"$\",\"nav\",null,{\"style\":{\"color\":\"#64748b\",\"fontSize\":\"0.9rem\",\"marginBottom\":\"1rem\"},\"children\":[[\"$\",\"a\",null,{\"href\":\"/interview\",\"style\":{\"color\":\"#3b82f6\",\"textDecoration\":\"none\"},\"children\":\"Home\"}],\" \u003e \",[\"$\",\"span\",null,{\"children\":\"frontend \u003e coding-problems \u003e 19-web-apis-advanced\"}]]}],[\"$\",\"h1\",null,{\"style\":{\"fontSize\":\"2.5rem\",\"fontWeight\":\"800\",\"marginBottom\":\"0.5rem\",\"color\":\"#1e293b\"},\"children\":\"Advanced Web APIs Challenges\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#64748b\",\"fontSize\":\"0.9rem\",\"marginBottom\":\"2rem\"},\"children\":[[\"$\",\"span\",null,{\"children\":[\"üìÅ \",\"frontend/coding-problems/19-web-apis-advanced.md\"]}],\"$undefined\",\"$undefined\"]}]]}],[\"$\",\"$L5\",null,{\"content\":\"$6\"}]]}],null],null],null]},[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"docs\",\"children\",\"$8\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"docs\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/interview/_next/static/css/387024c6a2216908.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}],\"params\":{}}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Advanced Web APIs Challenges - Frontend Interview Docs\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\" # Advanced Web APIs Challenges  ## Overview Modern Web APIs provide powerful capabilities for building sophisticated frontend applications. These challenges fo\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"Advanced Web APIs Challenges - Frontend Interview Docs\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\" # Advanced Web APIs Challenges  ## Overview Modern Web APIs provide powerful capabilities for building sophisticated frontend applications. These challenges fo\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Advanced Web APIs Challenges - Frontend Interview Docs\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\" # Advanced Web APIs Challenges  ## Overview Modern Web APIs provide powerful capabilities for building sophisticated frontend applications. These challenges fo\"}],[\"$\",\"meta\",\"10\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>