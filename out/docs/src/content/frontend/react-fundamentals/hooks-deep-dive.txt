2:I[5907,["918","static/chunks/918-3273b83890f10546.js","930","static/chunks/930-3262a6c9c5acace4.js","687","static/chunks/app/docs/%5B...slug%5D/page-32962e9542d32755.js"],"default"]
4:I[4707,[],""]
6:I[6423,[],""]
7:I[2,["918","static/chunks/918-3273b83890f10546.js","710","static/chunks/710-dfaa11b4dff08f8e.js","972","static/chunks/972-011bba60ed155615.js","233","static/chunks/233-3e0c1d820a17eca9.js","185","static/chunks/app/layout-333f4adcd11f8f39.js"],"default",1]
3:T544d,
# React Hooks Deep Dive - Advanced Patterns and Internals

## üé£ useState Deep Theory

### **What is useState Internally?**
**Definition:** useState is a React Hook that allows functional components to have local state. Internally, it uses a fiber node's memoizedState to store state values and update functions.

**Why useState Works:**
- **Fiber Architecture**: React's reconciliation algorithm tracks state per component instance
- **Closure Mechanism**: State updater functions capture the current fiber context
- **Batching**: Multiple setState calls are batched for performance
- **Immutability**: State updates trigger re-renders through reference comparison

**How useState Works Internally:**

```mermaid
graph TB
    subgraph "useState Internal Mechanism"
        A[Component Render] --> B[Hook Index Tracking]
        B --> C[Fiber Node State]
        C --> D[Memoized State Array]
        
        E[setState Call] --> F[Update Queue]
        F --> G[Schedule Re-render]
        G --> H[Reconciliation]
        H --> I[Component Re-render]
    end

    subgraph "State Update Lifecycle"
        J[User Action] --> K[setState(newValue)]
        K --> L[Create Update Object]
        L --> M[Enqueue Update]
        M --> N[Schedule Work]
        N --> O[Process Updates]
        O --> P[Calculate New State]
        P --> Q[Trigger Re-render]
    end

    subgraph "Batching Mechanism"
        R[Multiple setState] --> S[Update Queue]
        S --> T[Batch Processing]
        T --> U[Single Re-render]
        
        V[Automatic Batching] --> W[React 18+]
        W --> X[All Updates Batched]
    end
```

**Deep Theory with Advanced Examples:**
```javascript
// WHAT: useState internal behavior simulation
class UseStateSimulator {
    constructor() {
        this.currentHookIndex = 0;
        this.hooks = [];
        this.isRendering = false;
        this.updateQueue = [];
        this.batchedUpdates = new Set();
    }
    
    // Simulate useState hook
    useState(initialValue) {
        const hookIndex = this.currentHookIndex++;
        
        // Initialize hook if first render
        if (!this.hooks[hookIndex]) {
            this.hooks[hookIndex] = {
                state: typeof initialValue === 'function' ? initialValue() : initialValue,
                queue: [],
                dispatch: null
            };
        }
        
        const hook = this.hooks[hookIndex];
        
        // Process queued updates
        if (hook.queue.length > 0) {
            let newState = hook.state;
            
            hook.queue.forEach(update => {
                if (typeof update === 'function') {
                    newState = update(newState);
                } else {
                    newState = update;
                }
            });
            
            hook.state = newState;
            hook.queue = [];
        }
        
        // Create dispatch function
        const dispatch = (action) => {
            const update = {
                action,
                hookIndex,
                timestamp: Date.now()
            };
            
            // Add to update queue
            hook.queue.push(action);
            this.scheduleUpdate(update);
        };
        
        hook.dispatch = dispatch;
        
        return [hook.state, dispatch];
    }
    
    scheduleUpdate(update) {
        this.updateQueue.push(update);
        
        // Batch updates (simulate React's batching)
        if (!this.isRendering) {
            this.batchedUpdates.add(update);
            
            // Process batched updates in next tick
            Promise.resolve().then(() => {
                this.processBatchedUpdates();
            });
        }
    }
    
    processBatchedUpdates() {
        if (this.batchedUpdates.size === 0) return;
        
        console.log(`Processing ${this.batchedUpdates.size} batched updates`);
        
        this.isRendering = true;
        this.currentHookIndex = 0;
        
        // Simulate component re-render
        this.render();
        
        this.batchedUpdates.clear();
        this.isRendering = false;
    }
    
    render() {
        console.log('Component re-rendering...');
        // Reset hook index for next render
        this.currentHookIndex = 0;
    }
}

// WHY: Advanced useState patterns
function advancedUseStatePatterns() {
    // 1. Functional updates for complex state
    const [state, setState] = useState({ count: 0, name: '', items: [] });
    
    // Functional update prevents stale closure issues
    const incrementCount = useCallback(() => {
        setState(prevState => ({
            ...prevState,
            count: prevState.count + 1
        }));
    }, []);
    
    // 2. Lazy initial state for expensive computations
    const [expensiveState, setExpensiveState] = useState(() => {
        console.log('Expensive computation only runs once');
        return Array.from({ length: 10000 }, (_, i) => i * i);
    });
    
    // 3. State reducer pattern with useState
    const [complexState, setComplexState] = useState({
        loading: false,
        data: null,
        error: null
    });
    
    const stateReducer = useCallback((action) => {
        setComplexState(prevState => {
            switch (action.type) {
                case 'FETCH_START':
                    return { ...prevState, loading: true, error: null };
                case 'FETCH_SUCCESS':
                    return { loading: false, data: action.payload, error: null };
                case 'FETCH_ERROR':
                    return { loading: false, data: null, error: action.payload };
                default:
                    return prevState;
            }
        });
    }, []);
    
    // 4. Optimistic updates pattern
    const [optimisticState, setOptimisticState] = useState([]);
    
    const addItemOptimistically = useCallback(async (newItem) => {
        const tempId = Date.now();
        const optimisticItem = { ...newItem, id: tempId, pending: true };
        
        // Optimistically add item
        setOptimisticState(prev => [...prev, optimisticItem]);
        
        try {
            const savedItem = await api.saveItem(newItem);
            
            // Replace optimistic item with real item
            setOptimisticState(prev => 
                prev.map(item => 
                    item.id === tempId ? savedItem : item
                )
            );
        } catch (error) {
            // Remove optimistic item on error
            setOptimisticState(prev => 
                prev.filter(item => item.id !== tempId)
            );
            throw error;
        }
    }, []);
    
    return {
        state,
        incrementCount,
        expensiveState,
        stateReducer,
        addItemOptimistically
    };
}

// HOW: Custom hooks for advanced state management
function useAdvancedState(initialState, options = {}) {
    const {
        serialize = JSON.stringify,
        deserialize = JSON.parse,
        storage = localStorage,
        key = null,
        validator = null,
        middleware = []
    } = options;
    
    // Initialize state with persistence
    const [state, setState] = useState(() => {
        if (key && storage) {
            try {
                const stored = storage.getItem(key);
                if (stored) {
                    const parsed = deserialize(stored);
                    return validator ? validator(parsed) ? parsed : initialState : parsed;
                }
            } catch (error) {
                console.warn('Failed to load state from storage:', error);
            }
        }
        return typeof initialState === 'function' ? initialState() : initialState;
    });
    
    // Enhanced setState with middleware and persistence
    const enhancedSetState = useCallback((action) => {
        setState(prevState => {
            let newState;
            
            if (typeof action === 'function') {
                newState = action(prevState);
            } else {
                newState = action;
            }
            
            // Apply middleware
            middleware.forEach(mw => {
                newState = mw(newState, prevState);
            });
            
            // Persist to storage
            if (key && storage) {
                try {
                    storage.setItem(key, serialize(newState));
                } catch (error) {
                    console.warn('Failed to persist state:', error);
                }
            }
            
            return newState;
        });
    }, [key, storage, serialize, middleware]);
    
    // Clear persisted state
    const clearPersistedState = useCallback(() => {
        if (key && storage) {
            storage.removeItem(key);
        }
    }, [key, storage]);
    
    return [state, enhancedSetState, { clearPersistedState }];
}

// Advanced state synchronization hook
function useSharedState(key, initialValue) {
    const [state, setState] = useState(initialValue);
    const listeners = useRef(new Set());
    
    // Subscribe to state changes
    useEffect(() => {
        const handleStorageChange = (e) => {
            if (e.key === key && e.newValue) {
                try {
                    const newValue = JSON.parse(e.newValue);
                    setState(newValue);
                } catch (error) {
                    console.warn('Failed to parse shared state:', error);
                }
            }
        };
        
        window.addEventListener('storage', handleStorageChange);
        return () => window.removeEventListener('storage', handleStorageChange);
    }, [key]);
    
    // Enhanced setState that broadcasts changes
    const setSharedState = useCallback((action) => {
        setState(prevState => {
            const newState = typeof action === 'function' ? action(prevState) : action;
            
            // Broadcast to other tabs/windows
            try {
                localStorage.setItem(key, JSON.stringify(newState));
                
                // Notify local listeners
                listeners.current.forEach(listener => {
                    listener(newState, prevState);
                });
            } catch (error) {
                console.warn('Failed to broadcast state change:', error);
            }
            
            return newState;
        });
    }, [key]);
    
    // Subscribe to state changes
    const subscribe = useCallback((listener) => {
        listeners.current.add(listener);
        
        return () => {
            listeners.current.delete(listener);
        };
    }, []);
    
    return [state, setSharedState, { subscribe }];
}
```

## ‚ö° useEffect Deep Theory

### **What is useEffect Internally?**
**Definition:** useEffect is a Hook that lets you perform side effects in functional components. It serves the same purpose as componentDidMount, componentDidUpdate, and componentWillUnmount combined.

**Why useEffect is Powerful:**
- **Unified Lifecycle**: Combines multiple lifecycle methods into one API
- **Dependency Tracking**: Automatically optimizes when effects should run
- **Cleanup Management**: Handles resource cleanup automatically
- **Concurrent Safe**: Works with React's concurrent features

**How useEffect Works Internally:**

```mermaid
graph TB
    subgraph "useEffect Lifecycle"
        A[Component Mount] --> B[Run Effect]
        B --> C[Store Cleanup Function]
        
        D[Component Update] --> E[Compare Dependencies]
        E --> F{Dependencies Changed?}
        F -->|Yes| G[Run Cleanup]
        F -->|No| H[Skip Effect]
        G --> I[Run New Effect]
        I --> J[Store New Cleanup]
        
        K[Component Unmount] --> L[Run Final Cleanup]
    end

    subgraph "Dependency Array Behavior"
        M[No Deps Array] --> N[Run Every Render]
        O[Empty Deps Array] --> P[Run Once on Mount]
        Q[Deps Array with Values] --> R[Run When Deps Change]
    end

    subgraph "Effect Scheduling"
        S[Effect Queue] --> T[Passive Effects]
        T --> U[Layout Effects]
        U --> V[Mutation Effects]
        
        W[useEffect] --> X[Passive Phase]
        Y[useLayoutEffect] --> Z[Layout Phase]
    end
```

**Deep Theory with Advanced Examples:**
```javascript
// WHAT: useEffect internal behavior patterns
function useEffectDeepDive() {
    const [count, setCount] = useState(0);
    const [name, setName] = useState('');
    const [data, setData] = useState(null);
    
    // 1. Effect without dependencies (runs every render)
    useEffect(() => {
        console.log('Runs on every render');
        document.title = `Count: ${count}, Name: ${name}`;
    });
    
    // 2. Effect with empty dependencies (runs once on mount)
    useEffect(() => {
        console.log('Runs once on mount');
        
        const handleResize = () => {
            console.log('Window resized');
        };
        
        window.addEventListener('resize', handleResize);
        
        // Cleanup function
        return () => {
            console.log('Cleanup on unmount');
            window.removeEventListener('resize', handleResize);
        };
    }, []); // Empty dependency array
    
    // 3. Effect with specific dependencies
    useEffect(() => {
        console.log('Runs when count changes');
        
        if (count > 0) {
            const timer = setTimeout(() => {
                console.log(`Count is ${count}`);
            }, 1000);
            
            // Cleanup previous timer
            return () => {
                clearTimeout(timer);
            };
        }
    }, [count]); // Only runs when count changes
    
    // 4. Complex effect with multiple dependencies
    useEffect(() => {
        let isCancelled = false;
        
        async function fetchData() {
            if (!name) return;
            
            try {
                setData({ loading: true, error: null, result: null });
                
                const response = await fetch(`/api/users/${name}`);
                const result = await response.json();
                
                if (!isCancelled) {
                    setData({ loading: false, error: null, result });
                }
            } catch (error) {
                if (!isCancelled) {
                    setData({ loading: false, error: error.message, result: null });
                }
            }
        }
        
        fetchData();
        
        return () => {
            isCancelled = true;
        };
    }, [name]); // Runs when name changes
    
    return { count, setCount, name, setName, data };
}

// WHY: Advanced useEffect patterns
function advancedUseEffectPatterns() {
    // 1. Debounced effect
    function useDebounceEffect(callback, dependencies, delay) {
        useEffect(() => {
            const timer = setTimeout(callback, delay);
            return () => clearTimeout(timer);
        }, [...dependencies, delay]);
    }
    
    // 2. Previous value tracking
    function usePrevious(value) {
        const ref = useRef();
        
        useEffect(() => {
            ref.current = value;
        });
        
        return ref.current;
    }
    
    // 3. Async effect with cleanup
    function useAsyncEffect(asyncFunction, dependencies) {
        useEffect(() => {
            let isCancelled = false;
            
            const runAsync = async () => {
                try {
                    await asyncFunction(() => isCancelled);
                } catch (error) {
                    if (!isCancelled) {
                        console.error('Async effect error:', error);
                    }
                }
            };
            
            runAsync();
            
            return () => {
                isCancelled = true;
            };
        }, dependencies);
    }
    
    // 4. Interval effect with dynamic delay
    function useInterval(callback, delay) {
        const savedCallback = useRef(callback);
        
        // Remember the latest callback
        useEffect(() => {
            savedCallback.current = callback;
        }, [callback]);
        
        // Set up the interval
        useEffect(() => {
            if (delay === null) return;
            
            const tick = () => savedCallback.current();
            const id = setInterval(tick, delay);
            
            return () => clearInterval(id);
        }, [delay]);
    }
    
    // 5. Effect with error boundary
    function useEffectWithErrorBoundary(effect, dependencies, onError) {
        useEffect(() => {
            try {
                const cleanup = effect();
                return cleanup;
            } catch (error) {
                onError?.(error);
                console.error('Effect error:', error);
            }
        }, dependencies);
    }
    
    return {
        useDebounceEffect,
        usePrevious,
        useAsyncEffect,
        useInterval,
        useEffectWithErrorBoundary
    };
}

// HOW: Custom hooks combining useState and useEffect
function useAdvancedAsyncState(asyncFunction, dependencies = []) {
    const [state, setState] = useState({
        data: null,
        loading: false,
        error: null
    });
    
    const execute = useCallback(async (...args) => {
        setState(prev => ({ ...prev, loading: true, error: null }));
        
        try {
            const data = await asyncFunction(...args);
            setState({ data, loading: false, error: null });
            return data;
        } catch (error) {
            setState({ data: null, loading: false, error });
            throw error;
        }
    }, dependencies);
    
    // Auto-execute on mount if no arguments needed
    useEffect(() => {
        if (asyncFunction.length === 0) {
            execute();
        }
    }, [execute]);
    
    return { ...state, execute };
}

// Resource management hook
function useResource(createResource, dependencies = []) {
    const [resource, setResource] = useState(null);
    const [error, setError] = useState(null);
    
    useEffect(() => {
        let currentResource = null;
        
        const initResource = async () => {
            try {
                setError(null);
                currentResource = await createResource();
                setResource(currentResource);
            } catch (err) {
                setError(err);
                setResource(null);
            }
        };
        
        initResource();
        
        return () => {
            if (currentResource && typeof currentResource.cleanup === 'function') {
                currentResource.cleanup();
            }
        };
    }, dependencies);
    
    return { resource, error };
}

// WebSocket hook with automatic reconnection
function useWebSocket(url, options = {}) {
    const {
        onMessage,
        onError,
        onOpen,
        onClose,
        reconnectAttempts = 5,
        reconnectInterval = 1000
    } = options;
    
    const [socket, setSocket] = useState(null);
    const [connectionStatus, setConnectionStatus] = useState('Disconnected');
    const reconnectCount = useRef(0);
    
    useEffect(() => {
        let ws = null;
        let reconnectTimer = null;
        
        const connect = () => {
            try {
                ws = new WebSocket(url);
                setSocket(ws);
                
                ws.onopen = (event) => {
                    setConnectionStatus('Connected');
                    reconnectCount.current = 0;
                    onOpen?.(event);
                };
                
                ws.onmessage = (event) => {
                    onMessage?.(event);
                };
                
                ws.onerror = (event) => {
                    setConnectionStatus('Error');
                    onError?.(event);
                };
                
                ws.onclose = (event) => {
                    setConnectionStatus('Disconnected');
                    onClose?.(event);
                    
                    // Attempt reconnection
                    if (reconnectCount.current < reconnectAttempts) {
                        reconnectCount.current++;
                        setConnectionStatus(`Reconnecting (${reconnectCount.current}/${reconnectAttempts})`);
                        
                        reconnectTimer = setTimeout(() => {
                            connect();
                        }, reconnectInterval * reconnectCount.current);
                    }
                };
            } catch (error) {
                setConnectionStatus('Error');
                onError?.(error);
            }
        };
        
        connect();
        
        return () => {
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
            }
            if (ws) {
                ws.close();
            }
        };
    }, [url, onMessage, onError, onOpen, onClose, reconnectAttempts, reconnectInterval]);
    
    const sendMessage = useCallback((message) => {
        if (socket && socket.readyState === WebSocket.OPEN) {
            socket.send(typeof message === 'string' ? message : JSON.stringify(message));
        } else {
            console.warn('WebSocket is not connected');
        }
    }, [socket]);
    
    return { socket, connectionStatus, sendMessage };
}
```

This comprehensive deep dive into React Hooks provides the theoretical foundation and practical patterns needed for advanced React development and technical interviews.5:["slug","src/content/frontend/react-fundamentals/hooks-deep-dive","c"]
0:["7uJ7BVaXJTiEOD9iYDv3n",[[["",{"children":["docs",{"children":[["slug","src/content/frontend/react-fundamentals/hooks-deep-dive","c"],{"children":["__PAGE__?{\"slug\":[\"src\",\"content\",\"frontend\",\"react-fundamentals\",\"hooks-deep-dive\"]}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["docs",{"children":[["slug","src/content/frontend/react-fundamentals/hooks-deep-dive","c"],{"children":["__PAGE__",{},[["$L1",["$","div",null,{"style":{"maxWidth":"1200px","margin":"0 auto","padding":"2rem","paddingTop":"6rem"},"children":[["$","div",null,{"style":{"marginBottom":"2rem"},"children":[["$","nav",null,{"style":{"color":"#64748b","fontSize":"0.9rem","marginBottom":"1rem"},"children":[["$","a",null,{"href":"/","style":{"color":"#3b82f6","textDecoration":"none"},"children":"Home"}]," > ",["$","span",null,{"children":"src > content > frontend > react-fundamentals > hooks-deep-dive"}]]}],["$","h1",null,{"style":{"fontSize":"2.5rem","fontWeight":"800","marginBottom":"0.5rem","color":"#1e293b"},"children":"React Hooks Deep Dive - Advanced Patterns and Internals"}],["$","div",null,{"style":{"color":"#64748b","fontSize":"0.9rem","marginBottom":"2rem"},"children":[["$","span",null,{"children":["üìÅ ","src/content/frontend/react-fundamentals/hooks-deep-dive.md"]}],"$undefined","$undefined"]}]]}],["$","$L2",null,{"content":"$3"}]]}],null],null],null]},[null,["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","docs","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","docs","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/interview/_next/static/css/387024c6a2216908.css","precedence":"next","crossOrigin":"$undefined"}]],["$","$L7",null,{"children":["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}],"params":{}}]],null],null],["$L8",null]]]]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"React Hooks Deep Dive - Advanced Patterns and Internals - Frontend Interview Docs"}],["$","meta","3",{"name":"description","content":"Comprehensive understanding of React Hooks, custom hooks, and advanced patterns for state management and side effects"}],["$","meta","4",{"property":"og:title","content":"React Hooks Deep Dive - Advanced Patterns and Internals - Frontend Interview Docs"}],["$","meta","5",{"property":"og:description","content":"Comprehensive understanding of React Hooks, custom hooks, and advanced patterns for state management and side effects"}],["$","meta","6",{"property":"og:type","content":"article"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"React Hooks Deep Dive - Advanced Patterns and Internals - Frontend Interview Docs"}],["$","meta","9",{"name":"twitter:description","content":"Comprehensive understanding of React Hooks, custom hooks, and advanced patterns for state management and side effects"}],["$","meta","10",{"name":"next-size-adjust"}]]
1:null
