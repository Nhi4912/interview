<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/interview/_next/static/css/387024c6a2216908.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js"/><script src="/interview/_next/static/chunks/fd9d1056-6922f449a204c2cc.js" async=""></script><script src="/interview/_next/static/chunks/117-e7ecc085ce9cfab3.js" async=""></script><script src="/interview/_next/static/chunks/main-app-b06be5f3411c20c3.js" async=""></script><script src="/interview/_next/static/chunks/918-3273b83890f10546.js" async=""></script><script src="/interview/_next/static/chunks/930-3262a6c9c5acace4.js" async=""></script><script src="/interview/_next/static/chunks/app/docs/%5B...slug%5D/page-036ada1d0a865043.js" async=""></script><script src="/interview/_next/static/chunks/710-dfaa11b4dff08f8e.js" async=""></script><script src="/interview/_next/static/chunks/972-011bba60ed155615.js" async=""></script><script src="/interview/_next/static/chunks/233-3e0c1d820a17eca9.js" async=""></script><script src="/interview/_next/static/chunks/app/layout-333f4adcd11f8f39.js" async=""></script><title>Frontend Interview Prep 2025 - Big Tech Interview Guide</title><meta name="description" content="Comprehensive frontend interview preparation for Big Tech companies including React, TypeScript, algorithms, and system design."/><link rel="icon" href="/favicon.ico"/><meta name="theme-color" content="#1a1a1a"/><meta property="og:title" content="Frontend Interview Prep 2025"/><meta property="og:description" content="Complete guide for frontend engineers targeting Big Tech companies"/><meta property="og:type" content="website"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"/><title>Browser Architecture and Rendering Pipeline Deep Dive - Frontend Interview Docs</title><meta name="description" content="Comprehensive guide to browser internals, rendering pipeline, performance optimization, and debugging techniques for frontend interviews"/><meta property="og:title" content="Browser Architecture and Rendering Pipeline Deep Dive - Frontend Interview Docs"/><meta property="og:description" content="Comprehensive guide to browser internals, rendering pipeline, performance optimization, and debugging techniques for frontend interviews"/><meta property="og:type" content="article"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Browser Architecture and Rendering Pipeline Deep Dive - Frontend Interview Docs"/><meta name="twitter:description" content="Comprehensive guide to browser internals, rendering pipeline, performance optimization, and debugging techniques for frontend interviews"/><meta name="next-size-adjust"/><script src="/interview/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script><style data-styled="" data-styled-version="6.1.19">*{margin:0;padding:0;box-sizing:border-box;}/*!sc*/
html{font-size:16px;line-height:1.5;scroll-behavior:smooth;}/*!sc*/
body{font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;font-size:1rem;line-height:1.5;color:#1e293b;background-color:#ffffff;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}/*!sc*/
h1,h2,h3,h4,h5,h6{font-weight:700;line-height:1.25;margin-bottom:0.5em;}/*!sc*/
h1{font-size:3rem;}/*!sc*/
@media (max-width: 768px){h1{font-size:2.25rem;}}/*!sc*/
h2{font-size:2.25rem;}/*!sc*/
@media (max-width: 768px){h2{font-size:1.875rem;}}/*!sc*/
h3{font-size:1.875rem;}/*!sc*/
@media (max-width: 768px){h3{font-size:1.5rem;}}/*!sc*/
h4{font-size:1.5rem;}/*!sc*/
@media (max-width: 768px){h4{font-size:1.25rem;}}/*!sc*/
h5{font-size:1.25rem;}/*!sc*/
h6{font-size:1.125rem;}/*!sc*/
p{margin-bottom:1rem;line-height:1.75;}/*!sc*/
a{color:#3b82f6;text-decoration:none;transition:color 0.15s ease;}/*!sc*/
a:hover{color:#2563eb;}/*!sc*/
a:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
button{cursor:pointer;border:none;background:none;font-family:inherit;font-size:inherit;}/*!sc*/
button:disabled{cursor:not-allowed;opacity:0.6;}/*!sc*/
button:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
input,textarea,select{font-family:inherit;font-size:inherit;}/*!sc*/
input:focus,textarea:focus,select:focus{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
img{max-width:100%;height:auto;}/*!sc*/
ul,ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
li{margin-bottom:0.25rem;}/*!sc*/
blockquote{margin:1rem 0;padding:1rem;border-left:4px solid #3b82f6;background-color:#f1f5f9;font-style:italic;}/*!sc*/
code{font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;background-color:#f1f5f9;padding:0.2em 0.4em;border-radius:0.25rem;}/*!sc*/
pre{background-color:#f1f5f9;padding:1rem;border-radius:0.5rem;overflow-x:auto;margin-bottom:1rem;}/*!sc*/
pre code{background:none;padding:0;}/*!sc*/
table{width:100%;border-collapse:collapse;margin-bottom:1rem;}/*!sc*/
th,td{padding:0.75rem;text-align:left;border-bottom:1px solid #e2e8f0;}/*!sc*/
th{font-weight:600;background-color:#f1f5f9;}/*!sc*/
.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0;}/*!sc*/
.skip-link{position:absolute;top:-40px;left:6px;background:#3b82f6;color:white;padding:8px;text-decoration:none;border-radius:4px;z-index:100;}/*!sc*/
.skip-link:focus{top:6px;}/*!sc*/
::-webkit-scrollbar{width:8px;height:8px;}/*!sc*/
::-webkit-scrollbar-track{background:#f1f5f9;}/*!sc*/
::-webkit-scrollbar-thumb{background:#94a3b8;border-radius:4px;}/*!sc*/
::-webkit-scrollbar-thumb:hover{background:#64748b;}/*!sc*/
::selection{background:#3b82f6;color:white;}/*!sc*/
.focus-visible{outline:2px solid #3b82f6;outline-offset:2px;}/*!sc*/
.fade-in{opacity:0;animation:fadeIn 0.3s ease forwards;}/*!sc*/
.slide-up{transform:translateY(20px);opacity:0;animation:slideUp 0.3s ease forwards;}/*!sc*/
@keyframes fadeIn{to{opacity:1;}}/*!sc*/
@keyframes slideUp{to{transform:translateY(0);opacity:1;}}/*!sc*/
@media print{*{background:white!important;color:black!important;box-shadow:none!important;text-shadow:none!important;}a,a:visited{text-decoration:underline;}h1,h2,h3,h4,h5,h6{break-after:avoid;}pre,blockquote{border:1px solid #999;break-inside:avoid;}img{max-width:100%!important;}@page{margin:0.5in;}}/*!sc*/
data-styled.g19[id="sc-global-kxA-Ddz1"]{content:"sc-global-kxA-Ddz1,"}/*!sc*/
.hNPaTO{position:fixed;top:0;width:100%;z-index:1020;background:transparent;backdrop-filter:blur(10px);border-bottom:1px solid transparent;transition:all 0.3s ease;}/*!sc*/
data-styled.g20[id="sc-dNdcvo"]{content:"hNPaTO,"}/*!sc*/
.jJxjWc{max-width:1200px;margin:0 auto;padding:0 2rem;display:flex;align-items:center;justify-content:space-between;height:70px;}/*!sc*/
data-styled.g21[id="sc-fbQrwq"]{content:"jJxjWc,"}/*!sc*/
.jwmRwa{display:flex;align-items:center;gap:0.5rem;font-size:1.5rem;font-weight:700;color:#3b82f6;text-decoration:none;cursor:pointer;}/*!sc*/
.jwmRwa:hover{color:#2563eb;}/*!sc*/
data-styled.g22[id="sc-gGKoUb"]{content:"jwmRwa,"}/*!sc*/
.KQdZw{display:flex;align-items:center;gap:2rem;}/*!sc*/
@media (max-width: 768px){.KQdZw{display:none;}}/*!sc*/
data-styled.g23[id="sc-hwddKA"]{content:"KQdZw,"}/*!sc*/
.ETszJ{color:#1e293b;font-weight:500;text-decoration:none;transition:color 0.15s ease;position:relative;}/*!sc*/
.ETszJ:hover{color:#3b82f6;}/*!sc*/
.ETszJ:after{content:'';position:absolute;bottom:-5px;left:0;width:0;height:2px;background:#3b82f6;transition:width 0.15s ease;}/*!sc*/
.ETszJ:hover:after{width:100%;}/*!sc*/
data-styled.g24[id="sc-jaXbil"]{content:"ETszJ,"}/*!sc*/
.foClcg{display:none;background:none;border:none;color:#1e293b;cursor:pointer;padding:0.5rem;}/*!sc*/
@media (max-width: 768px){.foClcg{display:block;}}/*!sc*/
data-styled.g25[id="sc-eqNDNG"]{content:"foClcg,"}/*!sc*/
.kBjfBo{display:flex;align-items:center;gap:0.5rem;background:#f1f5f9;border:1px solid #e2e8f0;border-radius:0.5rem;padding:0.5rem 1rem;color:#64748b;font-size:0.9rem;transition:all 0.15s ease;}/*!sc*/
.kBjfBo:hover{background:#ffffff;border-color:#3b82f6;}/*!sc*/
data-styled.g29[id="sc-eQwNpu"]{content:"kBjfBo,"}/*!sc*/
.booJNS{background:#1e293b;color:white;padding:3rem 0 1rem;margin-top:auto;}/*!sc*/
data-styled.g30[id="sc-gvqKNf"]{content:"booJNS,"}/*!sc*/
.fVoYcP{max-width:1200px;margin:0 auto;padding:0 2rem;}/*!sc*/
data-styled.g31[id="sc-cOpnSz"]{content:"fVoYcP,"}/*!sc*/
.kKfrkv{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:2rem;margin-bottom:2rem;}/*!sc*/
@media (max-width: 768px){.kKfrkv{grid-template-columns:1fr 1fr;gap:1.5rem;}}/*!sc*/
@media (max-width: 480px){.kKfrkv{grid-template-columns:1fr;}}/*!sc*/
data-styled.g32[id="sc-kjwdDK"]{content:"kKfrkv,"}/*!sc*/
.inEXDm h3{font-size:1.1rem;font-weight:600;margin-bottom:1rem;color:white;}/*!sc*/
.inEXDm ul{list-style:none;padding:0;margin:0;}/*!sc*/
.inEXDm li{margin-bottom:0.5rem;}/*!sc*/
.inEXDm a{color:rgba(255, 255, 255, 0.7);text-decoration:none;transition:color 0.15s ease;}/*!sc*/
.inEXDm a:hover{color:white;}/*!sc*/
data-styled.g33[id="sc-eVqvcJ"]{content:"inEXDm,"}/*!sc*/
.hWhopJ{display:flex;align-items:center;gap:0.5rem;font-size:1.2rem;font-weight:700;margin-bottom:1rem;color:white;}/*!sc*/
data-styled.g34[id="sc-bbbBoY"]{content:"hWhopJ,"}/*!sc*/
.exeTne{color:rgba(255, 255, 255, 0.7);line-height:1.6;margin-bottom:1rem;}/*!sc*/
data-styled.g35[id="sc-cdmAjP"]{content:"exeTne,"}/*!sc*/
.cgXMuV{display:flex;gap:1rem;}/*!sc*/
.cgXMuV a{display:flex;align-items:center;justify-content:center;width:40px;height:40px;background:rgba(255, 255, 255, 0.1);border-radius:0.5rem;color:rgba(255, 255, 255, 0.7);transition:all 0.15s ease;}/*!sc*/
.cgXMuV a:hover{background:rgba(255, 255, 255, 0.2);color:white;}/*!sc*/
data-styled.g36[id="sc-jytpVa"]{content:"cgXMuV,"}/*!sc*/
.iQqwrD{border-top:1px solid rgba(255, 255, 255, 0.1);padding-top:2rem;display:flex;justify-content:space-between;align-items:center;}/*!sc*/
@media (max-width: 768px){.iQqwrD{flex-direction:column;gap:1rem;text-align:center;}}/*!sc*/
data-styled.g37[id="sc-eknHtZ"]{content:"iQqwrD,"}/*!sc*/
.gObJRG{color:rgba(255, 255, 255, 0.7);margin:0;font-size:0.9rem;}/*!sc*/
data-styled.g38[id="sc-pYNGo"]{content:"gObJRG,"}/*!sc*/
.eBqBtc{display:flex;gap:2rem;}/*!sc*/
@media (max-width: 480px){.eBqBtc{flex-direction:column;gap:1rem;}}/*!sc*/
.eBqBtc a{color:rgba(255, 255, 255, 0.7);text-decoration:none;font-size:0.9rem;transition:color 0.15s ease;}/*!sc*/
.eBqBtc a:hover{color:white;}/*!sc*/
data-styled.g39[id="sc-cCVJLD"]{content:"eBqBtc,"}/*!sc*/
.ehAIaV{color:#1e293b;line-height:1.6;}/*!sc*/
.ehAIaV h1,.ehAIaV h2,.ehAIaV h3,.ehAIaV h4,.ehAIaV h5,.ehAIaV h6{color:#1e293b;margin-top:2rem;margin-bottom:1rem;font-weight:600;}/*!sc*/
.ehAIaV h1{font-size:2rem;border-bottom:2px solid #e2e8f0;padding-bottom:0.5rem;}/*!sc*/
.ehAIaV h2{font-size:1.5rem;border-bottom:1px solid #e2e8f0;padding-bottom:0.3rem;}/*!sc*/
.ehAIaV h3{font-size:1.25rem;}/*!sc*/
.ehAIaV h4{font-size:1.1rem;}/*!sc*/
.ehAIaV p{margin-bottom:1rem;color:#64748b;}/*!sc*/
.ehAIaV a{color:#3b82f6;text-decoration:none;}/*!sc*/
.ehAIaV a:hover{text-decoration:underline;}/*!sc*/
.ehAIaV ul,.ehAIaV ol{margin-bottom:1rem;padding-left:1.5rem;}/*!sc*/
.ehAIaV ul li,.ehAIaV ol li{margin-bottom:0.5rem;color:#64748b;}/*!sc*/
.ehAIaV blockquote{border-left:4px solid #3b82f6;padding-left:1rem;margin:1rem 0;font-style:italic;color:#64748b;background:#f1f5f9;padding:1rem;border-radius:0.5rem;}/*!sc*/
.ehAIaV code{background:#f1f5f9;padding:0.2rem 0.4rem;border-radius:0.25rem;font-family:SFMono-Regular,Consolas,"Liberation Mono",Menlo,monospace;font-size:0.9em;color:#f59e0b;}/*!sc*/
.ehAIaV pre{background:#ffffff;border:1px solid #e2e8f0;border-radius:0.5rem;padding:1rem;margin:1rem 0;overflow-x:auto;}/*!sc*/
.ehAIaV pre code{background:none;padding:0;color:#1e293b;font-size:0.9rem;}/*!sc*/
.ehAIaV table{width:100%;border-collapse:collapse;margin:1rem 0;}/*!sc*/
.ehAIaV table th,.ehAIaV table td{border:1px solid #e2e8f0;padding:0.5rem;text-align:left;}/*!sc*/
.ehAIaV table th{background:#ffffff;font-weight:600;}/*!sc*/
.ehAIaV table tr:nth-child(even){background:#f1f5f9;}/*!sc*/
.ehAIaV hr{border:none;height:1px;background:#e2e8f0;margin:2rem 0;}/*!sc*/
.ehAIaV .highlight{background:#3b82f620;padding:0.2rem 0.4rem;border-radius:0.25rem;font-weight:600;}/*!sc*/
.ehAIaV .hljs{background:#ffffff;color:#1e293b;}/*!sc*/
.ehAIaV .hljs-keyword{color:#3b82f6;font-weight:600;}/*!sc*/
.ehAIaV .hljs-string{color:#10b981;}/*!sc*/
.ehAIaV .hljs-function{color:#f59e0b;}/*!sc*/
.ehAIaV .hljs-comment{color:#94a3b8;font-style:italic;}/*!sc*/
.ehAIaV .hljs-number{color:#f59e0b;}/*!sc*/
.ehAIaV .hljs-variable{color:#1e293b;}/*!sc*/
.ehAIaV .hljs-title{color:#f59e0b;font-weight:600;}/*!sc*/
data-styled.g40[id="sc-jYczwO"]{content:"ehAIaV,"}/*!sc*/
</style></head><body class="__className_6eac61"><div style="min-height:100vh;display:flex;flex-direction:column"><nav class="sc-dNdcvo hNPaTO"><div class="sc-fbQrwq jJxjWc"><a href="/interview"><a class="sc-gGKoUb jwmRwa"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</a></a><div class="sc-hwddKA KQdZw"><a href="/interview/problems"><a class="sc-jaXbil ETszJ">Problems</a></a><a href="/interview/learn"><a class="sc-jaXbil ETszJ">Learn</a></a><a href="/interview/study-guide"><a class="sc-jaXbil ETszJ">Study Guide</a></a><a href="/interview/system-design"><a class="sc-jaXbil ETszJ">System Design</a></a><a href="/interview/performance"><a class="sc-jaXbil ETszJ">Performance</a></a><a href="/interview/accessibility"><a class="sc-jaXbil ETszJ">Accessibility</a></a><a href="/interview/interview-tips"><a class="sc-jaXbil ETszJ">Interview Tips</a></a><button class="sc-eQwNpu kBjfBo"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search "><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.3-4.3"></path></svg>Search</button></div><button class="sc-eqNDNG foClcg"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu "><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button></div></nav><main style="flex:1"><div style="max-width:1200px;margin:0 auto;padding:2rem;padding-top:6rem"><div style="margin-bottom:2rem"><nav style="color:#64748b;font-size:0.9rem;margin-bottom:1rem"><a href="/interview" style="color:#3b82f6;text-decoration:none">Home</a> &gt; <span>src &gt; content &gt; theory &gt; browser-rendering-pipeline-deep-dive</span></nav><h1 style="font-size:2.5rem;font-weight:800;margin-bottom:0.5rem;color:#1e293b">Browser Architecture and Rendering Pipeline Deep Dive</h1><div style="color:#64748b;font-size:0.9rem;margin-bottom:2rem"><span>📁 <!-- -->src/content/theory/browser-rendering-pipeline-deep-dive.md</span></div></div><div class="sc-jYczwO ehAIaV"><h1 id="browser-architecture-and-rendering-pipeline-deep-dive" node="[object Object]">Browser Architecture and Rendering Pipeline Deep Dive</h1>
<h2 id="🎯-overview" node="[object Object]">🎯 Overview</h2>
<p>Understanding browser internals is crucial for frontend interviews at big tech companies. This guide provides deep insights into how browsers work, enabling you to answer performance, debugging, and optimization questions with confidence.</p>
<h2 id="🏗️-browser-architecture-overview" node="[object Object]">🏗️ Browser Architecture Overview</h2>
<h3 id="multi-process-architecture" node="[object Object]">Multi-Process Architecture</h3>
<p>Modern browsers use a multi-process architecture for security, stability, and performance:</p>
<pre><pre><code class="hljs hljs language-mermaid">graph TB
    subgraph &quot;Browser Process&quot;
        A[UI Thread] --&gt; B[Network Thread]
        B --&gt; C[Storage Thread]
        C --&gt; D[Device Thread]
    end
    
    subgraph &quot;Renderer Process&quot;
        E[Main Thread] --&gt; F[Compositor Thread]
        F --&gt; G[Web Workers]
    end
    
    subgraph &quot;GPU Process&quot;
        H[Graphics Operations]
        I[Hardware Acceleration]
    end
    
    subgraph &quot;Plugin Process&quot;
        J[Flash/Extensions]
    end
    
    A -.-&gt; E
    F -.-&gt; H
</code></pre></pre>
<h3 id="process-responsibilities" node="[object Object]">Process Responsibilities</h3>
<h4>1. Browser Process</h4>
<ul>
<li><strong>UI Thread</strong>: Handles browser UI, tabs, address bar</li>
<li><strong>Network Thread</strong>: Manages HTTP requests, downloads</li>
<li><strong>Storage Thread</strong>: File system access, databases</li>
<li><strong>Device Thread</strong>: Camera, microphone access</li>
</ul>
<h4>2. Renderer Process (Site Isolation)</h4>
<ul>
<li><strong>Main Thread</strong>: JavaScript execution, DOM manipulation, layout</li>
<li><strong>Compositor Thread</strong>: Handles scrolling, animations</li>
<li><strong>Web Workers</strong>: Background JavaScript execution</li>
</ul>
<h4>3. GPU Process</h4>
<ul>
<li>Hardware-accelerated graphics</li>
<li>Video decoding</li>
<li>Canvas and WebGL operations</li>
</ul>
<h2 id="🔄-critical-rendering-path" node="[object Object]">🔄 Critical Rendering Path</h2>
<h3 id="1.-navigation-and-resource-loading" node="[object Object]">1. Navigation and Resource Loading</h3>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Performance timing visualization</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">NavigationTiming</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">measureNavigation</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> navigation = performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">&#x27;navigation&#x27;</span>)[<span class="hljs-number">0</span>];
    
    <span class="hljs-keyword">const</span> timing = {
      <span class="hljs-comment">// DNS resolution</span>
      <span class="hljs-attr">dnsTime</span>: navigation.<span class="hljs-property">domainLookupEnd</span> - navigation.<span class="hljs-property">domainLookupStart</span>,
      
      <span class="hljs-comment">// TCP connection</span>
      <span class="hljs-attr">tcpTime</span>: navigation.<span class="hljs-property">connectEnd</span> - navigation.<span class="hljs-property">connectStart</span>,
      
      <span class="hljs-comment">// SSL handshake</span>
      <span class="hljs-attr">sslTime</span>: navigation.<span class="hljs-property">secureConnectionStart</span> &gt; <span class="hljs-number">0</span> 
        ? navigation.<span class="hljs-property">connectEnd</span> - navigation.<span class="hljs-property">secureConnectionStart</span> 
        : <span class="hljs-number">0</span>,
        
      <span class="hljs-comment">// Request/Response</span>
      <span class="hljs-attr">requestTime</span>: navigation.<span class="hljs-property">responseStart</span> - navigation.<span class="hljs-property">requestStart</span>,
      <span class="hljs-attr">responseTime</span>: navigation.<span class="hljs-property">responseEnd</span> - navigation.<span class="hljs-property">responseStart</span>,
      
      <span class="hljs-comment">// DOM processing</span>
      <span class="hljs-attr">domProcessing</span>: navigation.<span class="hljs-property">domContentLoadedEventStart</span> - navigation.<span class="hljs-property">responseEnd</span>,
      
      <span class="hljs-comment">// Resource loading</span>
      <span class="hljs-attr">resourceLoadTime</span>: navigation.<span class="hljs-property">loadEventStart</span> - navigation.<span class="hljs-property">domContentLoadedEventEnd</span>
    };
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">table</span>(timing);
    <span class="hljs-keyword">return</span> timing;
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">visualizeWaterfall</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> resources = performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">&#x27;resource&#x27;</span>);
    
    resources.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">resource</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> waterfall = {
        <span class="hljs-attr">name</span>: resource.<span class="hljs-property">name</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>).<span class="hljs-title function_">pop</span>(),
        <span class="hljs-attr">startTime</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(resource.<span class="hljs-property">startTime</span>),
        <span class="hljs-attr">duration</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">round</span>(resource.<span class="hljs-property">duration</span>),
        <span class="hljs-attr">size</span>: resource.<span class="hljs-property">transferSize</span> || <span class="hljs-string">&#x27;cached&#x27;</span>,
        <span class="hljs-attr">type</span>: resource.<span class="hljs-property">initiatorType</span>
      };
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
        <span class="hljs-string">`<span class="hljs-subst">${waterfall.name.padEnd(<span class="hljs-number">30</span>)}</span> | `</span> +
        <span class="hljs-string">`<span class="hljs-subst">${waterfall.startTime}</span>ms`</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">10</span>) +
        <span class="hljs-string">`<span class="hljs-subst">${waterfall.duration}</span>ms`</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">10</span>) +
        <span class="hljs-string">`<span class="hljs-subst">${waterfall.size}</span>`</span>.<span class="hljs-title function_">padEnd</span>(<span class="hljs-number">15</span>) +
        <span class="hljs-string">`<span class="hljs-subst">${waterfall.type}</span>`</span>
      );
    });
  }
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-title class_">NavigationTiming</span>.<span class="hljs-title function_">measureNavigation</span>();
<span class="hljs-title class_">NavigationTiming</span>.<span class="hljs-title function_">visualizeWaterfall</span>();
</code></pre></pre>
<p>{% endraw %}</p>
<h3 id="2.-html-parsing-and-dom-construction" node="[object Object]">2. HTML Parsing and DOM Construction</h3>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// DOM construction simulation</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">DOMParser</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tokens</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">domTree</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">parseStartTime</span> = <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-comment">// Tokenization phase</span>
  <span class="hljs-title function_">tokenize</span>(<span class="hljs-params">html</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">parseStartTime</span> = performance.<span class="hljs-title function_">now</span>();
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;🔍 Starting HTML tokenization...&#x27;</span>);
    
    <span class="hljs-comment">// Simplified tokenization</span>
    <span class="hljs-keyword">const</span> tokenRegex = <span class="hljs-regexp">/&lt;\/?([a-zA-Z][a-zA-Z0-9]*)\s*([^&gt;]*)&gt;/g</span>;
    <span class="hljs-keyword">let</span> match;
    
    <span class="hljs-keyword">while</span> ((match = tokenRegex.<span class="hljs-title function_">exec</span>(html)) !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">const</span> [fullMatch, tagName, attributes] = match;
      <span class="hljs-keyword">const</span> isClosing = fullMatch.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;&lt;/&#x27;</span>);
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">tokens</span>.<span class="hljs-title function_">push</span>({
        <span class="hljs-attr">type</span>: isClosing ? <span class="hljs-string">&#x27;endTag&#x27;</span> : <span class="hljs-string">&#x27;startTag&#x27;</span>,
        <span class="hljs-attr">tagName</span>: tagName.<span class="hljs-title function_">toLowerCase</span>(),
        <span class="hljs-attr">attributes</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseAttributes</span>(attributes),
        <span class="hljs-attr">position</span>: match.<span class="hljs-property">index</span>
      });
    }
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📝 Tokenized <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.tokens.length}</span> tokens`</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tokens</span>;
  }
  
  <span class="hljs-title function_">parseAttributes</span>(<span class="hljs-params">attrString</span>) {
    <span class="hljs-keyword">const</span> attributes = {};
    <span class="hljs-keyword">const</span> attrRegex = <span class="hljs-regexp">/(\w+)=[&quot;&#x27;]([^&quot;&#x27;]*)[&quot;&#x27;]/g</span>;
    <span class="hljs-keyword">let</span> match;
    
    <span class="hljs-keyword">while</span> ((match = attrRegex.<span class="hljs-title function_">exec</span>(attrString)) !== <span class="hljs-literal">null</span>) {
      attributes[match[<span class="hljs-number">1</span>]] = match[<span class="hljs-number">2</span>];
    }
    
    <span class="hljs-keyword">return</span> attributes;
  }
  
  <span class="hljs-comment">// Tree construction phase</span>
  <span class="hljs-title function_">buildDOM</span>(<span class="hljs-params">tokens</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;🌳 Building DOM tree...&#x27;</span>);
    
    <span class="hljs-keyword">const</span> stack = [];
    <span class="hljs-keyword">const</span> root = { <span class="hljs-attr">tagName</span>: <span class="hljs-string">&#x27;document&#x27;</span>, <span class="hljs-attr">children</span>: [] };
    <span class="hljs-keyword">let</span> current = root;
    
    tokens.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">token</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;startTag&#x27;</span>) {
        <span class="hljs-keyword">const</span> element = {
          <span class="hljs-attr">tagName</span>: token.<span class="hljs-property">tagName</span>,
          <span class="hljs-attr">attributes</span>: token.<span class="hljs-property">attributes</span>,
          <span class="hljs-attr">children</span>: [],
          <span class="hljs-attr">parent</span>: current
        };
        
        current.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(element);
        
        <span class="hljs-comment">// Self-closing tags don&#x27;t need to be pushed to stack</span>
        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isSelfClosing</span>(token.<span class="hljs-property">tagName</span>)) {
          stack.<span class="hljs-title function_">push</span>(current);
          current = element;
        }
        
        <span class="hljs-comment">// Simulate parser blocking for synchronous scripts</span>
        <span class="hljs-keyword">if</span> (token.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;script&#x27;</span> &amp;&amp; !token.<span class="hljs-property">attributes</span>.<span class="hljs-property">async</span> &amp;&amp; !token.<span class="hljs-property">attributes</span>.<span class="hljs-property">defer</span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;⏸️  Parser blocked by synchronous script&#x27;</span>);
          <span class="hljs-comment">// In real browser, parser would wait for script execution</span>
        }
        
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (token.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;endTag&#x27;</span>) {
        <span class="hljs-keyword">if</span> (stack.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
          current = stack.<span class="hljs-title function_">pop</span>();
        }
      }
    });
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">domTree</span> = root;
    <span class="hljs-keyword">const</span> parseTime = performance.<span class="hljs-title function_">now</span>() - <span class="hljs-variable language_">this</span>.<span class="hljs-property">parseStartTime</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✅ DOM construction completed in <span class="hljs-subst">${parseTime.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>);
    
    <span class="hljs-keyword">return</span> root;
  }
  
  <span class="hljs-title function_">isSelfClosing</span>(<span class="hljs-params">tagName</span>) {
    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;img&#x27;</span>, <span class="hljs-string">&#x27;br&#x27;</span>, <span class="hljs-string">&#x27;hr&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;meta&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>].<span class="hljs-title function_">includes</span>(tagName);
  }
  
  <span class="hljs-comment">// DOM tree visualization</span>
  <span class="hljs-title function_">visualizeDOM</span>(<span class="hljs-params">node = <span class="hljs-variable language_">this</span>.domTree, depth = <span class="hljs-number">0</span></span>) {
    <span class="hljs-keyword">const</span> indent = <span class="hljs-string">&#x27;  &#x27;</span>.<span class="hljs-title function_">repeat</span>(depth);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${indent}</span><span class="hljs-subst">${node.tagName}</span>`</span>);
    
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">children</span>) {
      node.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">visualizeDOM</span>(child, depth + <span class="hljs-number">1</span>));
    }
  }
}
</code></pre></pre>
<p>{% endraw %}</p>
<h3 id="3.-css-parsing-and-cssom-construction" node="[object Object]">3. CSS Parsing and CSSOM Construction</h3>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// CSSOM construction simulation</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CSSOMBuilder</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stylesheets</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cssom</span> = <span class="hljs-literal">null</span>;
  }
  
  <span class="hljs-title function_">parseCSS</span>(<span class="hljs-params">cssText, source = <span class="hljs-string">&#x27;inline&#x27;</span></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🎨 Parsing CSS from <span class="hljs-subst">${source}</span>...`</span>);
    
    <span class="hljs-keyword">const</span> rules = [];
    <span class="hljs-keyword">const</span> ruleRegex = <span class="hljs-regexp">/([^{]+)\s*\{([^}]+)\}/g</span>;
    <span class="hljs-keyword">let</span> match;
    
    <span class="hljs-keyword">while</span> ((match = ruleRegex.<span class="hljs-title function_">exec</span>(cssText)) !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">const</span> [, selector, declarations] = match;
      
      <span class="hljs-keyword">const</span> rule = {
        <span class="hljs-attr">selector</span>: selector.<span class="hljs-title function_">trim</span>(),
        <span class="hljs-attr">declarations</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseDeclarations</span>(declarations),
        <span class="hljs-attr">specificity</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateSpecificity</span>(selector.<span class="hljs-title function_">trim</span>()),
        source
      };
      
      rules.<span class="hljs-title function_">push</span>(rule);
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stylesheets</span>.<span class="hljs-title function_">push</span>({ source, rules });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📄 Parsed <span class="hljs-subst">${rules.length}</span> CSS rules`</span>);
    
    <span class="hljs-keyword">return</span> rules;
  }
  
  <span class="hljs-title function_">parseDeclarations</span>(<span class="hljs-params">declarationsText</span>) {
    <span class="hljs-keyword">const</span> declarations = {};
    <span class="hljs-keyword">const</span> declRegex = <span class="hljs-regexp">/([^:]+):\s*([^;]+)/g</span>;
    <span class="hljs-keyword">let</span> match;
    
    <span class="hljs-keyword">while</span> ((match = declRegex.<span class="hljs-title function_">exec</span>(declarationsText)) !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">const</span> property = match[<span class="hljs-number">1</span>].<span class="hljs-title function_">trim</span>();
      <span class="hljs-keyword">const</span> value = match[<span class="hljs-number">2</span>].<span class="hljs-title function_">trim</span>();
      declarations[property] = value;
    }
    
    <span class="hljs-keyword">return</span> declarations;
  }
  
  <span class="hljs-title function_">calculateSpecificity</span>(<span class="hljs-params">selector</span>) {
    <span class="hljs-comment">// Simplified specificity calculation</span>
    <span class="hljs-keyword">const</span> ids = (selector.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/#/g</span>) || []).<span class="hljs-property">length</span>;
    <span class="hljs-keyword">const</span> classes = (selector.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\./g</span>) || []).<span class="hljs-property">length</span>;
    <span class="hljs-keyword">const</span> elements = (selector.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\b[a-z]+\b/g</span>) || []).<span class="hljs-property">length</span>;
    
    <span class="hljs-keyword">return</span> ids * <span class="hljs-number">100</span> + classes * <span class="hljs-number">10</span> + elements;
  }
  
  buildCSSOМ() {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;🏗️  Building CSSOM...&#x27;</span>);
    
    <span class="hljs-comment">// Combine all stylesheets and sort by specificity</span>
    <span class="hljs-keyword">const</span> allRules = [];
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stylesheets</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">stylesheet</span> =&gt;</span> {
      allRules.<span class="hljs-title function_">push</span>(...stylesheet.<span class="hljs-property">rules</span>);
    });
    
    <span class="hljs-comment">// Sort by specificity (higher specificity first)</span>
    allRules.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> b.<span class="hljs-property">specificity</span> - a.<span class="hljs-property">specificity</span>);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cssom</span> = {
      <span class="hljs-attr">rules</span>: allRules,
      <span class="hljs-attr">computedStyles</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>() <span class="hljs-comment">// Will store computed styles for elements</span>
    };
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✅ CSSOM built with <span class="hljs-subst">${allRules.length}</span> rules`</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">cssom</span>;
  }
  
  <span class="hljs-comment">// Simulate style computation</span>
  <span class="hljs-title function_">computeStyles</span>(<span class="hljs-params">element, domTree</span>) {
    <span class="hljs-keyword">const</span> computedStyle = {};
    
    <span class="hljs-comment">// Apply matching rules</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cssom</span>.<span class="hljs-property">rules</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">rule</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">matchesSelector</span>(element, rule.<span class="hljs-property">selector</span>, domTree)) {
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(computedStyle, rule.<span class="hljs-property">declarations</span>);
      }
    });
    
    <span class="hljs-comment">// Apply inheritance</span>
    <span class="hljs-keyword">if</span> (element.<span class="hljs-property">parent</span> &amp;&amp; element.<span class="hljs-property">parent</span> !== domTree) {
      <span class="hljs-keyword">const</span> parentStyle = <span class="hljs-variable language_">this</span>.<span class="hljs-property">cssom</span>.<span class="hljs-property">computedStyles</span>.<span class="hljs-title function_">get</span>(element.<span class="hljs-property">parent</span>) || {};
      <span class="hljs-keyword">const</span> inheritableProperties = [<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-string">&#x27;font-family&#x27;</span>, <span class="hljs-string">&#x27;font-size&#x27;</span>, <span class="hljs-string">&#x27;line-height&#x27;</span>];
      
      inheritableProperties.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">prop</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (parentStyle[prop] &amp;&amp; !computedStyle[prop]) {
          computedStyle[prop] = parentStyle[prop];
        }
      });
    }
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cssom</span>.<span class="hljs-property">computedStyles</span>.<span class="hljs-title function_">set</span>(element, computedStyle);
    <span class="hljs-keyword">return</span> computedStyle;
  }
  
  <span class="hljs-title function_">matchesSelector</span>(<span class="hljs-params">element, selector, domTree</span>) {
    <span class="hljs-comment">// Simplified selector matching</span>
    <span class="hljs-keyword">if</span> (selector.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;#&#x27;</span>)) {
      <span class="hljs-keyword">return</span> element.<span class="hljs-property">attributes</span>.<span class="hljs-property">id</span> === selector.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);
    }
    
    <span class="hljs-keyword">if</span> (selector.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;.&#x27;</span>)) {
      <span class="hljs-keyword">const</span> classes = element.<span class="hljs-property">attributes</span>.<span class="hljs-property">class</span> || <span class="hljs-string">&#x27;&#x27;</span>;
      <span class="hljs-keyword">return</span> classes.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-title function_">includes</span>(selector.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>));
    }
    
    <span class="hljs-keyword">return</span> element.<span class="hljs-property">tagName</span> === selector;
  }
}
</code></pre></pre>
<p>{% endraw %}</p>
<h3 id="4.-layout-(reflow)-engine" node="[object Object]">4. Layout (Reflow) Engine</h3>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Layout engine simulation</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LayoutEngine</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">layoutTree</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">viewport</span> = { <span class="hljs-attr">width</span>: <span class="hljs-number">1024</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">768</span> };
  }
  
  <span class="hljs-title function_">createLayoutTree</span>(<span class="hljs-params">domTree, cssom</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;📐 Starting layout phase...&#x27;</span>);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">layoutTree</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">buildLayoutTree</span>(domTree, cssom);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateLayout</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">layoutTree</span>);
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;✅ Layout phase completed&#x27;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">layoutTree</span>;
  }
  
  <span class="hljs-title function_">buildLayoutTree</span>(<span class="hljs-params">domNode, cssom, parentLayoutNode = <span class="hljs-literal">null</span></span>) {
    <span class="hljs-comment">// Skip text nodes and elements with display: none</span>
    <span class="hljs-keyword">const</span> computedStyle = cssom.<span class="hljs-property">computedStyles</span>.<span class="hljs-title function_">get</span>(domNode) || {};
    
    <span class="hljs-keyword">if</span> (computedStyle.<span class="hljs-property">display</span> === <span class="hljs-string">&#x27;none&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    
    <span class="hljs-keyword">const</span> layoutNode = {
      domNode,
      computedStyle,
      <span class="hljs-attr">children</span>: [],
      <span class="hljs-attr">parent</span>: parentLayoutNode,
      <span class="hljs-attr">box</span>: {
        <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">width</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">height</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">marginTop</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">marginRight</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">marginBottom</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">marginLeft</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">paddingTop</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">paddingRight</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">paddingBottom</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">paddingLeft</span>: <span class="hljs-number">0</span>
      }
    };
    
    <span class="hljs-comment">// Process children</span>
    <span class="hljs-keyword">if</span> (domNode.<span class="hljs-property">children</span>) {
      domNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> childLayoutNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">buildLayoutTree</span>(child, cssom, layoutNode);
        <span class="hljs-keyword">if</span> (childLayoutNode) {
          layoutNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(childLayoutNode);
        }
      });
    }
    
    <span class="hljs-keyword">return</span> layoutNode;
  }
  
  <span class="hljs-title function_">calculateLayout</span>(<span class="hljs-params">layoutNode, containerWidth = <span class="hljs-variable language_">this</span>.viewport.width</span>) {
    <span class="hljs-keyword">if</span> (!layoutNode) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-keyword">const</span> style = layoutNode.<span class="hljs-property">computedStyle</span>;
    
    <span class="hljs-comment">// Calculate box model</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateBoxModel</span>(layoutNode, style);
    
    <span class="hljs-comment">// Calculate position and size based on display type</span>
    <span class="hljs-keyword">switch</span> (style.<span class="hljs-property">display</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;block&#x27;</span>:
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">layoutBlock</span>(layoutNode, containerWidth);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;inline&#x27;</span>:
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">layoutInline</span>(layoutNode, containerWidth);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;flex&#x27;</span>:
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">layoutFlex</span>(layoutNode, containerWidth);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;grid&#x27;</span>:
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">layoutGrid</span>(layoutNode, containerWidth);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-attr">default</span>:
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">layoutBlock</span>(layoutNode, containerWidth);
    }
    
    <span class="hljs-comment">// Layout children</span>
    layoutNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateLayout</span>(child, layoutNode.<span class="hljs-property">box</span>.<span class="hljs-property">width</span>);
    });
  }
  
  <span class="hljs-title function_">calculateBoxModel</span>(<span class="hljs-params">layoutNode, style</span>) {
    <span class="hljs-keyword">const</span> box = layoutNode.<span class="hljs-property">box</span>;
    
    <span class="hljs-comment">// Parse CSS values (simplified)</span>
    box.<span class="hljs-property">marginTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(style.<span class="hljs-property">marginTop</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
    box.<span class="hljs-property">marginRight</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(style.<span class="hljs-property">marginRight</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
    box.<span class="hljs-property">marginBottom</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(style.<span class="hljs-property">marginBottom</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
    box.<span class="hljs-property">marginLeft</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(style.<span class="hljs-property">marginLeft</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
    
    box.<span class="hljs-property">paddingTop</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(style.<span class="hljs-property">paddingTop</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
    box.<span class="hljs-property">paddingRight</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(style.<span class="hljs-property">paddingRight</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
    box.<span class="hljs-property">paddingBottom</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(style.<span class="hljs-property">paddingBottom</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
    box.<span class="hljs-property">paddingLeft</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(style.<span class="hljs-property">paddingLeft</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
  }
  
  <span class="hljs-title function_">parseValue</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-comment">// Simplified CSS value parsing</span>
    <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;px&#x27;</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(value);
    }
    <span class="hljs-keyword">if</span> (value.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;%&#x27;</span>)) {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;percentage&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">parseInt</span>(value) };
    }
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(value) || <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-title function_">layoutBlock</span>(<span class="hljs-params">layoutNode, containerWidth</span>) {
    <span class="hljs-keyword">const</span> box = layoutNode.<span class="hljs-property">box</span>;
    <span class="hljs-keyword">const</span> style = layoutNode.<span class="hljs-property">computedStyle</span>;
    
    <span class="hljs-comment">// Block elements take full width by default</span>
    box.<span class="hljs-property">width</span> = containerWidth - box.<span class="hljs-property">marginLeft</span> - box.<span class="hljs-property">marginRight</span>;
    
    <span class="hljs-comment">// Calculate height based on content</span>
    <span class="hljs-keyword">let</span> contentHeight = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> currentY = box.<span class="hljs-property">paddingTop</span>;
    
    layoutNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
      child.<span class="hljs-property">box</span>.<span class="hljs-property">x</span> = box.<span class="hljs-property">paddingLeft</span>;
      child.<span class="hljs-property">box</span>.<span class="hljs-property">y</span> = currentY;
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateLayout</span>(child, box.<span class="hljs-property">width</span> - box.<span class="hljs-property">paddingLeft</span> - box.<span class="hljs-property">paddingRight</span>);
      
      currentY += child.<span class="hljs-property">box</span>.<span class="hljs-property">height</span> + child.<span class="hljs-property">box</span>.<span class="hljs-property">marginTop</span> + child.<span class="hljs-property">box</span>.<span class="hljs-property">marginBottom</span>;
      contentHeight = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(contentHeight, currentY);
    });
    
    box.<span class="hljs-property">height</span> = contentHeight + box.<span class="hljs-property">paddingBottom</span>;
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📦 Block layout: <span class="hljs-subst">${layoutNode.domNode.tagName}</span> (<span class="hljs-subst">${box.width}</span>x<span class="hljs-subst">${box.height}</span>)`</span>);
  }
  
  <span class="hljs-title function_">layoutFlex</span>(<span class="hljs-params">layoutNode, containerWidth</span>) {
    <span class="hljs-keyword">const</span> box = layoutNode.<span class="hljs-property">box</span>;
    <span class="hljs-keyword">const</span> style = layoutNode.<span class="hljs-property">computedStyle</span>;
    
    box.<span class="hljs-property">width</span> = containerWidth - box.<span class="hljs-property">marginLeft</span> - box.<span class="hljs-property">marginRight</span>;
    
    <span class="hljs-keyword">const</span> flexDirection = style.<span class="hljs-property">flexDirection</span> || <span class="hljs-string">&#x27;row&#x27;</span>;
    <span class="hljs-keyword">const</span> justifyContent = style.<span class="hljs-property">justifyContent</span> || <span class="hljs-string">&#x27;flex-start&#x27;</span>;
    <span class="hljs-keyword">const</span> alignItems = style.<span class="hljs-property">alignItems</span> || <span class="hljs-string">&#x27;stretch&#x27;</span>;
    
    <span class="hljs-keyword">if</span> (flexDirection === <span class="hljs-string">&#x27;row&#x27;</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">layoutFlexRow</span>(layoutNode, justifyContent, alignItems);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">layoutFlexColumn</span>(layoutNode, justifyContent, alignItems);
    }
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🔧 Flex layout: <span class="hljs-subst">${layoutNode.domNode.tagName}</span> (<span class="hljs-subst">${box.width}</span>x<span class="hljs-subst">${box.height}</span>)`</span>);
  }
  
  <span class="hljs-title function_">layoutFlexRow</span>(<span class="hljs-params">layoutNode, justifyContent, alignItems</span>) {
    <span class="hljs-keyword">const</span> availableWidth = layoutNode.<span class="hljs-property">box</span>.<span class="hljs-property">width</span> - layoutNode.<span class="hljs-property">box</span>.<span class="hljs-property">paddingLeft</span> - layoutNode.<span class="hljs-property">box</span>.<span class="hljs-property">paddingRight</span>;
    <span class="hljs-keyword">const</span> children = layoutNode.<span class="hljs-property">children</span>;
    
    <span class="hljs-comment">// Calculate flex basis and grow</span>
    <span class="hljs-keyword">let</span> totalFlexBasis = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> totalFlexGrow = <span class="hljs-number">0</span>;
    
    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> flexBasis = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(child.<span class="hljs-property">computedStyle</span>.<span class="hljs-property">flexBasis</span> || <span class="hljs-string">&#x27;auto&#x27;</span>);
      <span class="hljs-keyword">const</span> flexGrow = <span class="hljs-built_in">parseInt</span>(child.<span class="hljs-property">computedStyle</span>.<span class="hljs-property">flexGrow</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
      
      child.<span class="hljs-property">flexBasis</span> = flexBasis === <span class="hljs-string">&#x27;auto&#x27;</span> ? <span class="hljs-number">0</span> : flexBasis;
      child.<span class="hljs-property">flexGrow</span> = flexGrow;
      
      totalFlexBasis += child.<span class="hljs-property">flexBasis</span>;
      totalFlexGrow += flexGrow;
    });
    
    <span class="hljs-comment">// Distribute remaining space</span>
    <span class="hljs-keyword">const</span> remainingSpace = availableWidth - totalFlexBasis;
    <span class="hljs-keyword">const</span> spacePerGrow = totalFlexGrow &gt; <span class="hljs-number">0</span> ? remainingSpace / totalFlexGrow : <span class="hljs-number">0</span>;
    
    <span class="hljs-keyword">let</span> currentX = layoutNode.<span class="hljs-property">box</span>.<span class="hljs-property">paddingLeft</span>;
    <span class="hljs-keyword">let</span> maxHeight = <span class="hljs-number">0</span>;
    
    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
      child.<span class="hljs-property">box</span>.<span class="hljs-property">x</span> = currentX;
      child.<span class="hljs-property">box</span>.<span class="hljs-property">y</span> = layoutNode.<span class="hljs-property">box</span>.<span class="hljs-property">paddingTop</span>;
      child.<span class="hljs-property">box</span>.<span class="hljs-property">width</span> = child.<span class="hljs-property">flexBasis</span> + (child.<span class="hljs-property">flexGrow</span> * spacePerGrow);
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateLayout</span>(child, child.<span class="hljs-property">box</span>.<span class="hljs-property">width</span>);
      
      currentX += child.<span class="hljs-property">box</span>.<span class="hljs-property">width</span>;
      maxHeight = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxHeight, child.<span class="hljs-property">box</span>.<span class="hljs-property">height</span>);
    });
    
    layoutNode.<span class="hljs-property">box</span>.<span class="hljs-property">height</span> = maxHeight + layoutNode.<span class="hljs-property">box</span>.<span class="hljs-property">paddingTop</span> + layoutNode.<span class="hljs-property">box</span>.<span class="hljs-property">paddingBottom</span>;
  }
  
  <span class="hljs-title function_">layoutGrid</span>(<span class="hljs-params">layoutNode, containerWidth</span>) {
    <span class="hljs-comment">// Simplified CSS Grid implementation</span>
    <span class="hljs-keyword">const</span> box = layoutNode.<span class="hljs-property">box</span>;
    <span class="hljs-keyword">const</span> style = layoutNode.<span class="hljs-property">computedStyle</span>;
    
    box.<span class="hljs-property">width</span> = containerWidth - box.<span class="hljs-property">marginLeft</span> - box.<span class="hljs-property">marginRight</span>;
    
    <span class="hljs-keyword">const</span> gridTemplateColumns = style.<span class="hljs-property">gridTemplateColumns</span> || <span class="hljs-string">&#x27;1fr&#x27;</span>;
    <span class="hljs-keyword">const</span> gridTemplateRows = style.<span class="hljs-property">gridTemplateRows</span> || <span class="hljs-string">&#x27;auto&#x27;</span>;
    <span class="hljs-keyword">const</span> gap = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(style.<span class="hljs-property">gap</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
    
    <span class="hljs-comment">// Parse grid template</span>
    <span class="hljs-keyword">const</span> columns = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseGridTemplate</span>(gridTemplateColumns, box.<span class="hljs-property">width</span>);
    <span class="hljs-keyword">const</span> rows = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseGridTemplate</span>(gridTemplateRows, <span class="hljs-number">0</span>); <span class="hljs-comment">// Will be calculated</span>
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📊 Grid layout: <span class="hljs-subst">${columns.length}</span> columns, <span class="hljs-subst">${rows.length}</span> rows`</span>);
    
    <span class="hljs-comment">// Position grid items</span>
    <span class="hljs-keyword">let</span> currentRow = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> currentCol = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> maxRowHeight = <span class="hljs-number">0</span>;
    
    layoutNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child, index</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (currentCol &gt;= columns.<span class="hljs-property">length</span>) {
        currentCol = <span class="hljs-number">0</span>;
        currentRow++;
        <span class="hljs-keyword">if</span> (currentRow &gt;= rows.<span class="hljs-property">length</span>) {
          rows.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">size</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;auto&#x27;</span> });
        }
      }
      
      child.<span class="hljs-property">box</span>.<span class="hljs-property">x</span> = columns.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, currentCol).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, col</span>) =&gt;</span> sum + col.<span class="hljs-property">size</span>, <span class="hljs-number">0</span>) + (currentCol * gap);
      child.<span class="hljs-property">box</span>.<span class="hljs-property">y</span> = rows.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, currentRow).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, row</span>) =&gt;</span> sum + row.<span class="hljs-property">size</span>, <span class="hljs-number">0</span>) + (currentRow * gap);
      child.<span class="hljs-property">box</span>.<span class="hljs-property">width</span> = columns[currentCol].<span class="hljs-property">size</span>;
      
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateLayout</span>(child, child.<span class="hljs-property">box</span>.<span class="hljs-property">width</span>);
      
      maxRowHeight = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(maxRowHeight, child.<span class="hljs-property">box</span>.<span class="hljs-property">height</span>);
      
      currentCol++;
      
      <span class="hljs-comment">// Update row height for auto rows</span>
      <span class="hljs-keyword">if</span> (rows[currentRow] &amp;&amp; rows[currentRow].<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;auto&#x27;</span>) {
        rows[currentRow].<span class="hljs-property">size</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(rows[currentRow].<span class="hljs-property">size</span>, child.<span class="hljs-property">box</span>.<span class="hljs-property">height</span>);
      }
    });
    
    <span class="hljs-keyword">const</span> totalHeight = rows.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, row</span>) =&gt;</span> sum + row.<span class="hljs-property">size</span>, <span class="hljs-number">0</span>) + ((rows.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) * gap);
    box.<span class="hljs-property">height</span> = totalHeight + box.<span class="hljs-property">paddingTop</span> + box.<span class="hljs-property">paddingBottom</span>;
  }
  
  <span class="hljs-title function_">parseGridTemplate</span>(<span class="hljs-params">template, containerSize</span>) {
    <span class="hljs-keyword">const</span> tracks = template.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);
    <span class="hljs-keyword">const</span> result = [];
    
    tracks.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">track</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (track.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;fr&#x27;</span>)) {
        <span class="hljs-keyword">const</span> fraction = <span class="hljs-built_in">parseFloat</span>(track);
        result.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">size</span>: (containerSize / tracks.<span class="hljs-property">length</span>) * fraction, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;fr&#x27;</span>, fraction });
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (track.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&#x27;px&#x27;</span>)) {
        result.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">size</span>: <span class="hljs-built_in">parseInt</span>(track), <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;px&#x27;</span> });
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (track === <span class="hljs-string">&#x27;auto&#x27;</span>) {
        result.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">size</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;auto&#x27;</span> });
      } <span class="hljs-keyword">else</span> {
        result.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">size</span>: containerSize / tracks.<span class="hljs-property">length</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;default&#x27;</span> });
      }
    });
    
    <span class="hljs-keyword">return</span> result;
  }
  
  <span class="hljs-comment">// Performance monitoring</span>
  <span class="hljs-title function_">measureLayoutPerformance</span>(<span class="hljs-params">domTree, cssom</span>) {
    <span class="hljs-keyword">const</span> startTime = performance.<span class="hljs-title function_">now</span>();
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;⏱️  Starting layout performance measurement...&#x27;</span>);
    
    <span class="hljs-comment">// Simulate forced layout</span>
    <span class="hljs-keyword">const</span> layoutTree = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createLayoutTree</span>(domTree, cssom);
    
    <span class="hljs-keyword">const</span> endTime = performance.<span class="hljs-title function_">now</span>();
    <span class="hljs-keyword">const</span> layoutTime = endTime - startTime;
    
    <span class="hljs-keyword">const</span> stats = {
      <span class="hljs-attr">layoutTime</span>: <span class="hljs-string">`<span class="hljs-subst">${layoutTime.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>,
      <span class="hljs-attr">nodesProcessed</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">countNodes</span>(layoutTree),
      <span class="hljs-attr">averageTimePerNode</span>: <span class="hljs-string">`<span class="hljs-subst">${(layoutTime / <span class="hljs-variable language_">this</span>.countNodes(layoutTree)).toFixed(<span class="hljs-number">4</span>)}</span>ms`</span>
    };
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">table</span>(stats);
    
    <span class="hljs-comment">// Detect layout thrashing</span>
    <span class="hljs-keyword">if</span> (layoutTime &gt; <span class="hljs-number">16</span>) { <span class="hljs-comment">// More than one frame</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`⚠️  Layout took <span class="hljs-subst">${layoutTime.toFixed(<span class="hljs-number">2</span>)}</span>ms, may cause jank!`</span>);
    }
    
    <span class="hljs-keyword">return</span> stats;
  }
  
  <span class="hljs-title function_">countNodes</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">if</span> (!node) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + node.<span class="hljs-property">children</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">count, child</span>) =&gt;</span> count + <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">countNodes</span>(child), <span class="hljs-number">0</span>);
  }
}
</code></pre></pre>
<p>{% endraw %}</p>
<h3 id="5.-paint-and-composite" node="[object Object]">5. Paint and Composite</h3>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Paint and composite simulation</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PaintCompositeEngine</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">paintTree</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">layers</span> = [];
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">paintTime</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compositeTime</span> = <span class="hljs-number">0</span>;
  }
  
  <span class="hljs-title function_">createPaintTree</span>(<span class="hljs-params">layoutTree</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;🎨 Starting paint phase...&#x27;</span>);
    <span class="hljs-keyword">const</span> startTime = performance.<span class="hljs-title function_">now</span>();
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">paintTree</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">buildPaintTree</span>(layoutTree);
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">createCompositingLayers</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">paintTree</span>);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">paintTime</span> = performance.<span class="hljs-title function_">now</span>() - startTime;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✅ Paint phase completed in <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.paintTime.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>);
    
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">paintTree</span>;
  }
  
  <span class="hljs-title function_">buildPaintTree</span>(<span class="hljs-params">layoutNode, parentPaintNode = <span class="hljs-literal">null</span></span>) {
    <span class="hljs-keyword">if</span> (!layoutNode) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    
    <span class="hljs-keyword">const</span> paintNode = {
      layoutNode,
      <span class="hljs-attr">paintProperties</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">extractPaintProperties</span>(layoutNode.<span class="hljs-property">computedStyle</span>),
      <span class="hljs-attr">children</span>: [],
      <span class="hljs-attr">parent</span>: parentPaintNode,
      <span class="hljs-attr">needsNewLayer</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">shouldCreateNewLayer</span>(layoutNode),
      <span class="hljs-attr">layerId</span>: <span class="hljs-literal">null</span>
    };
    
    <span class="hljs-comment">// Process children</span>
    layoutNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> childPaintNode = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">buildPaintTree</span>(child, paintNode);
      <span class="hljs-keyword">if</span> (childPaintNode) {
        paintNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(childPaintNode);
      }
    });
    
    <span class="hljs-keyword">return</span> paintNode;
  }
  
  <span class="hljs-title function_">extractPaintProperties</span>(<span class="hljs-params">style</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">backgroundColor</span>: style.<span class="hljs-property">backgroundColor</span> || <span class="hljs-string">&#x27;transparent&#x27;</span>,
      <span class="hljs-attr">color</span>: style.<span class="hljs-property">color</span> || <span class="hljs-string">&#x27;black&#x27;</span>,
      <span class="hljs-attr">border</span>: {
        <span class="hljs-attr">width</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(style.<span class="hljs-property">borderWidth</span> || <span class="hljs-string">&#x27;0&#x27;</span>),
        <span class="hljs-attr">color</span>: style.<span class="hljs-property">borderColor</span> || <span class="hljs-string">&#x27;black&#x27;</span>,
        <span class="hljs-attr">style</span>: style.<span class="hljs-property">borderStyle</span> || <span class="hljs-string">&#x27;solid&#x27;</span>
      },
      <span class="hljs-attr">borderRadius</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">parseValue</span>(style.<span class="hljs-property">borderRadius</span> || <span class="hljs-string">&#x27;0&#x27;</span>),
      <span class="hljs-attr">boxShadow</span>: style.<span class="hljs-property">boxShadow</span> || <span class="hljs-string">&#x27;none&#x27;</span>,
      <span class="hljs-attr">opacity</span>: <span class="hljs-built_in">parseFloat</span>(style.<span class="hljs-property">opacity</span> || <span class="hljs-string">&#x27;1&#x27;</span>),
      <span class="hljs-attr">transform</span>: style.<span class="hljs-property">transform</span> || <span class="hljs-string">&#x27;none&#x27;</span>,
      <span class="hljs-attr">filter</span>: style.<span class="hljs-property">filter</span> || <span class="hljs-string">&#x27;none&#x27;</span>
    };
  }
  
  <span class="hljs-title function_">shouldCreateNewLayer</span>(<span class="hljs-params">layoutNode</span>) {
    <span class="hljs-keyword">const</span> style = layoutNode.<span class="hljs-property">computedStyle</span>;
    
    <span class="hljs-comment">// Conditions that create new compositing layers</span>
    <span class="hljs-keyword">return</span> (
      style.<span class="hljs-property">position</span> === <span class="hljs-string">&#x27;fixed&#x27;</span> ||
      style.<span class="hljs-property">position</span> === <span class="hljs-string">&#x27;sticky&#x27;</span> ||
      <span class="hljs-built_in">parseFloat</span>(style.<span class="hljs-property">opacity</span> || <span class="hljs-string">&#x27;1&#x27;</span>) &lt; <span class="hljs-number">1</span> ||
      style.<span class="hljs-property">transform</span> !== <span class="hljs-string">&#x27;none&#x27;</span> ||
      style.<span class="hljs-property">filter</span> !== <span class="hljs-string">&#x27;none&#x27;</span> ||
      style.<span class="hljs-property">zIndex</span> !== <span class="hljs-string">&#x27;auto&#x27;</span> ||
      style.<span class="hljs-property">willChange</span> === <span class="hljs-string">&#x27;transform&#x27;</span> ||
      style.<span class="hljs-property">willChange</span> === <span class="hljs-string">&#x27;opacity&#x27;</span> ||
      layoutNode.<span class="hljs-property">domNode</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;video&#x27;</span> ||
      layoutNode.<span class="hljs-property">domNode</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;canvas&#x27;</span>
    );
  }
  
  <span class="hljs-title function_">createCompositingLayers</span>(<span class="hljs-params">paintTree</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;🔗 Creating compositing layers...&#x27;</span>);
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">layers</span> = [];
    <span class="hljs-keyword">let</span> layerId = <span class="hljs-number">0</span>;
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">traversePaintTree</span>(paintTree, <span class="hljs-function">(<span class="hljs-params">paintNode</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (paintNode.<span class="hljs-property">needsNewLayer</span> || !paintNode.<span class="hljs-property">parent</span>) {
        <span class="hljs-keyword">const</span> layer = {
          <span class="hljs-attr">id</span>: layerId++,
          paintNode,
          <span class="hljs-attr">elements</span>: [],
          <span class="hljs-attr">bounds</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculateLayerBounds</span>(paintNode),
          <span class="hljs-attr">needsRepaint</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">isGPULayer</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">shouldUseGPU</span>(paintNode)
        };
        
        paintNode.<span class="hljs-property">layerId</span> = layer.<span class="hljs-property">id</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">layers</span>.<span class="hljs-title function_">push</span>(layer);
        
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📋 Created layer <span class="hljs-subst">${layer.id}</span> for <span class="hljs-subst">${paintNode.layoutNode.domNode.tagName}</span><span class="hljs-subst">${layer.isGPULayer ? <span class="hljs-string">&#x27; (GPU)&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>}</span>`</span>);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Inherit parent&#x27;s layer</span>
        paintNode.<span class="hljs-property">layerId</span> = paintNode.<span class="hljs-property">parent</span>.<span class="hljs-property">layerId</span>;
      }
    });
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✅ Created <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.layers.length}</span> compositing layers`</span>);
  }
  
  <span class="hljs-title function_">shouldUseGPU</span>(<span class="hljs-params">paintNode</span>) {
    <span class="hljs-keyword">const</span> style = paintNode.<span class="hljs-property">layoutNode</span>.<span class="hljs-property">computedStyle</span>;
    
    <span class="hljs-keyword">return</span> (
      style.<span class="hljs-property">transform</span> !== <span class="hljs-string">&#x27;none&#x27;</span> ||
      style.<span class="hljs-property">opacity</span> !== <span class="hljs-string">&#x27;1&#x27;</span> ||
      style.<span class="hljs-property">filter</span> !== <span class="hljs-string">&#x27;none&#x27;</span> ||
      paintNode.<span class="hljs-property">layoutNode</span>.<span class="hljs-property">domNode</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;video&#x27;</span> ||
      paintNode.<span class="hljs-property">layoutNode</span>.<span class="hljs-property">domNode</span>.<span class="hljs-property">tagName</span> === <span class="hljs-string">&#x27;canvas&#x27;</span> ||
      style.<span class="hljs-property">willChange</span> === <span class="hljs-string">&#x27;transform&#x27;</span> ||
      style.<span class="hljs-property">willChange</span> === <span class="hljs-string">&#x27;opacity&#x27;</span>
    );
  }
  
  <span class="hljs-title function_">calculateLayerBounds</span>(<span class="hljs-params">paintNode</span>) {
    <span class="hljs-keyword">const</span> box = paintNode.<span class="hljs-property">layoutNode</span>.<span class="hljs-property">box</span>;
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">x</span>: box.<span class="hljs-property">x</span>,
      <span class="hljs-attr">y</span>: box.<span class="hljs-property">y</span>,
      <span class="hljs-attr">width</span>: box.<span class="hljs-property">width</span>,
      <span class="hljs-attr">height</span>: box.<span class="hljs-property">height</span>
    };
  }
  
  <span class="hljs-title function_">traversePaintTree</span>(<span class="hljs-params">paintNode, callback</span>) {
    <span class="hljs-keyword">if</span> (!paintNode) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-title function_">callback</span>(paintNode);
    paintNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">traversePaintTree</span>(child, callback);
    });
  }
  
  <span class="hljs-comment">// Simulate painting process</span>
  <span class="hljs-title function_">paintLayers</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;🖌️  Starting paint process...&#x27;</span>);
    <span class="hljs-keyword">const</span> startTime = performance.<span class="hljs-title function_">now</span>();
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">layers</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">layer</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (layer.<span class="hljs-property">needsRepaint</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">paintLayer</span>(layer);
        layer.<span class="hljs-property">needsRepaint</span> = <span class="hljs-literal">false</span>;
      }
    });
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">paintTime</span> = performance.<span class="hljs-title function_">now</span>() - startTime;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🎨 Painted <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.layers.length}</span> layers in <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.paintTime.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>);
  }
  
  <span class="hljs-title function_">paintLayer</span>(<span class="hljs-params">layer</span>) {
    <span class="hljs-keyword">const</span> paintOps = [];
    
    <span class="hljs-comment">// Collect paint operations for this layer</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">collectPaintOperations</span>(layer.<span class="hljs-property">paintNode</span>, paintOps);
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🖼️  Layer <span class="hljs-subst">${layer.id}</span>: <span class="hljs-subst">${paintOps.length}</span> paint operations`</span>);
    
    <span class="hljs-comment">// Simulate paint operations</span>
    paintOps.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">op</span> =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">executePaintOperation</span>(op);
    });
    
    layer.<span class="hljs-property">paintOperations</span> = paintOps;
  }
  
  <span class="hljs-title function_">collectPaintOperations</span>(<span class="hljs-params">paintNode, operations</span>) {
    <span class="hljs-keyword">if</span> (!paintNode) <span class="hljs-keyword">return</span>;
    
    <span class="hljs-keyword">const</span> box = paintNode.<span class="hljs-property">layoutNode</span>.<span class="hljs-property">box</span>;
    <span class="hljs-keyword">const</span> props = paintNode.<span class="hljs-property">paintProperties</span>;
    
    <span class="hljs-comment">// Background</span>
    <span class="hljs-keyword">if</span> (props.<span class="hljs-property">backgroundColor</span> !== <span class="hljs-string">&#x27;transparent&#x27;</span>) {
      operations.<span class="hljs-title function_">push</span>({
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;fillRect&#x27;</span>,
        <span class="hljs-attr">x</span>: box.<span class="hljs-property">x</span>,
        <span class="hljs-attr">y</span>: box.<span class="hljs-property">y</span>,
        <span class="hljs-attr">width</span>: box.<span class="hljs-property">width</span>,
        <span class="hljs-attr">height</span>: box.<span class="hljs-property">height</span>,
        <span class="hljs-attr">color</span>: props.<span class="hljs-property">backgroundColor</span>
      });
    }
    
    <span class="hljs-comment">// Border</span>
    <span class="hljs-keyword">if</span> (props.<span class="hljs-property">border</span>.<span class="hljs-property">width</span> &gt; <span class="hljs-number">0</span>) {
      operations.<span class="hljs-title function_">push</span>({
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;strokeRect&#x27;</span>,
        <span class="hljs-attr">x</span>: box.<span class="hljs-property">x</span>,
        <span class="hljs-attr">y</span>: box.<span class="hljs-property">y</span>,
        <span class="hljs-attr">width</span>: box.<span class="hljs-property">width</span>,
        <span class="hljs-attr">height</span>: box.<span class="hljs-property">height</span>,
        <span class="hljs-attr">borderWidth</span>: props.<span class="hljs-property">border</span>.<span class="hljs-property">width</span>,
        <span class="hljs-attr">borderColor</span>: props.<span class="hljs-property">border</span>.<span class="hljs-property">color</span>
      });
    }
    
    <span class="hljs-comment">// Text content (simplified)</span>
    <span class="hljs-keyword">if</span> (paintNode.<span class="hljs-property">layoutNode</span>.<span class="hljs-property">domNode</span>.<span class="hljs-property">textContent</span>) {
      operations.<span class="hljs-title function_">push</span>({
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;fillText&#x27;</span>,
        <span class="hljs-attr">text</span>: paintNode.<span class="hljs-property">layoutNode</span>.<span class="hljs-property">domNode</span>.<span class="hljs-property">textContent</span>,
        <span class="hljs-attr">x</span>: box.<span class="hljs-property">x</span> + box.<span class="hljs-property">paddingLeft</span>,
        <span class="hljs-attr">y</span>: box.<span class="hljs-property">y</span> + box.<span class="hljs-property">paddingTop</span>,
        <span class="hljs-attr">color</span>: props.<span class="hljs-property">color</span>
      });
    }
    
    <span class="hljs-comment">// Process children that belong to the same layer</span>
    paintNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (child.<span class="hljs-property">layerId</span> === paintNode.<span class="hljs-property">layerId</span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">collectPaintOperations</span>(child, operations);
      }
    });
  }
  
  <span class="hljs-title function_">executePaintOperation</span>(<span class="hljs-params">operation</span>) {
    <span class="hljs-comment">// Simulate paint operation execution time</span>
    <span class="hljs-keyword">const</span> complexity = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calculatePaintComplexity</span>(operation);
    <span class="hljs-keyword">const</span> executionTime = complexity * <span class="hljs-number">0.1</span>; <span class="hljs-comment">// Simulate time based on complexity</span>
    
    <span class="hljs-comment">// In a real browser, this would involve actual graphics APIs</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  🎯 <span class="hljs-subst">${operation.type}</span> (<span class="hljs-subst">${executionTime.toFixed(<span class="hljs-number">2</span>)}</span>ms)`</span>);
  }
  
  <span class="hljs-title function_">calculatePaintComplexity</span>(<span class="hljs-params">operation</span>) {
    <span class="hljs-keyword">switch</span> (operation.<span class="hljs-property">type</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;fillRect&#x27;</span>:
        <span class="hljs-keyword">return</span> operation.<span class="hljs-property">width</span> * operation.<span class="hljs-property">height</span> / <span class="hljs-number">1000</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;strokeRect&#x27;</span>:
        <span class="hljs-keyword">return</span> (operation.<span class="hljs-property">width</span> + operation.<span class="hljs-property">height</span>) * operation.<span class="hljs-property">borderWidth</span> / <span class="hljs-number">100</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;fillText&#x27;</span>:
        <span class="hljs-keyword">return</span> operation.<span class="hljs-property">text</span>.<span class="hljs-property">length</span> * <span class="hljs-number">2</span>;
      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
  }
  
  <span class="hljs-comment">// Composite layers</span>
  <span class="hljs-title function_">composite</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;🔧 Starting composite phase...&#x27;</span>);
    <span class="hljs-keyword">const</span> startTime = performance.<span class="hljs-title function_">now</span>();
    
    <span class="hljs-comment">// Sort layers by z-index and document order</span>
    <span class="hljs-keyword">const</span> sortedLayers = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sortLayersForComposite</span>();
    
    <span class="hljs-comment">// Composite layers</span>
    sortedLayers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">layer, index</span>) =&gt;</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compositeLayer</span>(layer, index);
    });
    
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">compositeTime</span> = performance.<span class="hljs-title function_">now</span>() - startTime;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`✅ Composite completed in <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.compositeTime.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>);
  }
  
  <span class="hljs-title function_">sortLayersForComposite</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">layers</span>.<span class="hljs-title function_">slice</span>().<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> aZIndex = <span class="hljs-built_in">parseInt</span>(a.<span class="hljs-property">paintNode</span>.<span class="hljs-property">layoutNode</span>.<span class="hljs-property">computedStyle</span>.<span class="hljs-property">zIndex</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
      <span class="hljs-keyword">const</span> bZIndex = <span class="hljs-built_in">parseInt</span>(b.<span class="hljs-property">paintNode</span>.<span class="hljs-property">layoutNode</span>.<span class="hljs-property">computedStyle</span>.<span class="hljs-property">zIndex</span> || <span class="hljs-string">&#x27;0&#x27;</span>);
      
      <span class="hljs-keyword">if</span> (aZIndex !== bZIndex) {
        <span class="hljs-keyword">return</span> aZIndex - bZIndex;
      }
      
      <span class="hljs-comment">// Fall back to document order</span>
      <span class="hljs-keyword">return</span> a.<span class="hljs-property">id</span> - b.<span class="hljs-property">id</span>;
    });
  }
  
  <span class="hljs-title function_">compositeLayer</span>(<span class="hljs-params">layer, index</span>) {
    <span class="hljs-keyword">const</span> isGPULayer = layer.<span class="hljs-property">isGPULayer</span>;
    <span class="hljs-keyword">const</span> processingType = isGPULayer ? <span class="hljs-string">&#x27;GPU&#x27;</span> : <span class="hljs-string">&#x27;CPU&#x27;</span>;
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🔄 Compositing layer <span class="hljs-subst">${layer.id}</span> (<span class="hljs-subst">${processingType}</span>)`</span>);
    
    <span class="hljs-keyword">if</span> (isGPULayer) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compositeOnGPU</span>(layer);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">compositeOnCPU</span>(layer);
    }
  }
  
  <span class="hljs-title function_">compositeOnGPU</span>(<span class="hljs-params">layer</span>) {
    <span class="hljs-comment">// Simulate GPU compositing</span>
    <span class="hljs-keyword">const</span> operations = layer.<span class="hljs-property">paintOperations</span> || [];
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  ⚡ GPU compositing <span class="hljs-subst">${operations.length}</span> operations`</span>);
  }
  
  <span class="hljs-title function_">compositeOnCPU</span>(<span class="hljs-params">layer</span>) {
    <span class="hljs-comment">// Simulate CPU compositing</span>
    <span class="hljs-keyword">const</span> operations = layer.<span class="hljs-property">paintOperations</span> || [];
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  🖥️  CPU compositing <span class="hljs-subst">${operations.length}</span> operations`</span>);
  }
  
  <span class="hljs-comment">// Performance analysis</span>
  <span class="hljs-title function_">analyzeRenderingPerformance</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> totalRenderTime = <span class="hljs-variable language_">this</span>.<span class="hljs-property">paintTime</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">compositeTime</span>;
    
    <span class="hljs-keyword">const</span> analysis = {
      <span class="hljs-attr">paintTime</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.paintTime.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>,
      <span class="hljs-attr">compositeTime</span>: <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.compositeTime.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>,
      <span class="hljs-attr">totalRenderTime</span>: <span class="hljs-string">`<span class="hljs-subst">${totalRenderTime.toFixed(<span class="hljs-number">2</span>)}</span>ms`</span>,
      <span class="hljs-attr">layerCount</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">layers</span>.<span class="hljs-property">length</span>,
      <span class="hljs-attr">gpuLayers</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">layers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> l.<span class="hljs-property">isGPULayer</span>).<span class="hljs-property">length</span>,
      <span class="hljs-attr">cpuLayers</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">layers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">l</span> =&gt;</span> !l.<span class="hljs-property">isGPULayer</span>).<span class="hljs-property">length</span>,
      <span class="hljs-attr">performance</span>: totalRenderTime &lt; <span class="hljs-number">16</span> ? <span class="hljs-string">&#x27;Good&#x27;</span> : totalRenderTime &lt; <span class="hljs-number">32</span> ? <span class="hljs-string">&#x27;Warning&#x27;</span> : <span class="hljs-string">&#x27;Poor&#x27;</span>
    };
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;📊 Rendering Performance Analysis:&#x27;</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">table</span>(analysis);
    
    <span class="hljs-comment">// Recommendations</span>
    <span class="hljs-keyword">if</span> (analysis.<span class="hljs-property">layerCount</span> &gt; <span class="hljs-number">20</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;⚠️  High layer count detected. Consider reducing compositing layers.&#x27;</span>);
    }
    
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">paintTime</span> &gt; <span class="hljs-number">10</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;⚠️  Paint time is high. Consider optimizing paint operations.&#x27;</span>);
    }
    
    <span class="hljs-keyword">if</span> (totalRenderTime &gt; <span class="hljs-number">16</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;⚠️  Total render time exceeds 16ms. May cause frame drops.&#x27;</span>);
    }
    
    <span class="hljs-keyword">return</span> analysis;
  }
}
</code></pre></pre>
<p>{% endraw %}</p>
<h2 id="🚀-performance-optimization-techniques" node="[object Object]">🚀 Performance Optimization Techniques</h2>
<h3 id="1.-critical-resource-prioritization" node="[object Object]">1. Critical Resource Prioritization</h3>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Resource priority optimization</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourcePriority</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">optimizeResourceLoading</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Critical CSS inlining</span>
    <span class="hljs-keyword">const</span> criticalCSS = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">extractCriticalCSS</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">inlineCriticalCSS</span>(criticalCSS);
    
    <span class="hljs-comment">// Preload critical resources</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">preloadCriticalResources</span>();
    
    <span class="hljs-comment">// Defer non-critical resources</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">deferNonCriticalResources</span>();
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">extractCriticalCSS</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> aboveFoldElements = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;*&#x27;</span>);
    <span class="hljs-keyword">const</span> criticalRules = [];
    
    <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">styleSheets</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">stylesheet</span> =&gt;</span> {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(stylesheet.<span class="hljs-property">cssRules</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">rule</span> =&gt;</span> {
          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isRuleCritical</span>(rule, aboveFoldElements)) {
            criticalRules.<span class="hljs-title function_">push</span>(rule.<span class="hljs-property">cssText</span>);
          }
        });
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;Cannot access stylesheet:&#x27;</span>, e);
      }
    });
    
    <span class="hljs-keyword">return</span> criticalRules.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">isRuleCritical</span>(<span class="hljs-params">rule, elements</span>) {
    <span class="hljs-keyword">if</span> (rule.<span class="hljs-property">type</span> !== <span class="hljs-title class_">CSSRule</span>.<span class="hljs-property">STYLE_RULE</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(elements).<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.<span class="hljs-title function_">matches</span>(rule.<span class="hljs-property">selectorText</span>));
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">preloadCriticalResources</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> criticalResources = [
      { <span class="hljs-attr">href</span>: <span class="hljs-string">&#x27;/critical-font.woff2&#x27;</span>, <span class="hljs-attr">as</span>: <span class="hljs-string">&#x27;font&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;font/woff2&#x27;</span> },
      { <span class="hljs-attr">href</span>: <span class="hljs-string">&#x27;/hero-image.jpg&#x27;</span>, <span class="hljs-attr">as</span>: <span class="hljs-string">&#x27;image&#x27;</span> },
      { <span class="hljs-attr">href</span>: <span class="hljs-string">&#x27;/critical-script.js&#x27;</span>, <span class="hljs-attr">as</span>: <span class="hljs-string">&#x27;script&#x27;</span> }
    ];
    
    criticalResources.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">resource</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> link = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;link&#x27;</span>);
      link.<span class="hljs-property">rel</span> = <span class="hljs-string">&#x27;preload&#x27;</span>;
      link.<span class="hljs-property">href</span> = resource.<span class="hljs-property">href</span>;
      link.<span class="hljs-property">as</span> = resource.<span class="hljs-property">as</span>;
      <span class="hljs-keyword">if</span> (resource.<span class="hljs-property">type</span>) link.<span class="hljs-property">type</span> = resource.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">if</span> (resource.<span class="hljs-property">as</span> === <span class="hljs-string">&#x27;font&#x27;</span>) link.<span class="hljs-property">crossOrigin</span> = <span class="hljs-string">&#x27;anonymous&#x27;</span>;
      
      <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(link);
    });
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">deferNonCriticalResources</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Defer non-critical CSS</span>
    <span class="hljs-keyword">const</span> nonCriticalCSS = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;link[rel=&quot;stylesheet&quot;]:not([data-critical])&#x27;</span>);
    nonCriticalCSS.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">link</span> =&gt;</span> {
      link.<span class="hljs-property">media</span> = <span class="hljs-string">&#x27;print&#x27;</span>;
      link.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> { link.<span class="hljs-property">media</span> = <span class="hljs-string">&#x27;all&#x27;</span>; };
    });
    
    <span class="hljs-comment">// Lazy load non-critical scripts</span>
    <span class="hljs-keyword">const</span> nonCriticalScripts = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;script[data-defer]&#x27;</span>);
    nonCriticalScripts.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">script</span> =&gt;</span> {
      script.<span class="hljs-property">defer</span> = <span class="hljs-literal">true</span>;
    });
  }
}
</code></pre></pre>
<h3 id="2.-layout-optimization" node="[object Object]">2. Layout Optimization</h3>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-comment">// Layout optimization utilities</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">LayoutOptimizer</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">measureLayoutShift</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> clsValue = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">let</span> clsEntries = [];
    
    <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">entryList</span>) =&gt;</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entryList.<span class="hljs-title function_">getEntries</span>()) {
        <span class="hljs-keyword">if</span> (!entry.<span class="hljs-property">hadRecentInput</span>) {
          clsValue += entry.<span class="hljs-property">value</span>;
          clsEntries.<span class="hljs-title function_">push</span>(entry);
        }
      }
    });
    
    observer.<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;layout-shift&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span> });
    
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      observer.<span class="hljs-title function_">disconnect</span>();
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Cumulative Layout Shift:&#x27;</span>, clsValue);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;CLS Entries:&#x27;</span>, clsEntries);
      
      <span class="hljs-keyword">if</span> (clsValue &gt; <span class="hljs-number">0.1</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;⚠️  High CLS detected! Consider fixing layout shifts.&#x27;</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">analyzeLayoutShifts</span>(clsEntries);
      }
    }, <span class="hljs-number">5000</span>);
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">analyzeLayoutShifts</span>(<span class="hljs-params">entries</span>) {
    entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">entry, index</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Layout Shift <span class="hljs-subst">${index + <span class="hljs-number">1</span>}</span>:`</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  Value: <span class="hljs-subst">${entry.value}</span>`</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  Time: <span class="hljs-subst">${entry.startTime}</span>ms`</span>);
      
      entry.<span class="hljs-property">sources</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  Affected element:`</span>, source.<span class="hljs-property">node</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  Previous rect:`</span>, source.<span class="hljs-property">previousRect</span>);
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  Current rect:`</span>, source.<span class="hljs-property">currentRect</span>);
      });
    });
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">preventLayoutShifts</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Reserve space for images</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">reserveImageSpace</span>();
    
    <span class="hljs-comment">// Set font display swap</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">optimizeFontLoading</span>();
    
    <span class="hljs-comment">// Prevent ad-related shifts</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">reserveAdSpace</span>();
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">reserveImageSpace</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> images = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img[data-src]&#x27;</span>);
    images.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">img</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!img.<span class="hljs-property">style</span>.<span class="hljs-property">aspectRatio</span>) {
        <span class="hljs-keyword">const</span> width = img.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;width&#x27;</span>);
        <span class="hljs-keyword">const</span> height = img.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;height&#x27;</span>);
        
        <span class="hljs-keyword">if</span> (width &amp;&amp; height) {
          img.<span class="hljs-property">style</span>.<span class="hljs-property">aspectRatio</span> = <span class="hljs-string">`<span class="hljs-subst">${width}</span> / <span class="hljs-subst">${height}</span>`</span>;
        }
      }
    });
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">optimizeFontLoading</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> fontFaces = <span class="hljs-variable language_">document</span>.<span class="hljs-property">fonts</span>;
    
    fontFaces.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">font</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (font.<span class="hljs-property">display</span> !== <span class="hljs-string">&#x27;swap&#x27;</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Font <span class="hljs-subst">${font.family}</span> should use font-display: swap`</span>);
      }
    });
  }
}
</code></pre></pre>
<p>{% endraw %}</p>
<h2 id="🧠-interview-questions-and-scenarios" node="[object Object]">🧠 Interview Questions and Scenarios</h2>
<h3 id="1.-performance-debugging" node="[object Object]">1. Performance Debugging</h3>
<p><strong>Question</strong>: &quot;The page is slow to load. How would you debug it?&quot;</p>
<p><strong>Answer Framework</strong>:</p>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PerformanceDebugger</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">debugSlowPage</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;🔍 Starting performance debugging...&#x27;</span>);
    
    <span class="hljs-comment">// 1. Check Core Web Vitals</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">measureCoreWebVitals</span>();
    
    <span class="hljs-comment">// 2. Analyze network waterfall</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">analyzeNetworkWaterfall</span>();
    
    <span class="hljs-comment">// 3. Check rendering performance</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">analyzeRenderingPerformance</span>();
    
    <span class="hljs-comment">// 4. Identify JavaScript bottlenecks</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">analyzeJavaScriptPerformance</span>();
    
    <span class="hljs-comment">// 5. Check memory usage</span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">analyzeMemoryUsage</span>();
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">measureCoreWebVitals</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// LCP (Largest Contentful Paint)</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">entryList</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> entries = entryList.<span class="hljs-title function_">getEntries</span>();
      <span class="hljs-keyword">const</span> lastEntry = entries[entries.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;LCP:&#x27;</span>, lastEntry.<span class="hljs-property">startTime</span>);
    }).<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;largest-contentful-paint&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span> });
    
    <span class="hljs-comment">// FID (First Input Delay)</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">entryList</span>) =&gt;</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entryList.<span class="hljs-title function_">getEntries</span>()) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;FID:&#x27;</span>, entry.<span class="hljs-property">processingStart</span> - entry.<span class="hljs-property">startTime</span>);
      }
    }).<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;first-input&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span> });
    
    <span class="hljs-comment">// CLS (Cumulative Layout Shift)</span>
    <span class="hljs-title class_">LayoutOptimizer</span>.<span class="hljs-title function_">measureLayoutShift</span>();
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">analyzeNetworkWaterfall</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> resources = performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">&#x27;resource&#x27;</span>);
    
    <span class="hljs-comment">// Find slow resources</span>
    <span class="hljs-keyword">const</span> slowResources = resources.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> r.<span class="hljs-property">duration</span> &gt; <span class="hljs-number">1000</span>);
    <span class="hljs-keyword">if</span> (slowResources.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;Slow resources detected:&#x27;</span>, slowResources);
    }
    
    <span class="hljs-comment">// Check for render-blocking resources</span>
    <span class="hljs-keyword">const</span> renderBlocking = resources.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> 
      r.<span class="hljs-property">name</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;.css&#x27;</span>) &amp;&amp; r.<span class="hljs-property">startTime</span> &lt; <span class="hljs-number">1000</span>
    );
    
    <span class="hljs-keyword">if</span> (renderBlocking.<span class="hljs-property">length</span> &gt; <span class="hljs-number">3</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;Too many render-blocking CSS files:&#x27;</span>, renderBlocking);
    }
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">analyzeRenderingPerformance</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Check for expensive layout operations</span>
    <span class="hljs-keyword">const</span> measureEntries = performance.<span class="hljs-title function_">getEntriesByType</span>(<span class="hljs-string">&#x27;measure&#x27;</span>);
    <span class="hljs-keyword">const</span> layoutMeasures = measureEntries.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.<span class="hljs-property">name</span>.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;layout&#x27;</span>));
    
    layoutMeasures.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">measure</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (measure.<span class="hljs-property">duration</span> &gt; <span class="hljs-number">16</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Expensive layout operation: <span class="hljs-subst">${measure.name}</span> (<span class="hljs-subst">${measure.duration}</span>ms)`</span>);
      }
    });
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">analyzeJavaScriptPerformance</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// Check for long tasks</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">PerformanceObserver</span>(<span class="hljs-function">(<span class="hljs-params">entryList</span>) =&gt;</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> entry <span class="hljs-keyword">of</span> entryList.<span class="hljs-title function_">getEntries</span>()) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Long task detected: <span class="hljs-subst">${entry.duration}</span>ms`</span>);
        
        <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">attribution</span>) {
          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Attribution:&#x27;</span>, entry.<span class="hljs-property">attribution</span>);
        }
      }
    }).<span class="hljs-title function_">observe</span>({ <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;longtask&#x27;</span>, <span class="hljs-attr">buffered</span>: <span class="hljs-literal">true</span> });
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">analyzeMemoryUsage</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;memory&#x27;</span> <span class="hljs-keyword">in</span> performance) {
      <span class="hljs-keyword">const</span> memory = performance.<span class="hljs-property">memory</span>;
      <span class="hljs-keyword">const</span> memoryUsage = {
        <span class="hljs-attr">used</span>: <span class="hljs-string">`<span class="hljs-subst">${(memory.usedJSHeapSize / <span class="hljs-number">1048576</span>).toFixed(<span class="hljs-number">2</span>)}</span> MB`</span>,
        <span class="hljs-attr">total</span>: <span class="hljs-string">`<span class="hljs-subst">${(memory.totalJSHeapSize / <span class="hljs-number">1048576</span>).toFixed(<span class="hljs-number">2</span>)}</span> MB`</span>,
        <span class="hljs-attr">limit</span>: <span class="hljs-string">`<span class="hljs-subst">${(memory.jsHeapSizeLimit / <span class="hljs-number">1048576</span>).toFixed(<span class="hljs-number">2</span>)}</span> MB`</span>
      };
      
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">table</span>(memoryUsage);
      
      <span class="hljs-keyword">if</span> (memory.<span class="hljs-property">usedJSHeapSize</span> / memory.<span class="hljs-property">jsHeapSizeLimit</span> &gt; <span class="hljs-number">0.9</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;⚠️  High memory usage detected!&#x27;</span>);
      }
    }
  }
}
</code></pre></pre>
<p>{% endraw %}</p>
<h3 id="2.-rendering-pipeline-questions" node="[object Object]">2. Rendering Pipeline Questions</h3>
<p><strong>Question</strong>: &quot;What happens when you change a CSS property?&quot;</p>
<p><strong>Answer</strong>: Different CSS properties trigger different stages of the rendering pipeline:</p>
<p>{% raw %}</p>
<pre><pre><code class="hljs hljs language-javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RenderingPipelineAnalyzer</span> {
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">analyzeCSSPropertyImpact</span>(<span class="hljs-params">property, value</span>) {
    <span class="hljs-keyword">const</span> propertyImpacts = {
      <span class="hljs-comment">// Layout-triggering properties</span>
      <span class="hljs-string">&#x27;width&#x27;</span>: [<span class="hljs-string">&#x27;layout&#x27;</span>, <span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;height&#x27;</span>: [<span class="hljs-string">&#x27;layout&#x27;</span>, <span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;padding&#x27;</span>: [<span class="hljs-string">&#x27;layout&#x27;</span>, <span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;margin&#x27;</span>: [<span class="hljs-string">&#x27;layout&#x27;</span>, <span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;display&#x27;</span>: [<span class="hljs-string">&#x27;layout&#x27;</span>, <span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;position&#x27;</span>: [<span class="hljs-string">&#x27;layout&#x27;</span>, <span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;float&#x27;</span>: [<span class="hljs-string">&#x27;layout&#x27;</span>, <span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;clear&#x27;</span>: [<span class="hljs-string">&#x27;layout&#x27;</span>, <span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      
      <span class="hljs-comment">// Paint-triggering properties</span>
      <span class="hljs-string">&#x27;color&#x27;</span>: [<span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;background&#x27;</span>: [<span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;border&#x27;</span>: [<span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;box-shadow&#x27;</span>: [<span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;border-radius&#x27;</span>: [<span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;visibility&#x27;</span>: [<span class="hljs-string">&#x27;paint&#x27;</span>, <span class="hljs-string">&#x27;composite&#x27;</span>],
      
      <span class="hljs-comment">// Composite-only properties</span>
      <span class="hljs-string">&#x27;transform&#x27;</span>: [<span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;opacity&#x27;</span>: [<span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;filter&#x27;</span>: [<span class="hljs-string">&#x27;composite&#x27;</span>],
      <span class="hljs-string">&#x27;will-change&#x27;</span>: [<span class="hljs-string">&#x27;composite&#x27;</span>]
    };
    
    <span class="hljs-keyword">const</span> impact = propertyImpacts[property] || [<span class="hljs-string">&#x27;unknown&#x27;</span>];
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`🎯 Changing <span class="hljs-subst">${property}</span> will trigger:`</span>, impact);
    
    <span class="hljs-keyword">const</span> performance = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getPerformanceRating</span>(impact);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`📊 Performance impact: <span class="hljs-subst">${performance}</span>`</span>);
    
    <span class="hljs-keyword">return</span> { property, value, impact, performance };
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getPerformanceRating</span>(<span class="hljs-params">impact</span>) {
    <span class="hljs-keyword">if</span> (impact.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;layout&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;High (Avoid in animations)&#x27;</span>;
    <span class="hljs-keyword">if</span> (impact.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;paint&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Medium (Use sparingly)&#x27;</span>;
    <span class="hljs-keyword">if</span> (impact.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;composite&#x27;</span>)) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Low (Good for animations)&#x27;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Unknown&#x27;</span>;
  }
  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">demonstrateOptimalAnimations</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;✅ Optimal CSS properties for animations:&#x27;</span>);
    
    <span class="hljs-keyword">const</span> optimalProperties = [
      <span class="hljs-string">&#x27;transform: translateX(100px)&#x27;</span>,
      <span class="hljs-string">&#x27;transform: scale(1.2)&#x27;</span>,
      <span class="hljs-string">&#x27;transform: rotate(45deg)&#x27;</span>,
      <span class="hljs-string">&#x27;opacity: 0.5&#x27;</span>,
      <span class="hljs-string">&#x27;filter: blur(5px)&#x27;</span>
    ];
    
    optimalProperties.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">prop</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  <span class="hljs-subst">${prop}</span> - Composite only`</span>);
    });
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;\n❌ Avoid these properties in animations:&#x27;</span>);
    
    <span class="hljs-keyword">const</span> avoidProperties = [
      <span class="hljs-string">&#x27;width/height - Triggers layout&#x27;</span>,
      <span class="hljs-string">&#x27;padding/margin - Triggers layout&#x27;</span>,
      <span class="hljs-string">&#x27;top/left - Triggers layout&#x27;</span>,
      <span class="hljs-string">&#x27;background-color - Triggers paint&#x27;</span>,
      <span class="hljs-string">&#x27;border-width - Triggers layout&#x27;</span>
    ];
    
    avoidProperties.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">prop</span> =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`  <span class="hljs-subst">${prop}</span>`</span>);
    });
  }
}
</code></pre></pre>
<p>{% endraw %}</p>
<p>This comprehensive guide provides deep insights into browser architecture and rendering pipeline, essential knowledge for frontend interviews at big tech companies. The practical examples and performance debugging techniques demonstrate real-world application of these concepts.</p></div></div></main><footer class="sc-gvqKNf booJNS"><div class="sc-cOpnSz fVoYcP"><div class="sc-kjwdDK kKfrkv"><div class="sc-eVqvcJ inEXDm"><div class="sc-bbbBoY hWhopJ"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-code "><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>Frontend Interview Prep</div><p class="sc-cdmAjP exeTne">Comprehensive interview preparation for frontend engineers targeting Big Tech companies.</p><div class="sc-jytpVa cgXMuV"><a href="https://github.com" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github "><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><a href="https://twitter.com" aria-label="Twitter"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-twitter "><path d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"></path></svg></a><a href="https://linkedin.com" aria-label="LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-linkedin "><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect width="4" height="12" x="2" y="9"></rect><circle cx="4" cy="4" r="2"></circle></svg></a><a href="mailto:contact@example.com" aria-label="Email"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail "><rect width="20" height="16" x="2" y="4" rx="2"></rect><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"></path></svg></a></div></div><div class="sc-eVqvcJ inEXDm"><h3>Study Materials</h3><ul><li><a href="/algorithms">Algorithms</a></li><li><a href="/react">React &amp; Frontend</a></li><li><a href="/system-design">System Design</a></li><li><a href="/typescript">TypeScript</a></li><li><a href="/performance">Performance</a></li></ul></div><div class="sc-eVqvcJ inEXDm"><h3>Companies</h3><ul><li><a href="/google">Google</a></li><li><a href="/meta">Meta</a></li><li><a href="/amazon">Amazon</a></li><li><a href="/microsoft">Microsoft</a></li><li><a href="/apple">Apple</a></li></ul></div><div class="sc-eVqvcJ inEXDm"><h3>Resources</h3><ul><li><a href="/interview-tips">Interview Tips</a></li><li><a href="/coding-challenges">Coding Challenges</a></li><li><a href="/mock-interviews">Mock Interviews</a></li><li><a href="/blog">Blog</a></li><li><a href="/faq">FAQ</a></li></ul></div></div><div class="sc-eknHtZ iQqwrD"><p class="sc-pYNGo gObJRG">© 2025 Frontend Interview Prep. All rights reserved.</p><div class="sc-cCVJLD eBqBtc"><a href="/privacy">Privacy Policy</a><a href="/terms">Terms of Service</a><a href="/contact">Contact</a></div></div></div></footer></div><script src="/interview/_next/static/chunks/webpack-be7d7df45533bffc.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/interview/_next/static/media/e4af272ccee01ff0-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/interview/_next/static/css/387024c6a2216908.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"3:I[2846,[],\"\"]\n5:I[5907,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"930\",\"static/chunks/930-3262a6c9c5acace4.js\",\"687\",\"static/chunks/app/docs/%5B...slug%5D/page-036ada1d0a865043.js\"],\"default\"]\n7:I[4707,[],\"\"]\n9:I[6423,[],\"\"]\na:I[2,[\"918\",\"static/chunks/918-3273b83890f10546.js\",\"710\",\"static/chunks/710-dfaa11b4dff08f8e.js\",\"972\",\"static/chunks/972-011bba60ed155615.js\",\"233\",\"static/chunks/233-3e0c1d820a17eca9.js\",\"185\",\"static/chunks/app/layout-333f4adcd11f8f39.js\"],\"default\",1]\nc:I[1060,[],\"\"]\n6:T9da1,"])</script><script>self.__next_f.push([1,"\n# Browser Architecture and Rendering Pipeline Deep Dive\n\n## 🎯 Overview\n\nUnderstanding browser internals is crucial for frontend interviews at big tech companies. This guide provides deep insights into how browsers work, enabling you to answer performance, debugging, and optimization questions with confidence.\n\n## 🏗️ Browser Architecture Overview\n\n### Multi-Process Architecture\n\nModern browsers use a multi-process architecture for security, stability, and performance:\n\n```mermaid\ngraph TB\n    subgraph \"Browser Process\"\n        A[UI Thread] --\u003e B[Network Thread]\n        B --\u003e C[Storage Thread]\n        C --\u003e D[Device Thread]\n    end\n    \n    subgraph \"Renderer Process\"\n        E[Main Thread] --\u003e F[Compositor Thread]\n        F --\u003e G[Web Workers]\n    end\n    \n    subgraph \"GPU Process\"\n        H[Graphics Operations]\n        I[Hardware Acceleration]\n    end\n    \n    subgraph \"Plugin Process\"\n        J[Flash/Extensions]\n    end\n    \n    A -.-\u003e E\n    F -.-\u003e H\n```\n\n### Process Responsibilities\n\n#### 1. Browser Process\n- **UI Thread**: Handles browser UI, tabs, address bar\n- **Network Thread**: Manages HTTP requests, downloads\n- **Storage Thread**: File system access, databases\n- **Device Thread**: Camera, microphone access\n\n#### 2. Renderer Process (Site Isolation)\n- **Main Thread**: JavaScript execution, DOM manipulation, layout\n- **Compositor Thread**: Handles scrolling, animations\n- **Web Workers**: Background JavaScript execution\n\n#### 3. GPU Process\n- Hardware-accelerated graphics\n- Video decoding\n- Canvas and WebGL operations\n\n## 🔄 Critical Rendering Path\n\n### 1. Navigation and Resource Loading\n\n{% raw %}\n```javascript\n// Performance timing visualization\nclass NavigationTiming {\n  static measureNavigation() {\n    const navigation = performance.getEntriesByType('navigation')[0];\n    \n    const timing = {\n      // DNS resolution\n      dnsTime: navigation.domainLookupEnd - navigation.domainLookupStart,\n      \n      // TCP connection\n      tcpTime: navigation.connectEnd - navigation.connectStart,\n      \n      // SSL handshake\n      sslTime: navigation.secureConnectionStart \u003e 0 \n        ? navigation.connectEnd - navigation.secureConnectionStart \n        : 0,\n        \n      // Request/Response\n      requestTime: navigation.responseStart - navigation.requestStart,\n      responseTime: navigation.responseEnd - navigation.responseStart,\n      \n      // DOM processing\n      domProcessing: navigation.domContentLoadedEventStart - navigation.responseEnd,\n      \n      // Resource loading\n      resourceLoadTime: navigation.loadEventStart - navigation.domContentLoadedEventEnd\n    };\n    \n    console.table(timing);\n    return timing;\n  }\n  \n  static visualizeWaterfall() {\n    const resources = performance.getEntriesByType('resource');\n    \n    resources.forEach(resource =\u003e {\n      const waterfall = {\n        name: resource.name.split('/').pop(),\n        startTime: Math.round(resource.startTime),\n        duration: Math.round(resource.duration),\n        size: resource.transferSize || 'cached',\n        type: resource.initiatorType\n      };\n      \n      console.log(\n        `${waterfall.name.padEnd(30)} | ` +\n        `${waterfall.startTime}ms`.padEnd(10) +\n        `${waterfall.duration}ms`.padEnd(10) +\n        `${waterfall.size}`.padEnd(15) +\n        `${waterfall.type}`\n      );\n    });\n  }\n}\n\n// Usage\nNavigationTiming.measureNavigation();\nNavigationTiming.visualizeWaterfall();\n```\n{% endraw %}\n\n### 2. HTML Parsing and DOM Construction\n\n{% raw %}\n```javascript\n// DOM construction simulation\nclass DOMParser {\n  constructor() {\n    this.tokens = [];\n    this.domTree = null;\n    this.parseStartTime = 0;\n  }\n  \n  // Tokenization phase\n  tokenize(html) {\n    this.parseStartTime = performance.now();\n    console.log('🔍 Starting HTML tokenization...');\n    \n    // Simplified tokenization\n    const tokenRegex = /\u003c\\/?([a-zA-Z][a-zA-Z0-9]*)\\s*([^\u003e]*)\u003e/g;\n    let match;\n    \n    while ((match = tokenRegex.exec(html)) !== null) {\n      const [fullMatch, tagName, attributes] = match;\n      const isClosing = fullMatch.startsWith('\u003c/');\n      \n      this.tokens.push({\n        type: isClosing ? 'endTag' : 'startTag',\n        tagName: tagName.toLowerCase(),\n        attributes: this.parseAttributes(attributes),\n        position: match.index\n      });\n    }\n    \n    console.log(`📝 Tokenized ${this.tokens.length} tokens`);\n    return this.tokens;\n  }\n  \n  parseAttributes(attrString) {\n    const attributes = {};\n    const attrRegex = /(\\w+)=[\"']([^\"']*)[\"']/g;\n    let match;\n    \n    while ((match = attrRegex.exec(attrString)) !== null) {\n      attributes[match[1]] = match[2];\n    }\n    \n    return attributes;\n  }\n  \n  // Tree construction phase\n  buildDOM(tokens) {\n    console.log('🌳 Building DOM tree...');\n    \n    const stack = [];\n    const root = { tagName: 'document', children: [] };\n    let current = root;\n    \n    tokens.forEach(token =\u003e {\n      if (token.type === 'startTag') {\n        const element = {\n          tagName: token.tagName,\n          attributes: token.attributes,\n          children: [],\n          parent: current\n        };\n        \n        current.children.push(element);\n        \n        // Self-closing tags don't need to be pushed to stack\n        if (!this.isSelfClosing(token.tagName)) {\n          stack.push(current);\n          current = element;\n        }\n        \n        // Simulate parser blocking for synchronous scripts\n        if (token.tagName === 'script' \u0026\u0026 !token.attributes.async \u0026\u0026 !token.attributes.defer) {\n          console.log('⏸️  Parser blocked by synchronous script');\n          // In real browser, parser would wait for script execution\n        }\n        \n      } else if (token.type === 'endTag') {\n        if (stack.length \u003e 0) {\n          current = stack.pop();\n        }\n      }\n    });\n    \n    this.domTree = root;\n    const parseTime = performance.now() - this.parseStartTime;\n    console.log(`✅ DOM construction completed in ${parseTime.toFixed(2)}ms`);\n    \n    return root;\n  }\n  \n  isSelfClosing(tagName) {\n    return ['img', 'br', 'hr', 'input', 'meta', 'link'].includes(tagName);\n  }\n  \n  // DOM tree visualization\n  visualizeDOM(node = this.domTree, depth = 0) {\n    const indent = '  '.repeat(depth);\n    console.log(`${indent}${node.tagName}`);\n    \n    if (node.children) {\n      node.children.forEach(child =\u003e this.visualizeDOM(child, depth + 1));\n    }\n  }\n}\n```\n{% endraw %}\n\n### 3. CSS Parsing and CSSOM Construction\n\n{% raw %}\n```javascript\n// CSSOM construction simulation\nclass CSSOMBuilder {\n  constructor() {\n    this.stylesheets = [];\n    this.cssom = null;\n  }\n  \n  parseCSS(cssText, source = 'inline') {\n    console.log(`🎨 Parsing CSS from ${source}...`);\n    \n    const rules = [];\n    const ruleRegex = /([^{]+)\\s*\\{([^}]+)\\}/g;\n    let match;\n    \n    while ((match = ruleRegex.exec(cssText)) !== null) {\n      const [, selector, declarations] = match;\n      \n      const rule = {\n        selector: selector.trim(),\n        declarations: this.parseDeclarations(declarations),\n        specificity: this.calculateSpecificity(selector.trim()),\n        source\n      };\n      \n      rules.push(rule);\n    }\n    \n    this.stylesheets.push({ source, rules });\n    console.log(`📄 Parsed ${rules.length} CSS rules`);\n    \n    return rules;\n  }\n  \n  parseDeclarations(declarationsText) {\n    const declarations = {};\n    const declRegex = /([^:]+):\\s*([^;]+)/g;\n    let match;\n    \n    while ((match = declRegex.exec(declarationsText)) !== null) {\n      const property = match[1].trim();\n      const value = match[2].trim();\n      declarations[property] = value;\n    }\n    \n    return declarations;\n  }\n  \n  calculateSpecificity(selector) {\n    // Simplified specificity calculation\n    const ids = (selector.match(/#/g) || []).length;\n    const classes = (selector.match(/\\./g) || []).length;\n    const elements = (selector.match(/\\b[a-z]+\\b/g) || []).length;\n    \n    return ids * 100 + classes * 10 + elements;\n  }\n  \n  buildCSSOМ() {\n    console.log('🏗️  Building CSSOM...');\n    \n    // Combine all stylesheets and sort by specificity\n    const allRules = [];\n    \n    this.stylesheets.forEach(stylesheet =\u003e {\n      allRules.push(...stylesheet.rules);\n    });\n    \n    // Sort by specificity (higher specificity first)\n    allRules.sort((a, b) =\u003e b.specificity - a.specificity);\n    \n    this.cssom = {\n      rules: allRules,\n      computedStyles: new Map() // Will store computed styles for elements\n    };\n    \n    console.log(`✅ CSSOM built with ${allRules.length} rules`);\n    return this.cssom;\n  }\n  \n  // Simulate style computation\n  computeStyles(element, domTree) {\n    const computedStyle = {};\n    \n    // Apply matching rules\n    this.cssom.rules.forEach(rule =\u003e {\n      if (this.matchesSelector(element, rule.selector, domTree)) {\n        Object.assign(computedStyle, rule.declarations);\n      }\n    });\n    \n    // Apply inheritance\n    if (element.parent \u0026\u0026 element.parent !== domTree) {\n      const parentStyle = this.cssom.computedStyles.get(element.parent) || {};\n      const inheritableProperties = ['color', 'font-family', 'font-size', 'line-height'];\n      \n      inheritableProperties.forEach(prop =\u003e {\n        if (parentStyle[prop] \u0026\u0026 !computedStyle[prop]) {\n          computedStyle[prop] = parentStyle[prop];\n        }\n      });\n    }\n    \n    this.cssom.computedStyles.set(element, computedStyle);\n    return computedStyle;\n  }\n  \n  matchesSelector(element, selector, domTree) {\n    // Simplified selector matching\n    if (selector.startsWith('#')) {\n      return element.attributes.id === selector.slice(1);\n    }\n    \n    if (selector.startsWith('.')) {\n      const classes = element.attributes.class || '';\n      return classes.split(' ').includes(selector.slice(1));\n    }\n    \n    return element.tagName === selector;\n  }\n}\n```\n{% endraw %}\n\n### 4. Layout (Reflow) Engine\n\n{% raw %}\n```javascript\n// Layout engine simulation\nclass LayoutEngine {\n  constructor() {\n    this.layoutTree = null;\n    this.viewport = { width: 1024, height: 768 };\n  }\n  \n  createLayoutTree(domTree, cssom) {\n    console.log('📐 Starting layout phase...');\n    \n    this.layoutTree = this.buildLayoutTree(domTree, cssom);\n    this.calculateLayout(this.layoutTree);\n    \n    console.log('✅ Layout phase completed');\n    return this.layoutTree;\n  }\n  \n  buildLayoutTree(domNode, cssom, parentLayoutNode = null) {\n    // Skip text nodes and elements with display: none\n    const computedStyle = cssom.computedStyles.get(domNode) || {};\n    \n    if (computedStyle.display === 'none') {\n      return null;\n    }\n    \n    const layoutNode = {\n      domNode,\n      computedStyle,\n      children: [],\n      parent: parentLayoutNode,\n      box: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        marginTop: 0,\n        marginRight: 0,\n        marginBottom: 0,\n        marginLeft: 0,\n        paddingTop: 0,\n        paddingRight: 0,\n        paddingBottom: 0,\n        paddingLeft: 0\n      }\n    };\n    \n    // Process children\n    if (domNode.children) {\n      domNode.children.forEach(child =\u003e {\n        const childLayoutNode = this.buildLayoutTree(child, cssom, layoutNode);\n        if (childLayoutNode) {\n          layoutNode.children.push(childLayoutNode);\n        }\n      });\n    }\n    \n    return layoutNode;\n  }\n  \n  calculateLayout(layoutNode, containerWidth = this.viewport.width) {\n    if (!layoutNode) return;\n    \n    const style = layoutNode.computedStyle;\n    \n    // Calculate box model\n    this.calculateBoxModel(layoutNode, style);\n    \n    // Calculate position and size based on display type\n    switch (style.display) {\n      case 'block':\n        this.layoutBlock(layoutNode, containerWidth);\n        break;\n      case 'inline':\n        this.layoutInline(layoutNode, containerWidth);\n        break;\n      case 'flex':\n        this.layoutFlex(layoutNode, containerWidth);\n        break;\n      case 'grid':\n        this.layoutGrid(layoutNode, containerWidth);\n        break;\n      default:\n        this.layoutBlock(layoutNode, containerWidth);\n    }\n    \n    // Layout children\n    layoutNode.children.forEach(child =\u003e {\n      this.calculateLayout(child, layoutNode.box.width);\n    });\n  }\n  \n  calculateBoxModel(layoutNode, style) {\n    const box = layoutNode.box;\n    \n    // Parse CSS values (simplified)\n    box.marginTop = this.parseValue(style.marginTop || '0');\n    box.marginRight = this.parseValue(style.marginRight || '0');\n    box.marginBottom = this.parseValue(style.marginBottom || '0');\n    box.marginLeft = this.parseValue(style.marginLeft || '0');\n    \n    box.paddingTop = this.parseValue(style.paddingTop || '0');\n    box.paddingRight = this.parseValue(style.paddingRight || '0');\n    box.paddingBottom = this.parseValue(style.paddingBottom || '0');\n    box.paddingLeft = this.parseValue(style.paddingLeft || '0');\n  }\n  \n  parseValue(value) {\n    // Simplified CSS value parsing\n    if (value.endsWith('px')) {\n      return parseInt(value);\n    }\n    if (value.endsWith('%')) {\n      return { type: 'percentage', value: parseInt(value) };\n    }\n    return parseInt(value) || 0;\n  }\n  \n  layoutBlock(layoutNode, containerWidth) {\n    const box = layoutNode.box;\n    const style = layoutNode.computedStyle;\n    \n    // Block elements take full width by default\n    box.width = containerWidth - box.marginLeft - box.marginRight;\n    \n    // Calculate height based on content\n    let contentHeight = 0;\n    let currentY = box.paddingTop;\n    \n    layoutNode.children.forEach(child =\u003e {\n      child.box.x = box.paddingLeft;\n      child.box.y = currentY;\n      \n      this.calculateLayout(child, box.width - box.paddingLeft - box.paddingRight);\n      \n      currentY += child.box.height + child.box.marginTop + child.box.marginBottom;\n      contentHeight = Math.max(contentHeight, currentY);\n    });\n    \n    box.height = contentHeight + box.paddingBottom;\n    \n    console.log(`📦 Block layout: ${layoutNode.domNode.tagName} (${box.width}x${box.height})`);\n  }\n  \n  layoutFlex(layoutNode, containerWidth) {\n    const box = layoutNode.box;\n    const style = layoutNode.computedStyle;\n    \n    box.width = containerWidth - box.marginLeft - box.marginRight;\n    \n    const flexDirection = style.flexDirection || 'row';\n    const justifyContent = style.justifyContent || 'flex-start';\n    const alignItems = style.alignItems || 'stretch';\n    \n    if (flexDirection === 'row') {\n      this.layoutFlexRow(layoutNode, justifyContent, alignItems);\n    } else {\n      this.layoutFlexColumn(layoutNode, justifyContent, alignItems);\n    }\n    \n    console.log(`🔧 Flex layout: ${layoutNode.domNode.tagName} (${box.width}x${box.height})`);\n  }\n  \n  layoutFlexRow(layoutNode, justifyContent, alignItems) {\n    const availableWidth = layoutNode.box.width - layoutNode.box.paddingLeft - layoutNode.box.paddingRight;\n    const children = layoutNode.children;\n    \n    // Calculate flex basis and grow\n    let totalFlexBasis = 0;\n    let totalFlexGrow = 0;\n    \n    children.forEach(child =\u003e {\n      const flexBasis = this.parseValue(child.computedStyle.flexBasis || 'auto');\n      const flexGrow = parseInt(child.computedStyle.flexGrow || '0');\n      \n      child.flexBasis = flexBasis === 'auto' ? 0 : flexBasis;\n      child.flexGrow = flexGrow;\n      \n      totalFlexBasis += child.flexBasis;\n      totalFlexGrow += flexGrow;\n    });\n    \n    // Distribute remaining space\n    const remainingSpace = availableWidth - totalFlexBasis;\n    const spacePerGrow = totalFlexGrow \u003e 0 ? remainingSpace / totalFlexGrow : 0;\n    \n    let currentX = layoutNode.box.paddingLeft;\n    let maxHeight = 0;\n    \n    children.forEach(child =\u003e {\n      child.box.x = currentX;\n      child.box.y = layoutNode.box.paddingTop;\n      child.box.width = child.flexBasis + (child.flexGrow * spacePerGrow);\n      \n      this.calculateLayout(child, child.box.width);\n      \n      currentX += child.box.width;\n      maxHeight = Math.max(maxHeight, child.box.height);\n    });\n    \n    layoutNode.box.height = maxHeight + layoutNode.box.paddingTop + layoutNode.box.paddingBottom;\n  }\n  \n  layoutGrid(layoutNode, containerWidth) {\n    // Simplified CSS Grid implementation\n    const box = layoutNode.box;\n    const style = layoutNode.computedStyle;\n    \n    box.width = containerWidth - box.marginLeft - box.marginRight;\n    \n    const gridTemplateColumns = style.gridTemplateColumns || '1fr';\n    const gridTemplateRows = style.gridTemplateRows || 'auto';\n    const gap = this.parseValue(style.gap || '0');\n    \n    // Parse grid template\n    const columns = this.parseGridTemplate(gridTemplateColumns, box.width);\n    const rows = this.parseGridTemplate(gridTemplateRows, 0); // Will be calculated\n    \n    console.log(`📊 Grid layout: ${columns.length} columns, ${rows.length} rows`);\n    \n    // Position grid items\n    let currentRow = 0;\n    let currentCol = 0;\n    let maxRowHeight = 0;\n    \n    layoutNode.children.forEach((child, index) =\u003e {\n      if (currentCol \u003e= columns.length) {\n        currentCol = 0;\n        currentRow++;\n        if (currentRow \u003e= rows.length) {\n          rows.push({ size: 0, type: 'auto' });\n        }\n      }\n      \n      child.box.x = columns.slice(0, currentCol).reduce((sum, col) =\u003e sum + col.size, 0) + (currentCol * gap);\n      child.box.y = rows.slice(0, currentRow).reduce((sum, row) =\u003e sum + row.size, 0) + (currentRow * gap);\n      child.box.width = columns[currentCol].size;\n      \n      this.calculateLayout(child, child.box.width);\n      \n      maxRowHeight = Math.max(maxRowHeight, child.box.height);\n      \n      currentCol++;\n      \n      // Update row height for auto rows\n      if (rows[currentRow] \u0026\u0026 rows[currentRow].type === 'auto') {\n        rows[currentRow].size = Math.max(rows[currentRow].size, child.box.height);\n      }\n    });\n    \n    const totalHeight = rows.reduce((sum, row) =\u003e sum + row.size, 0) + ((rows.length - 1) * gap);\n    box.height = totalHeight + box.paddingTop + box.paddingBottom;\n  }\n  \n  parseGridTemplate(template, containerSize) {\n    const tracks = template.split(' ');\n    const result = [];\n    \n    tracks.forEach(track =\u003e {\n      if (track.endsWith('fr')) {\n        const fraction = parseFloat(track);\n        result.push({ size: (containerSize / tracks.length) * fraction, type: 'fr', fraction });\n      } else if (track.endsWith('px')) {\n        result.push({ size: parseInt(track), type: 'px' });\n      } else if (track === 'auto') {\n        result.push({ size: 0, type: 'auto' });\n      } else {\n        result.push({ size: containerSize / tracks.length, type: 'default' });\n      }\n    });\n    \n    return result;\n  }\n  \n  // Performance monitoring\n  measureLayoutPerformance(domTree, cssom) {\n    const startTime = performance.now();\n    \n    console.log('⏱️  Starting layout performance measurement...');\n    \n    // Simulate forced layout\n    const layoutTree = this.createLayoutTree(domTree, cssom);\n    \n    const endTime = performance.now();\n    const layoutTime = endTime - startTime;\n    \n    const stats = {\n      layoutTime: `${layoutTime.toFixed(2)}ms`,\n      nodesProcessed: this.countNodes(layoutTree),\n      averageTimePerNode: `${(layoutTime / this.countNodes(layoutTree)).toFixed(4)}ms`\n    };\n    \n    console.table(stats);\n    \n    // Detect layout thrashing\n    if (layoutTime \u003e 16) { // More than one frame\n      console.warn(`⚠️  Layout took ${layoutTime.toFixed(2)}ms, may cause jank!`);\n    }\n    \n    return stats;\n  }\n  \n  countNodes(node) {\n    if (!node) return 0;\n    return 1 + node.children.reduce((count, child) =\u003e count + this.countNodes(child), 0);\n  }\n}\n```\n{% endraw %}\n\n### 5. Paint and Composite\n\n{% raw %}\n```javascript\n// Paint and composite simulation\nclass PaintCompositeEngine {\n  constructor() {\n    this.paintTree = null;\n    this.layers = [];\n    this.paintTime = 0;\n    this.compositeTime = 0;\n  }\n  \n  createPaintTree(layoutTree) {\n    console.log('🎨 Starting paint phase...');\n    const startTime = performance.now();\n    \n    this.paintTree = this.buildPaintTree(layoutTree);\n    this.createCompositingLayers(this.paintTree);\n    \n    this.paintTime = performance.now() - startTime;\n    console.log(`✅ Paint phase completed in ${this.paintTime.toFixed(2)}ms`);\n    \n    return this.paintTree;\n  }\n  \n  buildPaintTree(layoutNode, parentPaintNode = null) {\n    if (!layoutNode) return null;\n    \n    const paintNode = {\n      layoutNode,\n      paintProperties: this.extractPaintProperties(layoutNode.computedStyle),\n      children: [],\n      parent: parentPaintNode,\n      needsNewLayer: this.shouldCreateNewLayer(layoutNode),\n      layerId: null\n    };\n    \n    // Process children\n    layoutNode.children.forEach(child =\u003e {\n      const childPaintNode = this.buildPaintTree(child, paintNode);\n      if (childPaintNode) {\n        paintNode.children.push(childPaintNode);\n      }\n    });\n    \n    return paintNode;\n  }\n  \n  extractPaintProperties(style) {\n    return {\n      backgroundColor: style.backgroundColor || 'transparent',\n      color: style.color || 'black',\n      border: {\n        width: this.parseValue(style.borderWidth || '0'),\n        color: style.borderColor || 'black',\n        style: style.borderStyle || 'solid'\n      },\n      borderRadius: this.parseValue(style.borderRadius || '0'),\n      boxShadow: style.boxShadow || 'none',\n      opacity: parseFloat(style.opacity || '1'),\n      transform: style.transform || 'none',\n      filter: style.filter || 'none'\n    };\n  }\n  \n  shouldCreateNewLayer(layoutNode) {\n    const style = layoutNode.computedStyle;\n    \n    // Conditions that create new compositing layers\n    return (\n      style.position === 'fixed' ||\n      style.position === 'sticky' ||\n      parseFloat(style.opacity || '1') \u003c 1 ||\n      style.transform !== 'none' ||\n      style.filter !== 'none' ||\n      style.zIndex !== 'auto' ||\n      style.willChange === 'transform' ||\n      style.willChange === 'opacity' ||\n      layoutNode.domNode.tagName === 'video' ||\n      layoutNode.domNode.tagName === 'canvas'\n    );\n  }\n  \n  createCompositingLayers(paintTree) {\n    console.log('🔗 Creating compositing layers...');\n    \n    this.layers = [];\n    let layerId = 0;\n    \n    this.traversePaintTree(paintTree, (paintNode) =\u003e {\n      if (paintNode.needsNewLayer || !paintNode.parent) {\n        const layer = {\n          id: layerId++,\n          paintNode,\n          elements: [],\n          bounds: this.calculateLayerBounds(paintNode),\n          needsRepaint: true,\n          isGPULayer: this.shouldUseGPU(paintNode)\n        };\n        \n        paintNode.layerId = layer.id;\n        this.layers.push(layer);\n        \n        console.log(`📋 Created layer ${layer.id} for ${paintNode.layoutNode.domNode.tagName}${layer.isGPULayer ? ' (GPU)' : ''}`);\n      } else {\n        // Inherit parent's layer\n        paintNode.layerId = paintNode.parent.layerId;\n      }\n    });\n    \n    console.log(`✅ Created ${this.layers.length} compositing layers`);\n  }\n  \n  shouldUseGPU(paintNode) {\n    const style = paintNode.layoutNode.computedStyle;\n    \n    return (\n      style.transform !== 'none' ||\n      style.opacity !== '1' ||\n      style.filter !== 'none' ||\n      paintNode.layoutNode.domNode.tagName === 'video' ||\n      paintNode.layoutNode.domNode.tagName === 'canvas' ||\n      style.willChange === 'transform' ||\n      style.willChange === 'opacity'\n    );\n  }\n  \n  calculateLayerBounds(paintNode) {\n    const box = paintNode.layoutNode.box;\n    return {\n      x: box.x,\n      y: box.y,\n      width: box.width,\n      height: box.height\n    };\n  }\n  \n  traversePaintTree(paintNode, callback) {\n    if (!paintNode) return;\n    \n    callback(paintNode);\n    paintNode.children.forEach(child =\u003e {\n      this.traversePaintTree(child, callback);\n    });\n  }\n  \n  // Simulate painting process\n  paintLayers() {\n    console.log('🖌️  Starting paint process...');\n    const startTime = performance.now();\n    \n    this.layers.forEach(layer =\u003e {\n      if (layer.needsRepaint) {\n        this.paintLayer(layer);\n        layer.needsRepaint = false;\n      }\n    });\n    \n    this.paintTime = performance.now() - startTime;\n    console.log(`🎨 Painted ${this.layers.length} layers in ${this.paintTime.toFixed(2)}ms`);\n  }\n  \n  paintLayer(layer) {\n    const paintOps = [];\n    \n    // Collect paint operations for this layer\n    this.collectPaintOperations(layer.paintNode, paintOps);\n    \n    console.log(`🖼️  Layer ${layer.id}: ${paintOps.length} paint operations`);\n    \n    // Simulate paint operations\n    paintOps.forEach(op =\u003e {\n      this.executePaintOperation(op);\n    });\n    \n    layer.paintOperations = paintOps;\n  }\n  \n  collectPaintOperations(paintNode, operations) {\n    if (!paintNode) return;\n    \n    const box = paintNode.layoutNode.box;\n    const props = paintNode.paintProperties;\n    \n    // Background\n    if (props.backgroundColor !== 'transparent') {\n      operations.push({\n        type: 'fillRect',\n        x: box.x,\n        y: box.y,\n        width: box.width,\n        height: box.height,\n        color: props.backgroundColor\n      });\n    }\n    \n    // Border\n    if (props.border.width \u003e 0) {\n      operations.push({\n        type: 'strokeRect',\n        x: box.x,\n        y: box.y,\n        width: box.width,\n        height: box.height,\n        borderWidth: props.border.width,\n        borderColor: props.border.color\n      });\n    }\n    \n    // Text content (simplified)\n    if (paintNode.layoutNode.domNode.textContent) {\n      operations.push({\n        type: 'fillText',\n        text: paintNode.layoutNode.domNode.textContent,\n        x: box.x + box.paddingLeft,\n        y: box.y + box.paddingTop,\n        color: props.color\n      });\n    }\n    \n    // Process children that belong to the same layer\n    paintNode.children.forEach(child =\u003e {\n      if (child.layerId === paintNode.layerId) {\n        this.collectPaintOperations(child, operations);\n      }\n    });\n  }\n  \n  executePaintOperation(operation) {\n    // Simulate paint operation execution time\n    const complexity = this.calculatePaintComplexity(operation);\n    const executionTime = complexity * 0.1; // Simulate time based on complexity\n    \n    // In a real browser, this would involve actual graphics APIs\n    console.log(`  🎯 ${operation.type} (${executionTime.toFixed(2)}ms)`);\n  }\n  \n  calculatePaintComplexity(operation) {\n    switch (operation.type) {\n      case 'fillRect':\n        return operation.width * operation.height / 1000;\n      case 'strokeRect':\n        return (operation.width + operation.height) * operation.borderWidth / 100;\n      case 'fillText':\n        return operation.text.length * 2;\n      default:\n        return 1;\n    }\n  }\n  \n  // Composite layers\n  composite() {\n    console.log('🔧 Starting composite phase...');\n    const startTime = performance.now();\n    \n    // Sort layers by z-index and document order\n    const sortedLayers = this.sortLayersForComposite();\n    \n    // Composite layers\n    sortedLayers.forEach((layer, index) =\u003e {\n      this.compositeLayer(layer, index);\n    });\n    \n    this.compositeTime = performance.now() - startTime;\n    console.log(`✅ Composite completed in ${this.compositeTime.toFixed(2)}ms`);\n  }\n  \n  sortLayersForComposite() {\n    return this.layers.slice().sort((a, b) =\u003e {\n      const aZIndex = parseInt(a.paintNode.layoutNode.computedStyle.zIndex || '0');\n      const bZIndex = parseInt(b.paintNode.layoutNode.computedStyle.zIndex || '0');\n      \n      if (aZIndex !== bZIndex) {\n        return aZIndex - bZIndex;\n      }\n      \n      // Fall back to document order\n      return a.id - b.id;\n    });\n  }\n  \n  compositeLayer(layer, index) {\n    const isGPULayer = layer.isGPULayer;\n    const processingType = isGPULayer ? 'GPU' : 'CPU';\n    \n    console.log(`🔄 Compositing layer ${layer.id} (${processingType})`);\n    \n    if (isGPULayer) {\n      this.compositeOnGPU(layer);\n    } else {\n      this.compositeOnCPU(layer);\n    }\n  }\n  \n  compositeOnGPU(layer) {\n    // Simulate GPU compositing\n    const operations = layer.paintOperations || [];\n    console.log(`  ⚡ GPU compositing ${operations.length} operations`);\n  }\n  \n  compositeOnCPU(layer) {\n    // Simulate CPU compositing\n    const operations = layer.paintOperations || [];\n    console.log(`  🖥️  CPU compositing ${operations.length} operations`);\n  }\n  \n  // Performance analysis\n  analyzeRenderingPerformance() {\n    const totalRenderTime = this.paintTime + this.compositeTime;\n    \n    const analysis = {\n      paintTime: `${this.paintTime.toFixed(2)}ms`,\n      compositeTime: `${this.compositeTime.toFixed(2)}ms`,\n      totalRenderTime: `${totalRenderTime.toFixed(2)}ms`,\n      layerCount: this.layers.length,\n      gpuLayers: this.layers.filter(l =\u003e l.isGPULayer).length,\n      cpuLayers: this.layers.filter(l =\u003e !l.isGPULayer).length,\n      performance: totalRenderTime \u003c 16 ? 'Good' : totalRenderTime \u003c 32 ? 'Warning' : 'Poor'\n    };\n    \n    console.log('📊 Rendering Performance Analysis:');\n    console.table(analysis);\n    \n    // Recommendations\n    if (analysis.layerCount \u003e 20) {\n      console.warn('⚠️  High layer count detected. Consider reducing compositing layers.');\n    }\n    \n    if (this.paintTime \u003e 10) {\n      console.warn('⚠️  Paint time is high. Consider optimizing paint operations.');\n    }\n    \n    if (totalRenderTime \u003e 16) {\n      console.warn('⚠️  Total render time exceeds 16ms. May cause frame drops.');\n    }\n    \n    return analysis;\n  }\n}\n```\n{% endraw %}\n\n## 🚀 Performance Optimization Techniques\n\n### 1. Critical Resource Prioritization\n\n```javascript\n// Resource priority optimization\nclass ResourcePriority {\n  static optimizeResourceLoading() {\n    // Critical CSS inlining\n    const criticalCSS = this.extractCriticalCSS();\n    this.inlineCriticalCSS(criticalCSS);\n    \n    // Preload critical resources\n    this.preloadCriticalResources();\n    \n    // Defer non-critical resources\n    this.deferNonCriticalResources();\n  }\n  \n  static extractCriticalCSS() {\n    const aboveFoldElements = document.querySelectorAll('*');\n    const criticalRules = [];\n    \n    Array.from(document.styleSheets).forEach(stylesheet =\u003e {\n      try {\n        Array.from(stylesheet.cssRules).forEach(rule =\u003e {\n          if (this.isRuleCritical(rule, aboveFoldElements)) {\n            criticalRules.push(rule.cssText);\n          }\n        });\n      } catch (e) {\n        console.warn('Cannot access stylesheet:', e);\n      }\n    });\n    \n    return criticalRules.join('\\n');\n  }\n  \n  static isRuleCritical(rule, elements) {\n    if (rule.type !== CSSRule.STYLE_RULE) return false;\n    \n    try {\n      return Array.from(elements).some(el =\u003e el.matches(rule.selectorText));\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  static preloadCriticalResources() {\n    const criticalResources = [\n      { href: '/critical-font.woff2', as: 'font', type: 'font/woff2' },\n      { href: '/hero-image.jpg', as: 'image' },\n      { href: '/critical-script.js', as: 'script' }\n    ];\n    \n    criticalResources.forEach(resource =\u003e {\n      const link = document.createElement('link');\n      link.rel = 'preload';\n      link.href = resource.href;\n      link.as = resource.as;\n      if (resource.type) link.type = resource.type;\n      if (resource.as === 'font') link.crossOrigin = 'anonymous';\n      \n      document.head.appendChild(link);\n    });\n  }\n  \n  static deferNonCriticalResources() {\n    // Defer non-critical CSS\n    const nonCriticalCSS = document.querySelectorAll('link[rel=\"stylesheet\"]:not([data-critical])');\n    nonCriticalCSS.forEach(link =\u003e {\n      link.media = 'print';\n      link.onload = () =\u003e { link.media = 'all'; };\n    });\n    \n    // Lazy load non-critical scripts\n    const nonCriticalScripts = document.querySelectorAll('script[data-defer]');\n    nonCriticalScripts.forEach(script =\u003e {\n      script.defer = true;\n    });\n  }\n}\n```\n\n### 2. Layout Optimization\n\n{% raw %}\n```javascript\n// Layout optimization utilities\nclass LayoutOptimizer {\n  static measureLayoutShift() {\n    let clsValue = 0;\n    let clsEntries = [];\n    \n    const observer = new PerformanceObserver((entryList) =\u003e {\n      for (const entry of entryList.getEntries()) {\n        if (!entry.hadRecentInput) {\n          clsValue += entry.value;\n          clsEntries.push(entry);\n        }\n      }\n    });\n    \n    observer.observe({ type: 'layout-shift', buffered: true });\n    \n    setTimeout(() =\u003e {\n      observer.disconnect();\n      console.log('Cumulative Layout Shift:', clsValue);\n      console.log('CLS Entries:', clsEntries);\n      \n      if (clsValue \u003e 0.1) {\n        console.warn('⚠️  High CLS detected! Consider fixing layout shifts.');\n        this.analyzeLayoutShifts(clsEntries);\n      }\n    }, 5000);\n  }\n  \n  static analyzeLayoutShifts(entries) {\n    entries.forEach((entry, index) =\u003e {\n      console.log(`Layout Shift ${index + 1}:`);\n      console.log(`  Value: ${entry.value}`);\n      console.log(`  Time: ${entry.startTime}ms`);\n      \n      entry.sources.forEach(source =\u003e {\n        console.log(`  Affected element:`, source.node);\n        console.log(`  Previous rect:`, source.previousRect);\n        console.log(`  Current rect:`, source.currentRect);\n      });\n    });\n  }\n  \n  static preventLayoutShifts() {\n    // Reserve space for images\n    this.reserveImageSpace();\n    \n    // Set font display swap\n    this.optimizeFontLoading();\n    \n    // Prevent ad-related shifts\n    this.reserveAdSpace();\n  }\n  \n  static reserveImageSpace() {\n    const images = document.querySelectorAll('img[data-src]');\n    images.forEach(img =\u003e {\n      if (!img.style.aspectRatio) {\n        const width = img.getAttribute('width');\n        const height = img.getAttribute('height');\n        \n        if (width \u0026\u0026 height) {\n          img.style.aspectRatio = `${width} / ${height}`;\n        }\n      }\n    });\n  }\n  \n  static optimizeFontLoading() {\n    const fontFaces = document.fonts;\n    \n    fontFaces.forEach(font =\u003e {\n      if (font.display !== 'swap') {\n        console.warn(`Font ${font.family} should use font-display: swap`);\n      }\n    });\n  }\n}\n```\n{% endraw %}\n\n## 🧠 Interview Questions and Scenarios\n\n### 1. Performance Debugging\n\n**Question**: \"The page is slow to load. How would you debug it?\"\n\n**Answer Framework**:\n\n{% raw %}\n```javascript\nclass PerformanceDebugger {\n  static debugSlowPage() {\n    console.log('🔍 Starting performance debugging...');\n    \n    // 1. Check Core Web Vitals\n    this.measureCoreWebVitals();\n    \n    // 2. Analyze network waterfall\n    this.analyzeNetworkWaterfall();\n    \n    // 3. Check rendering performance\n    this.analyzeRenderingPerformance();\n    \n    // 4. Identify JavaScript bottlenecks\n    this.analyzeJavaScriptPerformance();\n    \n    // 5. Check memory usage\n    this.analyzeMemoryUsage();\n  }\n  \n  static measureCoreWebVitals() {\n    // LCP (Largest Contentful Paint)\n    new PerformanceObserver((entryList) =\u003e {\n      const entries = entryList.getEntries();\n      const lastEntry = entries[entries.length - 1];\n      console.log('LCP:', lastEntry.startTime);\n    }).observe({ type: 'largest-contentful-paint', buffered: true });\n    \n    // FID (First Input Delay)\n    new PerformanceObserver((entryList) =\u003e {\n      for (const entry of entryList.getEntries()) {\n        console.log('FID:', entry.processingStart - entry.startTime);\n      }\n    }).observe({ type: 'first-input', buffered: true });\n    \n    // CLS (Cumulative Layout Shift)\n    LayoutOptimizer.measureLayoutShift();\n  }\n  \n  static analyzeNetworkWaterfall() {\n    const resources = performance.getEntriesByType('resource');\n    \n    // Find slow resources\n    const slowResources = resources.filter(r =\u003e r.duration \u003e 1000);\n    if (slowResources.length \u003e 0) {\n      console.warn('Slow resources detected:', slowResources);\n    }\n    \n    // Check for render-blocking resources\n    const renderBlocking = resources.filter(r =\u003e \n      r.name.includes('.css') \u0026\u0026 r.startTime \u003c 1000\n    );\n    \n    if (renderBlocking.length \u003e 3) {\n      console.warn('Too many render-blocking CSS files:', renderBlocking);\n    }\n  }\n  \n  static analyzeRenderingPerformance() {\n    // Check for expensive layout operations\n    const measureEntries = performance.getEntriesByType('measure');\n    const layoutMeasures = measureEntries.filter(m =\u003e m.name.includes('layout'));\n    \n    layoutMeasures.forEach(measure =\u003e {\n      if (measure.duration \u003e 16) {\n        console.warn(`Expensive layout operation: ${measure.name} (${measure.duration}ms)`);\n      }\n    });\n  }\n  \n  static analyzeJavaScriptPerformance() {\n    // Check for long tasks\n    new PerformanceObserver((entryList) =\u003e {\n      for (const entry of entryList.getEntries()) {\n        console.warn(`Long task detected: ${entry.duration}ms`);\n        \n        if (entry.attribution) {\n          console.log('Attribution:', entry.attribution);\n        }\n      }\n    }).observe({ type: 'longtask', buffered: true });\n  }\n  \n  static analyzeMemoryUsage() {\n    if ('memory' in performance) {\n      const memory = performance.memory;\n      const memoryUsage = {\n        used: `${(memory.usedJSHeapSize / 1048576).toFixed(2)} MB`,\n        total: `${(memory.totalJSHeapSize / 1048576).toFixed(2)} MB`,\n        limit: `${(memory.jsHeapSizeLimit / 1048576).toFixed(2)} MB`\n      };\n      \n      console.table(memoryUsage);\n      \n      if (memory.usedJSHeapSize / memory.jsHeapSizeLimit \u003e 0.9) {\n        console.warn('⚠️  High memory usage detected!');\n      }\n    }\n  }\n}\n```\n{% endraw %}\n\n### 2. Rendering Pipeline Questions\n\n**Question**: \"What happens when you change a CSS property?\"\n\n**Answer**: Different CSS properties trigger different stages of the rendering pipeline:\n\n{% raw %}\n```javascript\nclass RenderingPipelineAnalyzer {\n  static analyzeCSSPropertyImpact(property, value) {\n    const propertyImpacts = {\n      // Layout-triggering properties\n      'width': ['layout', 'paint', 'composite'],\n      'height': ['layout', 'paint', 'composite'],\n      'padding': ['layout', 'paint', 'composite'],\n      'margin': ['layout', 'paint', 'composite'],\n      'display': ['layout', 'paint', 'composite'],\n      'position': ['layout', 'paint', 'composite'],\n      'float': ['layout', 'paint', 'composite'],\n      'clear': ['layout', 'paint', 'composite'],\n      \n      // Paint-triggering properties\n      'color': ['paint', 'composite'],\n      'background': ['paint', 'composite'],\n      'border': ['paint', 'composite'],\n      'box-shadow': ['paint', 'composite'],\n      'border-radius': ['paint', 'composite'],\n      'visibility': ['paint', 'composite'],\n      \n      // Composite-only properties\n      'transform': ['composite'],\n      'opacity': ['composite'],\n      'filter': ['composite'],\n      'will-change': ['composite']\n    };\n    \n    const impact = propertyImpacts[property] || ['unknown'];\n    \n    console.log(`🎯 Changing ${property} will trigger:`, impact);\n    \n    const performance = this.getPerformanceRating(impact);\n    console.log(`📊 Performance impact: ${performance}`);\n    \n    return { property, value, impact, performance };\n  }\n  \n  static getPerformanceRating(impact) {\n    if (impact.includes('layout')) return 'High (Avoid in animations)';\n    if (impact.includes('paint')) return 'Medium (Use sparingly)';\n    if (impact.includes('composite')) return 'Low (Good for animations)';\n    return 'Unknown';\n  }\n  \n  static demonstrateOptimalAnimations() {\n    console.log('✅ Optimal CSS properties for animations:');\n    \n    const optimalProperties = [\n      'transform: translateX(100px)',\n      'transform: scale(1.2)',\n      'transform: rotate(45deg)',\n      'opacity: 0.5',\n      'filter: blur(5px)'\n    ];\n    \n    optimalProperties.forEach(prop =\u003e {\n      console.log(`  ${prop} - Composite only`);\n    });\n    \n    console.log('\\n❌ Avoid these properties in animations:');\n    \n    const avoidProperties = [\n      'width/height - Triggers layout',\n      'padding/margin - Triggers layout',\n      'top/left - Triggers layout',\n      'background-color - Triggers paint',\n      'border-width - Triggers layout'\n    ];\n    \n    avoidProperties.forEach(prop =\u003e {\n      console.log(`  ${prop}`);\n    });\n  }\n}\n```\n{% endraw %}\n\nThis comprehensive guide provides deep insights into browser architecture and rendering pipeline, essential knowledge for frontend interviews at big tech companies. The practical examples and performance debugging techniques demonstrate real-world application of these concepts.\n"])</script><script>self.__next_f.push([1,"8:[\"slug\",\"src/content/theory/browser-rendering-pipeline-deep-dive\",\"c\"]\nd:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L3\",null,{\"buildId\":\"fjDGwqtt1UnBZeA2uH4xO\",\"assetPrefix\":\"/interview\",\"urlParts\":[\"\",\"docs\",\"src\",\"content\",\"theory\",\"browser-rendering-pipeline-deep-dive\"],\"initialTree\":[\"\",{\"children\":[\"docs\",{\"children\":[[\"slug\",\"src/content/theory/browser-rendering-pipeline-deep-dive\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"src\\\",\\\"content\\\",\\\"theory\\\",\\\"browser-rendering-pipeline-deep-dive\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"docs\",{\"children\":[[\"slug\",\"src/content/theory/browser-rendering-pipeline-deep-dive\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L4\",[\"$\",\"div\",null,{\"style\":{\"maxWidth\":\"1200px\",\"margin\":\"0 auto\",\"padding\":\"2rem\",\"paddingTop\":\"6rem\"},\"children\":[[\"$\",\"div\",null,{\"style\":{\"marginBottom\":\"2rem\"},\"children\":[[\"$\",\"nav\",null,{\"style\":{\"color\":\"#64748b\",\"fontSize\":\"0.9rem\",\"marginBottom\":\"1rem\"},\"children\":[[\"$\",\"a\",null,{\"href\":\"/interview\",\"style\":{\"color\":\"#3b82f6\",\"textDecoration\":\"none\"},\"children\":\"Home\"}],\" \u003e \",[\"$\",\"span\",null,{\"children\":\"src \u003e content \u003e theory \u003e browser-rendering-pipeline-deep-dive\"}]]}],[\"$\",\"h1\",null,{\"style\":{\"fontSize\":\"2.5rem\",\"fontWeight\":\"800\",\"marginBottom\":\"0.5rem\",\"color\":\"#1e293b\"},\"children\":\"Browser Architecture and Rendering Pipeline Deep Dive\"}],[\"$\",\"div\",null,{\"style\":{\"color\":\"#64748b\",\"fontSize\":\"0.9rem\",\"marginBottom\":\"2rem\"},\"children\":[[\"$\",\"span\",null,{\"children\":[\"📁 \",\"src/content/theory/browser-rendering-pipeline-deep-dive.md\"]}],\"$undefined\",\"$undefined\"]}]]}],[\"$\",\"$L5\",null,{\"content\":\"$6\"}]]}],null],null],null]},[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"docs\",\"children\",\"$8\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[null,[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"docs\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/interview/_next/static/css/387024c6a2216908.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$\",\"$L7\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L9\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}],\"params\":{}}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$Lb\"],\"globalErrorComponent\":\"$c\",\"missingSlots\":\"$Wd\"}]\n"])</script><script>self.__next_f.push([1,"b:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Browser Architecture and Rendering Pipeline Deep Dive - Frontend Interview Docs\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Comprehensive guide to browser internals, rendering pipeline, performance optimization, and debugging techniques for frontend interviews\"}],[\"$\",\"meta\",\"4\",{\"property\":\"og:title\",\"content\":\"Browser Architecture and Rendering Pipeline Deep Dive - Frontend Interview Docs\"}],[\"$\",\"meta\",\"5\",{\"property\":\"og:description\",\"content\":\"Comprehensive guide to browser internals, rendering pipeline, performance optimization, and debugging techniques for frontend interviews\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"$\",\"meta\",\"7\",{\"name\":\"twitter:card\",\"content\":\"summary\"}],[\"$\",\"meta\",\"8\",{\"name\":\"twitter:title\",\"content\":\"Browser Architecture and Rendering Pipeline Deep Dive - Frontend Interview Docs\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:description\",\"content\":\"Comprehensive guide to browser internals, rendering pipeline, performance optimization, and debugging techniques for frontend interviews\"}],[\"$\",\"meta\",\"10\",{\"name\":\"next-size-adjust\"}]]\n4:null\n"])</script></body></html>