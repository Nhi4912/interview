2:I[5907,["918","static/chunks/918-3273b83890f10546.js","930","static/chunks/930-3262a6c9c5acace4.js","687","static/chunks/app/docs/%5B...slug%5D/page-32962e9542d32755.js"],"default"]
4:I[4707,[],""]
6:I[6423,[],""]
7:I[2,["918","static/chunks/918-3273b83890f10546.js","710","static/chunks/710-dfaa11b4dff08f8e.js","972","static/chunks/972-011bba60ed155615.js","233","static/chunks/233-3e0c1d820a17eca9.js","185","static/chunks/app/layout-333f4adcd11f8f39.js"],"default",1]
3:T38d5,
# Design Hit Counter



## Problem Description

 *  * Design a hit counter which counts the number of hits received in the past 5 minutes (i.e., the past 300 seconds).  *  * Your system should accept a timestamp parameter (in seconds granularity), and you may assume that calls are being made to the system in chronological order (i.e., timestamp is monotonically increasing). You may also assume that the earliest timestamp starts at 1.  * 

## Solutions

{% raw %}
/**
 * Design Hit Counter
 *
 * Problem: https://leetcode.com/problems/design-hit-counter/
 *
 * Design a hit counter which counts the number of hits received in the past 5 minutes (i.e., the past 300 seconds).
 *
 * Your system should accept a timestamp parameter (in seconds granularity), and you may assume that calls are being made to the system in chronological order (i.e., timestamp is monotonically increasing). You may also assume that the earliest timestamp starts at 1.
 *
 * Implement the HitCounter class:
 * - HitCounter() Initializes the object of the hit counter system.
 * - void hit(int timestamp) Records a hit that happened at timestamp (in seconds). Several hits may happen at the same timestamp.
 * - int getHits(int timestamp) Returns the number of hits in the past 5 minutes from timestamp (i.e., the past 300 seconds).
 *
 * Example 1:
 * Input: ["HitCounter", "hit", "hit", "hit", "getHits", "hit", "getHits", "getHits"]
 * [[], [1], [2], [3], [4], [300], [300], [301]]
 * Output: [null, null, null, null, 3, null, 4, 3]
 *
 * Explanation:
 * HitCounter hitCounter = new HitCounter();
 * hitCounter.hit(1);       // hit at timestamp 1.
 * hitCounter.hit(2);       // hit at timestamp 2.
 * hitCounter.hit(3);       // hit at timestamp 3.
 * hitCounter.getHits(4);   // get hits at timestamp 4, return 3.
 * hitCounter.hit(300);     // hit at timestamp 300.
 * hitCounter.getHits(300); // get hits at timestamp 300, return 4.
 * hitCounter.getHits(301); // get hits at timestamp 301, return 3.
 *
 * Constraints:
 * - 1 <= timestamp <= 2 * 10^9
 * - All the calls are being made to the system in chronological order (i.e., timestamp is monotonically increasing).
 * - At most 300 calls will be made to hit and getHits.
 *
 * Solution Approach:
 * 1. Use a queue to store timestamps
 * 2. Remove expired timestamps (older than 300 seconds) when getting hits
 * 3. Alternative: Use circular buffer for better performance
 * 4. Alternative: Use sliding window with buckets
 *
 * Time Complexity: O(1) average for hit, O(k) for getHits where k is expired hits
 * Space Complexity: O(n) where n is the number of hits in the window
 */

/**
 * HitCounter class using Queue
 *
 * L·ªõp HitCounter s·ª≠ d·ª•ng Queue
 */
class HitCounter {
  private queue: number[];

  constructor() {
    this.queue = [];
  }

  /**
   * Record a hit at the given timestamp
   *
   * Ghi l·∫°i m·ªôt hit t·∫°i timestamp cho tr∆∞·ªõc
   *
   * @param timestamp - Timestamp in seconds
   */
  hit(timestamp: number): void {
    this.queue.push(timestamp);
  }

  /**
   * Get number of hits in the past 5 minutes
   *
   * L·∫•y s·ªë l∆∞·ª£ng hits trong 5 ph√∫t qua
   *
   * @param timestamp - Current timestamp
   * @returns Number of hits in the past 300 seconds
   */
  getHits(timestamp: number): number {
    // Remove expired timestamps
    while (this.queue.length > 0 && this.queue[0] <= timestamp - 300) {
      this.queue.shift();
    }

    return this.queue.length;
  }

  /**
   * Get all hits in the window
   *
   * L·∫•y t·∫•t c·∫£ hits trong c·ª≠a s·ªï
   *
   * @param timestamp - Current timestamp
   * @returns Array of timestamps in the window
   */
  getHitsInWindow(timestamp: number): number[] {
    // Remove expired timestamps
    while (this.queue.length > 0 && this.queue[0] <= timestamp - 300) {
      this.queue.shift();
    }

    return [...this.queue];
  }
}

/**
 * Alternative Implementation: Using Circular Buffer
 *
 * Gi·∫£i ph√°p thay th·∫ø: S·ª≠ d·ª•ng Circular Buffer
 */
class HitCounterCircular {
  private timestamps: number[];
  private hits: number[];
  private total: number;
  private lastTimestamp: number;

  constructor() {
    this.timestamps = new Array(300).fill(0);
    this.hits = new Array(300).fill(0);
    this.total = 0;
    this.lastTimestamp = 0;
  }

  hit(timestamp: number): void {
    this.update(timestamp);
    const index = timestamp % 300;

    if (this.timestamps[index] === timestamp) {
      this.hits[index]++;
    } else {
      this.timestamps[index] = timestamp;
      this.hits[index] = 1;
    }

    this.total++;
  }

  getHits(timestamp: number): number {
    this.update(timestamp);
    return this.total;
  }

  private update(timestamp: number): void {
    const diff = timestamp - this.lastTimestamp;

    if (diff >= 300) {
      // All previous hits are expired
      this.timestamps.fill(0);
      this.hits.fill(0);
      this.total = 0;
    } else {
      // Remove expired hits
      for (let i = 0; i < diff; i++) {
        const index = (this.lastTimestamp - i) % 300;
        if (this.timestamps[index] === this.lastTimestamp - i) {
          this.total -= this.hits[index];
          this.hits[index] = 0;
        }
      }
    }

    this.lastTimestamp = timestamp;
  }
}

/**
 * Implementation with Statistics
 *
 * Gi·∫£i ph√°p v·ªõi th·ªëng k√™
 */
class HitCounterWithStats extends HitCounter {
  private hitCount: number;
  private getHitsCount: number;
  private totalHits: number;

  constructor() {
    super();
    this.hitCount = 0;
    this.getHitsCount = 0;
    this.totalHits = 0;
  }

  hit(timestamp: number): void {
    super.hit(timestamp);
    this.hitCount++;
    this.totalHits++;
  }

  getHits(timestamp: number): number {
    this.getHitsCount++;
    return super.getHits(timestamp);
  }

  /**
   * Get statistics about the hit counter
   *
   * L·∫•y th·ªëng k√™ v·ªÅ hit counter
   *
   * @returns Object containing statistics
   */
  getStats(): {
    totalHits: number;
    hitCalls: number;
    getHitsCalls: number;
    currentWindowSize: number;
  } {
    return {
      totalHits: this.totalHits,
      hitCalls: this.hitCount,
      getHitsCalls: this.getHitsCount,
      currentWindowSize: this.getHitsInWindow(Date.now() / 1000).length,
    };
  }

  /**
   * Get hit distribution in the current window
   *
   * L·∫•y ph√¢n b·ªë hits trong c·ª≠a s·ªï hi·ªán t·∫°i
   *
   * @param timestamp - Current timestamp
   * @returns Map of timestamp -> hit count
   */
  getHitDistribution(timestamp: number): Map<number, number> {
    const hits = this.getHitsInWindow(timestamp);
    const distribution = new Map<number, number>();

    for (const hit of hits) {
      distribution.set(hit, (distribution.get(hit) || 0) + 1);
    }

    return distribution;
  }
}

/**
 * Implementation with Sliding Window
 *
 * Gi·∫£i ph√°p v·ªõi c·ª≠a s·ªï tr∆∞·ª£t
 */
class HitCounterSlidingWindow {
  private window: number;
  private hits: Map<number, number>;

  constructor(windowSize: number = 300) {
    this.window = windowSize;
    this.hits = new Map();
  }

  hit(timestamp: number): void {
    this.hits.set(timestamp, (this.hits.get(timestamp) || 0) + 1);
  }

  getHits(timestamp: number): number {
    let count = 0;
    const startTime = timestamp - this.window + 1;

    // Remove expired entries and count hits
    for (const [time, hitCount] of this.hits.entries()) {
      if (time < startTime) {
        this.hits.delete(time);
      } else {
        count += hitCount;
      }
    }

    return count;
  }

  /**
   * Get hits in a specific time range
   *
   * L·∫•y hits trong m·ªôt kho·∫£ng th·ªùi gian c·ª• th·ªÉ
   *
   * @param start - Start timestamp
   * @param end - End timestamp
   * @returns Number of hits in the range
   */
  getHitsInRange(start: number, end: number): number {
    let count = 0;

    for (const [time, hitCount] of this.hits.entries()) {
      if (time >= start && time <= end) {
        count += hitCount;
      }
    }

    return count;
  }
}

// Test cases / C√°c tr∆∞·ªùng h·ª£p ki·ªÉm th·ª≠
function runTests() {
  console.log("=== Design Hit Counter Tests ===");
  console.log("=== Ki·ªÉm th·ª≠ b√†i to√°n Thi·∫øt k·∫ø Hit Counter ===\n");

  const testCases = [
    {
      name: "Example 1: Standard case",
      operations: [
        { type: "hit", timestamp: 1 },
        { type: "hit", timestamp: 2 },
        { type: "hit", timestamp: 3 },
        { type: "getHits", timestamp: 4, expected: 3 },
        { type: "hit", timestamp: 300 },
        { type: "getHits", timestamp: 300, expected: 4 },
        { type: "getHits", timestamp: 301, expected: 3 },
      ],
      description: "Standard hit counter operations",
    },
    {
      name: "Empty window",
      operations: [
        { type: "getHits", timestamp: 100, expected: 0 },
        { type: "hit", timestamp: 100 },
        { type: "getHits", timestamp: 100, expected: 1 },
        { type: "getHits", timestamp: 400, expected: 0 },
      ],
      description: "Testing empty window and expiration",
    },
    {
      name: "Multiple hits at same timestamp",
      operations: [
        { type: "hit", timestamp: 1 },
        { type: "hit", timestamp: 1 },
        { type: "hit", timestamp: 1 },
        { type: "getHits", timestamp: 1, expected: 3 },
        { type: "getHits", timestamp: 301, expected: 0 },
      ],
      description: "Multiple hits at the same timestamp",
    },
    {
      name: "Large timestamps",
      operations: [
        { type: "hit", timestamp: 1000000 },
        { type: "hit", timestamp: 1000001 },
        { type: "getHits", timestamp: 1000300, expected: 0 },
        { type: "getHits", timestamp: 1000002, expected: 2 },
      ],
      description: "Testing with large timestamp values",
    },
  ];

  for (const testCase of testCases) {
    console.log(`Test: ${testCase.name}`);
    console.log(`Description: ${testCase.description}`);

    const hitCounter = new HitCounterWithStats();
    let testPassed = true;

    for (let i = 0; i < testCase.operations.length; i++) {
      const operation = testCase.operations[i];
      let result: any;

      switch (operation.type) {
        case "hit":
          hitCounter.hit(operation.timestamp);
          console.log(`  ${i + 1}. hit(${operation.timestamp})`);
          break;
        case "getHits":
          result = hitCounter.getHits(operation.timestamp);
          const passed = result === operation.expected;
          console.log(
            `  ${i + 1}. getHits(${operation.timestamp}) -> ${result} ${
              passed ? "‚úÖ" : "‚ùå"
            }`
          );

          if (!passed) {
            testPassed = false;
            console.log(`    Expected: ${operation.expected}, Got: ${result}`);
          }
          break;
      }
    }

    console.log(`Test ${testPassed ? "PASSED" : "FAILED"}`);

    // Show statistics
    const stats = hitCounter.getStats();
    console.log(
      `Stats: Total hits: ${stats.totalHits}, Hit calls: ${stats.hitCalls}, GetHits calls: ${stats.getHitsCalls}`
    );

    console.log("---");
  }

  // Test different implementations
  console.log("\n=== Implementation Comparison ===");
  console.log("=== So s√°nh c√°c gi·∫£i ph√°p ===\n");

  const testOperations = [
    { type: "hit", timestamp: 1 },
    { type: "hit", timestamp: 2 },
    { type: "hit", timestamp: 3 },
    { type: "getHits", timestamp: 4 },
    { type: "hit", timestamp: 300 },
    { type: "getHits", timestamp: 300 },
    { type: "getHits", timestamp: 301 },
  ];

  const implementations = [
    { name: "Queue", class: HitCounter },
    { name: "Circular Buffer", class: HitCounterCircular },
    { name: "Sliding Window", class: HitCounterSlidingWindow },
  ];

  for (const impl of implementations) {
    console.log(`Testing ${impl.name} implementation:`);
    const counter = new impl.class();

    for (const operation of testOperations) {
      if (operation.type === "hit") {
        counter.hit(operation.timestamp);
      } else {
        const result = counter.getHits(operation.timestamp);
        console.log(`  getHits(${operation.timestamp}) -> ${result}`);
      }
    }
    console.log("");
  }

  // Performance comparison
  console.log("\n=== Performance Comparison ===");
  console.log("=== So s√°nh hi·ªáu su·∫•t ===\n");

  const largeTestSize = 10000;

  console.log(`Testing with ${largeTestSize} operations...`);
  console.log(`Ki·ªÉm th·ª≠ v·ªõi ${largeTestSize} thao t√°c...`);

  // Test Queue implementation
  const start1 = performance.now();
  const queueCounter = new HitCounter();
  for (let i = 0; i < largeTestSize; i++) {
    if (i % 3 === 0) {
      queueCounter.getHits(i);
    } else {
      queueCounter.hit(i);
    }
  }
  const time1 = performance.now() - start1;

  // Test Circular Buffer implementation
  const start2 = performance.now();
  const circularCounter = new HitCounterCircular();
  for (let i = 0; i < largeTestSize; i++) {
    if (i % 3 === 0) {
      circularCounter.getHits(i);
    } else {
      circularCounter.hit(i);
    }
  }
  const time2 = performance.now() - start2;

  // Test Sliding Window implementation
  const start3 = performance.now();
  const slidingCounter = new HitCounterSlidingWindow();
  for (let i = 0; i < largeTestSize; i++) {
    if (i % 3 === 0) {
      slidingCounter.getHits(i);
    } else {
      slidingCounter.hit(i);
    }
  }
  const time3 = performance.now() - start3;

  console.log(`Queue: ${time1.toFixed(4)}ms`);
  console.log(`Circular Buffer: ${time2.toFixed(4)}ms`);
  console.log(`Sliding Window: ${time3.toFixed(4)}ms`);

  // Test hit distribution
  console.log("\n=== Hit Distribution Analysis ===");
  console.log("=== Ph√¢n t√≠ch ph√¢n b·ªë hits ===\n");

  const statsCounter = new HitCounterWithStats();

  // Simulate some hits
  for (let i = 1; i <= 10; i++) {
    statsCounter.hit(i);
    if (i % 3 === 0) {
      statsCounter.hit(i); // Double hits at multiples of 3
    }
  }

  const distribution = statsCounter.getHitDistribution(10);
  console.log("Hit distribution in window [1-10]:");
  for (const [timestamp, count] of distribution.entries()) {
    console.log(`  Timestamp ${timestamp}: ${count} hits`);
  }

  const stats = statsCounter.getStats();
  console.log(
    `\nOverall stats: ${stats.totalHits} total hits, ${stats.hitCalls} hit calls, ${stats.getHitsCalls} getHits calls`
  );
}

// Run tests if this file is executed directly
if (require.main === module) {
  runTests();
}

export {
  HitCounter,
  HitCounterCircular,
  HitCounterWithStats,
  HitCounterSlidingWindow,
};
{% endraw %}
5:["slug","leetcode/design/problems/07-design-hit-counter","c"]
0:["GkGybauu5extr5oVPcZnD",[[["",{"children":["docs",{"children":[["slug","leetcode/design/problems/07-design-hit-counter","c"],{"children":["__PAGE__?{\"slug\":[\"leetcode\",\"design\",\"problems\",\"07-design-hit-counter\"]}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["docs",{"children":[["slug","leetcode/design/problems/07-design-hit-counter","c"],{"children":["__PAGE__",{},[["$L1",["$","div",null,{"style":{"maxWidth":"1200px","margin":"0 auto","padding":"2rem","paddingTop":"6rem"},"children":[["$","div",null,{"style":{"marginBottom":"2rem"},"children":[["$","nav",null,{"style":{"color":"#64748b","fontSize":"0.9rem","marginBottom":"1rem"},"children":[["$","a",null,{"href":"/interview","style":{"color":"#3b82f6","textDecoration":"none"},"children":"Home"}]," > ",["$","span",null,{"children":"leetcode > design > problems > 07-design-hit-counter"}]]}],["$","h1",null,{"style":{"fontSize":"2.5rem","fontWeight":"800","marginBottom":"0.5rem","color":"#1e293b"},"children":"Design Hit Counter"}],["$","div",null,{"style":{"color":"#64748b","fontSize":"0.9rem","marginBottom":"2rem"},"children":[["$","span",null,{"children":["üìÅ ","leetcode/design/problems/07-design-hit-counter.md"]}],"$undefined","$undefined"]}]]}],["$","$L2",null,{"content":"$3"}]]}],null],null],null]},[null,["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","docs","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","docs","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/interview/_next/static/css/387024c6a2216908.css","precedence":"next","crossOrigin":"$undefined"}]],["$","$L7",null,{"children":["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}],"params":{}}]],null],null],["$L8",null]]]]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Design Hit Counter - Frontend Interview Docs"}],["$","meta","3",{"name":"description","content":" # Design Hit Counter    ## Problem Description   *  * Design a hit counter which counts the number of hits received in the past 5 minutes (i.e., the past 300 s"}],["$","meta","4",{"property":"og:title","content":"Design Hit Counter - Frontend Interview Docs"}],["$","meta","5",{"property":"og:description","content":" # Design Hit Counter    ## Problem Description   *  * Design a hit counter which counts the number of hits received in the past 5 minutes (i.e., the past 300 s"}],["$","meta","6",{"property":"og:type","content":"article"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"Design Hit Counter - Frontend Interview Docs"}],["$","meta","9",{"name":"twitter:description","content":" # Design Hit Counter    ## Problem Description   *  * Design a hit counter which counts the number of hits received in the past 5 minutes (i.e., the past 300 s"}],["$","meta","10",{"name":"next-size-adjust"}]]
1:null
