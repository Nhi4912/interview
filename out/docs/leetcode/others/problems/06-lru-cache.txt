2:I[5907,["918","static/chunks/918-3273b83890f10546.js","930","static/chunks/930-3262a6c9c5acace4.js","687","static/chunks/app/docs/%5B...slug%5D/page-32962e9542d32755.js"],"default"]
4:I[4707,[],""]
6:I[6423,[],""]
7:I[2,["918","static/chunks/918-3273b83890f10546.js","710","static/chunks/710-dfaa11b4dff08f8e.js","972","static/chunks/972-011bba60ed155615.js","233","static/chunks/233-3e0c1d820a17eca9.js","185","static/chunks/app/layout-333f4adcd11f8f39.js"],"default",1]
3:T38d6,
# LRU Cache



## Problem Description

 *  * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  *  * Implement the LRUCache class:  * - LRUCache(int capacity) Initialize the LRU cache with positive size capacity. 

## Solutions

{% raw %}
/**
 * LRU Cache
 *
 * Problem: https://leetcode.com/problems/lru-cache/
 *
 * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
 *
 * Implement the LRUCache class:
 * - LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
 * - int get(int key) Return the value of the key if the key exists, otherwise return -1.
 * - void put(int key, int value) Update the value of the key if the key exists. Otherwise,
 *   add the key-value pair to the cache. If the number of keys exceeds the capacity from
 *   this operation, evict the least recently used key.
 *
 * The functions get and put must each run in O(1) average time complexity.
 *
 * Example 1:
 * Input:
 * ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
 * [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
 * Output: [null, null, null, 1, null, -1, null, -1, 3, 4]
 *
 * Explanation:
 * LRUCache lRUCache = new LRUCache(2);
 * lRUCache.put(1, 1); // cache is {1=1}
 * lRUCache.put(2, 2); // cache is {1=1, 2=2}
 * lRUCache.get(1);    // return 1
 * lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
 * lRUCache.get(2);    // returns -1 (not found)
 * lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
 * lRUCache.get(1);    // return -1 (not found)
 * lRUCache.get(3);    // return 3
 * lRUCache.get(4);    // return 4
 *
 * Constraints:
 * - 1 <= capacity <= 3000
 * - 0 <= key <= 10^4
 * - 0 <= value <= 10^5
 * - At most 2 * 10^5 calls will be made to get and put.
 *
 * Solution Approaches:
 * 1. HashMap + Doubly Linked List
 * 2. Using Map (built-in LRU behavior in some languages)
 * 3. Array-based implementation (for small capacity)
 * 4. With eviction statistics
 *
 * Time Complexity: O(1) for get and put operations
 * Space Complexity: O(capacity)
 */

/**
 * Doubly Linked List Node
 */
class ListNode {
  key: number;
  value: number;
  prev: ListNode | null;
  next: ListNode | null;

  constructor(key: number, value: number) {
    this.key = key;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
}

/**
 * LRU Cache - HashMap + Doubly Linked List Implementation
 *
 * LRU Cache - Tri·ªÉn khai HashMap + Doubly Linked List
 *
 * This approach uses a HashMap for O(1) lookups and a doubly linked list
 * to maintain the order of recently used items
 */
class LRUCache {
  private capacity: number;
  private cache: Map<number, ListNode>;
  private head: ListNode;
  private tail: ListNode;

  constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();

    // Initialize dummy head and tail nodes
    this.head = new ListNode(0, 0);
    this.tail = new ListNode(0, 0);
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }

  /**
   * Get value by key
   * L·∫•y gi√° tr·ªã theo kh√≥a
   */
  get(key: number): number {
    const node = this.cache.get(key);

    if (!node) {
      return -1;
    }

    // Move to front (most recently used)
    this.moveToFront(node);

    return node.value;
  }

  /**
   * Put key-value pair
   * ƒê·∫∑t c·∫∑p kh√≥a-gi√° tr·ªã
   */
  put(key: number, value: number): void {
    const existingNode = this.cache.get(key);

    if (existingNode) {
      // Update existing node
      existingNode.value = value;
      this.moveToFront(existingNode);
    } else {
      // Create new node
      const newNode = new ListNode(key, value);
      this.cache.set(key, newNode);
      this.addToFront(newNode);

      // Check capacity and evict if necessary
      if (this.cache.size > this.capacity) {
        this.evictLRU();
      }
    }
  }

  /**
   * Move node to front of list (most recently used)
   * Di chuy·ªÉn node l√™n ƒë·∫ßu danh s√°ch (s·ª≠ d·ª•ng g·∫ßn ƒë√¢y nh·∫•t)
   */
  private moveToFront(node: ListNode): void {
    // Remove from current position
    this.removeNode(node);
    // Add to front
    this.addToFront(node);
  }

  /**
   * Add node to front of list
   * Th√™m node v√†o ƒë·∫ßu danh s√°ch
   */
  private addToFront(node: ListNode): void {
    node.prev = this.head;
    node.next = this.head.next;
    this.head.next!.prev = node;
    this.head.next = node;
  }

  /**
   * Remove node from list
   * X√≥a node kh·ªèi danh s√°ch
   */
  private removeNode(node: ListNode): void {
    node.prev!.next = node.next;
    node.next!.prev = node.prev;
  }

  /**
   * Evict least recently used item
   * Lo·∫°i b·ªè ph·∫ßn t·ª≠ √≠t ƒë∆∞·ª£c s·ª≠ d·ª•ng nh·∫•t
   */
  private evictLRU(): void {
    const lruNode = this.tail.prev!;
    this.removeNode(lruNode);
    this.cache.delete(lruNode.key);
  }

  /**
   * Get current size of cache
   * L·∫•y k√≠ch th∆∞·ªõc hi·ªán t·∫°i c·ªßa cache
   */
  size(): number {
    return this.cache.size;
  }

  /**
   * Check if cache is full
   * Ki·ªÉm tra xem cache c√≥ ƒë·∫ßy kh√¥ng
   */
  isFull(): boolean {
    return this.cache.size >= this.capacity;
  }

  /**
   * Get all keys in order of usage (most recent first)
   * L·∫•y t·∫•t c·∫£ kh√≥a theo th·ª© t·ª± s·ª≠ d·ª•ng (g·∫ßn ƒë√¢y nh·∫•t tr∆∞·ªõc)
   */
  getKeysInOrder(): number[] {
    const keys: number[] = [];
    let current = this.head.next;

    while (current && current !== this.tail) {
      keys.push(current.key);
      current = current.next;
    }

    return keys;
  }

  /**
   * Get cache statistics
   * L·∫•y th·ªëng k√™ cache
   */
  getStats(): { size: number; capacity: number; usage: number } {
    return {
      size: this.cache.size,
      capacity: this.capacity,
      usage: (this.cache.size / this.capacity) * 100,
    };
  }
}

/**
 * Alternative Implementation: Using Map (built-in LRU behavior)
 *
 * Tri·ªÉn khai thay th·∫ø: S·ª≠ d·ª•ng Map (h√†nh vi LRU c√≥ s·∫µn)
 */
class LRUCacheMap {
  private capacity: number;
  private cache: Map<number, number>;

  constructor(capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key: number): number {
    if (!this.cache.has(key)) {
      return -1;
    }

    // Move to end (most recently used)
    const value = this.cache.get(key)!;
    this.cache.delete(key);
    this.cache.set(key, value);

    return value;
  }

  put(key: number, value: number): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // Remove least recently used (first key)
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    this.cache.set(key, value);
  }

  size(): number {
    return this.cache.size;
  }

  isFull(): boolean {
    return this.cache.size >= this.capacity;
  }
}

/**
 * Implementation with Eviction Statistics
 *
 * Tri·ªÉn khai v·ªõi th·ªëng k√™ lo·∫°i b·ªè
 */
class LRUCacheWithStats extends LRUCache {
  private evictionCount: number;
  private hitCount: number;
  private missCount: number;
  private evictionHistory: Array<{ key: number; timestamp: number }>;

  constructor(capacity: number) {
    super(capacity);
    this.evictionCount = 0;
    this.hitCount = 0;
    this.missCount = 0;
    this.evictionHistory = [];
  }

  get(key: number): number {
    const result = super.get(key);

    if (result === -1) {
      this.missCount++;
    } else {
      this.hitCount++;
    }

    return result;
  }

  put(key: number, value: number): void {
    const wasFull = this.isFull();
    const hadKey = this.get(key) !== -1;

    super.put(key, value);

    // Track eviction if cache was full and we added a new key
    if (wasFull && !hadKey) {
      this.evictionCount++;
      this.evictionHistory.push({ key, timestamp: Date.now() });
    }
  }

  /**
   * Get cache performance statistics
   * L·∫•y th·ªëng k√™ hi·ªáu su·∫•t cache
   */
  getPerformanceStats(): {
    hitCount: number;
    missCount: number;
    hitRate: number;
    evictionCount: number;
    evictionHistory: Array<{ key: number; timestamp: number }>;
  } {
    const totalRequests = this.hitCount + this.missCount;
    const hitRate =
      totalRequests > 0 ? (this.hitCount / totalRequests) * 100 : 0;

    return {
      hitCount: this.hitCount,
      missCount: this.missCount,
      hitRate,
      evictionCount: this.evictionCount,
      evictionHistory: [...this.evictionHistory],
    };
  }

  /**
   * Clear performance statistics
   * X√≥a th·ªëng k√™ hi·ªáu su·∫•t
   */
  clearStats(): void {
    this.evictionCount = 0;
    this.hitCount = 0;
    this.missCount = 0;
    this.evictionHistory = [];
  }
}

/**
 * Implementation with TTL (Time To Live)
 *
 * Tri·ªÉn khai v·ªõi TTL (Th·ªùi gian s·ªëng)
 */
class LRUCacheWithTTL extends LRUCache {
  private ttl: number; // Time to live in milliseconds
  private timestamps: Map<number, number>;

  constructor(capacity: number, ttl: number = 60000) {
    // Default 1 minute
    super(capacity);
    this.ttl = ttl;
    this.timestamps = new Map();
  }

  get(key: number): number {
    const timestamp = this.timestamps.get(key);

    if (timestamp && Date.now() - timestamp > this.ttl) {
      // Key has expired, remove it
      this.timestamps.delete(key);
      return -1;
    }

    const result = super.get(key);

    if (result !== -1) {
      // Update timestamp
      this.timestamps.set(key, Date.now());
    }

    return result;
  }

  put(key: number, value: number): void {
    super.put(key, value);
    this.timestamps.set(key, Date.now());
  }

  /**
   * Clean up expired entries
   * D·ªçn d·∫πp c√°c m·ª•c ƒë√£ h·∫øt h·∫°n
   */
  cleanup(): number {
    const now = Date.now();
    let cleanedCount = 0;

    for (const [key, timestamp] of this.timestamps.entries()) {
      if (now - timestamp > this.ttl) {
        this.timestamps.delete(key);
        cleanedCount++;
      }
    }

    return cleanedCount;
  }

  /**
   * Get TTL statistics
   * L·∫•y th·ªëng k√™ TTL
   */
  getTTLStats(): {
    ttl: number;
    activeEntries: number;
    expiredEntries: number;
  } {
    const now = Date.now();
    let expiredCount = 0;

    for (const timestamp of this.timestamps.values()) {
      if (now - timestamp > this.ttl) {
        expiredCount++;
      }
    }

    return {
      ttl: this.ttl,
      activeEntries: this.timestamps.size - expiredCount,
      expiredEntries: expiredCount,
    };
  }
}

/**
 * Performance Comparison Function
 *
 * H√†m so s√°nh hi·ªáu su·∫•t c√°c ph∆∞∆°ng ph√°p
 */
function compareLRUImplementations(
  operations: Array<{ type: "get" | "put"; key: number; value?: number }>
): void {
  console.log(
    "LRU Cache Implementation Performance Comparison / So s√°nh hi·ªáu su·∫•t tri·ªÉn khai LRU Cache"
  );
  console.log("=".repeat(80));

  const implementations = [
    { name: "Doubly Linked List", cache: new LRUCache(100) },
    { name: "Map-based", cache: new LRUCacheMap(100) },
  ];

  for (const impl of implementations) {
    console.log(`\nTesting ${impl.name}:`);

    const start = performance.now();

    for (const op of operations) {
      switch (op.type) {
        case "get":
          impl.cache.get(op.key);
          break;
        case "put":
          impl.cache.put(op.key, op.value!);
          break;
      }
    }

    const end = performance.now();
    console.log(`  Time: ${(end - start).toFixed(4)}ms`);
    console.log(`  Final size: ${impl.cache.size()}`);
  }
}

/**
 * Test Cases
 *
 * C√°c tr∆∞·ªùng h·ª£p ki·ªÉm th·ª≠
 */
function runTests(): void {
  console.log("LRU Cache Tests / Ki·ªÉm th·ª≠ LRU Cache");
  console.log("=".repeat(50));

  // Test 1: Basic operations
  console.log("\nTest 1: Basic operations / C√°c thao t√°c c∆° b·∫£n");
  const cache1 = new LRUCache(2);
  cache1.put(1, 1);
  cache1.put(2, 2);
  console.log(`get(1): ${cache1.get(1)}`); // Expected: 1
  cache1.put(3, 3);
  console.log(`get(2): ${cache1.get(2)}`); // Expected: -1
  cache1.put(4, 4);
  console.log(`get(1): ${cache1.get(1)}`); // Expected: -1
  console.log(`get(3): ${cache1.get(3)}`); // Expected: 3
  console.log(`get(4): ${cache1.get(4)}`); // Expected: 4

  // Test 2: Performance tracking
  console.log("\nTest 2: Performance tracking / Theo d√µi hi·ªáu su·∫•t");
  const perfCache = new LRUCacheWithStats(3);

  perfCache.put(1, 1);
  perfCache.put(2, 2);
  perfCache.put(3, 3);
  perfCache.get(1); // Hit
  perfCache.get(4); // Miss
  perfCache.put(4, 4); // Evicts 2
  perfCache.get(2); // Miss (evicted)

  const stats = perfCache.getPerformanceStats();
  console.log(`Hit count: ${stats.hitCount}`);
  console.log(`Miss count: ${stats.missCount}`);
  console.log(`Hit rate: ${stats.hitRate.toFixed(2)}%`);
  console.log(`Eviction count: ${stats.evictionCount}`);

  // Test 3: TTL cache
  console.log("\nTest 3: TTL cache / Cache v·ªõi TTL");
  const ttlCache = new LRUCacheWithTTL(3, 1000); // 1 second TTL

  ttlCache.put(1, 1);
  ttlCache.put(2, 2);
  console.log(`get(1): ${ttlCache.get(1)}`); // Expected: 1

  // Wait for TTL to expire (simulate)
  setTimeout(() => {
    console.log(`get(1) after TTL: ${ttlCache.get(1)}`); // Expected: -1
    console.log(`TTL stats: ${JSON.stringify(ttlCache.getTTLStats())}`);
  }, 1100);

  // Test 4: Cache statistics
  console.log("\nTest 4: Cache statistics / Th·ªëng k√™ cache");
  const statCache = new LRUCache(5);

  for (let i = 1; i <= 7; i++) {
    statCache.put(i, i * 10);
  }

  console.log(`Size: ${statCache.size()}`);
  console.log(`Is full: ${statCache.isFull()}`);
  console.log(`Keys in order: [${statCache.getKeysInOrder().join(", ")}]`);
  console.log(`Stats: ${JSON.stringify(statCache.getStats())}`);

  // Test 5: Performance comparison
  console.log("\nTest 5: Performance comparison / So s√°nh hi·ªáu su·∫•t");
  const testOperations = [
    { type: "put" as const, key: 1, value: 1 },
    { type: "put" as const, key: 2, value: 2 },
    { type: "get" as const, key: 1 },
    { type: "put" as const, key: 3, value: 3 },
    { type: "get" as const, key: 2 },
    { type: "put" as const, key: 4, value: 4 },
    { type: "get" as const, key: 1 },
    { type: "get" as const, key: 3 },
    { type: "get" as const, key: 4 },
  ];

  compareLRUImplementations(testOperations);
}

// Uncomment to run tests
// runTests();

export {
  LRUCache,
  LRUCacheMap,
  LRUCacheWithStats,
  LRUCacheWithTTL,
  ListNode,
  compareLRUImplementations,
  runTests,
};
{% endraw %}
5:["slug","leetcode/others/problems/06-lru-cache","c"]
0:["7uJ7BVaXJTiEOD9iYDv3n",[[["",{"children":["docs",{"children":[["slug","leetcode/others/problems/06-lru-cache","c"],{"children":["__PAGE__?{\"slug\":[\"leetcode\",\"others\",\"problems\",\"06-lru-cache\"]}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["docs",{"children":[["slug","leetcode/others/problems/06-lru-cache","c"],{"children":["__PAGE__",{},[["$L1",["$","div",null,{"style":{"maxWidth":"1200px","margin":"0 auto","padding":"2rem","paddingTop":"6rem"},"children":[["$","div",null,{"style":{"marginBottom":"2rem"},"children":[["$","nav",null,{"style":{"color":"#64748b","fontSize":"0.9rem","marginBottom":"1rem"},"children":[["$","a",null,{"href":"/","style":{"color":"#3b82f6","textDecoration":"none"},"children":"Home"}]," > ",["$","span",null,{"children":"leetcode > others > problems > 06-lru-cache"}]]}],["$","h1",null,{"style":{"fontSize":"2.5rem","fontWeight":"800","marginBottom":"0.5rem","color":"#1e293b"},"children":"LRU Cache"}],["$","div",null,{"style":{"color":"#64748b","fontSize":"0.9rem","marginBottom":"2rem"},"children":[["$","span",null,{"children":["üìÅ ","leetcode/others/problems/06-lru-cache.md"]}],"$undefined","$undefined"]}]]}],["$","$L2",null,{"content":"$3"}]]}],null],null],null]},[null,["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","docs","children","$5","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[null,["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children","docs","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/interview/_next/static/css/387024c6a2216908.css","precedence":"next","crossOrigin":"$undefined"}]],["$","$L7",null,{"children":["$","$L4",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L6",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}],"params":{}}]],null],null],["$L8",null]]]]
8:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"LRU Cache - Frontend Interview Docs"}],["$","meta","3",{"name":"description","content":" # LRU Cache    ## Problem Description   *  * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  *  * Implement the LRU"}],["$","meta","4",{"property":"og:title","content":"LRU Cache - Frontend Interview Docs"}],["$","meta","5",{"property":"og:description","content":" # LRU Cache    ## Problem Description   *  * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  *  * Implement the LRU"}],["$","meta","6",{"property":"og:type","content":"article"}],["$","meta","7",{"name":"twitter:card","content":"summary"}],["$","meta","8",{"name":"twitter:title","content":"LRU Cache - Frontend Interview Docs"}],["$","meta","9",{"name":"twitter:description","content":" # LRU Cache    ## Problem Description   *  * Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.  *  * Implement the LRU"}],["$","meta","10",{"name":"next-size-adjust"}]]
1:null
